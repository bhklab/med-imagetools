# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.
# ruff: noqa
from sys import version_info as _swig_python_version_info

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _SimpleITK
else:
    import _SimpleITK

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (
        self.__class__.__module__,
        self.__class__.__name__,
        strthis,
    )


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(
            getattr(type(self), name), property
        ):
            set(self, name, value)
        else:
            raise AttributeError(
                "You cannot add instance attributes to %s" % self
            )

    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)

    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""

    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())

    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""

    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref


class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_SwigPyIterator

    def value(self):
        r"""value(SwigPyIterator self) -> PyObject *"""
        return _SimpleITK.SwigPyIterator_value(self)

    def incr(self, n=1):
        r"""incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _SimpleITK.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        r"""decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _SimpleITK.SwigPyIterator_decr(self, n)

    def distance(self, x):
        r"""distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _SimpleITK.SwigPyIterator_distance(self, x)

    def equal(self, x):
        r"""equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _SimpleITK.SwigPyIterator_equal(self, x)

    def copy(self):
        r"""copy(SwigPyIterator self) -> SwigPyIterator"""
        return _SimpleITK.SwigPyIterator_copy(self)

    def next(self):
        r"""next(SwigPyIterator self) -> PyObject *"""
        return _SimpleITK.SwigPyIterator_next(self)

    def __next__(self):
        r"""__next__(SwigPyIterator self) -> PyObject *"""
        return _SimpleITK.SwigPyIterator___next__(self)

    def previous(self):
        r"""previous(SwigPyIterator self) -> PyObject *"""
        return _SimpleITK.SwigPyIterator_previous(self)

    def advance(self, n):
        r"""advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _SimpleITK.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        r"""__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _SimpleITK.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        r"""__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _SimpleITK.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        r"""__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _SimpleITK.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        r"""__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _SimpleITK.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        r"""__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _SimpleITK.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        r"""
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _SimpleITK.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self


# Register SwigPyIterator in _SimpleITK:
_SimpleITK.SwigPyIterator_swigregister(SwigPyIterator)


class VectorBool(object):
    r"""Proxy of C++ std::vector< bool > class."""

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(VectorBool self) -> SwigPyIterator"""
        return _SimpleITK.VectorBool_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(VectorBool self) -> bool"""
        return _SimpleITK.VectorBool___nonzero__(self)

    def __bool__(self):
        r"""__bool__(VectorBool self) -> bool"""
        return _SimpleITK.VectorBool___bool__(self)

    def __len__(self):
        r"""__len__(VectorBool self) -> std::vector< bool >::size_type"""
        return _SimpleITK.VectorBool___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(VectorBool self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j) -> VectorBool"""
        return _SimpleITK.VectorBool___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(VectorBool self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j)
        __setslice__(VectorBool self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j, VectorBool v)
        """
        return _SimpleITK.VectorBool___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(VectorBool self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j)"""
        return _SimpleITK.VectorBool___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(VectorBool self, std::vector< bool >::difference_type i)
        __delitem__(VectorBool self, SWIGPY_SLICEOBJECT * slice)
        """
        return _SimpleITK.VectorBool___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(VectorBool self, SWIGPY_SLICEOBJECT * slice) -> VectorBool
        __getitem__(VectorBool self, std::vector< bool >::difference_type i) -> std::vector< bool >::value_type
        """
        return _SimpleITK.VectorBool___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(VectorBool self, SWIGPY_SLICEOBJECT * slice, VectorBool v)
        __setitem__(VectorBool self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(VectorBool self, std::vector< bool >::difference_type i, std::vector< bool >::value_type x)
        """
        return _SimpleITK.VectorBool___setitem__(self, *args)

    def pop(self):
        r"""pop(VectorBool self) -> std::vector< bool >::value_type"""
        return _SimpleITK.VectorBool_pop(self)

    def append(self, x):
        r"""append(VectorBool self, std::vector< bool >::value_type x)"""
        return _SimpleITK.VectorBool_append(self, x)

    def empty(self):
        r"""empty(VectorBool self) -> bool"""
        return _SimpleITK.VectorBool_empty(self)

    def size(self):
        r"""size(VectorBool self) -> std::vector< bool >::size_type"""
        return _SimpleITK.VectorBool_size(self)

    def swap(self, v):
        r"""swap(VectorBool self, VectorBool v)"""
        return _SimpleITK.VectorBool_swap(self, v)

    def begin(self):
        r"""begin(VectorBool self) -> std::vector< bool >::iterator"""
        return _SimpleITK.VectorBool_begin(self)

    def end(self):
        r"""end(VectorBool self) -> std::vector< bool >::iterator"""
        return _SimpleITK.VectorBool_end(self)

    def rbegin(self):
        r"""rbegin(VectorBool self) -> std::vector< bool >::reverse_iterator"""
        return _SimpleITK.VectorBool_rbegin(self)

    def rend(self):
        r"""rend(VectorBool self) -> std::vector< bool >::reverse_iterator"""
        return _SimpleITK.VectorBool_rend(self)

    def clear(self):
        r"""clear(VectorBool self)"""
        return _SimpleITK.VectorBool_clear(self)

    def get_allocator(self):
        r"""get_allocator(VectorBool self) -> std::vector< bool >::allocator_type"""
        return _SimpleITK.VectorBool_get_allocator(self)

    def pop_back(self):
        r"""pop_back(VectorBool self)"""
        return _SimpleITK.VectorBool_pop_back(self)

    def erase(self, *args):
        r"""
        erase(VectorBool self, std::vector< bool >::iterator pos) -> std::vector< bool >::iterator
        erase(VectorBool self, std::vector< bool >::iterator first, std::vector< bool >::iterator last) -> std::vector< bool >::iterator
        """
        return _SimpleITK.VectorBool_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(VectorBool self) -> VectorBool
        __init__(VectorBool self, VectorBool other) -> VectorBool
        __init__(VectorBool self, std::vector< bool >::size_type size) -> VectorBool
        __init__(VectorBool self, std::vector< bool >::size_type size, std::vector< bool >::value_type value) -> VectorBool
        """
        _SimpleITK.VectorBool_swiginit(self, _SimpleITK.new_VectorBool(*args))

    def push_back(self, x):
        r"""push_back(VectorBool self, std::vector< bool >::value_type x)"""
        return _SimpleITK.VectorBool_push_back(self, x)

    def front(self):
        r"""front(VectorBool self) -> std::vector< bool >::value_type"""
        return _SimpleITK.VectorBool_front(self)

    def back(self):
        r"""back(VectorBool self) -> std::vector< bool >::value_type"""
        return _SimpleITK.VectorBool_back(self)

    def assign(self, n, x):
        r"""assign(VectorBool self, std::vector< bool >::size_type n, std::vector< bool >::value_type x)"""
        return _SimpleITK.VectorBool_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(VectorBool self, std::vector< bool >::size_type new_size)
        resize(VectorBool self, std::vector< bool >::size_type new_size, std::vector< bool >::value_type x)
        """
        return _SimpleITK.VectorBool_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(VectorBool self, std::vector< bool >::iterator pos, std::vector< bool >::value_type x) -> std::vector< bool >::iterator
        insert(VectorBool self, std::vector< bool >::iterator pos, std::vector< bool >::size_type n, std::vector< bool >::value_type x)
        """
        return _SimpleITK.VectorBool_insert(self, *args)

    def reserve(self, n):
        r"""reserve(VectorBool self, std::vector< bool >::size_type n)"""
        return _SimpleITK.VectorBool_reserve(self, n)

    def capacity(self):
        r"""capacity(VectorBool self) -> std::vector< bool >::size_type"""
        return _SimpleITK.VectorBool_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorBool


# Register VectorBool in _SimpleITK:
_SimpleITK.VectorBool_swigregister(VectorBool)


class VectorUInt8(object):
    r"""Proxy of C++ std::vector< uint8_t > class."""

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(VectorUInt8 self) -> SwigPyIterator"""
        return _SimpleITK.VectorUInt8_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(VectorUInt8 self) -> bool"""
        return _SimpleITK.VectorUInt8___nonzero__(self)

    def __bool__(self):
        r"""__bool__(VectorUInt8 self) -> bool"""
        return _SimpleITK.VectorUInt8___bool__(self)

    def __len__(self):
        r"""__len__(VectorUInt8 self) -> std::vector< unsigned char >::size_type"""
        return _SimpleITK.VectorUInt8___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(VectorUInt8 self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j) -> VectorUInt8"""
        return _SimpleITK.VectorUInt8___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(VectorUInt8 self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j)
        __setslice__(VectorUInt8 self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j, VectorUInt8 v)
        """
        return _SimpleITK.VectorUInt8___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(VectorUInt8 self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j)"""
        return _SimpleITK.VectorUInt8___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(VectorUInt8 self, std::vector< unsigned char >::difference_type i)
        __delitem__(VectorUInt8 self, SWIGPY_SLICEOBJECT * slice)
        """
        return _SimpleITK.VectorUInt8___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(VectorUInt8 self, SWIGPY_SLICEOBJECT * slice) -> VectorUInt8
        __getitem__(VectorUInt8 self, std::vector< unsigned char >::difference_type i) -> std::vector< unsigned char >::value_type const &
        """
        return _SimpleITK.VectorUInt8___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(VectorUInt8 self, SWIGPY_SLICEOBJECT * slice, VectorUInt8 v)
        __setitem__(VectorUInt8 self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(VectorUInt8 self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::value_type const & x)
        """
        return _SimpleITK.VectorUInt8___setitem__(self, *args)

    def pop(self):
        r"""pop(VectorUInt8 self) -> std::vector< unsigned char >::value_type"""
        return _SimpleITK.VectorUInt8_pop(self)

    def append(self, x):
        r"""append(VectorUInt8 self, std::vector< unsigned char >::value_type const & x)"""
        return _SimpleITK.VectorUInt8_append(self, x)

    def empty(self):
        r"""empty(VectorUInt8 self) -> bool"""
        return _SimpleITK.VectorUInt8_empty(self)

    def size(self):
        r"""size(VectorUInt8 self) -> std::vector< unsigned char >::size_type"""
        return _SimpleITK.VectorUInt8_size(self)

    def swap(self, v):
        r"""swap(VectorUInt8 self, VectorUInt8 v)"""
        return _SimpleITK.VectorUInt8_swap(self, v)

    def begin(self):
        r"""begin(VectorUInt8 self) -> std::vector< unsigned char >::iterator"""
        return _SimpleITK.VectorUInt8_begin(self)

    def end(self):
        r"""end(VectorUInt8 self) -> std::vector< unsigned char >::iterator"""
        return _SimpleITK.VectorUInt8_end(self)

    def rbegin(self):
        r"""rbegin(VectorUInt8 self) -> std::vector< unsigned char >::reverse_iterator"""
        return _SimpleITK.VectorUInt8_rbegin(self)

    def rend(self):
        r"""rend(VectorUInt8 self) -> std::vector< unsigned char >::reverse_iterator"""
        return _SimpleITK.VectorUInt8_rend(self)

    def clear(self):
        r"""clear(VectorUInt8 self)"""
        return _SimpleITK.VectorUInt8_clear(self)

    def get_allocator(self):
        r"""get_allocator(VectorUInt8 self) -> std::vector< unsigned char >::allocator_type"""
        return _SimpleITK.VectorUInt8_get_allocator(self)

    def pop_back(self):
        r"""pop_back(VectorUInt8 self)"""
        return _SimpleITK.VectorUInt8_pop_back(self)

    def erase(self, *args):
        r"""
        erase(VectorUInt8 self, std::vector< unsigned char >::iterator pos) -> std::vector< unsigned char >::iterator
        erase(VectorUInt8 self, std::vector< unsigned char >::iterator first, std::vector< unsigned char >::iterator last) -> std::vector< unsigned char >::iterator
        """
        return _SimpleITK.VectorUInt8_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(VectorUInt8 self) -> VectorUInt8
        __init__(VectorUInt8 self, VectorUInt8 other) -> VectorUInt8
        __init__(VectorUInt8 self, std::vector< unsigned char >::size_type size) -> VectorUInt8
        __init__(VectorUInt8 self, std::vector< unsigned char >::size_type size, std::vector< unsigned char >::value_type const & value) -> VectorUInt8
        """
        _SimpleITK.VectorUInt8_swiginit(
            self, _SimpleITK.new_VectorUInt8(*args)
        )

    def push_back(self, x):
        r"""push_back(VectorUInt8 self, std::vector< unsigned char >::value_type const & x)"""
        return _SimpleITK.VectorUInt8_push_back(self, x)

    def front(self):
        r"""front(VectorUInt8 self) -> std::vector< unsigned char >::value_type const &"""
        return _SimpleITK.VectorUInt8_front(self)

    def back(self):
        r"""back(VectorUInt8 self) -> std::vector< unsigned char >::value_type const &"""
        return _SimpleITK.VectorUInt8_back(self)

    def assign(self, n, x):
        r"""assign(VectorUInt8 self, std::vector< unsigned char >::size_type n, std::vector< unsigned char >::value_type const & x)"""
        return _SimpleITK.VectorUInt8_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(VectorUInt8 self, std::vector< unsigned char >::size_type new_size)
        resize(VectorUInt8 self, std::vector< unsigned char >::size_type new_size, std::vector< unsigned char >::value_type const & x)
        """
        return _SimpleITK.VectorUInt8_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(VectorUInt8 self, std::vector< unsigned char >::iterator pos, std::vector< unsigned char >::value_type const & x) -> std::vector< unsigned char >::iterator
        insert(VectorUInt8 self, std::vector< unsigned char >::iterator pos, std::vector< unsigned char >::size_type n, std::vector< unsigned char >::value_type const & x)
        """
        return _SimpleITK.VectorUInt8_insert(self, *args)

    def reserve(self, n):
        r"""reserve(VectorUInt8 self, std::vector< unsigned char >::size_type n)"""
        return _SimpleITK.VectorUInt8_reserve(self, n)

    def capacity(self):
        r"""capacity(VectorUInt8 self) -> std::vector< unsigned char >::size_type"""
        return _SimpleITK.VectorUInt8_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorUInt8


# Register VectorUInt8 in _SimpleITK:
_SimpleITK.VectorUInt8_swigregister(VectorUInt8)


class VectorInt8(object):
    r"""Proxy of C++ std::vector< int8_t > class."""

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(VectorInt8 self) -> SwigPyIterator"""
        return _SimpleITK.VectorInt8_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(VectorInt8 self) -> bool"""
        return _SimpleITK.VectorInt8___nonzero__(self)

    def __bool__(self):
        r"""__bool__(VectorInt8 self) -> bool"""
        return _SimpleITK.VectorInt8___bool__(self)

    def __len__(self):
        r"""__len__(VectorInt8 self) -> std::vector< signed char >::size_type"""
        return _SimpleITK.VectorInt8___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(VectorInt8 self, std::vector< signed char >::difference_type i, std::vector< signed char >::difference_type j) -> VectorInt8"""
        return _SimpleITK.VectorInt8___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(VectorInt8 self, std::vector< signed char >::difference_type i, std::vector< signed char >::difference_type j)
        __setslice__(VectorInt8 self, std::vector< signed char >::difference_type i, std::vector< signed char >::difference_type j, VectorInt8 v)
        """
        return _SimpleITK.VectorInt8___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(VectorInt8 self, std::vector< signed char >::difference_type i, std::vector< signed char >::difference_type j)"""
        return _SimpleITK.VectorInt8___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(VectorInt8 self, std::vector< signed char >::difference_type i)
        __delitem__(VectorInt8 self, SWIGPY_SLICEOBJECT * slice)
        """
        return _SimpleITK.VectorInt8___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(VectorInt8 self, SWIGPY_SLICEOBJECT * slice) -> VectorInt8
        __getitem__(VectorInt8 self, std::vector< signed char >::difference_type i) -> std::vector< signed char >::value_type const &
        """
        return _SimpleITK.VectorInt8___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(VectorInt8 self, SWIGPY_SLICEOBJECT * slice, VectorInt8 v)
        __setitem__(VectorInt8 self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(VectorInt8 self, std::vector< signed char >::difference_type i, std::vector< signed char >::value_type const & x)
        """
        return _SimpleITK.VectorInt8___setitem__(self, *args)

    def pop(self):
        r"""pop(VectorInt8 self) -> std::vector< signed char >::value_type"""
        return _SimpleITK.VectorInt8_pop(self)

    def append(self, x):
        r"""append(VectorInt8 self, std::vector< signed char >::value_type const & x)"""
        return _SimpleITK.VectorInt8_append(self, x)

    def empty(self):
        r"""empty(VectorInt8 self) -> bool"""
        return _SimpleITK.VectorInt8_empty(self)

    def size(self):
        r"""size(VectorInt8 self) -> std::vector< signed char >::size_type"""
        return _SimpleITK.VectorInt8_size(self)

    def swap(self, v):
        r"""swap(VectorInt8 self, VectorInt8 v)"""
        return _SimpleITK.VectorInt8_swap(self, v)

    def begin(self):
        r"""begin(VectorInt8 self) -> std::vector< signed char >::iterator"""
        return _SimpleITK.VectorInt8_begin(self)

    def end(self):
        r"""end(VectorInt8 self) -> std::vector< signed char >::iterator"""
        return _SimpleITK.VectorInt8_end(self)

    def rbegin(self):
        r"""rbegin(VectorInt8 self) -> std::vector< signed char >::reverse_iterator"""
        return _SimpleITK.VectorInt8_rbegin(self)

    def rend(self):
        r"""rend(VectorInt8 self) -> std::vector< signed char >::reverse_iterator"""
        return _SimpleITK.VectorInt8_rend(self)

    def clear(self):
        r"""clear(VectorInt8 self)"""
        return _SimpleITK.VectorInt8_clear(self)

    def get_allocator(self):
        r"""get_allocator(VectorInt8 self) -> std::vector< signed char >::allocator_type"""
        return _SimpleITK.VectorInt8_get_allocator(self)

    def pop_back(self):
        r"""pop_back(VectorInt8 self)"""
        return _SimpleITK.VectorInt8_pop_back(self)

    def erase(self, *args):
        r"""
        erase(VectorInt8 self, std::vector< signed char >::iterator pos) -> std::vector< signed char >::iterator
        erase(VectorInt8 self, std::vector< signed char >::iterator first, std::vector< signed char >::iterator last) -> std::vector< signed char >::iterator
        """
        return _SimpleITK.VectorInt8_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(VectorInt8 self) -> VectorInt8
        __init__(VectorInt8 self, VectorInt8 other) -> VectorInt8
        __init__(VectorInt8 self, std::vector< signed char >::size_type size) -> VectorInt8
        __init__(VectorInt8 self, std::vector< signed char >::size_type size, std::vector< signed char >::value_type const & value) -> VectorInt8
        """
        _SimpleITK.VectorInt8_swiginit(self, _SimpleITK.new_VectorInt8(*args))

    def push_back(self, x):
        r"""push_back(VectorInt8 self, std::vector< signed char >::value_type const & x)"""
        return _SimpleITK.VectorInt8_push_back(self, x)

    def front(self):
        r"""front(VectorInt8 self) -> std::vector< signed char >::value_type const &"""
        return _SimpleITK.VectorInt8_front(self)

    def back(self):
        r"""back(VectorInt8 self) -> std::vector< signed char >::value_type const &"""
        return _SimpleITK.VectorInt8_back(self)

    def assign(self, n, x):
        r"""assign(VectorInt8 self, std::vector< signed char >::size_type n, std::vector< signed char >::value_type const & x)"""
        return _SimpleITK.VectorInt8_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(VectorInt8 self, std::vector< signed char >::size_type new_size)
        resize(VectorInt8 self, std::vector< signed char >::size_type new_size, std::vector< signed char >::value_type const & x)
        """
        return _SimpleITK.VectorInt8_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(VectorInt8 self, std::vector< signed char >::iterator pos, std::vector< signed char >::value_type const & x) -> std::vector< signed char >::iterator
        insert(VectorInt8 self, std::vector< signed char >::iterator pos, std::vector< signed char >::size_type n, std::vector< signed char >::value_type const & x)
        """
        return _SimpleITK.VectorInt8_insert(self, *args)

    def reserve(self, n):
        r"""reserve(VectorInt8 self, std::vector< signed char >::size_type n)"""
        return _SimpleITK.VectorInt8_reserve(self, n)

    def capacity(self):
        r"""capacity(VectorInt8 self) -> std::vector< signed char >::size_type"""
        return _SimpleITK.VectorInt8_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorInt8


# Register VectorInt8 in _SimpleITK:
_SimpleITK.VectorInt8_swigregister(VectorInt8)


class VectorUInt16(object):
    r"""Proxy of C++ std::vector< uint16_t > class."""

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(VectorUInt16 self) -> SwigPyIterator"""
        return _SimpleITK.VectorUInt16_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(VectorUInt16 self) -> bool"""
        return _SimpleITK.VectorUInt16___nonzero__(self)

    def __bool__(self):
        r"""__bool__(VectorUInt16 self) -> bool"""
        return _SimpleITK.VectorUInt16___bool__(self)

    def __len__(self):
        r"""__len__(VectorUInt16 self) -> std::vector< unsigned short >::size_type"""
        return _SimpleITK.VectorUInt16___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(VectorUInt16 self, std::vector< unsigned short >::difference_type i, std::vector< unsigned short >::difference_type j) -> VectorUInt16"""
        return _SimpleITK.VectorUInt16___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(VectorUInt16 self, std::vector< unsigned short >::difference_type i, std::vector< unsigned short >::difference_type j)
        __setslice__(VectorUInt16 self, std::vector< unsigned short >::difference_type i, std::vector< unsigned short >::difference_type j, VectorUInt16 v)
        """
        return _SimpleITK.VectorUInt16___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(VectorUInt16 self, std::vector< unsigned short >::difference_type i, std::vector< unsigned short >::difference_type j)"""
        return _SimpleITK.VectorUInt16___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(VectorUInt16 self, std::vector< unsigned short >::difference_type i)
        __delitem__(VectorUInt16 self, SWIGPY_SLICEOBJECT * slice)
        """
        return _SimpleITK.VectorUInt16___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(VectorUInt16 self, SWIGPY_SLICEOBJECT * slice) -> VectorUInt16
        __getitem__(VectorUInt16 self, std::vector< unsigned short >::difference_type i) -> std::vector< unsigned short >::value_type const &
        """
        return _SimpleITK.VectorUInt16___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(VectorUInt16 self, SWIGPY_SLICEOBJECT * slice, VectorUInt16 v)
        __setitem__(VectorUInt16 self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(VectorUInt16 self, std::vector< unsigned short >::difference_type i, std::vector< unsigned short >::value_type const & x)
        """
        return _SimpleITK.VectorUInt16___setitem__(self, *args)

    def pop(self):
        r"""pop(VectorUInt16 self) -> std::vector< unsigned short >::value_type"""
        return _SimpleITK.VectorUInt16_pop(self)

    def append(self, x):
        r"""append(VectorUInt16 self, std::vector< unsigned short >::value_type const & x)"""
        return _SimpleITK.VectorUInt16_append(self, x)

    def empty(self):
        r"""empty(VectorUInt16 self) -> bool"""
        return _SimpleITK.VectorUInt16_empty(self)

    def size(self):
        r"""size(VectorUInt16 self) -> std::vector< unsigned short >::size_type"""
        return _SimpleITK.VectorUInt16_size(self)

    def swap(self, v):
        r"""swap(VectorUInt16 self, VectorUInt16 v)"""
        return _SimpleITK.VectorUInt16_swap(self, v)

    def begin(self):
        r"""begin(VectorUInt16 self) -> std::vector< unsigned short >::iterator"""
        return _SimpleITK.VectorUInt16_begin(self)

    def end(self):
        r"""end(VectorUInt16 self) -> std::vector< unsigned short >::iterator"""
        return _SimpleITK.VectorUInt16_end(self)

    def rbegin(self):
        r"""rbegin(VectorUInt16 self) -> std::vector< unsigned short >::reverse_iterator"""
        return _SimpleITK.VectorUInt16_rbegin(self)

    def rend(self):
        r"""rend(VectorUInt16 self) -> std::vector< unsigned short >::reverse_iterator"""
        return _SimpleITK.VectorUInt16_rend(self)

    def clear(self):
        r"""clear(VectorUInt16 self)"""
        return _SimpleITK.VectorUInt16_clear(self)

    def get_allocator(self):
        r"""get_allocator(VectorUInt16 self) -> std::vector< unsigned short >::allocator_type"""
        return _SimpleITK.VectorUInt16_get_allocator(self)

    def pop_back(self):
        r"""pop_back(VectorUInt16 self)"""
        return _SimpleITK.VectorUInt16_pop_back(self)

    def erase(self, *args):
        r"""
        erase(VectorUInt16 self, std::vector< unsigned short >::iterator pos) -> std::vector< unsigned short >::iterator
        erase(VectorUInt16 self, std::vector< unsigned short >::iterator first, std::vector< unsigned short >::iterator last) -> std::vector< unsigned short >::iterator
        """
        return _SimpleITK.VectorUInt16_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(VectorUInt16 self) -> VectorUInt16
        __init__(VectorUInt16 self, VectorUInt16 other) -> VectorUInt16
        __init__(VectorUInt16 self, std::vector< unsigned short >::size_type size) -> VectorUInt16
        __init__(VectorUInt16 self, std::vector< unsigned short >::size_type size, std::vector< unsigned short >::value_type const & value) -> VectorUInt16
        """
        _SimpleITK.VectorUInt16_swiginit(
            self, _SimpleITK.new_VectorUInt16(*args)
        )

    def push_back(self, x):
        r"""push_back(VectorUInt16 self, std::vector< unsigned short >::value_type const & x)"""
        return _SimpleITK.VectorUInt16_push_back(self, x)

    def front(self):
        r"""front(VectorUInt16 self) -> std::vector< unsigned short >::value_type const &"""
        return _SimpleITK.VectorUInt16_front(self)

    def back(self):
        r"""back(VectorUInt16 self) -> std::vector< unsigned short >::value_type const &"""
        return _SimpleITK.VectorUInt16_back(self)

    def assign(self, n, x):
        r"""assign(VectorUInt16 self, std::vector< unsigned short >::size_type n, std::vector< unsigned short >::value_type const & x)"""
        return _SimpleITK.VectorUInt16_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(VectorUInt16 self, std::vector< unsigned short >::size_type new_size)
        resize(VectorUInt16 self, std::vector< unsigned short >::size_type new_size, std::vector< unsigned short >::value_type const & x)
        """
        return _SimpleITK.VectorUInt16_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(VectorUInt16 self, std::vector< unsigned short >::iterator pos, std::vector< unsigned short >::value_type const & x) -> std::vector< unsigned short >::iterator
        insert(VectorUInt16 self, std::vector< unsigned short >::iterator pos, std::vector< unsigned short >::size_type n, std::vector< unsigned short >::value_type const & x)
        """
        return _SimpleITK.VectorUInt16_insert(self, *args)

    def reserve(self, n):
        r"""reserve(VectorUInt16 self, std::vector< unsigned short >::size_type n)"""
        return _SimpleITK.VectorUInt16_reserve(self, n)

    def capacity(self):
        r"""capacity(VectorUInt16 self) -> std::vector< unsigned short >::size_type"""
        return _SimpleITK.VectorUInt16_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorUInt16


# Register VectorUInt16 in _SimpleITK:
_SimpleITK.VectorUInt16_swigregister(VectorUInt16)


class VectorInt16(object):
    r"""Proxy of C++ std::vector< int16_t > class."""

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(VectorInt16 self) -> SwigPyIterator"""
        return _SimpleITK.VectorInt16_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(VectorInt16 self) -> bool"""
        return _SimpleITK.VectorInt16___nonzero__(self)

    def __bool__(self):
        r"""__bool__(VectorInt16 self) -> bool"""
        return _SimpleITK.VectorInt16___bool__(self)

    def __len__(self):
        r"""__len__(VectorInt16 self) -> std::vector< short >::size_type"""
        return _SimpleITK.VectorInt16___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(VectorInt16 self, std::vector< short >::difference_type i, std::vector< short >::difference_type j) -> VectorInt16"""
        return _SimpleITK.VectorInt16___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(VectorInt16 self, std::vector< short >::difference_type i, std::vector< short >::difference_type j)
        __setslice__(VectorInt16 self, std::vector< short >::difference_type i, std::vector< short >::difference_type j, VectorInt16 v)
        """
        return _SimpleITK.VectorInt16___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(VectorInt16 self, std::vector< short >::difference_type i, std::vector< short >::difference_type j)"""
        return _SimpleITK.VectorInt16___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(VectorInt16 self, std::vector< short >::difference_type i)
        __delitem__(VectorInt16 self, SWIGPY_SLICEOBJECT * slice)
        """
        return _SimpleITK.VectorInt16___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(VectorInt16 self, SWIGPY_SLICEOBJECT * slice) -> VectorInt16
        __getitem__(VectorInt16 self, std::vector< short >::difference_type i) -> std::vector< short >::value_type const &
        """
        return _SimpleITK.VectorInt16___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(VectorInt16 self, SWIGPY_SLICEOBJECT * slice, VectorInt16 v)
        __setitem__(VectorInt16 self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(VectorInt16 self, std::vector< short >::difference_type i, std::vector< short >::value_type const & x)
        """
        return _SimpleITK.VectorInt16___setitem__(self, *args)

    def pop(self):
        r"""pop(VectorInt16 self) -> std::vector< short >::value_type"""
        return _SimpleITK.VectorInt16_pop(self)

    def append(self, x):
        r"""append(VectorInt16 self, std::vector< short >::value_type const & x)"""
        return _SimpleITK.VectorInt16_append(self, x)

    def empty(self):
        r"""empty(VectorInt16 self) -> bool"""
        return _SimpleITK.VectorInt16_empty(self)

    def size(self):
        r"""size(VectorInt16 self) -> std::vector< short >::size_type"""
        return _SimpleITK.VectorInt16_size(self)

    def swap(self, v):
        r"""swap(VectorInt16 self, VectorInt16 v)"""
        return _SimpleITK.VectorInt16_swap(self, v)

    def begin(self):
        r"""begin(VectorInt16 self) -> std::vector< short >::iterator"""
        return _SimpleITK.VectorInt16_begin(self)

    def end(self):
        r"""end(VectorInt16 self) -> std::vector< short >::iterator"""
        return _SimpleITK.VectorInt16_end(self)

    def rbegin(self):
        r"""rbegin(VectorInt16 self) -> std::vector< short >::reverse_iterator"""
        return _SimpleITK.VectorInt16_rbegin(self)

    def rend(self):
        r"""rend(VectorInt16 self) -> std::vector< short >::reverse_iterator"""
        return _SimpleITK.VectorInt16_rend(self)

    def clear(self):
        r"""clear(VectorInt16 self)"""
        return _SimpleITK.VectorInt16_clear(self)

    def get_allocator(self):
        r"""get_allocator(VectorInt16 self) -> std::vector< short >::allocator_type"""
        return _SimpleITK.VectorInt16_get_allocator(self)

    def pop_back(self):
        r"""pop_back(VectorInt16 self)"""
        return _SimpleITK.VectorInt16_pop_back(self)

    def erase(self, *args):
        r"""
        erase(VectorInt16 self, std::vector< short >::iterator pos) -> std::vector< short >::iterator
        erase(VectorInt16 self, std::vector< short >::iterator first, std::vector< short >::iterator last) -> std::vector< short >::iterator
        """
        return _SimpleITK.VectorInt16_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(VectorInt16 self) -> VectorInt16
        __init__(VectorInt16 self, VectorInt16 other) -> VectorInt16
        __init__(VectorInt16 self, std::vector< short >::size_type size) -> VectorInt16
        __init__(VectorInt16 self, std::vector< short >::size_type size, std::vector< short >::value_type const & value) -> VectorInt16
        """
        _SimpleITK.VectorInt16_swiginit(
            self, _SimpleITK.new_VectorInt16(*args)
        )

    def push_back(self, x):
        r"""push_back(VectorInt16 self, std::vector< short >::value_type const & x)"""
        return _SimpleITK.VectorInt16_push_back(self, x)

    def front(self):
        r"""front(VectorInt16 self) -> std::vector< short >::value_type const &"""
        return _SimpleITK.VectorInt16_front(self)

    def back(self):
        r"""back(VectorInt16 self) -> std::vector< short >::value_type const &"""
        return _SimpleITK.VectorInt16_back(self)

    def assign(self, n, x):
        r"""assign(VectorInt16 self, std::vector< short >::size_type n, std::vector< short >::value_type const & x)"""
        return _SimpleITK.VectorInt16_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(VectorInt16 self, std::vector< short >::size_type new_size)
        resize(VectorInt16 self, std::vector< short >::size_type new_size, std::vector< short >::value_type const & x)
        """
        return _SimpleITK.VectorInt16_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(VectorInt16 self, std::vector< short >::iterator pos, std::vector< short >::value_type const & x) -> std::vector< short >::iterator
        insert(VectorInt16 self, std::vector< short >::iterator pos, std::vector< short >::size_type n, std::vector< short >::value_type const & x)
        """
        return _SimpleITK.VectorInt16_insert(self, *args)

    def reserve(self, n):
        r"""reserve(VectorInt16 self, std::vector< short >::size_type n)"""
        return _SimpleITK.VectorInt16_reserve(self, n)

    def capacity(self):
        r"""capacity(VectorInt16 self) -> std::vector< short >::size_type"""
        return _SimpleITK.VectorInt16_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorInt16


# Register VectorInt16 in _SimpleITK:
_SimpleITK.VectorInt16_swigregister(VectorInt16)


class VectorUInt32(object):
    r"""Proxy of C++ std::vector< uint32_t > class."""

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(VectorUInt32 self) -> SwigPyIterator"""
        return _SimpleITK.VectorUInt32_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(VectorUInt32 self) -> bool"""
        return _SimpleITK.VectorUInt32___nonzero__(self)

    def __bool__(self):
        r"""__bool__(VectorUInt32 self) -> bool"""
        return _SimpleITK.VectorUInt32___bool__(self)

    def __len__(self):
        r"""__len__(VectorUInt32 self) -> std::vector< unsigned int >::size_type"""
        return _SimpleITK.VectorUInt32___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(VectorUInt32 self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j) -> VectorUInt32"""
        return _SimpleITK.VectorUInt32___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(VectorUInt32 self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)
        __setslice__(VectorUInt32 self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j, VectorUInt32 v)
        """
        return _SimpleITK.VectorUInt32___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(VectorUInt32 self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)"""
        return _SimpleITK.VectorUInt32___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(VectorUInt32 self, std::vector< unsigned int >::difference_type i)
        __delitem__(VectorUInt32 self, SWIGPY_SLICEOBJECT * slice)
        """
        return _SimpleITK.VectorUInt32___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(VectorUInt32 self, SWIGPY_SLICEOBJECT * slice) -> VectorUInt32
        __getitem__(VectorUInt32 self, std::vector< unsigned int >::difference_type i) -> std::vector< unsigned int >::value_type const &
        """
        return _SimpleITK.VectorUInt32___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(VectorUInt32 self, SWIGPY_SLICEOBJECT * slice, VectorUInt32 v)
        __setitem__(VectorUInt32 self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(VectorUInt32 self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::value_type const & x)
        """
        return _SimpleITK.VectorUInt32___setitem__(self, *args)

    def pop(self):
        r"""pop(VectorUInt32 self) -> std::vector< unsigned int >::value_type"""
        return _SimpleITK.VectorUInt32_pop(self)

    def append(self, x):
        r"""append(VectorUInt32 self, std::vector< unsigned int >::value_type const & x)"""
        return _SimpleITK.VectorUInt32_append(self, x)

    def empty(self):
        r"""empty(VectorUInt32 self) -> bool"""
        return _SimpleITK.VectorUInt32_empty(self)

    def size(self):
        r"""size(VectorUInt32 self) -> std::vector< unsigned int >::size_type"""
        return _SimpleITK.VectorUInt32_size(self)

    def swap(self, v):
        r"""swap(VectorUInt32 self, VectorUInt32 v)"""
        return _SimpleITK.VectorUInt32_swap(self, v)

    def begin(self):
        r"""begin(VectorUInt32 self) -> std::vector< unsigned int >::iterator"""
        return _SimpleITK.VectorUInt32_begin(self)

    def end(self):
        r"""end(VectorUInt32 self) -> std::vector< unsigned int >::iterator"""
        return _SimpleITK.VectorUInt32_end(self)

    def rbegin(self):
        r"""rbegin(VectorUInt32 self) -> std::vector< unsigned int >::reverse_iterator"""
        return _SimpleITK.VectorUInt32_rbegin(self)

    def rend(self):
        r"""rend(VectorUInt32 self) -> std::vector< unsigned int >::reverse_iterator"""
        return _SimpleITK.VectorUInt32_rend(self)

    def clear(self):
        r"""clear(VectorUInt32 self)"""
        return _SimpleITK.VectorUInt32_clear(self)

    def get_allocator(self):
        r"""get_allocator(VectorUInt32 self) -> std::vector< unsigned int >::allocator_type"""
        return _SimpleITK.VectorUInt32_get_allocator(self)

    def pop_back(self):
        r"""pop_back(VectorUInt32 self)"""
        return _SimpleITK.VectorUInt32_pop_back(self)

    def erase(self, *args):
        r"""
        erase(VectorUInt32 self, std::vector< unsigned int >::iterator pos) -> std::vector< unsigned int >::iterator
        erase(VectorUInt32 self, std::vector< unsigned int >::iterator first, std::vector< unsigned int >::iterator last) -> std::vector< unsigned int >::iterator
        """
        return _SimpleITK.VectorUInt32_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(VectorUInt32 self) -> VectorUInt32
        __init__(VectorUInt32 self, VectorUInt32 other) -> VectorUInt32
        __init__(VectorUInt32 self, std::vector< unsigned int >::size_type size) -> VectorUInt32
        __init__(VectorUInt32 self, std::vector< unsigned int >::size_type size, std::vector< unsigned int >::value_type const & value) -> VectorUInt32
        """
        _SimpleITK.VectorUInt32_swiginit(
            self, _SimpleITK.new_VectorUInt32(*args)
        )

    def push_back(self, x):
        r"""push_back(VectorUInt32 self, std::vector< unsigned int >::value_type const & x)"""
        return _SimpleITK.VectorUInt32_push_back(self, x)

    def front(self):
        r"""front(VectorUInt32 self) -> std::vector< unsigned int >::value_type const &"""
        return _SimpleITK.VectorUInt32_front(self)

    def back(self):
        r"""back(VectorUInt32 self) -> std::vector< unsigned int >::value_type const &"""
        return _SimpleITK.VectorUInt32_back(self)

    def assign(self, n, x):
        r"""assign(VectorUInt32 self, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)"""
        return _SimpleITK.VectorUInt32_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(VectorUInt32 self, std::vector< unsigned int >::size_type new_size)
        resize(VectorUInt32 self, std::vector< unsigned int >::size_type new_size, std::vector< unsigned int >::value_type const & x)
        """
        return _SimpleITK.VectorUInt32_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(VectorUInt32 self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::value_type const & x) -> std::vector< unsigned int >::iterator
        insert(VectorUInt32 self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)
        """
        return _SimpleITK.VectorUInt32_insert(self, *args)

    def reserve(self, n):
        r"""reserve(VectorUInt32 self, std::vector< unsigned int >::size_type n)"""
        return _SimpleITK.VectorUInt32_reserve(self, n)

    def capacity(self):
        r"""capacity(VectorUInt32 self) -> std::vector< unsigned int >::size_type"""
        return _SimpleITK.VectorUInt32_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorUInt32


# Register VectorUInt32 in _SimpleITK:
_SimpleITK.VectorUInt32_swigregister(VectorUInt32)


class VectorInt32(object):
    r"""Proxy of C++ std::vector< int32_t > class."""

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(VectorInt32 self) -> SwigPyIterator"""
        return _SimpleITK.VectorInt32_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(VectorInt32 self) -> bool"""
        return _SimpleITK.VectorInt32___nonzero__(self)

    def __bool__(self):
        r"""__bool__(VectorInt32 self) -> bool"""
        return _SimpleITK.VectorInt32___bool__(self)

    def __len__(self):
        r"""__len__(VectorInt32 self) -> std::vector< int >::size_type"""
        return _SimpleITK.VectorInt32___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(VectorInt32 self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> VectorInt32"""
        return _SimpleITK.VectorInt32___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(VectorInt32 self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)
        __setslice__(VectorInt32 self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, VectorInt32 v)
        """
        return _SimpleITK.VectorInt32___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(VectorInt32 self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)"""
        return _SimpleITK.VectorInt32___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(VectorInt32 self, std::vector< int >::difference_type i)
        __delitem__(VectorInt32 self, SWIGPY_SLICEOBJECT * slice)
        """
        return _SimpleITK.VectorInt32___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(VectorInt32 self, SWIGPY_SLICEOBJECT * slice) -> VectorInt32
        __getitem__(VectorInt32 self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &
        """
        return _SimpleITK.VectorInt32___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(VectorInt32 self, SWIGPY_SLICEOBJECT * slice, VectorInt32 v)
        __setitem__(VectorInt32 self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(VectorInt32 self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)
        """
        return _SimpleITK.VectorInt32___setitem__(self, *args)

    def pop(self):
        r"""pop(VectorInt32 self) -> std::vector< int >::value_type"""
        return _SimpleITK.VectorInt32_pop(self)

    def append(self, x):
        r"""append(VectorInt32 self, std::vector< int >::value_type const & x)"""
        return _SimpleITK.VectorInt32_append(self, x)

    def empty(self):
        r"""empty(VectorInt32 self) -> bool"""
        return _SimpleITK.VectorInt32_empty(self)

    def size(self):
        r"""size(VectorInt32 self) -> std::vector< int >::size_type"""
        return _SimpleITK.VectorInt32_size(self)

    def swap(self, v):
        r"""swap(VectorInt32 self, VectorInt32 v)"""
        return _SimpleITK.VectorInt32_swap(self, v)

    def begin(self):
        r"""begin(VectorInt32 self) -> std::vector< int >::iterator"""
        return _SimpleITK.VectorInt32_begin(self)

    def end(self):
        r"""end(VectorInt32 self) -> std::vector< int >::iterator"""
        return _SimpleITK.VectorInt32_end(self)

    def rbegin(self):
        r"""rbegin(VectorInt32 self) -> std::vector< int >::reverse_iterator"""
        return _SimpleITK.VectorInt32_rbegin(self)

    def rend(self):
        r"""rend(VectorInt32 self) -> std::vector< int >::reverse_iterator"""
        return _SimpleITK.VectorInt32_rend(self)

    def clear(self):
        r"""clear(VectorInt32 self)"""
        return _SimpleITK.VectorInt32_clear(self)

    def get_allocator(self):
        r"""get_allocator(VectorInt32 self) -> std::vector< int >::allocator_type"""
        return _SimpleITK.VectorInt32_get_allocator(self)

    def pop_back(self):
        r"""pop_back(VectorInt32 self)"""
        return _SimpleITK.VectorInt32_pop_back(self)

    def erase(self, *args):
        r"""
        erase(VectorInt32 self, std::vector< int >::iterator pos) -> std::vector< int >::iterator
        erase(VectorInt32 self, std::vector< int >::iterator first, std::vector< int >::iterator last) -> std::vector< int >::iterator
        """
        return _SimpleITK.VectorInt32_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(VectorInt32 self) -> VectorInt32
        __init__(VectorInt32 self, VectorInt32 other) -> VectorInt32
        __init__(VectorInt32 self, std::vector< int >::size_type size) -> VectorInt32
        __init__(VectorInt32 self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> VectorInt32
        """
        _SimpleITK.VectorInt32_swiginit(
            self, _SimpleITK.new_VectorInt32(*args)
        )

    def push_back(self, x):
        r"""push_back(VectorInt32 self, std::vector< int >::value_type const & x)"""
        return _SimpleITK.VectorInt32_push_back(self, x)

    def front(self):
        r"""front(VectorInt32 self) -> std::vector< int >::value_type const &"""
        return _SimpleITK.VectorInt32_front(self)

    def back(self):
        r"""back(VectorInt32 self) -> std::vector< int >::value_type const &"""
        return _SimpleITK.VectorInt32_back(self)

    def assign(self, n, x):
        r"""assign(VectorInt32 self, std::vector< int >::size_type n, std::vector< int >::value_type const & x)"""
        return _SimpleITK.VectorInt32_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(VectorInt32 self, std::vector< int >::size_type new_size)
        resize(VectorInt32 self, std::vector< int >::size_type new_size, std::vector< int >::value_type const & x)
        """
        return _SimpleITK.VectorInt32_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(VectorInt32 self, std::vector< int >::iterator pos, std::vector< int >::value_type const & x) -> std::vector< int >::iterator
        insert(VectorInt32 self, std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const & x)
        """
        return _SimpleITK.VectorInt32_insert(self, *args)

    def reserve(self, n):
        r"""reserve(VectorInt32 self, std::vector< int >::size_type n)"""
        return _SimpleITK.VectorInt32_reserve(self, n)

    def capacity(self):
        r"""capacity(VectorInt32 self) -> std::vector< int >::size_type"""
        return _SimpleITK.VectorInt32_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorInt32


# Register VectorInt32 in _SimpleITK:
_SimpleITK.VectorInt32_swigregister(VectorInt32)


class VectorUInt64(object):
    r"""Proxy of C++ std::vector< uint64_t > class."""

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(VectorUInt64 self) -> SwigPyIterator"""
        return _SimpleITK.VectorUInt64_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(VectorUInt64 self) -> bool"""
        return _SimpleITK.VectorUInt64___nonzero__(self)

    def __bool__(self):
        r"""__bool__(VectorUInt64 self) -> bool"""
        return _SimpleITK.VectorUInt64___bool__(self)

    def __len__(self):
        r"""__len__(VectorUInt64 self) -> std::vector< unsigned long >::size_type"""
        return _SimpleITK.VectorUInt64___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(VectorUInt64 self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j) -> VectorUInt64"""
        return _SimpleITK.VectorUInt64___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(VectorUInt64 self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)
        __setslice__(VectorUInt64 self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j, VectorUInt64 v)
        """
        return _SimpleITK.VectorUInt64___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(VectorUInt64 self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)"""
        return _SimpleITK.VectorUInt64___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(VectorUInt64 self, std::vector< unsigned long >::difference_type i)
        __delitem__(VectorUInt64 self, SWIGPY_SLICEOBJECT * slice)
        """
        return _SimpleITK.VectorUInt64___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(VectorUInt64 self, SWIGPY_SLICEOBJECT * slice) -> VectorUInt64
        __getitem__(VectorUInt64 self, std::vector< unsigned long >::difference_type i) -> std::vector< unsigned long >::value_type const &
        """
        return _SimpleITK.VectorUInt64___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(VectorUInt64 self, SWIGPY_SLICEOBJECT * slice, VectorUInt64 v)
        __setitem__(VectorUInt64 self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(VectorUInt64 self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::value_type const & x)
        """
        return _SimpleITK.VectorUInt64___setitem__(self, *args)

    def pop(self):
        r"""pop(VectorUInt64 self) -> std::vector< unsigned long >::value_type"""
        return _SimpleITK.VectorUInt64_pop(self)

    def append(self, x):
        r"""append(VectorUInt64 self, std::vector< unsigned long >::value_type const & x)"""
        return _SimpleITK.VectorUInt64_append(self, x)

    def empty(self):
        r"""empty(VectorUInt64 self) -> bool"""
        return _SimpleITK.VectorUInt64_empty(self)

    def size(self):
        r"""size(VectorUInt64 self) -> std::vector< unsigned long >::size_type"""
        return _SimpleITK.VectorUInt64_size(self)

    def swap(self, v):
        r"""swap(VectorUInt64 self, VectorUInt64 v)"""
        return _SimpleITK.VectorUInt64_swap(self, v)

    def begin(self):
        r"""begin(VectorUInt64 self) -> std::vector< unsigned long >::iterator"""
        return _SimpleITK.VectorUInt64_begin(self)

    def end(self):
        r"""end(VectorUInt64 self) -> std::vector< unsigned long >::iterator"""
        return _SimpleITK.VectorUInt64_end(self)

    def rbegin(self):
        r"""rbegin(VectorUInt64 self) -> std::vector< unsigned long >::reverse_iterator"""
        return _SimpleITK.VectorUInt64_rbegin(self)

    def rend(self):
        r"""rend(VectorUInt64 self) -> std::vector< unsigned long >::reverse_iterator"""
        return _SimpleITK.VectorUInt64_rend(self)

    def clear(self):
        r"""clear(VectorUInt64 self)"""
        return _SimpleITK.VectorUInt64_clear(self)

    def get_allocator(self):
        r"""get_allocator(VectorUInt64 self) -> std::vector< unsigned long >::allocator_type"""
        return _SimpleITK.VectorUInt64_get_allocator(self)

    def pop_back(self):
        r"""pop_back(VectorUInt64 self)"""
        return _SimpleITK.VectorUInt64_pop_back(self)

    def erase(self, *args):
        r"""
        erase(VectorUInt64 self, std::vector< unsigned long >::iterator pos) -> std::vector< unsigned long >::iterator
        erase(VectorUInt64 self, std::vector< unsigned long >::iterator first, std::vector< unsigned long >::iterator last) -> std::vector< unsigned long >::iterator
        """
        return _SimpleITK.VectorUInt64_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(VectorUInt64 self) -> VectorUInt64
        __init__(VectorUInt64 self, VectorUInt64 other) -> VectorUInt64
        __init__(VectorUInt64 self, std::vector< unsigned long >::size_type size) -> VectorUInt64
        __init__(VectorUInt64 self, std::vector< unsigned long >::size_type size, std::vector< unsigned long >::value_type const & value) -> VectorUInt64
        """
        _SimpleITK.VectorUInt64_swiginit(
            self, _SimpleITK.new_VectorUInt64(*args)
        )

    def push_back(self, x):
        r"""push_back(VectorUInt64 self, std::vector< unsigned long >::value_type const & x)"""
        return _SimpleITK.VectorUInt64_push_back(self, x)

    def front(self):
        r"""front(VectorUInt64 self) -> std::vector< unsigned long >::value_type const &"""
        return _SimpleITK.VectorUInt64_front(self)

    def back(self):
        r"""back(VectorUInt64 self) -> std::vector< unsigned long >::value_type const &"""
        return _SimpleITK.VectorUInt64_back(self)

    def assign(self, n, x):
        r"""assign(VectorUInt64 self, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)"""
        return _SimpleITK.VectorUInt64_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(VectorUInt64 self, std::vector< unsigned long >::size_type new_size)
        resize(VectorUInt64 self, std::vector< unsigned long >::size_type new_size, std::vector< unsigned long >::value_type const & x)
        """
        return _SimpleITK.VectorUInt64_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(VectorUInt64 self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::value_type const & x) -> std::vector< unsigned long >::iterator
        insert(VectorUInt64 self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)
        """
        return _SimpleITK.VectorUInt64_insert(self, *args)

    def reserve(self, n):
        r"""reserve(VectorUInt64 self, std::vector< unsigned long >::size_type n)"""
        return _SimpleITK.VectorUInt64_reserve(self, n)

    def capacity(self):
        r"""capacity(VectorUInt64 self) -> std::vector< unsigned long >::size_type"""
        return _SimpleITK.VectorUInt64_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorUInt64


# Register VectorUInt64 in _SimpleITK:
_SimpleITK.VectorUInt64_swigregister(VectorUInt64)


class VectorInt64(object):
    r"""Proxy of C++ std::vector< int64_t > class."""

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(VectorInt64 self) -> SwigPyIterator"""
        return _SimpleITK.VectorInt64_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(VectorInt64 self) -> bool"""
        return _SimpleITK.VectorInt64___nonzero__(self)

    def __bool__(self):
        r"""__bool__(VectorInt64 self) -> bool"""
        return _SimpleITK.VectorInt64___bool__(self)

    def __len__(self):
        r"""__len__(VectorInt64 self) -> std::vector< long >::size_type"""
        return _SimpleITK.VectorInt64___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(VectorInt64 self, std::vector< long >::difference_type i, std::vector< long >::difference_type j) -> VectorInt64"""
        return _SimpleITK.VectorInt64___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(VectorInt64 self, std::vector< long >::difference_type i, std::vector< long >::difference_type j)
        __setslice__(VectorInt64 self, std::vector< long >::difference_type i, std::vector< long >::difference_type j, VectorInt64 v)
        """
        return _SimpleITK.VectorInt64___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(VectorInt64 self, std::vector< long >::difference_type i, std::vector< long >::difference_type j)"""
        return _SimpleITK.VectorInt64___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(VectorInt64 self, std::vector< long >::difference_type i)
        __delitem__(VectorInt64 self, SWIGPY_SLICEOBJECT * slice)
        """
        return _SimpleITK.VectorInt64___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(VectorInt64 self, SWIGPY_SLICEOBJECT * slice) -> VectorInt64
        __getitem__(VectorInt64 self, std::vector< long >::difference_type i) -> std::vector< long >::value_type const &
        """
        return _SimpleITK.VectorInt64___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(VectorInt64 self, SWIGPY_SLICEOBJECT * slice, VectorInt64 v)
        __setitem__(VectorInt64 self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(VectorInt64 self, std::vector< long >::difference_type i, std::vector< long >::value_type const & x)
        """
        return _SimpleITK.VectorInt64___setitem__(self, *args)

    def pop(self):
        r"""pop(VectorInt64 self) -> std::vector< long >::value_type"""
        return _SimpleITK.VectorInt64_pop(self)

    def append(self, x):
        r"""append(VectorInt64 self, std::vector< long >::value_type const & x)"""
        return _SimpleITK.VectorInt64_append(self, x)

    def empty(self):
        r"""empty(VectorInt64 self) -> bool"""
        return _SimpleITK.VectorInt64_empty(self)

    def size(self):
        r"""size(VectorInt64 self) -> std::vector< long >::size_type"""
        return _SimpleITK.VectorInt64_size(self)

    def swap(self, v):
        r"""swap(VectorInt64 self, VectorInt64 v)"""
        return _SimpleITK.VectorInt64_swap(self, v)

    def begin(self):
        r"""begin(VectorInt64 self) -> std::vector< long >::iterator"""
        return _SimpleITK.VectorInt64_begin(self)

    def end(self):
        r"""end(VectorInt64 self) -> std::vector< long >::iterator"""
        return _SimpleITK.VectorInt64_end(self)

    def rbegin(self):
        r"""rbegin(VectorInt64 self) -> std::vector< long >::reverse_iterator"""
        return _SimpleITK.VectorInt64_rbegin(self)

    def rend(self):
        r"""rend(VectorInt64 self) -> std::vector< long >::reverse_iterator"""
        return _SimpleITK.VectorInt64_rend(self)

    def clear(self):
        r"""clear(VectorInt64 self)"""
        return _SimpleITK.VectorInt64_clear(self)

    def get_allocator(self):
        r"""get_allocator(VectorInt64 self) -> std::vector< long >::allocator_type"""
        return _SimpleITK.VectorInt64_get_allocator(self)

    def pop_back(self):
        r"""pop_back(VectorInt64 self)"""
        return _SimpleITK.VectorInt64_pop_back(self)

    def erase(self, *args):
        r"""
        erase(VectorInt64 self, std::vector< long >::iterator pos) -> std::vector< long >::iterator
        erase(VectorInt64 self, std::vector< long >::iterator first, std::vector< long >::iterator last) -> std::vector< long >::iterator
        """
        return _SimpleITK.VectorInt64_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(VectorInt64 self) -> VectorInt64
        __init__(VectorInt64 self, VectorInt64 other) -> VectorInt64
        __init__(VectorInt64 self, std::vector< long >::size_type size) -> VectorInt64
        __init__(VectorInt64 self, std::vector< long >::size_type size, std::vector< long >::value_type const & value) -> VectorInt64
        """
        _SimpleITK.VectorInt64_swiginit(
            self, _SimpleITK.new_VectorInt64(*args)
        )

    def push_back(self, x):
        r"""push_back(VectorInt64 self, std::vector< long >::value_type const & x)"""
        return _SimpleITK.VectorInt64_push_back(self, x)

    def front(self):
        r"""front(VectorInt64 self) -> std::vector< long >::value_type const &"""
        return _SimpleITK.VectorInt64_front(self)

    def back(self):
        r"""back(VectorInt64 self) -> std::vector< long >::value_type const &"""
        return _SimpleITK.VectorInt64_back(self)

    def assign(self, n, x):
        r"""assign(VectorInt64 self, std::vector< long >::size_type n, std::vector< long >::value_type const & x)"""
        return _SimpleITK.VectorInt64_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(VectorInt64 self, std::vector< long >::size_type new_size)
        resize(VectorInt64 self, std::vector< long >::size_type new_size, std::vector< long >::value_type const & x)
        """
        return _SimpleITK.VectorInt64_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(VectorInt64 self, std::vector< long >::iterator pos, std::vector< long >::value_type const & x) -> std::vector< long >::iterator
        insert(VectorInt64 self, std::vector< long >::iterator pos, std::vector< long >::size_type n, std::vector< long >::value_type const & x)
        """
        return _SimpleITK.VectorInt64_insert(self, *args)

    def reserve(self, n):
        r"""reserve(VectorInt64 self, std::vector< long >::size_type n)"""
        return _SimpleITK.VectorInt64_reserve(self, n)

    def capacity(self):
        r"""capacity(VectorInt64 self) -> std::vector< long >::size_type"""
        return _SimpleITK.VectorInt64_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorInt64


# Register VectorInt64 in _SimpleITK:
_SimpleITK.VectorInt64_swigregister(VectorInt64)


class VectorFloat(object):
    r"""Proxy of C++ std::vector< float > class."""

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(VectorFloat self) -> SwigPyIterator"""
        return _SimpleITK.VectorFloat_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(VectorFloat self) -> bool"""
        return _SimpleITK.VectorFloat___nonzero__(self)

    def __bool__(self):
        r"""__bool__(VectorFloat self) -> bool"""
        return _SimpleITK.VectorFloat___bool__(self)

    def __len__(self):
        r"""__len__(VectorFloat self) -> std::vector< float >::size_type"""
        return _SimpleITK.VectorFloat___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(VectorFloat self, std::vector< float >::difference_type i, std::vector< float >::difference_type j) -> VectorFloat"""
        return _SimpleITK.VectorFloat___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(VectorFloat self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)
        __setslice__(VectorFloat self, std::vector< float >::difference_type i, std::vector< float >::difference_type j, VectorFloat v)
        """
        return _SimpleITK.VectorFloat___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(VectorFloat self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)"""
        return _SimpleITK.VectorFloat___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(VectorFloat self, std::vector< float >::difference_type i)
        __delitem__(VectorFloat self, SWIGPY_SLICEOBJECT * slice)
        """
        return _SimpleITK.VectorFloat___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(VectorFloat self, SWIGPY_SLICEOBJECT * slice) -> VectorFloat
        __getitem__(VectorFloat self, std::vector< float >::difference_type i) -> std::vector< float >::value_type const &
        """
        return _SimpleITK.VectorFloat___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(VectorFloat self, SWIGPY_SLICEOBJECT * slice, VectorFloat v)
        __setitem__(VectorFloat self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(VectorFloat self, std::vector< float >::difference_type i, std::vector< float >::value_type const & x)
        """
        return _SimpleITK.VectorFloat___setitem__(self, *args)

    def pop(self):
        r"""pop(VectorFloat self) -> std::vector< float >::value_type"""
        return _SimpleITK.VectorFloat_pop(self)

    def append(self, x):
        r"""append(VectorFloat self, std::vector< float >::value_type const & x)"""
        return _SimpleITK.VectorFloat_append(self, x)

    def empty(self):
        r"""empty(VectorFloat self) -> bool"""
        return _SimpleITK.VectorFloat_empty(self)

    def size(self):
        r"""size(VectorFloat self) -> std::vector< float >::size_type"""
        return _SimpleITK.VectorFloat_size(self)

    def swap(self, v):
        r"""swap(VectorFloat self, VectorFloat v)"""
        return _SimpleITK.VectorFloat_swap(self, v)

    def begin(self):
        r"""begin(VectorFloat self) -> std::vector< float >::iterator"""
        return _SimpleITK.VectorFloat_begin(self)

    def end(self):
        r"""end(VectorFloat self) -> std::vector< float >::iterator"""
        return _SimpleITK.VectorFloat_end(self)

    def rbegin(self):
        r"""rbegin(VectorFloat self) -> std::vector< float >::reverse_iterator"""
        return _SimpleITK.VectorFloat_rbegin(self)

    def rend(self):
        r"""rend(VectorFloat self) -> std::vector< float >::reverse_iterator"""
        return _SimpleITK.VectorFloat_rend(self)

    def clear(self):
        r"""clear(VectorFloat self)"""
        return _SimpleITK.VectorFloat_clear(self)

    def get_allocator(self):
        r"""get_allocator(VectorFloat self) -> std::vector< float >::allocator_type"""
        return _SimpleITK.VectorFloat_get_allocator(self)

    def pop_back(self):
        r"""pop_back(VectorFloat self)"""
        return _SimpleITK.VectorFloat_pop_back(self)

    def erase(self, *args):
        r"""
        erase(VectorFloat self, std::vector< float >::iterator pos) -> std::vector< float >::iterator
        erase(VectorFloat self, std::vector< float >::iterator first, std::vector< float >::iterator last) -> std::vector< float >::iterator
        """
        return _SimpleITK.VectorFloat_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(VectorFloat self) -> VectorFloat
        __init__(VectorFloat self, VectorFloat other) -> VectorFloat
        __init__(VectorFloat self, std::vector< float >::size_type size) -> VectorFloat
        __init__(VectorFloat self, std::vector< float >::size_type size, std::vector< float >::value_type const & value) -> VectorFloat
        """
        _SimpleITK.VectorFloat_swiginit(
            self, _SimpleITK.new_VectorFloat(*args)
        )

    def push_back(self, x):
        r"""push_back(VectorFloat self, std::vector< float >::value_type const & x)"""
        return _SimpleITK.VectorFloat_push_back(self, x)

    def front(self):
        r"""front(VectorFloat self) -> std::vector< float >::value_type const &"""
        return _SimpleITK.VectorFloat_front(self)

    def back(self):
        r"""back(VectorFloat self) -> std::vector< float >::value_type const &"""
        return _SimpleITK.VectorFloat_back(self)

    def assign(self, n, x):
        r"""assign(VectorFloat self, std::vector< float >::size_type n, std::vector< float >::value_type const & x)"""
        return _SimpleITK.VectorFloat_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(VectorFloat self, std::vector< float >::size_type new_size)
        resize(VectorFloat self, std::vector< float >::size_type new_size, std::vector< float >::value_type const & x)
        """
        return _SimpleITK.VectorFloat_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(VectorFloat self, std::vector< float >::iterator pos, std::vector< float >::value_type const & x) -> std::vector< float >::iterator
        insert(VectorFloat self, std::vector< float >::iterator pos, std::vector< float >::size_type n, std::vector< float >::value_type const & x)
        """
        return _SimpleITK.VectorFloat_insert(self, *args)

    def reserve(self, n):
        r"""reserve(VectorFloat self, std::vector< float >::size_type n)"""
        return _SimpleITK.VectorFloat_reserve(self, n)

    def capacity(self):
        r"""capacity(VectorFloat self) -> std::vector< float >::size_type"""
        return _SimpleITK.VectorFloat_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorFloat


# Register VectorFloat in _SimpleITK:
_SimpleITK.VectorFloat_swigregister(VectorFloat)


class VectorDouble(object):
    r"""Proxy of C++ std::vector< double > class."""

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(VectorDouble self) -> SwigPyIterator"""
        return _SimpleITK.VectorDouble_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(VectorDouble self) -> bool"""
        return _SimpleITK.VectorDouble___nonzero__(self)

    def __bool__(self):
        r"""__bool__(VectorDouble self) -> bool"""
        return _SimpleITK.VectorDouble___bool__(self)

    def __len__(self):
        r"""__len__(VectorDouble self) -> std::vector< double >::size_type"""
        return _SimpleITK.VectorDouble___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(VectorDouble self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> VectorDouble"""
        return _SimpleITK.VectorDouble___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(VectorDouble self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(VectorDouble self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, VectorDouble v)
        """
        return _SimpleITK.VectorDouble___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(VectorDouble self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _SimpleITK.VectorDouble___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(VectorDouble self, std::vector< double >::difference_type i)
        __delitem__(VectorDouble self, SWIGPY_SLICEOBJECT * slice)
        """
        return _SimpleITK.VectorDouble___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(VectorDouble self, SWIGPY_SLICEOBJECT * slice) -> VectorDouble
        __getitem__(VectorDouble self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _SimpleITK.VectorDouble___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(VectorDouble self, SWIGPY_SLICEOBJECT * slice, VectorDouble v)
        __setitem__(VectorDouble self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(VectorDouble self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _SimpleITK.VectorDouble___setitem__(self, *args)

    def pop(self):
        r"""pop(VectorDouble self) -> std::vector< double >::value_type"""
        return _SimpleITK.VectorDouble_pop(self)

    def append(self, x):
        r"""append(VectorDouble self, std::vector< double >::value_type const & x)"""
        return _SimpleITK.VectorDouble_append(self, x)

    def empty(self):
        r"""empty(VectorDouble self) -> bool"""
        return _SimpleITK.VectorDouble_empty(self)

    def size(self):
        r"""size(VectorDouble self) -> std::vector< double >::size_type"""
        return _SimpleITK.VectorDouble_size(self)

    def swap(self, v):
        r"""swap(VectorDouble self, VectorDouble v)"""
        return _SimpleITK.VectorDouble_swap(self, v)

    def begin(self):
        r"""begin(VectorDouble self) -> std::vector< double >::iterator"""
        return _SimpleITK.VectorDouble_begin(self)

    def end(self):
        r"""end(VectorDouble self) -> std::vector< double >::iterator"""
        return _SimpleITK.VectorDouble_end(self)

    def rbegin(self):
        r"""rbegin(VectorDouble self) -> std::vector< double >::reverse_iterator"""
        return _SimpleITK.VectorDouble_rbegin(self)

    def rend(self):
        r"""rend(VectorDouble self) -> std::vector< double >::reverse_iterator"""
        return _SimpleITK.VectorDouble_rend(self)

    def clear(self):
        r"""clear(VectorDouble self)"""
        return _SimpleITK.VectorDouble_clear(self)

    def get_allocator(self):
        r"""get_allocator(VectorDouble self) -> std::vector< double >::allocator_type"""
        return _SimpleITK.VectorDouble_get_allocator(self)

    def pop_back(self):
        r"""pop_back(VectorDouble self)"""
        return _SimpleITK.VectorDouble_pop_back(self)

    def erase(self, *args):
        r"""
        erase(VectorDouble self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(VectorDouble self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _SimpleITK.VectorDouble_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(VectorDouble self) -> VectorDouble
        __init__(VectorDouble self, VectorDouble other) -> VectorDouble
        __init__(VectorDouble self, std::vector< double >::size_type size) -> VectorDouble
        __init__(VectorDouble self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> VectorDouble
        """
        _SimpleITK.VectorDouble_swiginit(
            self, _SimpleITK.new_VectorDouble(*args)
        )

    def push_back(self, x):
        r"""push_back(VectorDouble self, std::vector< double >::value_type const & x)"""
        return _SimpleITK.VectorDouble_push_back(self, x)

    def front(self):
        r"""front(VectorDouble self) -> std::vector< double >::value_type const &"""
        return _SimpleITK.VectorDouble_front(self)

    def back(self):
        r"""back(VectorDouble self) -> std::vector< double >::value_type const &"""
        return _SimpleITK.VectorDouble_back(self)

    def assign(self, n, x):
        r"""assign(VectorDouble self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _SimpleITK.VectorDouble_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(VectorDouble self, std::vector< double >::size_type new_size)
        resize(VectorDouble self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _SimpleITK.VectorDouble_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(VectorDouble self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(VectorDouble self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _SimpleITK.VectorDouble_insert(self, *args)

    def reserve(self, n):
        r"""reserve(VectorDouble self, std::vector< double >::size_type n)"""
        return _SimpleITK.VectorDouble_reserve(self, n)

    def capacity(self):
        r"""capacity(VectorDouble self) -> std::vector< double >::size_type"""
        return _SimpleITK.VectorDouble_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorDouble


# Register VectorDouble in _SimpleITK:
_SimpleITK.VectorDouble_swigregister(VectorDouble)


class VectorOfImage(object):
    r"""Proxy of C++ std::vector< itk::simple::Image > class."""

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(VectorOfImage self) -> SwigPyIterator"""
        return _SimpleITK.VectorOfImage_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(VectorOfImage self) -> bool"""
        return _SimpleITK.VectorOfImage___nonzero__(self)

    def __bool__(self):
        r"""__bool__(VectorOfImage self) -> bool"""
        return _SimpleITK.VectorOfImage___bool__(self)

    def __len__(self):
        r"""__len__(VectorOfImage self) -> std::vector< itk::simple::Image >::size_type"""
        return _SimpleITK.VectorOfImage___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(VectorOfImage self, std::vector< itk::simple::Image >::difference_type i, std::vector< itk::simple::Image >::difference_type j) -> VectorOfImage"""
        return _SimpleITK.VectorOfImage___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(VectorOfImage self, std::vector< itk::simple::Image >::difference_type i, std::vector< itk::simple::Image >::difference_type j)
        __setslice__(VectorOfImage self, std::vector< itk::simple::Image >::difference_type i, std::vector< itk::simple::Image >::difference_type j, VectorOfImage v)
        """
        return _SimpleITK.VectorOfImage___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(VectorOfImage self, std::vector< itk::simple::Image >::difference_type i, std::vector< itk::simple::Image >::difference_type j)"""
        return _SimpleITK.VectorOfImage___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(VectorOfImage self, std::vector< itk::simple::Image >::difference_type i)
        __delitem__(VectorOfImage self, SWIGPY_SLICEOBJECT * slice)
        """
        return _SimpleITK.VectorOfImage___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(VectorOfImage self, SWIGPY_SLICEOBJECT * slice) -> VectorOfImage
        __getitem__(VectorOfImage self, std::vector< itk::simple::Image >::difference_type i) -> Image
        """
        return _SimpleITK.VectorOfImage___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(VectorOfImage self, SWIGPY_SLICEOBJECT * slice, VectorOfImage v)
        __setitem__(VectorOfImage self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(VectorOfImage self, std::vector< itk::simple::Image >::difference_type i, Image x)
        """
        return _SimpleITK.VectorOfImage___setitem__(self, *args)

    def pop(self):
        r"""pop(VectorOfImage self) -> Image"""
        return _SimpleITK.VectorOfImage_pop(self)

    def append(self, x):
        r"""append(VectorOfImage self, Image x)"""
        return _SimpleITK.VectorOfImage_append(self, x)

    def empty(self):
        r"""empty(VectorOfImage self) -> bool"""
        return _SimpleITK.VectorOfImage_empty(self)

    def size(self):
        r"""size(VectorOfImage self) -> std::vector< itk::simple::Image >::size_type"""
        return _SimpleITK.VectorOfImage_size(self)

    def swap(self, v):
        r"""swap(VectorOfImage self, VectorOfImage v)"""
        return _SimpleITK.VectorOfImage_swap(self, v)

    def begin(self):
        r"""begin(VectorOfImage self) -> std::vector< itk::simple::Image >::iterator"""
        return _SimpleITK.VectorOfImage_begin(self)

    def end(self):
        r"""end(VectorOfImage self) -> std::vector< itk::simple::Image >::iterator"""
        return _SimpleITK.VectorOfImage_end(self)

    def rbegin(self):
        r"""rbegin(VectorOfImage self) -> std::vector< itk::simple::Image >::reverse_iterator"""
        return _SimpleITK.VectorOfImage_rbegin(self)

    def rend(self):
        r"""rend(VectorOfImage self) -> std::vector< itk::simple::Image >::reverse_iterator"""
        return _SimpleITK.VectorOfImage_rend(self)

    def clear(self):
        r"""clear(VectorOfImage self)"""
        return _SimpleITK.VectorOfImage_clear(self)

    def get_allocator(self):
        r"""get_allocator(VectorOfImage self) -> std::vector< itk::simple::Image >::allocator_type"""
        return _SimpleITK.VectorOfImage_get_allocator(self)

    def pop_back(self):
        r"""pop_back(VectorOfImage self)"""
        return _SimpleITK.VectorOfImage_pop_back(self)

    def erase(self, *args):
        r"""
        erase(VectorOfImage self, std::vector< itk::simple::Image >::iterator pos) -> std::vector< itk::simple::Image >::iterator
        erase(VectorOfImage self, std::vector< itk::simple::Image >::iterator first, std::vector< itk::simple::Image >::iterator last) -> std::vector< itk::simple::Image >::iterator
        """
        return _SimpleITK.VectorOfImage_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(VectorOfImage self) -> VectorOfImage
        __init__(VectorOfImage self, VectorOfImage other) -> VectorOfImage
        __init__(VectorOfImage self, std::vector< itk::simple::Image >::size_type size) -> VectorOfImage
        __init__(VectorOfImage self, std::vector< itk::simple::Image >::size_type size, Image value) -> VectorOfImage
        """
        _SimpleITK.VectorOfImage_swiginit(
            self, _SimpleITK.new_VectorOfImage(*args)
        )

    def push_back(self, x):
        r"""push_back(VectorOfImage self, Image x)"""
        return _SimpleITK.VectorOfImage_push_back(self, x)

    def front(self):
        r"""front(VectorOfImage self) -> Image"""
        return _SimpleITK.VectorOfImage_front(self)

    def back(self):
        r"""back(VectorOfImage self) -> Image"""
        return _SimpleITK.VectorOfImage_back(self)

    def assign(self, n, x):
        r"""assign(VectorOfImage self, std::vector< itk::simple::Image >::size_type n, Image x)"""
        return _SimpleITK.VectorOfImage_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(VectorOfImage self, std::vector< itk::simple::Image >::size_type new_size)
        resize(VectorOfImage self, std::vector< itk::simple::Image >::size_type new_size, Image x)
        """
        return _SimpleITK.VectorOfImage_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(VectorOfImage self, std::vector< itk::simple::Image >::iterator pos, Image x) -> std::vector< itk::simple::Image >::iterator
        insert(VectorOfImage self, std::vector< itk::simple::Image >::iterator pos, std::vector< itk::simple::Image >::size_type n, Image x)
        """
        return _SimpleITK.VectorOfImage_insert(self, *args)

    def reserve(self, n):
        r"""reserve(VectorOfImage self, std::vector< itk::simple::Image >::size_type n)"""
        return _SimpleITK.VectorOfImage_reserve(self, n)

    def capacity(self):
        r"""capacity(VectorOfImage self) -> std::vector< itk::simple::Image >::size_type"""
        return _SimpleITK.VectorOfImage_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorOfImage


# Register VectorOfImage in _SimpleITK:
_SimpleITK.VectorOfImage_swigregister(VectorOfImage)


class VectorOfTransform(object):
    r"""Proxy of C++ std::vector< itk::simple::Transform > class."""

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(VectorOfTransform self) -> SwigPyIterator"""
        return _SimpleITK.VectorOfTransform_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(VectorOfTransform self) -> bool"""
        return _SimpleITK.VectorOfTransform___nonzero__(self)

    def __bool__(self):
        r"""__bool__(VectorOfTransform self) -> bool"""
        return _SimpleITK.VectorOfTransform___bool__(self)

    def __len__(self):
        r"""__len__(VectorOfTransform self) -> std::vector< itk::simple::Transform >::size_type"""
        return _SimpleITK.VectorOfTransform___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(VectorOfTransform self, std::vector< itk::simple::Transform >::difference_type i, std::vector< itk::simple::Transform >::difference_type j) -> VectorOfTransform"""
        return _SimpleITK.VectorOfTransform___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(VectorOfTransform self, std::vector< itk::simple::Transform >::difference_type i, std::vector< itk::simple::Transform >::difference_type j)
        __setslice__(VectorOfTransform self, std::vector< itk::simple::Transform >::difference_type i, std::vector< itk::simple::Transform >::difference_type j, VectorOfTransform v)
        """
        return _SimpleITK.VectorOfTransform___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(VectorOfTransform self, std::vector< itk::simple::Transform >::difference_type i, std::vector< itk::simple::Transform >::difference_type j)"""
        return _SimpleITK.VectorOfTransform___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(VectorOfTransform self, std::vector< itk::simple::Transform >::difference_type i)
        __delitem__(VectorOfTransform self, SWIGPY_SLICEOBJECT * slice)
        """
        return _SimpleITK.VectorOfTransform___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(VectorOfTransform self, SWIGPY_SLICEOBJECT * slice) -> VectorOfTransform
        __getitem__(VectorOfTransform self, std::vector< itk::simple::Transform >::difference_type i) -> Transform
        """
        return _SimpleITK.VectorOfTransform___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(VectorOfTransform self, SWIGPY_SLICEOBJECT * slice, VectorOfTransform v)
        __setitem__(VectorOfTransform self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(VectorOfTransform self, std::vector< itk::simple::Transform >::difference_type i, Transform x)
        """
        return _SimpleITK.VectorOfTransform___setitem__(self, *args)

    def pop(self):
        r"""pop(VectorOfTransform self) -> Transform"""
        return _SimpleITK.VectorOfTransform_pop(self)

    def append(self, x):
        r"""append(VectorOfTransform self, Transform x)"""
        return _SimpleITK.VectorOfTransform_append(self, x)

    def empty(self):
        r"""empty(VectorOfTransform self) -> bool"""
        return _SimpleITK.VectorOfTransform_empty(self)

    def size(self):
        r"""size(VectorOfTransform self) -> std::vector< itk::simple::Transform >::size_type"""
        return _SimpleITK.VectorOfTransform_size(self)

    def swap(self, v):
        r"""swap(VectorOfTransform self, VectorOfTransform v)"""
        return _SimpleITK.VectorOfTransform_swap(self, v)

    def begin(self):
        r"""begin(VectorOfTransform self) -> std::vector< itk::simple::Transform >::iterator"""
        return _SimpleITK.VectorOfTransform_begin(self)

    def end(self):
        r"""end(VectorOfTransform self) -> std::vector< itk::simple::Transform >::iterator"""
        return _SimpleITK.VectorOfTransform_end(self)

    def rbegin(self):
        r"""rbegin(VectorOfTransform self) -> std::vector< itk::simple::Transform >::reverse_iterator"""
        return _SimpleITK.VectorOfTransform_rbegin(self)

    def rend(self):
        r"""rend(VectorOfTransform self) -> std::vector< itk::simple::Transform >::reverse_iterator"""
        return _SimpleITK.VectorOfTransform_rend(self)

    def clear(self):
        r"""clear(VectorOfTransform self)"""
        return _SimpleITK.VectorOfTransform_clear(self)

    def get_allocator(self):
        r"""get_allocator(VectorOfTransform self) -> std::vector< itk::simple::Transform >::allocator_type"""
        return _SimpleITK.VectorOfTransform_get_allocator(self)

    def pop_back(self):
        r"""pop_back(VectorOfTransform self)"""
        return _SimpleITK.VectorOfTransform_pop_back(self)

    def erase(self, *args):
        r"""
        erase(VectorOfTransform self, std::vector< itk::simple::Transform >::iterator pos) -> std::vector< itk::simple::Transform >::iterator
        erase(VectorOfTransform self, std::vector< itk::simple::Transform >::iterator first, std::vector< itk::simple::Transform >::iterator last) -> std::vector< itk::simple::Transform >::iterator
        """
        return _SimpleITK.VectorOfTransform_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(VectorOfTransform self) -> VectorOfTransform
        __init__(VectorOfTransform self, VectorOfTransform other) -> VectorOfTransform
        __init__(VectorOfTransform self, std::vector< itk::simple::Transform >::size_type size) -> VectorOfTransform
        __init__(VectorOfTransform self, std::vector< itk::simple::Transform >::size_type size, Transform value) -> VectorOfTransform
        """
        _SimpleITK.VectorOfTransform_swiginit(
            self, _SimpleITK.new_VectorOfTransform(*args)
        )

    def push_back(self, x):
        r"""push_back(VectorOfTransform self, Transform x)"""
        return _SimpleITK.VectorOfTransform_push_back(self, x)

    def front(self):
        r"""front(VectorOfTransform self) -> Transform"""
        return _SimpleITK.VectorOfTransform_front(self)

    def back(self):
        r"""back(VectorOfTransform self) -> Transform"""
        return _SimpleITK.VectorOfTransform_back(self)

    def assign(self, n, x):
        r"""assign(VectorOfTransform self, std::vector< itk::simple::Transform >::size_type n, Transform x)"""
        return _SimpleITK.VectorOfTransform_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(VectorOfTransform self, std::vector< itk::simple::Transform >::size_type new_size)
        resize(VectorOfTransform self, std::vector< itk::simple::Transform >::size_type new_size, Transform x)
        """
        return _SimpleITK.VectorOfTransform_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(VectorOfTransform self, std::vector< itk::simple::Transform >::iterator pos, Transform x) -> std::vector< itk::simple::Transform >::iterator
        insert(VectorOfTransform self, std::vector< itk::simple::Transform >::iterator pos, std::vector< itk::simple::Transform >::size_type n, Transform x)
        """
        return _SimpleITK.VectorOfTransform_insert(self, *args)

    def reserve(self, n):
        r"""reserve(VectorOfTransform self, std::vector< itk::simple::Transform >::size_type n)"""
        return _SimpleITK.VectorOfTransform_reserve(self, n)

    def capacity(self):
        r"""capacity(VectorOfTransform self) -> std::vector< itk::simple::Transform >::size_type"""
        return _SimpleITK.VectorOfTransform_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorOfTransform


# Register VectorOfTransform in _SimpleITK:
_SimpleITK.VectorOfTransform_swigregister(VectorOfTransform)


class VectorUIntList(object):
    r"""Proxy of C++ std::vector< std::vector< unsigned int > > class."""

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(VectorUIntList self) -> SwigPyIterator"""
        return _SimpleITK.VectorUIntList_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(VectorUIntList self) -> bool"""
        return _SimpleITK.VectorUIntList___nonzero__(self)

    def __bool__(self):
        r"""__bool__(VectorUIntList self) -> bool"""
        return _SimpleITK.VectorUIntList___bool__(self)

    def __len__(self):
        r"""__len__(VectorUIntList self) -> std::vector< std::vector< unsigned int > >::size_type"""
        return _SimpleITK.VectorUIntList___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(VectorUIntList self, std::vector< std::vector< unsigned int > >::difference_type i, std::vector< std::vector< unsigned int > >::difference_type j) -> VectorUIntList"""
        return _SimpleITK.VectorUIntList___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(VectorUIntList self, std::vector< std::vector< unsigned int > >::difference_type i, std::vector< std::vector< unsigned int > >::difference_type j)
        __setslice__(VectorUIntList self, std::vector< std::vector< unsigned int > >::difference_type i, std::vector< std::vector< unsigned int > >::difference_type j, VectorUIntList v)
        """
        return _SimpleITK.VectorUIntList___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(VectorUIntList self, std::vector< std::vector< unsigned int > >::difference_type i, std::vector< std::vector< unsigned int > >::difference_type j)"""
        return _SimpleITK.VectorUIntList___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(VectorUIntList self, std::vector< std::vector< unsigned int > >::difference_type i)
        __delitem__(VectorUIntList self, SWIGPY_SLICEOBJECT * slice)
        """
        return _SimpleITK.VectorUIntList___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(VectorUIntList self, SWIGPY_SLICEOBJECT * slice) -> VectorUIntList
        __getitem__(VectorUIntList self, std::vector< std::vector< unsigned int > >::difference_type i) -> VectorUInt32
        """
        return _SimpleITK.VectorUIntList___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(VectorUIntList self, SWIGPY_SLICEOBJECT * slice, VectorUIntList v)
        __setitem__(VectorUIntList self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(VectorUIntList self, std::vector< std::vector< unsigned int > >::difference_type i, VectorUInt32 x)
        """
        return _SimpleITK.VectorUIntList___setitem__(self, *args)

    def pop(self):
        r"""pop(VectorUIntList self) -> VectorUInt32"""
        return _SimpleITK.VectorUIntList_pop(self)

    def append(self, x):
        r"""append(VectorUIntList self, VectorUInt32 x)"""
        return _SimpleITK.VectorUIntList_append(self, x)

    def empty(self):
        r"""empty(VectorUIntList self) -> bool"""
        return _SimpleITK.VectorUIntList_empty(self)

    def size(self):
        r"""size(VectorUIntList self) -> std::vector< std::vector< unsigned int > >::size_type"""
        return _SimpleITK.VectorUIntList_size(self)

    def swap(self, v):
        r"""swap(VectorUIntList self, std::vector< std::vector< unsigned int,std::allocator< unsigned int > > > & v)"""
        return _SimpleITK.VectorUIntList_swap(self, v)

    def begin(self):
        r"""begin(VectorUIntList self) -> std::vector< std::vector< unsigned int > >::iterator"""
        return _SimpleITK.VectorUIntList_begin(self)

    def end(self):
        r"""end(VectorUIntList self) -> std::vector< std::vector< unsigned int > >::iterator"""
        return _SimpleITK.VectorUIntList_end(self)

    def rbegin(self):
        r"""rbegin(VectorUIntList self) -> std::vector< std::vector< unsigned int > >::reverse_iterator"""
        return _SimpleITK.VectorUIntList_rbegin(self)

    def rend(self):
        r"""rend(VectorUIntList self) -> std::vector< std::vector< unsigned int > >::reverse_iterator"""
        return _SimpleITK.VectorUIntList_rend(self)

    def clear(self):
        r"""clear(VectorUIntList self)"""
        return _SimpleITK.VectorUIntList_clear(self)

    def get_allocator(self):
        r"""get_allocator(VectorUIntList self) -> std::vector< std::vector< unsigned int > >::allocator_type"""
        return _SimpleITK.VectorUIntList_get_allocator(self)

    def pop_back(self):
        r"""pop_back(VectorUIntList self)"""
        return _SimpleITK.VectorUIntList_pop_back(self)

    def erase(self, *args):
        r"""
        erase(VectorUIntList self, std::vector< std::vector< unsigned int > >::iterator pos) -> std::vector< std::vector< unsigned int > >::iterator
        erase(VectorUIntList self, std::vector< std::vector< unsigned int > >::iterator first, std::vector< std::vector< unsigned int > >::iterator last) -> std::vector< std::vector< unsigned int > >::iterator
        """
        return _SimpleITK.VectorUIntList_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(VectorUIntList self) -> VectorUIntList
        __init__(VectorUIntList self, std::vector< std::vector< unsigned int,std::allocator< unsigned int > > > const & other) -> VectorUIntList
        __init__(VectorUIntList self, std::vector< std::vector< unsigned int > >::size_type size) -> VectorUIntList
        __init__(VectorUIntList self, std::vector< std::vector< unsigned int > >::size_type size, VectorUInt32 value) -> VectorUIntList
        """
        _SimpleITK.VectorUIntList_swiginit(
            self, _SimpleITK.new_VectorUIntList(*args)
        )

    def push_back(self, x):
        r"""push_back(VectorUIntList self, VectorUInt32 x)"""
        return _SimpleITK.VectorUIntList_push_back(self, x)

    def front(self):
        r"""front(VectorUIntList self) -> VectorUInt32"""
        return _SimpleITK.VectorUIntList_front(self)

    def back(self):
        r"""back(VectorUIntList self) -> VectorUInt32"""
        return _SimpleITK.VectorUIntList_back(self)

    def assign(self, n, x):
        r"""assign(VectorUIntList self, std::vector< std::vector< unsigned int > >::size_type n, VectorUInt32 x)"""
        return _SimpleITK.VectorUIntList_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(VectorUIntList self, std::vector< std::vector< unsigned int > >::size_type new_size)
        resize(VectorUIntList self, std::vector< std::vector< unsigned int > >::size_type new_size, VectorUInt32 x)
        """
        return _SimpleITK.VectorUIntList_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(VectorUIntList self, std::vector< std::vector< unsigned int > >::iterator pos, VectorUInt32 x) -> std::vector< std::vector< unsigned int > >::iterator
        insert(VectorUIntList self, std::vector< std::vector< unsigned int > >::iterator pos, std::vector< std::vector< unsigned int > >::size_type n, VectorUInt32 x)
        """
        return _SimpleITK.VectorUIntList_insert(self, *args)

    def reserve(self, n):
        r"""reserve(VectorUIntList self, std::vector< std::vector< unsigned int > >::size_type n)"""
        return _SimpleITK.VectorUIntList_reserve(self, n)

    def capacity(self):
        r"""capacity(VectorUIntList self) -> std::vector< std::vector< unsigned int > >::size_type"""
        return _SimpleITK.VectorUIntList_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorUIntList


# Register VectorUIntList in _SimpleITK:
_SimpleITK.VectorUIntList_swigregister(VectorUIntList)


class VectorString(object):
    r"""Proxy of C++ std::vector< std::string > class."""

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(VectorString self) -> SwigPyIterator"""
        return _SimpleITK.VectorString_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(VectorString self) -> bool"""
        return _SimpleITK.VectorString___nonzero__(self)

    def __bool__(self):
        r"""__bool__(VectorString self) -> bool"""
        return _SimpleITK.VectorString___bool__(self)

    def __len__(self):
        r"""__len__(VectorString self) -> std::vector< std::string >::size_type"""
        return _SimpleITK.VectorString___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(VectorString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> VectorString"""
        return _SimpleITK.VectorString___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(VectorString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        __setslice__(VectorString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, VectorString v)
        """
        return _SimpleITK.VectorString___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(VectorString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _SimpleITK.VectorString___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(VectorString self, std::vector< std::string >::difference_type i)
        __delitem__(VectorString self, SWIGPY_SLICEOBJECT * slice)
        """
        return _SimpleITK.VectorString___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(VectorString self, SWIGPY_SLICEOBJECT * slice) -> VectorString
        __getitem__(VectorString self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _SimpleITK.VectorString___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(VectorString self, SWIGPY_SLICEOBJECT * slice, VectorString v)
        __setitem__(VectorString self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(VectorString self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _SimpleITK.VectorString___setitem__(self, *args)

    def pop(self):
        r"""pop(VectorString self) -> std::vector< std::string >::value_type"""
        return _SimpleITK.VectorString_pop(self)

    def append(self, x):
        r"""append(VectorString self, std::vector< std::string >::value_type const & x)"""
        return _SimpleITK.VectorString_append(self, x)

    def empty(self):
        r"""empty(VectorString self) -> bool"""
        return _SimpleITK.VectorString_empty(self)

    def size(self):
        r"""size(VectorString self) -> std::vector< std::string >::size_type"""
        return _SimpleITK.VectorString_size(self)

    def swap(self, v):
        r"""swap(VectorString self, VectorString v)"""
        return _SimpleITK.VectorString_swap(self, v)

    def begin(self):
        r"""begin(VectorString self) -> std::vector< std::string >::iterator"""
        return _SimpleITK.VectorString_begin(self)

    def end(self):
        r"""end(VectorString self) -> std::vector< std::string >::iterator"""
        return _SimpleITK.VectorString_end(self)

    def rbegin(self):
        r"""rbegin(VectorString self) -> std::vector< std::string >::reverse_iterator"""
        return _SimpleITK.VectorString_rbegin(self)

    def rend(self):
        r"""rend(VectorString self) -> std::vector< std::string >::reverse_iterator"""
        return _SimpleITK.VectorString_rend(self)

    def clear(self):
        r"""clear(VectorString self)"""
        return _SimpleITK.VectorString_clear(self)

    def get_allocator(self):
        r"""get_allocator(VectorString self) -> std::vector< std::string >::allocator_type"""
        return _SimpleITK.VectorString_get_allocator(self)

    def pop_back(self):
        r"""pop_back(VectorString self)"""
        return _SimpleITK.VectorString_pop_back(self)

    def erase(self, *args):
        r"""
        erase(VectorString self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(VectorString self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _SimpleITK.VectorString_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(VectorString self) -> VectorString
        __init__(VectorString self, VectorString other) -> VectorString
        __init__(VectorString self, std::vector< std::string >::size_type size) -> VectorString
        __init__(VectorString self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> VectorString
        """
        _SimpleITK.VectorString_swiginit(
            self, _SimpleITK.new_VectorString(*args)
        )

    def push_back(self, x):
        r"""push_back(VectorString self, std::vector< std::string >::value_type const & x)"""
        return _SimpleITK.VectorString_push_back(self, x)

    def front(self):
        r"""front(VectorString self) -> std::vector< std::string >::value_type const &"""
        return _SimpleITK.VectorString_front(self)

    def back(self):
        r"""back(VectorString self) -> std::vector< std::string >::value_type const &"""
        return _SimpleITK.VectorString_back(self)

    def assign(self, n, x):
        r"""assign(VectorString self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _SimpleITK.VectorString_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(VectorString self, std::vector< std::string >::size_type new_size)
        resize(VectorString self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _SimpleITK.VectorString_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(VectorString self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(VectorString self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)
        """
        return _SimpleITK.VectorString_insert(self, *args)

    def reserve(self, n):
        r"""reserve(VectorString self, std::vector< std::string >::size_type n)"""
        return _SimpleITK.VectorString_reserve(self, n)

    def capacity(self):
        r"""capacity(VectorString self) -> std::vector< std::string >::size_type"""
        return _SimpleITK.VectorString_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorString


# Register VectorString in _SimpleITK:
_SimpleITK.VectorString_swigregister(VectorString)


class DoubleDoubleMap(object):
    r"""Proxy of C++ std::map< double,double > class."""

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(DoubleDoubleMap self) -> SwigPyIterator"""
        return _SimpleITK.DoubleDoubleMap_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(DoubleDoubleMap self) -> bool"""
        return _SimpleITK.DoubleDoubleMap___nonzero__(self)

    def __bool__(self):
        r"""__bool__(DoubleDoubleMap self) -> bool"""
        return _SimpleITK.DoubleDoubleMap___bool__(self)

    def __len__(self):
        r"""__len__(DoubleDoubleMap self) -> std::map< double,double >::size_type"""
        return _SimpleITK.DoubleDoubleMap___len__(self)

    def __iter__(self):
        return self.key_iterator()

    def iterkeys(self):
        return self.key_iterator()

    def itervalues(self):
        return self.value_iterator()

    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        r"""__getitem__(DoubleDoubleMap self, std::map< double,double >::key_type const & key) -> std::map< double,double >::mapped_type const &"""
        return _SimpleITK.DoubleDoubleMap___getitem__(self, key)

    def __delitem__(self, key):
        r"""__delitem__(DoubleDoubleMap self, std::map< double,double >::key_type const & key)"""
        return _SimpleITK.DoubleDoubleMap___delitem__(self, key)

    def has_key(self, key):
        r"""has_key(DoubleDoubleMap self, std::map< double,double >::key_type const & key) -> bool"""
        return _SimpleITK.DoubleDoubleMap_has_key(self, key)

    def keys(self):
        r"""keys(DoubleDoubleMap self) -> PyObject *"""
        return _SimpleITK.DoubleDoubleMap_keys(self)

    def values(self):
        r"""values(DoubleDoubleMap self) -> PyObject *"""
        return _SimpleITK.DoubleDoubleMap_values(self)

    def items(self):
        r"""items(DoubleDoubleMap self) -> PyObject *"""
        return _SimpleITK.DoubleDoubleMap_items(self)

    def __contains__(self, key):
        r"""__contains__(DoubleDoubleMap self, std::map< double,double >::key_type const & key) -> bool"""
        return _SimpleITK.DoubleDoubleMap___contains__(self, key)

    def key_iterator(self):
        r"""key_iterator(DoubleDoubleMap self) -> SwigPyIterator"""
        return _SimpleITK.DoubleDoubleMap_key_iterator(self)

    def value_iterator(self):
        r"""value_iterator(DoubleDoubleMap self) -> SwigPyIterator"""
        return _SimpleITK.DoubleDoubleMap_value_iterator(self)

    def __setitem__(self, *args):
        r"""
        __setitem__(DoubleDoubleMap self, std::map< double,double >::key_type const & key)
        __setitem__(DoubleDoubleMap self, std::map< double,double >::key_type const & key, std::map< double,double >::mapped_type const & x)
        """
        return _SimpleITK.DoubleDoubleMap___setitem__(self, *args)

    def asdict(self):
        r"""asdict(DoubleDoubleMap self) -> PyObject *"""
        return _SimpleITK.DoubleDoubleMap_asdict(self)

    def __init__(self, *args):
        r"""
        __init__(DoubleDoubleMap self, std::less< double > const & other) -> DoubleDoubleMap
        __init__(DoubleDoubleMap self) -> DoubleDoubleMap
        __init__(DoubleDoubleMap self, DoubleDoubleMap other) -> DoubleDoubleMap
        """
        _SimpleITK.DoubleDoubleMap_swiginit(
            self, _SimpleITK.new_DoubleDoubleMap(*args)
        )

    def empty(self):
        r"""empty(DoubleDoubleMap self) -> bool"""
        return _SimpleITK.DoubleDoubleMap_empty(self)

    def size(self):
        r"""size(DoubleDoubleMap self) -> std::map< double,double >::size_type"""
        return _SimpleITK.DoubleDoubleMap_size(self)

    def swap(self, v):
        r"""swap(DoubleDoubleMap self, DoubleDoubleMap v)"""
        return _SimpleITK.DoubleDoubleMap_swap(self, v)

    def begin(self):
        r"""begin(DoubleDoubleMap self) -> std::map< double,double >::iterator"""
        return _SimpleITK.DoubleDoubleMap_begin(self)

    def end(self):
        r"""end(DoubleDoubleMap self) -> std::map< double,double >::iterator"""
        return _SimpleITK.DoubleDoubleMap_end(self)

    def rbegin(self):
        r"""rbegin(DoubleDoubleMap self) -> std::map< double,double >::reverse_iterator"""
        return _SimpleITK.DoubleDoubleMap_rbegin(self)

    def rend(self):
        r"""rend(DoubleDoubleMap self) -> std::map< double,double >::reverse_iterator"""
        return _SimpleITK.DoubleDoubleMap_rend(self)

    def clear(self):
        r"""clear(DoubleDoubleMap self)"""
        return _SimpleITK.DoubleDoubleMap_clear(self)

    def get_allocator(self):
        r"""get_allocator(DoubleDoubleMap self) -> std::map< double,double >::allocator_type"""
        return _SimpleITK.DoubleDoubleMap_get_allocator(self)

    def count(self, x):
        r"""count(DoubleDoubleMap self, std::map< double,double >::key_type const & x) -> std::map< double,double >::size_type"""
        return _SimpleITK.DoubleDoubleMap_count(self, x)

    def erase(self, *args):
        r"""
        erase(DoubleDoubleMap self, std::map< double,double >::key_type const & x) -> std::map< double,double >::size_type
        erase(DoubleDoubleMap self, std::map< double,double >::iterator position)
        erase(DoubleDoubleMap self, std::map< double,double >::iterator first, std::map< double,double >::iterator last)
        """
        return _SimpleITK.DoubleDoubleMap_erase(self, *args)

    def find(self, x):
        r"""find(DoubleDoubleMap self, std::map< double,double >::key_type const & x) -> std::map< double,double >::iterator"""
        return _SimpleITK.DoubleDoubleMap_find(self, x)

    def lower_bound(self, x):
        r"""lower_bound(DoubleDoubleMap self, std::map< double,double >::key_type const & x) -> std::map< double,double >::iterator"""
        return _SimpleITK.DoubleDoubleMap_lower_bound(self, x)

    def upper_bound(self, x):
        r"""upper_bound(DoubleDoubleMap self, std::map< double,double >::key_type const & x) -> std::map< double,double >::iterator"""
        return _SimpleITK.DoubleDoubleMap_upper_bound(self, x)

    __swig_destroy__ = _SimpleITK.delete_DoubleDoubleMap


# Register DoubleDoubleMap in _SimpleITK:
_SimpleITK.DoubleDoubleMap_swigregister(DoubleDoubleMap)

import operator
import sys
from collections import namedtuple

SITK_MAX_DIMENSION = _SimpleITK.SITK_MAX_DIMENSION

SITK_ITK_VERSION_MAJOR = _SimpleITK.SITK_ITK_VERSION_MAJOR

SITK_ITK_VERSION_MINOR = _SimpleITK.SITK_ITK_VERSION_MINOR

SITK_ITK_VERSION_PATCH = _SimpleITK.SITK_ITK_VERSION_PATCH


class Version(object):
    r"""


    Version info for SimpleITK.

    C++ includes: sitkVersion.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    @staticmethod
    def MajorVersion():
        r"""MajorVersion() -> unsigned int"""
        return _SimpleITK.Version_MajorVersion()

    @staticmethod
    def MinorVersion():
        r"""MinorVersion() -> unsigned int"""
        return _SimpleITK.Version_MinorVersion()

    @staticmethod
    def PatchVersion():
        r"""PatchVersion() -> unsigned int"""
        return _SimpleITK.Version_PatchVersion()

    @staticmethod
    def TweakVersion():
        r"""TweakVersion() -> unsigned int"""
        return _SimpleITK.Version_TweakVersion()

    @staticmethod
    def VersionString():
        r"""VersionString() -> std::string const &"""
        return _SimpleITK.Version_VersionString()

    @staticmethod
    def BuildDate():
        r"""BuildDate() -> std::string const &"""
        return _SimpleITK.Version_BuildDate()

    @staticmethod
    def ITKMajorVersion():
        r"""ITKMajorVersion() -> unsigned int"""
        return _SimpleITK.Version_ITKMajorVersion()

    @staticmethod
    def ITKMinorVersion():
        r"""ITKMinorVersion() -> unsigned int"""
        return _SimpleITK.Version_ITKMinorVersion()

    @staticmethod
    def ITKPatchVersion():
        r"""ITKPatchVersion() -> unsigned int"""
        return _SimpleITK.Version_ITKPatchVersion()

    @staticmethod
    def ITKVersionString():
        r"""ITKVersionString() -> std::string const &"""
        return _SimpleITK.Version_ITKVersionString()

    @staticmethod
    def ITKModulesEnabled():
        r"""ITKModulesEnabled() -> VectorString"""
        return _SimpleITK.Version_ITKModulesEnabled()

    @staticmethod
    def ExtendedVersionString():
        r"""ExtendedVersionString() -> std::string const &"""
        return _SimpleITK.Version_ExtendedVersionString()

    def __str__(self):
        r"""
        __str__(Version self) -> std::string


        """
        return _SimpleITK.Version___str__(self)

    def __init__(self):
        r"""__init__(Version self) -> Version"""
        _SimpleITK.Version_swiginit(self, _SimpleITK.new_Version())

    __swig_destroy__ = _SimpleITK.delete_Version


# Register Version in _SimpleITK:
_SimpleITK.Version_swigregister(Version)
_GetMemoryViewFromImage = _SimpleITK._GetMemoryViewFromImage
_SetImageFromArray = _SimpleITK._SetImageFromArray


def Version_MajorVersion():
    r"""Version_MajorVersion() -> unsigned int"""
    return _SimpleITK.Version_MajorVersion()


def Version_MinorVersion():
    r"""Version_MinorVersion() -> unsigned int"""
    return _SimpleITK.Version_MinorVersion()


def Version_PatchVersion():
    r"""Version_PatchVersion() -> unsigned int"""
    return _SimpleITK.Version_PatchVersion()


def Version_TweakVersion():
    r"""Version_TweakVersion() -> unsigned int"""
    return _SimpleITK.Version_TweakVersion()


def Version_VersionString():
    r"""Version_VersionString() -> std::string const &"""
    return _SimpleITK.Version_VersionString()


def Version_BuildDate():
    r"""Version_BuildDate() -> std::string const &"""
    return _SimpleITK.Version_BuildDate()


def Version_ITKMajorVersion():
    r"""Version_ITKMajorVersion() -> unsigned int"""
    return _SimpleITK.Version_ITKMajorVersion()


def Version_ITKMinorVersion():
    r"""Version_ITKMinorVersion() -> unsigned int"""
    return _SimpleITK.Version_ITKMinorVersion()


def Version_ITKPatchVersion():
    r"""Version_ITKPatchVersion() -> unsigned int"""
    return _SimpleITK.Version_ITKPatchVersion()


def Version_ITKVersionString():
    r"""Version_ITKVersionString() -> std::string const &"""
    return _SimpleITK.Version_ITKVersionString()


def Version_ITKModulesEnabled():
    r"""Version_ITKModulesEnabled() -> VectorString"""
    return _SimpleITK.Version_ITKModulesEnabled()


def Version_ExtendedVersionString():
    r"""Version_ExtendedVersionString() -> std::string const &"""
    return _SimpleITK.Version_ExtendedVersionString()


sitkUnknown = _SimpleITK.sitkUnknown

sitkUInt8 = _SimpleITK.sitkUInt8

sitkInt8 = _SimpleITK.sitkInt8

sitkUInt16 = _SimpleITK.sitkUInt16

sitkInt16 = _SimpleITK.sitkInt16

sitkUInt32 = _SimpleITK.sitkUInt32

sitkInt32 = _SimpleITK.sitkInt32

sitkUInt64 = _SimpleITK.sitkUInt64

sitkInt64 = _SimpleITK.sitkInt64

sitkFloat32 = _SimpleITK.sitkFloat32

sitkFloat64 = _SimpleITK.sitkFloat64

sitkComplexFloat32 = _SimpleITK.sitkComplexFloat32

sitkComplexFloat64 = _SimpleITK.sitkComplexFloat64

sitkVectorUInt8 = _SimpleITK.sitkVectorUInt8

sitkVectorInt8 = _SimpleITK.sitkVectorInt8

sitkVectorUInt16 = _SimpleITK.sitkVectorUInt16

sitkVectorInt16 = _SimpleITK.sitkVectorInt16

sitkVectorUInt32 = _SimpleITK.sitkVectorUInt32

sitkVectorInt32 = _SimpleITK.sitkVectorInt32

sitkVectorUInt64 = _SimpleITK.sitkVectorUInt64

sitkVectorInt64 = _SimpleITK.sitkVectorInt64

sitkVectorFloat32 = _SimpleITK.sitkVectorFloat32

sitkVectorFloat64 = _SimpleITK.sitkVectorFloat64

sitkLabelUInt8 = _SimpleITK.sitkLabelUInt8

sitkLabelUInt16 = _SimpleITK.sitkLabelUInt16

sitkLabelUInt32 = _SimpleITK.sitkLabelUInt32

sitkLabelUInt64 = _SimpleITK.sitkLabelUInt64


def GetPixelIDValueAsString(type):
    r"""
    GetPixelIDValueAsString(itk::simple::PixelIDValueEnum type) -> std::string const


    """
    return _SimpleITK.GetPixelIDValueAsString(type)


def GetPixelIDValueFromString(enumString):
    r"""
    GetPixelIDValueFromString(std::string const & enumString) -> itk::simple::PixelIDValueType


    Function mapping enumeration names in std::string to values.


    This function is intended for use by the R bindings. R stores the
    enumeration values using the names : "sitkUnknown", "sitkUInt8",
    etc from PixelIDValueEnum above. This function is used to provide the
    integer values using calls like:

    val = GetPixelIDValueFromString("sitkInt32")

    If the pixel type has not been instantiated then the sitkUnknown value
    (-1) will be returned. If the pixel type string is not recognized
    (i.e. is not in the set of tested names) then the return value is -99.
    The idea is to provide a warning (via the R package) if this function
    needs to be updated to match changes to PixelIDValueEnum - i.e. if a
    new pixel type is added.


    """
    return _SimpleITK.GetPixelIDValueFromString(enumString)


sitkNearestNeighbor = _SimpleITK.sitkNearestNeighbor

sitkLinear = _SimpleITK.sitkLinear

sitkBSpline1 = _SimpleITK.sitkBSpline1

sitkBSpline2 = _SimpleITK.sitkBSpline2

sitkBSpline = _SimpleITK.sitkBSpline

sitkBSpline3 = _SimpleITK.sitkBSpline3

sitkBSpline4 = _SimpleITK.sitkBSpline4

sitkBSpline5 = _SimpleITK.sitkBSpline5

sitkGaussian = _SimpleITK.sitkGaussian

sitkLabelGaussian = _SimpleITK.sitkLabelGaussian

sitkLabelLinear = _SimpleITK.sitkLabelLinear

sitkHammingWindowedSinc = _SimpleITK.sitkHammingWindowedSinc

sitkCosineWindowedSinc = _SimpleITK.sitkCosineWindowedSinc

sitkWelchWindowedSinc = _SimpleITK.sitkWelchWindowedSinc

sitkLanczosWindowedSinc = _SimpleITK.sitkLanczosWindowedSinc

sitkBlackmanWindowedSinc = _SimpleITK.sitkBlackmanWindowedSinc

sitkBSplineResampler = _SimpleITK.sitkBSplineResampler

sitkBSplineResamplerOrder3 = _SimpleITK.sitkBSplineResamplerOrder3

sitkBSplineResamplerOrder1 = _SimpleITK.sitkBSplineResamplerOrder1

sitkBSplineResamplerOrder2 = _SimpleITK.sitkBSplineResamplerOrder2

sitkBSplineResamplerOrder4 = _SimpleITK.sitkBSplineResamplerOrder4

sitkBSplineResamplerOrder5 = _SimpleITK.sitkBSplineResamplerOrder5


class Image(object):
    r"""


    The Image class for SimpleITK.


    This Image class can represent 2D, 3D, and 4D images. The pixel types may be a
    scalar, a multi-component vector or a run-length-encoded (RLE)
    "label". The dimension, pixel type and size is specified at
    construction.

    A fundamental concept of ITK images is that they occupy physical space
    where the image is defined by an origin, spacing, and direction cosine
    matrix. The attributes are taken into consideration when doing most
    operations on an image. A meta-data dictionary is also associated with
    the image, which may contain additional fields from reading but these
    attributes are not propagated by image filters.

    The SimpleITK Image provides a single facade interface to several ITK image types.
    Internally, the SimpleITK Image maintains a pointer to the ITK image class, and performs reference
    counting and lazy copying. This means that deep copying of an image
    including it's buffer is delayed until the image is modified. This
    removes the need to use pointers to SimpleITK Image class, as copying and returning by value do not unnecessarily
    duplicate the data.


    See:
     itk::Image itk::VectorImage itk::LabelMap itk::ImageBase


    C++ includes: sitkImage.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_Image

    def __init__(self, *args):
        r"""
        __init__(Image self) -> Image
        __init__(Image self, Image img) -> Image
        __init__(Image self, unsigned int width, unsigned int height, itk::simple::PixelIDValueEnum valueEnum) -> Image
        __init__(Image self, unsigned int width, unsigned int height, unsigned int depth, itk::simple::PixelIDValueEnum valueEnum) -> Image
        __init__(Image self, VectorUInt32 size, itk::simple::PixelIDValueEnum valueEnum, unsigned int numberOfComponents=0) -> Image


        Move constructor and assignment.




        Parameters:

        img:
        After the operation img is valid only for destructing and assignment;
        all other operations have undefined behavior.




        """
        _SimpleITK.Image_swiginit(self, _SimpleITK.new_Image(*args))

    def GetITKBase(self, *args):
        r"""
        GetITKBase(Image self) -> itk::DataObject
        GetITKBase(Image self) -> itk::DataObject const *
        """
        return _SimpleITK.Image_GetITKBase(self, *args)

    def GetPixelID(self):
        r"""
        GetPixelID(Image self) -> itk::simple::PixelIDValueEnum


        Get the pixel type

        The pixel type is set at construction type and can not be manually
        changed, unless by assignment. The value may be -1 or "Unknown".


        """
        return _SimpleITK.Image_GetPixelID(self)

    def GetPixelIDValue(self):
        r"""
        GetPixelIDValue(Image self) -> itk::simple::PixelIDValueType


        """
        return _SimpleITK.Image_GetPixelIDValue(self)

    def GetPixelIDTypeAsString(self):
        r"""
        GetPixelIDTypeAsString(Image self) -> std::string


        Return the pixel type as a human readable string value.


        """
        return _SimpleITK.Image_GetPixelIDTypeAsString(self)

    def GetDimension(self):
        r"""
        GetDimension(Image self) -> unsigned int


        Get the number of physical dimensions.

        Only the spatial dimensions are considered here. These are the
        dimensions the origin, spacing and direction cosine matrix are
        applicable to. This does not include the pixels' vector index as a
        dimension.


        """
        return _SimpleITK.Image_GetDimension(self)

    def GetNumberOfComponentsPerPixel(self):
        r"""
        GetNumberOfComponentsPerPixel(Image self) -> unsigned int


        Get the number of components for each pixel.


        For images with scalar or complex pixel types this method returns one.
        For images with a vector pixel type the method returns the number of
        vector components per pixel.


        """
        return _SimpleITK.Image_GetNumberOfComponentsPerPixel(self)

    def GetNumberOfPixels(self):
        r"""
        GetNumberOfPixels(Image self) -> uint64_t


        Get the number of pixels in the image.


        To calculate the total number of values stored continuously for the
        image's buffer, the NumberOfPixels should be multiplied by
        NumberOfComponentsPerPixel in order to account for multiple component
        images.


        """
        return _SimpleITK.Image_GetNumberOfPixels(self)

    def GetSizeOfPixelComponent(self):
        r"""
        GetSizeOfPixelComponent(Image self) -> unsigned int


        Get the number of bytes per component of a pixel.


        Returns the sizeof the pixel component type.


        """
        return _SimpleITK.Image_GetSizeOfPixelComponent(self)

    def GetOrigin(self):
        r"""GetOrigin(Image self) -> VectorDouble"""
        return _SimpleITK.Image_GetOrigin(self)

    def SetOrigin(self, origin):
        r"""SetOrigin(Image self, VectorDouble origin)"""
        return _SimpleITK.Image_SetOrigin(self, origin)

    def GetSpacing(self):
        r"""GetSpacing(Image self) -> VectorDouble"""
        return _SimpleITK.Image_GetSpacing(self)

    def SetSpacing(self, spacing):
        r"""SetSpacing(Image self, VectorDouble spacing)"""
        return _SimpleITK.Image_SetSpacing(self, spacing)

    def GetDirection(self):
        r"""GetDirection(Image self) -> VectorDouble"""
        return _SimpleITK.Image_GetDirection(self)

    def SetDirection(self, direction):
        r"""SetDirection(Image self, VectorDouble direction)"""
        return _SimpleITK.Image_SetDirection(self, direction)

    def TransformIndexToPhysicalPoint(self, index):
        r"""
        TransformIndexToPhysicalPoint(Image self, VectorInt64 index) -> VectorDouble


        Transform index to physical point


        """
        return _SimpleITK.Image_TransformIndexToPhysicalPoint(self, index)

    def TransformPhysicalPointToIndex(self, point):
        r"""
        TransformPhysicalPointToIndex(Image self, VectorDouble point) -> VectorInt64


        Transform physical point to index


        """
        return _SimpleITK.Image_TransformPhysicalPointToIndex(self, point)

    def TransformPhysicalPointToContinuousIndex(self, point):
        r"""
        TransformPhysicalPointToContinuousIndex(Image self, VectorDouble point) -> VectorDouble


        Transform physical point to continuous index


        """
        return _SimpleITK.Image_TransformPhysicalPointToContinuousIndex(
            self, point
        )

    def TransformContinuousIndexToPhysicalPoint(self, index):
        r"""
        TransformContinuousIndexToPhysicalPoint(Image self, VectorDouble index) -> VectorDouble


        Transform continuous index to physical point


        """
        return _SimpleITK.Image_TransformContinuousIndexToPhysicalPoint(
            self, index
        )

    def __EvaluateAtContinuousIndex__(self, *args, **kwargs):
        r"""
        __EvaluateAtContinuousIndex__(Image self, VectorDouble index, itk::simple::InterpolatorEnum interp=sitkLinear) -> VectorDouble


        Interpolate pixel value at a continuous index.


        This method is not supported for Label pixel types.

        The valid range of continuous index is [-0.5, size-0.5] for each
        dimension. An exception is thrown if index is out of bounds.



        Parameters:

        index:
        The continuous index must be at least the length of the image
        dimension.

        interp:
        The interpolation type to use, only sitkNearest and sitkLinear are
        supported for Vector and Complex pixel types.


        All supported pixel types are returned as an array, where complex
        numbers are returned with the real followed by the complex component.



        """
        return _SimpleITK.Image___EvaluateAtContinuousIndex__(
            self, *args, **kwargs
        )

    def __EvaluateAtPhysicalPoint__(self, *args, **kwargs):
        r"""
        __EvaluateAtPhysicalPoint__(Image self, VectorDouble point, itk::simple::InterpolatorEnum interp=sitkLinear) -> VectorDouble


        Interpolate pixel value at a physical point.

        This method is not supported for Label pixel types.

        An exception is thrown if the point is out of the defined region for
        the image.



        Parameters:

        point:
        The physical point at which the interpolation is computed.

        interp:
        The interpolation type to use, only sitkNearest and sitkLinear are
        supported for Vector and Complex pixel types.


        All supported pixel types are returned as an array, where complex
        numbers are returned with the real followed by the complex component.



        """
        return _SimpleITK.Image___EvaluateAtPhysicalPoint__(
            self, *args, **kwargs
        )

    def IsCongruentImageGeometry(
        self, otherImage, coordinateTolerance, directionTolerance
    ):
        r"""
        IsCongruentImageGeometry(Image self, Image otherImage, double coordinateTolerance, double directionTolerance) -> bool


        Checks whether the images' pixels at the same index occupy the same
        physical space.

        Compares the origin, spacing, and direction for equality within
        provided tolerances. There is no check for matching regions in between
        the images.

        If The dimensions of the images do not match, false is returned.


        """
        return _SimpleITK.Image_IsCongruentImageGeometry(
            self, otherImage, coordinateTolerance, directionTolerance
        )

    def IsSameImageGeometryAs(self, *args, **kwargs):
        r"""
        IsSameImageGeometryAs(Image self, Image otherImage, double arg3=DefaultImageCoordinateTolerance, double arg4=DefaultImageDirectionTolerance) -> bool


        Check whether the images have the same grid in physical space.

        Compares largest possible regions for equality, and the origin,
        spacing, and direction cosines for equality within provided
        tolerances.

        If the dimensions of the images do not match, false is returned.


        """
        return _SimpleITK.Image_IsSameImageGeometryAs(self, *args, **kwargs)

    def GetSize(self):
        r"""
        GetSize(Image self) -> VectorUInt32


        Get the number of pixels the Image is in each dimension as a std::vector. The size of the vector is
        equal to the number of dimensions for the image.


        """
        return _SimpleITK.Image_GetSize(self)

    def GetWidth(self):
        r"""
        GetWidth(Image self) -> unsigned int


        Get the number of pixels the Image is in the first dimension


        """
        return _SimpleITK.Image_GetWidth(self)

    def GetHeight(self):
        r"""
        GetHeight(Image self) -> unsigned int


        Get the number of pixels the Image is in the second dimension


        """
        return _SimpleITK.Image_GetHeight(self)

    def GetDepth(self):
        r"""
        GetDepth(Image self) -> unsigned int


        Get the number of pixels the Image is in the third dimension or 0 if the Image is only 2D


        """
        return _SimpleITK.Image_GetDepth(self)

    def CopyInformation(self, srcImage):
        r"""
        CopyInformation(Image self, Image srcImage)


        Copy common meta-data from an image to this one.


        Copies the Origin, Spacing, and Direction from the source image to
        this image. The meta-data dictionary is not copied.

        It is required for the source Image's dimension and size to match, this image's attributes, otherwise an
        exception will be generated.


        """
        return _SimpleITK.Image_CopyInformation(self, srcImage)

    def GetMetaDataKeys(self):
        r"""
        GetMetaDataKeys(Image self) -> VectorString


        get a vector of keys in from the meta-data dictionary


        Returns a vector of keys to the key/value entries in the image's meta-
        data dictionary. Iterate through with these keys to get the values.


        """
        return _SimpleITK.Image_GetMetaDataKeys(self)

    def HasMetaDataKey(self, key):
        r"""
        HasMetaDataKey(Image self, std::string const & key) -> bool


        Query the meta-data dictionary for the existence of a key.


        """
        return _SimpleITK.Image_HasMetaDataKey(self, key)

    def GetMetaData(self, key):
        r"""
        GetMetaData(Image self, std::string const & key) -> std::string


        Get the value of a meta-data dictionary entry as a string.


        If the key is not in the dictionary then an exception is thrown.

        string types in the dictionary are returned as their native strings.
        Other types are printed to string before returning.


        """
        return _SimpleITK.Image_GetMetaData(self, key)

    def SetMetaData(self, key, value):
        r"""
        SetMetaData(Image self, std::string const & key, std::string const & value)


        Set an entry in the meta-data dictionary.


        Replaces or creates an entry in the image's meta-data dictionary.


        """
        return _SimpleITK.Image_SetMetaData(self, key, value)

    def EraseMetaData(self, key):
        r"""
        EraseMetaData(Image self, std::string const & key) -> bool


        Remove an entry from the meta-data dictionary.


        Returns true, when the value exists in the dictionary and is removed,
        false otherwise.


        """
        return _SimpleITK.Image_EraseMetaData(self, key)

    def __str__(self):
        r"""
        __str__(Image self) -> std::string


        """
        return _SimpleITK.Image___str__(self)

    def ToVectorImage(self, inPlace=True):
        r"""
        ToVectorImage(Image self, bool inPlace=True) -> Image


        Convert the first dimension to the components for image with vector
        pixel type.


        This method will convert a scalar image to a vector image with the
        number of components equal to the size of the first dimension. If the
        image is already a vector image then the image is returned.

        The components of the direction cosine matrix for the first dimension
        must be the identity matrix, or else an exception is thrown.

        An exception is thrown if the image is 2D or if the pixel type is a
        label or complex pixel type.



        Parameters:

        inPlace:
        If true then the image is made unique and converted in place updating
        this image, otherwise a copy of the image is made and returned.


        See:
         ToScalarImage



        """
        return _SimpleITK.Image_ToVectorImage(self, inPlace)

    def ToScalarImage(self, inPlace=True):
        r"""
        ToScalarImage(Image self, bool inPlace=True) -> Image


        Convert a image of vector pixel type to a scalar image with N+1
        dimensions.


        This method will convert a vector image to a scalar image with the
        size of the first dimension equal to the number of components. If the
        image is already a scalar image then the image is returned.

        For the additional dimension the origin is set to zero, the spacing to
        one, and the new components of the direction cosine to the identity
        matrix.

        An exception is thrown if the image is has SITK_MAX_DIMENSION
        dimensions or if the pixel type is a label or complex pixel type.



        Parameters:

        inPlace:
        If true then the image is made unique and converted in place updating
        this image, otherwise a copy of the image is made and returned.


        See:
         ToVectorImage



        """
        return _SimpleITK.Image_ToScalarImage(self, inPlace)

    def __GetPixelAsInt8__(self, idx):
        r"""__GetPixelAsInt8__(Image self, VectorUInt32 idx) -> int8_t"""
        return _SimpleITK.Image___GetPixelAsInt8__(self, idx)

    def __GetPixelAsUInt8__(self, idx):
        r"""__GetPixelAsUInt8__(Image self, VectorUInt32 idx) -> uint8_t"""
        return _SimpleITK.Image___GetPixelAsUInt8__(self, idx)

    def __GetPixelAsInt16__(self, idx):
        r"""__GetPixelAsInt16__(Image self, VectorUInt32 idx) -> int16_t"""
        return _SimpleITK.Image___GetPixelAsInt16__(self, idx)

    def __GetPixelAsUInt16__(self, idx):
        r"""__GetPixelAsUInt16__(Image self, VectorUInt32 idx) -> uint16_t"""
        return _SimpleITK.Image___GetPixelAsUInt16__(self, idx)

    def __GetPixelAsInt32__(self, idx):
        r"""__GetPixelAsInt32__(Image self, VectorUInt32 idx) -> int32_t"""
        return _SimpleITK.Image___GetPixelAsInt32__(self, idx)

    def __GetPixelAsUInt32__(self, idx):
        r"""__GetPixelAsUInt32__(Image self, VectorUInt32 idx) -> uint32_t"""
        return _SimpleITK.Image___GetPixelAsUInt32__(self, idx)

    def __GetPixelAsInt64__(self, idx):
        r"""__GetPixelAsInt64__(Image self, VectorUInt32 idx) -> int64_t"""
        return _SimpleITK.Image___GetPixelAsInt64__(self, idx)

    def __GetPixelAsUInt64__(self, idx):
        r"""__GetPixelAsUInt64__(Image self, VectorUInt32 idx) -> uint64_t"""
        return _SimpleITK.Image___GetPixelAsUInt64__(self, idx)

    def __GetPixelAsFloat__(self, idx):
        r"""__GetPixelAsFloat__(Image self, VectorUInt32 idx) -> float"""
        return _SimpleITK.Image___GetPixelAsFloat__(self, idx)

    def __GetPixelAsDouble__(self, idx):
        r"""__GetPixelAsDouble__(Image self, VectorUInt32 idx) -> double"""
        return _SimpleITK.Image___GetPixelAsDouble__(self, idx)

    def __GetPixelAsVectorInt8__(self, idx):
        r"""__GetPixelAsVectorInt8__(Image self, VectorUInt32 idx) -> VectorInt8"""
        return _SimpleITK.Image___GetPixelAsVectorInt8__(self, idx)

    def __GetPixelAsVectorUInt8__(self, idx):
        r"""__GetPixelAsVectorUInt8__(Image self, VectorUInt32 idx) -> VectorUInt8"""
        return _SimpleITK.Image___GetPixelAsVectorUInt8__(self, idx)

    def __GetPixelAsVectorInt16__(self, idx):
        r"""__GetPixelAsVectorInt16__(Image self, VectorUInt32 idx) -> VectorInt16"""
        return _SimpleITK.Image___GetPixelAsVectorInt16__(self, idx)

    def __GetPixelAsVectorUInt16__(self, idx):
        r"""__GetPixelAsVectorUInt16__(Image self, VectorUInt32 idx) -> VectorUInt16"""
        return _SimpleITK.Image___GetPixelAsVectorUInt16__(self, idx)

    def __GetPixelAsVectorInt32__(self, idx):
        r"""__GetPixelAsVectorInt32__(Image self, VectorUInt32 idx) -> VectorInt32"""
        return _SimpleITK.Image___GetPixelAsVectorInt32__(self, idx)

    def __GetPixelAsVectorUInt32__(self, idx):
        r"""__GetPixelAsVectorUInt32__(Image self, VectorUInt32 idx) -> VectorUInt32"""
        return _SimpleITK.Image___GetPixelAsVectorUInt32__(self, idx)

    def __GetPixelAsVectorInt64__(self, idx):
        r"""__GetPixelAsVectorInt64__(Image self, VectorUInt32 idx) -> VectorInt64"""
        return _SimpleITK.Image___GetPixelAsVectorInt64__(self, idx)

    def __GetPixelAsVectorUInt64__(self, idx):
        r"""__GetPixelAsVectorUInt64__(Image self, VectorUInt32 idx) -> VectorUInt64"""
        return _SimpleITK.Image___GetPixelAsVectorUInt64__(self, idx)

    def __GetPixelAsVectorFloat32__(self, idx):
        r"""__GetPixelAsVectorFloat32__(Image self, VectorUInt32 idx) -> VectorFloat"""
        return _SimpleITK.Image___GetPixelAsVectorFloat32__(self, idx)

    def __GetPixelAsVectorFloat64__(self, idx):
        r"""__GetPixelAsVectorFloat64__(Image self, VectorUInt32 idx) -> VectorDouble"""
        return _SimpleITK.Image___GetPixelAsVectorFloat64__(self, idx)

    def __GetPixelAsComplexFloat32__(self, idx):
        r"""__GetPixelAsComplexFloat32__(Image self, VectorUInt32 idx) -> std::complex< float >"""
        return _SimpleITK.Image___GetPixelAsComplexFloat32__(self, idx)

    def __GetPixelAsComplexFloat64__(self, idx):
        r"""__GetPixelAsComplexFloat64__(Image self, VectorUInt32 idx) -> std::complex< double >"""
        return _SimpleITK.Image___GetPixelAsComplexFloat64__(self, idx)

    def __SetPixelAsInt8__(self, idx, v):
        r"""__SetPixelAsInt8__(Image self, VectorUInt32 idx, int8_t v)"""
        return _SimpleITK.Image___SetPixelAsInt8__(self, idx, v)

    def __SetPixelAsUInt8__(self, idx, v):
        r"""__SetPixelAsUInt8__(Image self, VectorUInt32 idx, uint8_t v)"""
        return _SimpleITK.Image___SetPixelAsUInt8__(self, idx, v)

    def __SetPixelAsInt16__(self, idx, v):
        r"""__SetPixelAsInt16__(Image self, VectorUInt32 idx, int16_t v)"""
        return _SimpleITK.Image___SetPixelAsInt16__(self, idx, v)

    def __SetPixelAsUInt16__(self, idx, v):
        r"""__SetPixelAsUInt16__(Image self, VectorUInt32 idx, uint16_t v)"""
        return _SimpleITK.Image___SetPixelAsUInt16__(self, idx, v)

    def __SetPixelAsInt32__(self, idx, v):
        r"""__SetPixelAsInt32__(Image self, VectorUInt32 idx, int32_t v)"""
        return _SimpleITK.Image___SetPixelAsInt32__(self, idx, v)

    def __SetPixelAsUInt32__(self, idx, v):
        r"""__SetPixelAsUInt32__(Image self, VectorUInt32 idx, uint32_t v)"""
        return _SimpleITK.Image___SetPixelAsUInt32__(self, idx, v)

    def __SetPixelAsInt64__(self, idx, v):
        r"""__SetPixelAsInt64__(Image self, VectorUInt32 idx, int64_t v)"""
        return _SimpleITK.Image___SetPixelAsInt64__(self, idx, v)

    def __SetPixelAsUInt64__(self, idx, v):
        r"""__SetPixelAsUInt64__(Image self, VectorUInt32 idx, uint64_t v)"""
        return _SimpleITK.Image___SetPixelAsUInt64__(self, idx, v)

    def __SetPixelAsFloat__(self, idx, v):
        r"""__SetPixelAsFloat__(Image self, VectorUInt32 idx, float v)"""
        return _SimpleITK.Image___SetPixelAsFloat__(self, idx, v)

    def __SetPixelAsDouble__(self, idx, v):
        r"""__SetPixelAsDouble__(Image self, VectorUInt32 idx, double v)"""
        return _SimpleITK.Image___SetPixelAsDouble__(self, idx, v)

    def __SetPixelAsVectorInt8__(self, idx, v):
        r"""__SetPixelAsVectorInt8__(Image self, VectorUInt32 idx, VectorInt8 v)"""
        return _SimpleITK.Image___SetPixelAsVectorInt8__(self, idx, v)

    def __SetPixelAsVectorUInt8__(self, idx, v):
        r"""__SetPixelAsVectorUInt8__(Image self, VectorUInt32 idx, VectorUInt8 v)"""
        return _SimpleITK.Image___SetPixelAsVectorUInt8__(self, idx, v)

    def __SetPixelAsVectorInt16__(self, idx, v):
        r"""__SetPixelAsVectorInt16__(Image self, VectorUInt32 idx, VectorInt16 v)"""
        return _SimpleITK.Image___SetPixelAsVectorInt16__(self, idx, v)

    def __SetPixelAsVectorUInt16__(self, idx, v):
        r"""__SetPixelAsVectorUInt16__(Image self, VectorUInt32 idx, VectorUInt16 v)"""
        return _SimpleITK.Image___SetPixelAsVectorUInt16__(self, idx, v)

    def __SetPixelAsVectorInt32__(self, idx, v):
        r"""__SetPixelAsVectorInt32__(Image self, VectorUInt32 idx, VectorInt32 v)"""
        return _SimpleITK.Image___SetPixelAsVectorInt32__(self, idx, v)

    def __SetPixelAsVectorUInt32__(self, idx, v):
        r"""__SetPixelAsVectorUInt32__(Image self, VectorUInt32 idx, VectorUInt32 v)"""
        return _SimpleITK.Image___SetPixelAsVectorUInt32__(self, idx, v)

    def __SetPixelAsVectorInt64__(self, idx, v):
        r"""__SetPixelAsVectorInt64__(Image self, VectorUInt32 idx, VectorInt64 v)"""
        return _SimpleITK.Image___SetPixelAsVectorInt64__(self, idx, v)

    def __SetPixelAsVectorUInt64__(self, idx, v):
        r"""__SetPixelAsVectorUInt64__(Image self, VectorUInt32 idx, VectorUInt64 v)"""
        return _SimpleITK.Image___SetPixelAsVectorUInt64__(self, idx, v)

    def __SetPixelAsVectorFloat32__(self, idx, v):
        r"""__SetPixelAsVectorFloat32__(Image self, VectorUInt32 idx, VectorFloat v)"""
        return _SimpleITK.Image___SetPixelAsVectorFloat32__(self, idx, v)

    def __SetPixelAsVectorFloat64__(self, idx, v):
        r"""__SetPixelAsVectorFloat64__(Image self, VectorUInt32 idx, VectorDouble v)"""
        return _SimpleITK.Image___SetPixelAsVectorFloat64__(self, idx, v)

    def __SetPixelAsComplexFloat32__(self, idx, v):
        r"""__SetPixelAsComplexFloat32__(Image self, VectorUInt32 idx, std::complex< float > const v)"""
        return _SimpleITK.Image___SetPixelAsComplexFloat32__(self, idx, v)

    def SetPixelAsComplexFloat64(self, idx, v):
        r"""SetPixelAsComplexFloat64(Image self, VectorUInt32 idx, std::complex< double > const v)"""
        return _SimpleITK.Image_SetPixelAsComplexFloat64(self, idx, v)

    def MakeUnique(self):
        r"""
        MakeUnique(Image self)


        Performs actually coping if needed to make object unique.


        The Image class by default performs lazy coping and assignment. This method
        make sure that coping actually happens to the itk::Image pointed to is only pointed to by this object.


        """
        return _SimpleITK.Image_MakeUnique(self)

    def IsUnique(self):
        r"""
        IsUnique(Image self) -> bool


        Returns true if no other SimpleITK Image object refers to the same internal data structure.


        """
        return _SimpleITK.Image_IsUnique(self)

    DefaultImageCoordinateTolerance = (
        _SimpleITK.Image_DefaultImageCoordinateTolerance
    )

    DefaultImageDirectionTolerance = (
        _SimpleITK.Image_DefaultImageDirectionTolerance
    )

    def __iadd__(self, *args):
        r"""
        __iadd__(Image self, Image i) -> Image
        __iadd__(Image self, double c) -> Image
        """
        return _SimpleITK.Image___iadd__(self, *args)

    def __isub__(self, *args):
        r"""
        __isub__(Image self, Image i) -> Image
        __isub__(Image self, double c) -> Image
        """
        return _SimpleITK.Image___isub__(self, *args)

    def __imul__(self, *args):
        r"""
        __imul__(Image self, Image i) -> Image
        __imul__(Image self, double c) -> Image
        """
        return _SimpleITK.Image___imul__(self, *args)

    def __imod__(self, *args):
        r"""
        __imod__(Image self, Image i) -> Image
        __imod__(Image self, int c) -> Image
        """
        return _SimpleITK.Image___imod__(self, *args)

    def __ifloordiv__(self, *args):
        r"""
        __ifloordiv__(Image self, Image i) -> Image
        __ifloordiv__(Image self, double c) -> Image
        """
        return _SimpleITK.Image___ifloordiv__(self, *args)

    def __itruediv__(self, *args):
        r"""
        __itruediv__(Image self, Image i) -> Image
        __itruediv__(Image self, double c) -> Image
        """
        return _SimpleITK.Image___itruediv__(self, *args)

    def __ipow__(self, *args):
        r"""
        __ipow__(Image self, Image i) -> Image
        __ipow__(Image self, double c) -> Image
        """
        return _SimpleITK.Image___ipow__(self, *args)

    def __ior__(self, *args):
        r"""
        __ior__(Image self, Image i) -> Image
        __ior__(Image self, int c) -> Image
        """
        return _SimpleITK.Image___ior__(self, *args)

    def __ixor__(self, *args):
        r"""
        __ixor__(Image self, Image i) -> Image
        __ixor__(Image self, int c) -> Image
        """
        return _SimpleITK.Image___ixor__(self, *args)

    def __iand__(self, *args):
        r"""
        __iand__(Image self, Image i) -> Image
        __iand__(Image self, int c) -> Image
        """
        return _SimpleITK.Image___iand__(self, *args)

    def __ipaste(self, *args):
        r"""
        __ipaste(Image self, Image sourceImage, VectorUInt32 sourceSize, VectorInt32 sourceIndex, VectorInt32 destinationIndex, VectorBool destinationSkipAxes) -> Image
        __ipaste(Image self, double constant, VectorUInt32 sourceSize, VectorInt32 sourceIndex, VectorInt32 destinationIndex, VectorBool destinationSkipAxes) -> Image
        """
        return _SimpleITK.Image___ipaste(self, *args)

    def __imasked_assign(self, *args):
        r"""
        __imasked_assign(Image self, Image mask, Image assign) -> Image
        __imasked_assign(Image self, Image mask, double constant) -> Image
        """
        return _SimpleITK.Image___imasked_assign(self, *args)

    def __copy__(self):
        """Create a SimpleITK shallow copy, where the internal image share is shared with copy on write implementation."""
        return Image(self)

    def __deepcopy__(self, memo):
        """Create a new copy of the data and image class."""
        dc = Image(self)
        dc.MakeUnique()
        return dc

    def __setstate__(self, args):
        if args[0] != 0:
            raise ValueError(
                "Unable to handle SimpleITK.Image pickle version {0}".args[0]
            )

        state = namedtuple(
            "state_tuple_0", "version buffer origin spacing direction metadata"
        )(*args)

        _SetImageFromArray(state.buffer, self)
        self.SetOrigin(state.origin)
        self.SetSpacing(state.spacing)
        self.SetDirection(state.direction)
        for k, v in state.metadata.items():
            self.SetMetaData(k, v)

    def __reduce_ex__(self, protocol):
        version = 0
        size = tuple(self.GetSize())
        t = int(self.GetPixelIDValue())
        ncomponents = int(self.GetNumberOfComponentsPerPixel())

        mv = _GetMemoryViewFromImage(self)
        origin = tuple(self.GetOrigin())
        spacing = tuple(self.GetSpacing())
        direction = tuple(self.GetDirection())
        metadata = {k: self.GetMetaData(k) for k in self.GetMetaDataKeys()}

        if protocol >= 5:
            import sys

            if sys.hexversion >= 0x03080000:
                import pickle
            elif sys.hexversion >= 0x03060000:
                try:
                    import pickle5 as pickle
                except ImportError:
                    raise ImportError(
                        "Pickle protocol 5 requires the pickle5 module for Python 3.6, 3.7"
                    )
            P = (
                version,
                pickle.PickleBuffer(mv),
                origin,
                spacing,
                direction,
                metadata,
            )
        else:
            P = (version, mv.tobytes(), origin, spacing, direction, metadata)

        return self.__class__, (size, t, ncomponents), P

    # mathematical operators

    def __add__(self, other):
        if isinstance(other, Image):
            return Add(self, other)
        try:
            return Add(self, float(other))
        except ValueError:
            return NotImplemented

    def __sub__(self, other):
        if isinstance(other, Image):
            return Subtract(self, other)
        try:
            return Subtract(self, float(other))
        except ValueError:
            return NotImplemented

    def __mul__(self, other):
        if isinstance(other, Image):
            return Multiply(self, other)
        try:
            return Multiply(self, float(other))
        except ValueError:
            return NotImplemented

    def __div__(self, other):
        if isinstance(other, Image):
            return Divide(self, other)
        try:
            return Divide(self, float(other))
        except ValueError:
            return NotImplemented

    def __floordiv__(self, other):
        if isinstance(other, Image):
            return DivideFloor(self, other)
        try:
            return DivideFloor(self, float(other))
        except ValueError:
            return NotImplemented

    def __truediv__(self, other):
        if isinstance(other, Image):
            return DivideReal(self, other)
        try:
            return DivideReal(self, float(other))
        except ValueError:
            return NotImplemented

    def __neg__(self):
        return UnaryMinus(self)

    def __pos__(self):
        return self

    # NOTE: for the reverse methods other cannot be an image, so
    # therefore other should be able to be considered a constant.

    def __radd__(self, other):
        try:
            return Add(float(other), self)
        except ValueError:
            return NotImplemented

    def __rsub__(self, other):
        try:
            return Subtract(float(other), self)
        except ValueError:
            return NotImplemented

    def __rmul__(self, other):
        try:
            return Multiply(float(other), self)
        except ValueError:
            return NotImplemented

    def __rdiv__(self, other):
        try:
            return Divide(float(other), self)
        except ValueError:
            return NotImplemented

    def __rfloordiv__(self, other):
        try:
            return DivideFloor(float(other), self)
        except ValueError:
            return NotImplemented

    def __rtruediv__(self, other):
        try:
            return DivideReal(float(other), self)
        except ValueError:
            return NotImplemented

    # logic operators

    def __and__(self, other):
        if isinstance(other, Image):
            return And(self, other)
        try:
            return And(self, int(other))
        except ValueError:
            return NotImplemented

    def __rand__(self, other):
        try:
            return And(int(other), self)
        except ValueError:
            return NotImplemented

    def __or__(self, other):
        if isinstance(other, Image):
            return Or(self, other)
        try:
            return Or(self, int(other))
        except ValueError:
            return NotImplemented

    def __ror__(self, other):
        try:
            return Or(int(other), self)
        except ValueError:
            return NotImplemented

    def __xor__(self, other):
        if isinstance(other, Image):
            return Xor(self, other)
        try:
            return Xor(self, int(other))
        except ValueError:
            return NotImplemented

    def __rxor__(self, other):
        try:
            return Xor(int(other), self)
        except ValueError:
            return NotImplemented

    def __invert__(self):
        return BitwiseNot(self)

    # Relational and Equality operators

    def __lt__(self, other):
        if isinstance(other, Image):
            return Less(self, other)
        try:
            return Less(self, float(other))
        except (ValueError, TypeError):
            return NotImplemented

    def __le__(self, other):
        if isinstance(other, Image):
            return LessEqual(self, other)
        try:
            return LessEqual(self, float(other))
        except (ValueError, TypeError):
            return NotImplemented

    def __eq__(self, other):
        if isinstance(other, Image):
            return Equal(self, other)
        try:
            return Equal(self, float(other))
        except (ValueError, TypeError):
            return NotImplemented

    def __ne__(self, other):
        if isinstance(other, Image):
            return NotEqual(self, other)
        try:
            return NotEqual(self, float(other))
        except (ValueError, TypeError):
            return NotImplemented

    def __gt__(self, other):
        if isinstance(other, Image):
            return Greater(self, other)
        try:
            return Greater(self, float(other))
        except (ValueError, TypeError):
            return NotImplemented

    def __ge__(self, other):
        if isinstance(other, Image):
            return GreaterEqual(self, other)
        try:
            return GreaterEqual(self, float(other))
        except (ValueError, TypeError):
            return NotImplemented

    # "function" operators

    def __pow__(self, other):
        if isinstance(other, Image):
            return Pow(self, other)
        try:
            return Pow(self, float(other))
        except ValueError:
            return NotImplemented

    def __rpow__(self, other):
        try:
            return Pow(float(other), self)
        except ValueError:
            return NotImplemented

    def __mod__(self, other):
        if isinstance(other, Image):
            return Modulus(self, other)
        try:
            return Modulus(self, float(other))
        except ValueError:
            return NotImplemented

    def __abs__(self):
        return Abs(self)

    # iterator and container methods

    def __iter__(self):
        if len(self) == 0:
            return

        dim = self.GetDimension()
        size = self.GetSize()
        idx = [0] * dim

        while idx[dim - 1] < size[dim - 1]:
            yield self[idx]

            # increment the idx
            for d in range(0, dim):
                idx[d] += 1
                if idx[d] >= size[d] and d != dim - 1:
                    idx[d] = 0
                else:
                    break

        return

    def __len__(self):
        l = 1
        for ds in self.GetSize():
            l *= ds
        return l

    # set/get pixel methods

    def __delitem__(self, key):
        """Remove an item from the meta-data dictionary.

        It is an exception to delete the "origin", "spacing" and "direction" reserved keys.

        If the key does not exist in the dictionary no action or exception occours.
        """
        if not isinstance(key, str):
            raise TypeError("MetaData dictionary key must be str")
        if key in ["origin", "spacing", "direction"]:
            raise KeyError(f"'{key} is read-only")
        return self.EraseMetaData(key)

    def __contains__(self, key):
        """Test if key is contained in the meta-data dictionary."""
        if not isinstance(key, str):
            raise TypeError("MetaData dictionary key must be str")
        return key in [
            "origin",
            "spacing",
            "direction",
        ] or self.HasMetaDataKey(key)

    def _expand_ellipsis(self, idx):
        """Expand "..." in idx with slice(None) to fill to dimension."""
        if Ellipsis in idx:
            if idx.count(Ellipsis) > 1:
                raise IndexError("an index can only have one ellipses ('...')")
            nidx = []
            for i in range(len(idx)):
                if idx[i] is Ellipsis:
                    dim = self.GetDimension()
                    nidx.extend([slice(None)] * (dim - len(idx) + 1))
                else:
                    nidx.append(idx[i])
            return tuple(nidx)
        return tuple(idx)

    def __getitem__(self, idx):
        """Get an pixel value, a sliced image, or a metadata item

        This operator implements basic indexing where idx is
        arguments or a squence of integers the same dimension as
        the image. The result will be a pixel value from that
        index.

        Multi-dimension extended slice based indexing is also
        implemented. The return is a copy of a new image. The
        standard sliced based indices are supported including
        negative indices, to indicate location relative to the
        end, along with negative step sized to indicate reversing
        of direction.

        If the length of idx is less than the number of dimension
        of the image it will be padded with the defaults slice
        ":".

        When an index element is an integer, that dimension is
        collapsed extracting an image with reduced dimensionality.
        The minimum dimension of an image which can be extracted
        is 2D.

        If indexing with a string, then the metadata dictionary
        queried with the index as the key. If the metadata dictionary
        does not contain the key, a KeyError will occour.
        """

        if isinstance(idx, str):
            if idx == "origin":
                return self.GetOrigin()
            elif idx == "spacing":
                return self.GetSpacing()
            elif idx == "direction":
                return self.GetDirection()
            else:
                try:
                    return self.GetMetaData(idx)
                except RuntimeError as e:
                    if not self.HasMetaDataKey(idx):
                        raise KeyError(f'"{idx}" not in meta-data dictionary')
                    raise e

        if sys.version_info[0] < 3:

            def isint(i):
                return type(i) == int or type(i) == long
        else:

            def isint(i):
                return type(i) == int

        dim = self.GetDimension()
        size = self.GetSize()

        try:
            len(idx)
        except TypeError as e:
            # if the len function did not work then, assume is a
            # non-iterable, and make it a single element then an ...
            if idx == Ellipsis:
                idx = (Ellipsis,)
            else:
                idx = (idx, Ellipsis)

        if len(idx) > dim + (Ellipsis in idx):
            raise IndexError("too many indices for image")
        if (len(idx) < dim) and Ellipsis not in idx:
            # if the argument tuple has fewer elements then the dimension of the image then extend to match that of the image
            idx = tuple(idx) + (Ellipsis,)

        idx = self._expand_ellipsis(idx)

        # All the indices are integers just return GetPixel value
        if all(isint(i) for i in idx):
            # if any of the arguments are negative integers subract them for the size
            idx = [
                idx[i] if idx[i] >= 0 else (size[i] + idx[i])
                for i in range(len(idx))
            ]

            for i in range(len(idx)):
                if idx[i] < 0 or idx[i] >= size[i]:
                    raise IndexError(
                        "index {0} is outside the extent for dimension {1} with size {2}".format(
                            idx[i], i, size[i]
                        )
                    )

            return self.GetPixel(*tuple(idx))

        # If an index is an integer then we are extracting to a small dimension
        slice_dims = []
        for i in range(len(idx)):
            if type(idx[i]) is slice:
                continue
            elif isint(idx[i]):
                slice_dims.append(i)

                s = idx[i]
                if s < 0:
                    s += size[i]
                if s < 0 or s >= size[i]:
                    raise IndexError(
                        "index {0} is outside the extent for dimension {1} with size {2}".format(
                            idx[i], i, size[i]
                        )
                    )

                idx = tuple(idx[:i]) + (slice(s, s + 1),) + tuple(idx[i + 1 :])

        if dim - len(slice_dims) < 2:
            raise IndexError("invalid slice extraction to 1 dimension")

        # Use the slice filter when all the elements are slices ( or have been processed to be )
        if all(type(i) is slice for i in idx):
            # perform standard slice indexing, to clamp to ranges and add in defaults
            sidx = [idx[i].indices(size[i]) for i in range(len(idx))]

            # extract each element of the indices rages together
            (start, stop, step) = zip(*sidx)

            # run the slice filter
            img = Slice(self, start=start, stop=stop, step=step)

            if slice_dims:
                size = img.GetSize()
                # set the slice dimension size to 0
                for i in slice_dims:
                    size = tuple(size[:i]) + (0,) + tuple(size[i + 1 :])

                # Reduce the dimension of the image
                img = Extract(img, size)

            return img

        # the index parameter was an invalid set of objects
        raise IndexError("invalid index")

    def __setitem__(self, idx, rvalue):
        """Sets this image's pixel value(s) to rvalue.

        The dimension of idx must match that of the image.

        If all indices are integers then rvalue should be a pixel value
        ( scalar or sequence for vector pixels). The value is assigned to
        the pixel.

        If idx is an image, it is considered a binary mask of 0s and non-zeros.
        The pixels corresponding to the non-zeros of the mask are assigned
        values. If rvalue is a scalar constant the scalar value is assigned to
        the pixel. If rvalue is an image then the corresponding pixel is
        assigned. All images involved in the operation must have congruent
        geometry.

        If the indices are slices or integers then, the PasteImageFilter is
        used to assign values to this image. The rvalue can be an image
        or a scalar constant value. When rvalue is an image it must be of
        the same pixel type and equal or lesser dimension than self. The
        region defined by idx and rvalue's size must be compatible. The
        region defined by idx will collapse one sized idx dimensions when it
        does not match the rvalue image's size.
        """

        if isinstance(idx, str):
            if idx == "origin":
                return self.SetOrigin(rvalue)
            elif idx == "spacing":
                return self.SetSpacing(rvalue)
            elif idx == "direction":
                return self.SetDirection(rvalue)
            else:
                if not isinstance(rvalue, str):
                    raise TypeError("metadata item must be a string")
                return self.SetMetaData(idx, rvalue)

        if isinstance(idx, Image):
            return self.__imasked_assign(idx, rvalue)

        if sys.version_info[0] < 3:

            def isint(i):
                return type(i) == int or type(i) == long
        else:

            def isint(i):
                return type(i) == int

        dim = self.GetDimension()
        size = self.GetSize()

        try:
            len(idx)
        except TypeError as e:
            # if the len function did not work then, assume is a
            # non-iterable, and make it a single element then an ...
            if idx == Ellipsis:
                idx = (Ellipsis,)
            else:
                idx = (idx, Ellipsis)

        if len(idx) > dim + (Ellipsis in idx):
            raise IndexError("too many indices for image")
        if (len(idx) < dim) and Ellipsis not in idx:
            # if the argument tuple has fewer elements then the dimension of the image then extend to match that of the image
            idx = tuple(idx) + (Ellipsis,)

        idx = self._expand_ellipsis(idx)

        # All the indices are integers use SetPixel
        if all(isint(i) for i in idx):
            # if any of the arguments are negative integers subract them from the size
            idx = [
                idx[i] if idx[i] >= 0 else (size[i] + idx[i])
                for i in range(len(idx))
            ]

            for i in range(len(idx)):
                if idx[i] < 0 or idx[i] >= size[i]:
                    raise IndexError(
                        "index {0} is outside the extent for dimension {1} with size {2}".format(
                            idx[i], i, size[i]
                        )
                    )

            return self.SetPixel(*(tuple(idx) + (rvalue,)))

        for i in range(len(idx)):
            if type(idx[i]) is slice:
                continue
            elif isint(idx[i]):
                s = idx[i]
                if s < 0:
                    s += size[i]
                if s < 0 or s >= size[i]:
                    raise IndexError(
                        "index {0} is outside the extent for dimension {1} with size {2}".format(
                            idx[i], i, size[i]
                        )
                    )

                idx = tuple(idx[:i]) + (slice(s, s + 1),) + tuple(idx[i + 1 :])

        if all(type(i) is slice for i in idx):
            sidx = [idx[i].indices(size[i]) for i in range(len(idx))]

            (start, stop, step) = zip(*sidx)
            size = [e - b for b, e in zip(start, stop)]
            try:
                sourceSize = rvalue.GetSize()
            except AttributeError:
                sourceSize = size

            for i in range(dim):
                if step[i] != 1:
                    raise IndexError(
                        "step {0} is not 1 for dimension {1}".format(
                            step[i], i
                        )
                    )

            skipAxes = [False] * dim

            s = 0
            for i in range(dim):
                if size[i] == 1 and (
                    len(sourceSize) <= s or sourceSize[s] != size[i]
                ):
                    skipAxes[i] = True
                    continue

                if len(sourceSize) <= s or sourceSize[s] != size[i]:
                    raise IndexError(
                        "cannot paste source with size {0} into destination with size {1}".format(
                            size, sourceSize
                        )
                    )
                s += 1

            size = [sz for sz, skip in zip(size, skipAxes) if not skip]
            return self.__ipaste(
                rvalue, size, [0] * len(size), start, skipAxes
            )

        # the index parameter was an invalid set of objects
        raise IndexError(
            "invalid index with types: {0}".format([type(i) for i in idx])
        )

    def GetPixel(self, *idx):
        """Returns the value of a pixel.

        This method takes 2 parameters in 2D: the x and y index,
        and 3 parameters in 3D: the x, y and z index."""

        if len(idx) == 1:
            idx = idx[0]

        pixelID = self.GetPixelIDValue()
        if pixelID == sitkUnknown:
            raise Exception("invalid pixel type")
        if pixelID == sitkInt8:
            return self.__GetPixelAsInt8__(idx)
        if pixelID == sitkUInt8 or pixelID == sitkLabelUInt8:
            return self.__GetPixelAsUInt8__(idx)
        if pixelID == sitkInt16:
            return self.__GetPixelAsInt16__(idx)
        if pixelID == sitkUInt16 or pixelID == sitkLabelUInt16:
            return self.__GetPixelAsUInt16__(idx)
        if pixelID == sitkInt32:
            return self.__GetPixelAsInt32__(idx)
        if pixelID == sitkUInt32 or pixelID == sitkLabelUInt32:
            return self.__GetPixelAsUInt32__(idx)
        if pixelID == sitkInt64:
            return self.__GetPixelAsInt64__(idx)
        if pixelID == sitkUInt64 or pixelID == sitkLabelUInt64:
            return self.__GetPixelAsUInt64__(idx)
        if pixelID == sitkFloat32:
            return self.__GetPixelAsFloat__(idx)
        if pixelID == sitkFloat64:
            return self.__GetPixelAsDouble__(idx)

        if pixelID == sitkVectorInt8:
            return self.__GetPixelAsVectorInt8__(idx)
        if pixelID == sitkVectorUInt8:
            return self.__GetPixelAsVectorUInt8__(idx)
        if pixelID == sitkVectorInt16:
            return self.__GetPixelAsVectorInt16__(idx)
        if pixelID == sitkVectorUInt16:
            return self.__GetPixelAsVectorUInt16__(idx)
        if pixelID == sitkVectorInt32:
            return self.__GetPixelAsVectorInt32__(idx)
        if pixelID == sitkVectorUInt32:
            return self.__GetPixelAsVectorUInt32__(idx)
        if pixelID == sitkVectorInt64:
            return self.__GetPixelAsVectorInt64__(idx)
        if pixelID == sitkVectorUInt64:
            return self.__GetPixelAsVectorUInt64__(idx)
        if pixelID == sitkVectorFloat32:
            return self.__GetPixelAsVectorFloat32__(idx)
        if pixelID == sitkVectorFloat64:
            return self.__GetPixelAsVectorFloat64__(idx)

        if pixelID == sitkComplexFloat32:
            return self.__GetPixelAsComplexFloat32__(idx)
        if pixelID == sitkComplexFloat64:
            return self.__GetPixelAsComplexFloat64__(idx)

        raise Exception("unknown pixel type")

    def SetPixel(self, *args):
        """Sets the value of a pixel.

        This method takes 3 parameters in 2D: the x and y index then the value,
        and 4 parameters in 3D: the x, y and z index then the value."""

        pixelID = self.GetPixelIDValue()
        if pixelID == sitkUnknown:
            raise Exception("invalid pixel type")

        if len(args) < 2:
            raise Exception(
                "Wrong number of arguments, coordinates arguments then value"
            )
        idx = args[: len(args) - 1]
        if len(idx) == 1:
            idx = idx[0]
        value = args[-1]

        if pixelID == sitkInt8:
            return self.__SetPixelAsInt8__(idx, value)
        if pixelID == sitkUInt8 or pixelID == sitkLabelUInt8:
            return self.__SetPixelAsUInt8__(idx, value)
        if pixelID == sitkInt16:
            return self.__SetPixelAsInt16__(idx, value)
        if pixelID == sitkUInt16 or pixelID == sitkLabelUInt16:
            return self.__SetPixelAsUInt16__(idx, value)
        if pixelID == sitkInt32:
            return self.__SetPixelAsInt32__(idx, value)
        if pixelID == sitkUInt32 or pixelID == sitkLabelUInt32:
            return self.__SetPixelAsUInt32__(idx, value)
        if pixelID == sitkInt64:
            return self.__SetPixelAsInt64__(idx, value)
        if pixelID == sitkUInt64 or pixelID == sitkLabelUInt64:
            return self.__SetPixelAsUInt64__(idx, value)
        if pixelID == sitkFloat32:
            return self.__SetPixelAsFloat__(idx, value)
        if pixelID == sitkFloat64:
            return self.__SetPixelAsDouble__(idx, value)

        if pixelID == sitkVectorInt8:
            return self.__SetPixelAsVectorInt8__(idx, value)
        if pixelID == sitkVectorUInt8:
            return self.__SetPixelAsVectorUInt8__(idx, value)
        if pixelID == sitkVectorInt16:
            return self.__SetPixelAsVectorInt16__(idx, value)
        if pixelID == sitkVectorUInt16:
            return self.__SetPixelAsVectorUInt16__(idx, value)
        if pixelID == sitkVectorInt32:
            return self.__SetPixelAsVectorInt32__(idx, value)
        if pixelID == sitkVectorUInt32:
            return self.__SetPixelAsVectorUInt32__(idx, value)
        if pixelID == sitkVectorInt64:
            return self.__SetPixelAsVectorInt64__(idx, value)
        if pixelID == sitkVectorUInt64:
            return self.__SetPixelAsVectorUInt64__(idx, value)
        if pixelID == sitkVectorFloat32:
            return self.__SetPixelAsVectorFloat32__(idx, value)
        if pixelID == sitkVectorFloat64:
            return self.__SetPixelAsVectorFloat64__(idx, value)

        if pixelID == sitkComplexFloat32:
            return self.__SetPixelAsComplexFloat32__(idx, value)
        if pixelID == sitkComplexFloat64:
            return self.__SetPixelAsComplexFloat64__(idx, value)

        raise Exception("unknown pixel type")

    @staticmethod
    def _tuple_to_py_type(v, pixelID):
        if pixelID in (sitkComplexFloat32, sitkComplexFloat64):
            return complex(*v)
        elif pixelID in (
            sitkVectorUInt8,
            sitkVectorInt8,
            sitkVectorUInt16,
            sitkVectorInt16,
            sitkVectorUInt32,
            sitkVectorInt32,
            sitkVectorUInt64,
            sitkVectorInt64,
            sitkVectorFloat32,
            sitkVectorFloat64,
        ):
            return v
        elif pixelID in (
            sitkUInt8,
            sitkInt8,
            sitkUInt16,
            sitkInt16,
            sitkUInt32,
            sitkInt32,
            sitkUInt64,
            sitkInt64,
            sitkFloat32,
            sitkFloat64,
            sitkLabelUInt8,
            sitkLabelUInt16,
            sitkLabelUInt32,
            sitkLabelUInt64,
        ):
            assert len(v) == 1
            return v[0]
        else:
            raise ValueError(f"pixelID of {pixelID} is not supported.")

    def EvaluateAtContinuousIndex(self, index, interp=sitkLinear):
        """Interpolate pixel value at a continuous index.

        This method is not supported for Label pixel types.

        The valid range of continuous index is [-0.5, size-0.5] for each dimension. An exception is thrown if index is out of bounds.

        Parameters
        ----------
        index
          The continuous index must be at least the length of the image dimension.
        interp
          The interpolation type to use, only sitkNearest and sitkLinear are supported for Vector and Complex pixel types.

        Returns
        -------
          The results will be of type float, complex, or an tuple of float of vectors.

        """

        r = self.__EvaluateAtContinuousIndex__(index, interp)

        return self._tuple_to_py_type(r, self.GetPixelIDValue())

    def EvaluateAtPhysicalPoint(self, point, interp=sitkLinear):
        """Interpolate pixel value at a physical point.

        This method is not supported for Label pixel types.

        An exception is thrown if the point is out of the defined region for the image.

        Parameters
        ----------
        point
          The physical point at which the interpolation is computed.
        interp
          The interpolation type to use, only sitkNearest and sitkLinear are supported for Vector and Complex pixel types.

        Returns
        -------
          The results will be of type float, complex, or an tuple of float of vectors.
        """

        r = self.__EvaluateAtPhysicalPoint__(point, interp)

        return self._tuple_to_py_type(r, self.GetPixelIDValue())


# Register Image in _SimpleITK:
_SimpleITK.Image_swigregister(Image)


class ObjectOwnedBase(object):
    r"""


    An abstract base class to connect this object with the lifetime of
    another.


    This class maintains a list of Objects and callbacks to call when this
    object is deleted.

    Optionally, "OwnedByObjects" property can be enabled so that when
    the last referenced object is removed this object will be deleted.

    C++ includes: sitkObjectOwnedBase.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ObjectOwnedBase

    def GetName(self):
        r"""
        GetName(ObjectOwnedBase self) -> std::string


        Set object name.


        """
        return _SimpleITK.ObjectOwnedBase_GetName(self)

    def SetName(self, name):
        r"""
        SetName(ObjectOwnedBase self, std::string const & name)


        Get object name.


        """
        return _SimpleITK.ObjectOwnedBase_SetName(self, name)


# Register ObjectOwnedBase in _SimpleITK:
_SimpleITK.ObjectOwnedBase_swigregister(ObjectOwnedBase)


class Command(ObjectOwnedBase):
    r"""


    An implementation of the Command design pattern for callback.


    This class provides a callback mechanism for event that occur from the ProcessObject. These commands can be utilized to observe these events.

    The Command can be created on the stack, and will automatically unregistered it's
    self when destroyed.

    For more information see the page CommandPage.

    C++ includes: sitkCommand.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(Command self) -> Command


        Default Constructor.


        """
        if self.__class__ == Command:
            _self = None
        else:
            _self = self
        _SimpleITK.Command_swiginit(
            self,
            _SimpleITK.new_Command(
                _self,
            ),
        )

    __swig_destroy__ = _SimpleITK.delete_Command

    def GetName(self):
        r"""
        GetName(Command self) -> std::string


        Set/Get Command Name


        """
        return _SimpleITK.Command_GetName(self)

    def SetName(self, n):
        r"""
        SetName(Command self, std::string const & n)


        Get object name.


        """
        return _SimpleITK.Command_SetName(self, n)

    def Execute(self):
        r"""
        Execute(Command self)


        The method that defines action to be taken by the command


        """
        return _SimpleITK.Command_Execute(self)

    def __disown__(self):
        self.this.disown()
        _SimpleITK.disown_Command(self)
        return weakref.proxy(self)


# Register Command in _SimpleITK:
_SimpleITK.Command_swigregister(Command)


class LoggerBase(ObjectOwnedBase):
    r"""


    A base class to handle SimpleITK and ITK messages and logging.


    In ITK this function is implemented by the itk::OutputWindow, but in SimpleITK it is called a logger.

    Provides a base class for SimpleITK to provide the "DisplayText"
    methods that match the interface of itk::OutputWindow. Derived instances of LoggerBase are used by an internal adaptor derived from the itk::OutputWindow so that this object instances can be used in ITK.


    See:
     itk::OutputWindow


    C++ includes: sitkLogger.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(LoggerBase self) -> LoggerBase


        """
        if self.__class__ == LoggerBase:
            _self = None
        else:
            _self = self
        _SimpleITK.LoggerBase_swiginit(
            self,
            _SimpleITK.new_LoggerBase(
                _self,
            ),
        )

    __swig_destroy__ = _SimpleITK.delete_LoggerBase

    def DisplayText(self, t):
        r"""
        DisplayText(LoggerBase self, char const * t)


        """
        return _SimpleITK.LoggerBase_DisplayText(self, t)

    def DisplayErrorText(self, t):
        r"""
        DisplayErrorText(LoggerBase self, char const * t)


        """
        return _SimpleITK.LoggerBase_DisplayErrorText(self, t)

    def DisplayWarningText(self, t):
        r"""
        DisplayWarningText(LoggerBase self, char const * t)


        """
        return _SimpleITK.LoggerBase_DisplayWarningText(self, t)

    def DisplayGenericOutputText(self, t):
        r"""
        DisplayGenericOutputText(LoggerBase self, char const * t)


        """
        return _SimpleITK.LoggerBase_DisplayGenericOutputText(self, t)

    def DisplayDebugText(self, t):
        r"""
        DisplayDebugText(LoggerBase self, char const * t)


        """
        return _SimpleITK.LoggerBase_DisplayDebugText(self, t)

    def GetName(self):
        r"""
        GetName(LoggerBase self) -> std::string


        Set object name.


        """
        return _SimpleITK.LoggerBase_GetName(self)

    def SetName(self, n):
        r"""
        SetName(LoggerBase self, std::string const & n)


        Get object name.


        """
        return _SimpleITK.LoggerBase_SetName(self, n)

    def SetAsGlobalITKLogger(self):
        r"""
        SetAsGlobalITKLogger(LoggerBase self) -> ITKLogger


        Set this logger instance to the ITK output window.

        After calling this method, all ITK and SimpleITK display, warning and
        error texts will be handled by this object's methods.


        An ITKLogger object holding the previous itk::OutputWindow instance. The returned object can be used to restore the original
        instance.



        """
        return _SimpleITK.LoggerBase_SetAsGlobalITKLogger(self)

    @staticmethod
    def GetGlobalITKLogger():
        r"""GetGlobalITKLogger() -> ITKLogger"""
        return _SimpleITK.LoggerBase_GetGlobalITKLogger()

    def __disown__(self):
        self.this.disown()
        _SimpleITK.disown_LoggerBase(self)
        return weakref.proxy(self)


# Register LoggerBase in _SimpleITK:
_SimpleITK.LoggerBase_swigregister(LoggerBase)


def LoggerBase_GetGlobalITKLogger():
    r"""LoggerBase_GetGlobalITKLogger() -> ITKLogger"""
    return _SimpleITK.LoggerBase_GetGlobalITKLogger()


class ITKLogger(LoggerBase):
    r"""Proxy of C++ itk::simple::ITKLogger class."""

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ITKLogger

    def __init__(self, *args):
        r"""
        __init__(ITKLogger self, itk::OutputWindow * arg2) -> ITKLogger
        __init__(ITKLogger self) -> ITKLogger
        __init__(ITKLogger self, ITKLogger arg2) -> ITKLogger
        """
        _SimpleITK.ITKLogger_swiginit(self, _SimpleITK.new_ITKLogger(*args))

    def DisplayText(self, t):
        r"""
        DisplayText(ITKLogger self, char const * t)


        """
        return _SimpleITK.ITKLogger_DisplayText(self, t)

    def DisplayErrorText(self, t):
        r"""
        DisplayErrorText(ITKLogger self, char const * t)


        """
        return _SimpleITK.ITKLogger_DisplayErrorText(self, t)

    def DisplayWarningText(self, t):
        r"""
        DisplayWarningText(ITKLogger self, char const * t)


        """
        return _SimpleITK.ITKLogger_DisplayWarningText(self, t)

    def DisplayGenericOutputText(self, t):
        r"""
        DisplayGenericOutputText(ITKLogger self, char const * t)


        """
        return _SimpleITK.ITKLogger_DisplayGenericOutputText(self, t)

    def DisplayDebugText(self, t):
        r"""
        DisplayDebugText(ITKLogger self, char const * t)


        """
        return _SimpleITK.ITKLogger_DisplayDebugText(self, t)

    def SetAsGlobalITKLogger(self):
        r"""
        SetAsGlobalITKLogger(ITKLogger self) -> ITKLogger


        Set this logger instance to the ITK output window.

        After calling this method, all ITK and SimpleITK display, warning and
        error texts will be handled by this object's methods.


        An ITKLogger object holding the previous itk::OutputWindow instance. The returned object can be used to restore the original
        instance.



        """
        return _SimpleITK.ITKLogger_SetAsGlobalITKLogger(self)


# Register ITKLogger in _SimpleITK:
_SimpleITK.ITKLogger_swigregister(ITKLogger)
sitkAnnulus = _SimpleITK.sitkAnnulus

sitkBall = _SimpleITK.sitkBall

sitkBox = _SimpleITK.sitkBox

sitkCross = _SimpleITK.sitkCross

sitkPolygon3 = _SimpleITK.sitkPolygon3

sitkPolygon4 = _SimpleITK.sitkPolygon4

sitkPolygon5 = _SimpleITK.sitkPolygon5

sitkPolygon6 = _SimpleITK.sitkPolygon6

sitkPolygon7 = _SimpleITK.sitkPolygon7

sitkPolygon8 = _SimpleITK.sitkPolygon8

sitkPolygon9 = _SimpleITK.sitkPolygon9

sitkAnyEvent = _SimpleITK.sitkAnyEvent

sitkAbortEvent = _SimpleITK.sitkAbortEvent

sitkDeleteEvent = _SimpleITK.sitkDeleteEvent

sitkEndEvent = _SimpleITK.sitkEndEvent

sitkIterationEvent = _SimpleITK.sitkIterationEvent

sitkProgressEvent = _SimpleITK.sitkProgressEvent

sitkStartEvent = _SimpleITK.sitkStartEvent

sitkMultiResolutionIterationEvent = (
    _SimpleITK.sitkMultiResolutionIterationEvent
)

sitkUserEvent = _SimpleITK.sitkUserEvent

sitkWallClock = _SimpleITK.sitkWallClock

sitkUnknownTransform = _SimpleITK.sitkUnknownTransform

sitkIdentity = _SimpleITK.sitkIdentity

sitkTranslation = _SimpleITK.sitkTranslation

sitkScale = _SimpleITK.sitkScale

sitkScaleLogarithmic = _SimpleITK.sitkScaleLogarithmic

sitkEuler = _SimpleITK.sitkEuler

sitkSimilarity = _SimpleITK.sitkSimilarity

sitkQuaternionRigid = _SimpleITK.sitkQuaternionRigid

sitkVersor = _SimpleITK.sitkVersor

sitkVersorRigid = _SimpleITK.sitkVersorRigid

sitkScaleSkewVersor = _SimpleITK.sitkScaleSkewVersor

sitkComposeScaleSkewVersor = _SimpleITK.sitkComposeScaleSkewVersor

sitkScaleVersor = _SimpleITK.sitkScaleVersor

sitkAffine = _SimpleITK.sitkAffine

sitkComposite = _SimpleITK.sitkComposite

sitkDisplacementField = _SimpleITK.sitkDisplacementField

sitkBSplineTransform = _SimpleITK.sitkBSplineTransform


class Transform(object):
    r"""


    A simplified wrapper around a variety of ITK transforms.


    The interface to ITK transform objects to be used with the ImageRegistrationMethod, ResampleImageFilter and other SimpleITK process objects. The transforms are designed to
    have a serialized array of parameters to facilitate optimization for
    registration.

    Provides a base class interface to any type of ITK transform. Objects
    of this type may have their interface converted to a derived interface
    while keeping the same reference to the ITK object.

    Additionally, this class provides a basic interface to a composite
    transforms.


    See:
     itk::CompositeTransform


    C++ includes: sitkTransform.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_Transform

    def __init__(self, *args):
        r"""
        __init__(Transform self) -> Transform
        __init__(Transform self, itk::TransformBase * transform) -> Transform
        __init__(Transform self, unsigned int dimensions, itk::simple::TransformEnum type) -> Transform
        __init__(Transform self, Image displacement, itk::simple::TransformEnum type=sitkDisplacementField) -> Transform
        __init__(Transform self, Transform arg2) -> Transform


        Construct a specific transformation.


        Deprecated
        This constructor will be removed in future releases.



        """
        _SimpleITK.Transform_swiginit(self, _SimpleITK.new_Transform(*args))

    def GetITKBase(self, *args):
        r"""
        GetITKBase(Transform self) -> itk::TransformBase
        GetITKBase(Transform self) -> itk::TransformBase const *
        """
        return _SimpleITK.Transform_GetITKBase(self, *args)

    def GetDimension(self):
        r"""
        GetDimension(Transform self) -> unsigned int


        Return the dimension of the Transform ( 2D or 3D )


        """
        return _SimpleITK.Transform_GetDimension(self)

    def SetParameters(self, parameters):
        r"""SetParameters(Transform self, VectorDouble parameters)"""
        return _SimpleITK.Transform_SetParameters(self, parameters)

    def GetParameters(self):
        r"""GetParameters(Transform self) -> VectorDouble"""
        return _SimpleITK.Transform_GetParameters(self)

    def GetNumberOfParameters(self):
        r"""
        GetNumberOfParameters(Transform self) -> unsigned int


        Return the number of optimizable parameters


        """
        return _SimpleITK.Transform_GetNumberOfParameters(self)

    def SetFixedParameters(self, parameters):
        r"""SetFixedParameters(Transform self, VectorDouble parameters)"""
        return _SimpleITK.Transform_SetFixedParameters(self, parameters)

    def GetFixedParameters(self):
        r"""GetFixedParameters(Transform self) -> VectorDouble"""
        return _SimpleITK.Transform_GetFixedParameters(self)

    def GetNumberOfFixedParameters(self):
        r"""
        GetNumberOfFixedParameters(Transform self) -> unsigned int


        Get the number of fixed parameters


        """
        return _SimpleITK.Transform_GetNumberOfFixedParameters(self)

    def TransformPoint(self, point):
        r"""
        TransformPoint(Transform self, VectorDouble point) -> VectorDouble


        Apply transform to a point.

        The dimension of the point must match the transform.


        """
        return _SimpleITK.Transform_TransformPoint(self, point)

    def TransformVector(self, vector, point):
        r"""
        TransformVector(Transform self, VectorDouble vector, VectorDouble point) -> VectorDouble


        Apply transform to a vector at a point.

        The ITK concept of a vector is a direction at a specific point, for
        example the difference between two points is a vector.

        For linear transforms the point does not matter, in general the vector
        is transformed by the Jacobian with respect to point position.

        The dimension of the vector and point must match the transform.


        """
        return _SimpleITK.Transform_TransformVector(self, vector, point)

    def WriteTransform(self, filename):
        r"""
        WriteTransform(Transform self, std::string const & filename)


        """
        return _SimpleITK.Transform_WriteTransform(self, filename)

    def IsLinear(self):
        r"""
        IsLinear(Transform self) -> bool


        """
        return _SimpleITK.Transform_IsLinear(self)

    def SetIdentity(self):
        r"""
        SetIdentity(Transform self)


        """
        return _SimpleITK.Transform_SetIdentity(self)

    def SetInverse(self):
        r"""
        SetInverse(Transform self) -> bool


        Try to change the current transform to it's inverse.


        If the transform has an inverse, i.e. non-singular linear transforms,
        then a new ITK transform is created of the same type and this object
        is set to it.

        However not all transform have a direct inverse, if the inverse does
        not exist or fails false will be returned and this transform will not
        be modified.


        """
        return _SimpleITK.Transform_SetInverse(self)

    def GetInverse(self):
        r"""
        GetInverse(Transform self) -> Transform


        Return a new inverse transform of the same type as this.


        Creates a new transform object and tries to set the value to the
        inverse. As not all transform types have inverse and some transforms
        are not invertible, an exception will be throw is there is no inverse.


        """
        val = _SimpleITK.Transform_GetInverse(self)

        val = val.Downcast()

        return val

    def __str__(self):
        r"""
        __str__(Transform self) -> std::string


        """
        return _SimpleITK.Transform___str__(self)

    def GetName(self):
        r"""
        GetName(Transform self) -> std::string


        return user readable name for the SimpleITK transform


        """
        return _SimpleITK.Transform_GetName(self)

    def MakeUnique(self):
        r"""
        MakeUnique(Transform self)


        Performs actually coping if needed to make object unique.


        The Transform class by default performs lazy coping and assignment. This method
        make sure that coping actually happens to the itk::Transform pointed to is only pointed to by this object.


        """
        return _SimpleITK.Transform_MakeUnique(self)

    def GetTransformEnum(self):
        r"""
        GetTransformEnum(Transform self) -> itk::simple::TransformEnum


        Get the TransformEnum of the underlying Transform.


        A SimpleITK Transform object can internally hold any ITK transform. This method returns the
        TransformEnum representing the internal ITK transform. This value may
        be used to identify which SimpleITK class the transform can be
        converted to.


        """
        return _SimpleITK.Transform_GetTransformEnum(self)

    def __copy__(self):
        """Create a SimpleITK shallow copy, where the internal transform is shared with a copy on write implementation."""
        return self.__class__(self)

    def __deepcopy__(self, memo):
        """Create a new copy of the data and internal ITK Transform object."""
        dc = self.__class__(self)
        dc.MakeUnique()
        return dc

    def __setstate__(self, args):
        if args[0] != 0:
            raise ValueError(
                "Unable to handle SimpleITK.Transform pickle version {0}".args[
                    0
                ]
            )

        if len(args) == 1:
            return

        state = namedtuple(
            "state_tuple_0", "version fixed_parameters parameters"
        )(*args)

        self.SetFixedParameters(state.fixed_parameters)
        self.SetParameters(state.parameters)

    def __reduce_ex__(self, protocol):
        version = 0

        downcasted = self.Downcast()

        if downcasted.__class__ is DisplacementFieldTransform:
            dis = downcasted.GetDisplacementField()
            if all(0 == s for s in dis.GetSize()):
                # The null state needs special handling
                args = (downcasted.GetDimension(),)
                S = (
                    version,
                    downcasted.GetFixedParameters(),
                    downcasted.GetParameters(),
                )
            else:
                args = (dis,)
                S = (version,)
        elif downcasted.__class__ is BSplineTransform:
            args = (
                tuple(downcasted.GetCoefficientImages()),
                downcasted.GetOrder(),
            )
            S = (version,)
        elif downcasted.__class__ == CompositeTransform:
            if downcasted.GetNumberOfTransforms() > 0:
                args = (
                    [
                        downcasted.GetNthTransform(n)
                        for n in range(downcasted.GetNumberOfTransforms())
                    ],
                )
            else:
                args = (downcasted.GetDimension(),)
            S = (version,)

        else:
            args = ()
            if downcasted.__class__ in [
                AffineTransform,
                ScaleTransform,
                TranslationTransform,
            ]:
                args = (downcasted.GetDimension(),)
            elif downcasted.__class__ is Transform:
                args = (
                    downcasted.GetDimension(),
                    downcasted.GetTransformEnum(),
                )

            S = (
                version,
                downcasted.GetFixedParameters(),
                downcasted.GetParameters(),
            )

        return downcasted.__class__, args, S

    def Downcast(self):
        """Convert to the appropriate derived SimpleITK object. A lazy copy to
        the underlying ITK object is performed."""

        transform_downcast_map = {
            sitkUnknownTransform: (None, None),
            sitkIdentity: (Transform, Transform),
            sitkTranslation: (TranslationTransform, TranslationTransform),
            sitkScale: (ScaleTransform, ScaleTransform),
            sitkScaleLogarithmic: (Transform, Transform),
            sitkEuler: (Euler2DTransform, Euler3DTransform),
            sitkSimilarity: (Similarity2DTransform, Similarity3DTransform),
            sitkQuaternionRigid: (None, Transform),
            sitkVersor: (None, VersorTransform),
            sitkVersorRigid: (None, VersorRigid3DTransform),
            sitkScaleSkewVersor: (None, ScaleSkewVersor3DTransform),
            sitkScaleVersor: (None, ScaleVersor3DTransform),
            sitkAffine: (AffineTransform, AffineTransform),
            sitkComposite: (CompositeTransform, CompositeTransform),
            sitkDisplacementField: (
                DisplacementFieldTransform,
                DisplacementFieldTransform,
            ),
            sitkBSplineTransform: (BSplineTransform, BSplineTransform),
        }

        id = self.GetTransformEnum()
        if id is sitkUnknownTransform:
            raise TypeError("Unknown internal ITK transform type.")
        downcast_type = transform_downcast_map[id][self.GetDimension() - 2]
        if downcast_type is None:
            raise TypeError("Unable to downcast transform type.")
        return downcast_type(self)


# Register Transform in _SimpleITK:
_SimpleITK.Transform_swigregister(Transform)


def ReadTransform(filename):
    r"""
    ReadTransform(itk::simple::PathType const & filename) -> Transform


    """
    val = _SimpleITK.ReadTransform(filename)

    val = val.Downcast()

    return val


def WriteTransform(transform, filename):
    r"""
    WriteTransform(Transform transform, itk::simple::PathType const & filename)


    """
    return _SimpleITK.WriteTransform(transform, filename)


class BSplineTransform(Transform):
    r"""


    A deformable transform over a bounded spatial domain using a BSpline
    representation for a 2D or 3D coordinate space.



    See:
     itk::BSplineTransform


    C++ includes: sitkBSplineTransform.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BSplineTransform

    def __init__(self, *args):
        r"""
        __init__(BSplineTransform self, unsigned int dimensions, unsigned int order=3) -> BSplineTransform
        __init__(BSplineTransform self, VectorOfImage coefficientImages, unsigned int order=3) -> BSplineTransform
        __init__(BSplineTransform self, BSplineTransform arg2) -> BSplineTransform
        __init__(BSplineTransform self, Transform arg2) -> BSplineTransform


        """
        _SimpleITK.BSplineTransform_swiginit(
            self, _SimpleITK.new_BSplineTransform(*args)
        )

    def GetName(self):
        r"""
        GetName(BSplineTransform self) -> std::string


        Name of this class


        """
        return _SimpleITK.BSplineTransform_GetName(self)

    def SetTransformDomainDirection(self, arg2):
        r"""
        SetTransformDomainDirection(BSplineTransform self, VectorDouble arg2)


        parameters fixed parameter


        """
        return _SimpleITK.BSplineTransform_SetTransformDomainDirection(
            self, arg2
        )

    def GetTransformDomainDirection(self):
        r"""
        GetTransformDomainDirection(BSplineTransform self) -> VectorDouble


        """
        return _SimpleITK.BSplineTransform_GetTransformDomainDirection(self)

    def SetTransformDomainMeshSize(self, arg2):
        r"""
        SetTransformDomainMeshSize(BSplineTransform self, VectorUInt32 arg2)


        """
        return _SimpleITK.BSplineTransform_SetTransformDomainMeshSize(
            self, arg2
        )

    def GetTransformDomainMeshSize(self):
        r"""
        GetTransformDomainMeshSize(BSplineTransform self) -> VectorUInt32


        """
        return _SimpleITK.BSplineTransform_GetTransformDomainMeshSize(self)

    def SetTransformDomainOrigin(self, arg2):
        r"""
        SetTransformDomainOrigin(BSplineTransform self, VectorDouble arg2)


        """
        return _SimpleITK.BSplineTransform_SetTransformDomainOrigin(self, arg2)

    def GetTransformDomainOrigin(self):
        r"""
        GetTransformDomainOrigin(BSplineTransform self) -> VectorDouble


        """
        return _SimpleITK.BSplineTransform_GetTransformDomainOrigin(self)

    def SetTransformDomainPhysicalDimensions(self, arg2):
        r"""
        SetTransformDomainPhysicalDimensions(BSplineTransform self, VectorDouble arg2)


        """
        return (
            _SimpleITK.BSplineTransform_SetTransformDomainPhysicalDimensions(
                self, arg2
            )
        )

    def GetTransformDomainPhysicalDimensions(self):
        r"""
        GetTransformDomainPhysicalDimensions(BSplineTransform self) -> VectorDouble


        """
        return (
            _SimpleITK.BSplineTransform_GetTransformDomainPhysicalDimensions(
                self
            )
        )

    def GetCoefficientImages(self):
        r"""
        GetCoefficientImages(BSplineTransform self) -> VectorOfImage


        Get a vector of the coefficient images representing the BSpline.


        A lazy shallow copy of the images from ITK is performed. If they are
        modified in SimpleITK a deep copy will occur. However, if the
        coefficient images are modified in ITK, then no copy will occur and
        the images held by SimpleITK may unexpectedly change.


        """
        return _SimpleITK.BSplineTransform_GetCoefficientImages(self)

    def GetOrder(self):
        r"""
        GetOrder(BSplineTransform self) -> unsigned int


        """
        return _SimpleITK.BSplineTransform_GetOrder(self)


# Register BSplineTransform in _SimpleITK:
_SimpleITK.BSplineTransform_swigregister(BSplineTransform)


class DisplacementFieldTransform(Transform):
    r"""


    A dense deformable transform over a bounded spatial domain for 2D or
    3D coordinates space.



    See:
     itk::DisplacementFieldTransform


    C++ includes: sitkDisplacementFieldTransform.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_DisplacementFieldTransform

    def __init__(self, *args):
        r"""
        __init__(DisplacementFieldTransform self, unsigned int dimensions) -> DisplacementFieldTransform
        __init__(DisplacementFieldTransform self, Image arg2) -> DisplacementFieldTransform
        __init__(DisplacementFieldTransform self, DisplacementFieldTransform arg2) -> DisplacementFieldTransform
        __init__(DisplacementFieldTransform self, Transform arg2) -> DisplacementFieldTransform


        """
        _SimpleITK.DisplacementFieldTransform_swiginit(
            self, _SimpleITK.new_DisplacementFieldTransform(*args)
        )

    def GetName(self):
        r"""
        GetName(DisplacementFieldTransform self) -> std::string


        Name of this class


        """
        return _SimpleITK.DisplacementFieldTransform_GetName(self)

    def SetDisplacementField(self, arg2):
        r"""
        SetDisplacementField(DisplacementFieldTransform self, Image arg2)


        Consume an image, and set the displacement field.


        parameters
        WARNING:
        The ownership of the input displacement image is transferred to the
        constructed transform object. The input image is modified to be a
        default constructed Image object.
        Image must be of sitkVectorFloat64 pixel type with the number of components
        equal to the image dimension.


        """
        return _SimpleITK.DisplacementFieldTransform_SetDisplacementField(
            self, arg2
        )

    def GetDisplacementField(self):
        r"""
        GetDisplacementField(DisplacementFieldTransform self) -> Image


        Todo
        The returned image should not directly modify the internal
        displacement field.



        """
        return _SimpleITK.DisplacementFieldTransform_GetDisplacementField(self)

    def SetInverseDisplacementField(self, arg2):
        r"""
        SetInverseDisplacementField(DisplacementFieldTransform self, Image arg2)


        fixed parameter


        """
        return (
            _SimpleITK.DisplacementFieldTransform_SetInverseDisplacementField(
                self, arg2
            )
        )

    def GetInverseDisplacementField(self):
        r"""
        GetInverseDisplacementField(DisplacementFieldTransform self) -> Image


        Todo
        The returned image is should not directly modify the internal
        displacement field.



        """
        return (
            _SimpleITK.DisplacementFieldTransform_GetInverseDisplacementField(
                self
            )
        )

    def SetInterpolator(self, interp):
        r"""
        SetInterpolator(DisplacementFieldTransform self, itk::simple::InterpolatorEnum interp)


        Set the interpolator used between the field voxels.


        """
        return _SimpleITK.DisplacementFieldTransform_SetInterpolator(
            self, interp
        )

    def SetSmoothingOff(self):
        r"""
        SetSmoothingOff(DisplacementFieldTransform self)


        """
        return _SimpleITK.DisplacementFieldTransform_SetSmoothingOff(self)

    def SetSmoothingGaussianOnUpdate(
        self, varianceForUpdateField=1.75, varianceForTotalField=0.5
    ):
        r"""
        SetSmoothingGaussianOnUpdate(DisplacementFieldTransform self, double varianceForUpdateField=1.75, double varianceForTotalField=0.5)


        """
        return (
            _SimpleITK.DisplacementFieldTransform_SetSmoothingGaussianOnUpdate(
                self, varianceForUpdateField, varianceForTotalField
            )
        )

    def SetSmoothingBSplineOnUpdate(self, *args, **kwargs):
        r"""
        SetSmoothingBSplineOnUpdate(DisplacementFieldTransform self, VectorUInt32 numberOfControlPointsForUpdateField=std::vector< unsigned int >(3, 4), VectorUInt32 numberOfControlPointsForTotalField=std::vector< unsigned int >(3, 4), bool enforceStationaryBoundary=True, unsigned int order=3)


        """
        return (
            _SimpleITK.DisplacementFieldTransform_SetSmoothingBSplineOnUpdate(
                self, *args, **kwargs
            )
        )


# Register DisplacementFieldTransform in _SimpleITK:
_SimpleITK.DisplacementFieldTransform_swigregister(DisplacementFieldTransform)


class AffineTransform(Transform):
    r"""


    An affine transformation about a fixed center with translation for a
    2D or 3D coordinate.



    See:
     itk::AffineTransform


    C++ includes: sitkAffineTransform.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_AffineTransform

    def __init__(self, *args):
        r"""
        __init__(AffineTransform self, unsigned int dimensions) -> AffineTransform
        __init__(AffineTransform self, AffineTransform arg2) -> AffineTransform
        __init__(AffineTransform self, Transform arg2) -> AffineTransform
        __init__(AffineTransform self, VectorDouble matrix, VectorDouble translation, VectorDouble fixedCenter=std::vector< double >(3, 0.0)) -> AffineTransform


        """
        _SimpleITK.AffineTransform_swiginit(
            self, _SimpleITK.new_AffineTransform(*args)
        )

    def GetName(self):
        r"""
        GetName(AffineTransform self) -> std::string


        Name of this class


        """
        return _SimpleITK.AffineTransform_GetName(self)

    def GetTranslation(self):
        r"""
        GetTranslation(AffineTransform self) -> VectorDouble


        parameters


        """
        return _SimpleITK.AffineTransform_GetTranslation(self)

    def SetTranslation(self, translation):
        r"""
        SetTranslation(AffineTransform self, VectorDouble translation)


        """
        return _SimpleITK.AffineTransform_SetTranslation(self, translation)

    def SetMatrix(self, matrix):
        r"""
        SetMatrix(AffineTransform self, VectorDouble matrix)


        """
        return _SimpleITK.AffineTransform_SetMatrix(self, matrix)

    def GetMatrix(self):
        r"""
        GetMatrix(AffineTransform self) -> VectorDouble


        """
        return _SimpleITK.AffineTransform_GetMatrix(self)

    def SetCenter(self, params):
        r"""
        SetCenter(AffineTransform self, VectorDouble params)


        fixed parameter


        """
        return _SimpleITK.AffineTransform_SetCenter(self, params)

    def GetCenter(self):
        r"""
        GetCenter(AffineTransform self) -> VectorDouble


        """
        return _SimpleITK.AffineTransform_GetCenter(self)

    def Scale(self, *args):
        r"""
        Scale(AffineTransform self, VectorDouble factor, bool pre=False)
        Scale(AffineTransform self, double factor, bool pre=False)


        """
        return _SimpleITK.AffineTransform_Scale(self, *args)

    def Shear(self, axis1, axis2, coef, pre=False):
        r"""
        Shear(AffineTransform self, int axis1, int axis2, double coef, bool pre=False)


        """
        return _SimpleITK.AffineTransform_Shear(self, axis1, axis2, coef, pre)

    def Translate(self, offset, pre=False):
        r"""
        Translate(AffineTransform self, VectorDouble offset, bool pre=False)


        """
        return _SimpleITK.AffineTransform_Translate(self, offset, pre)

    def Rotate(self, axis1, axis2, angle, pre=False):
        r"""
        Rotate(AffineTransform self, int axis1, int axis2, double angle, bool pre=False)


        """
        return _SimpleITK.AffineTransform_Rotate(
            self, axis1, axis2, angle, pre
        )


# Register AffineTransform in _SimpleITK:
_SimpleITK.AffineTransform_swigregister(AffineTransform)


class Euler3DTransform(Transform):
    r"""


    A rigid 3D transform with rotation in radians around a fixed center
    with translation.



    See:
     itk::Euler3DTransform


    C++ includes: sitkEuler3DTransform.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_Euler3DTransform

    def __init__(self, *args):
        r"""
        __init__(Euler3DTransform self) -> Euler3DTransform
        __init__(Euler3DTransform self, VectorDouble fixedCenter, double angleX=0.0, double angleY=0.0, double angleZ=0.0, VectorDouble translation=std::vector< double >(3, 0.0)) -> Euler3DTransform
        __init__(Euler3DTransform self, Euler3DTransform arg2) -> Euler3DTransform
        __init__(Euler3DTransform self, Transform arg2) -> Euler3DTransform


        """
        _SimpleITK.Euler3DTransform_swiginit(
            self, _SimpleITK.new_Euler3DTransform(*args)
        )

    def GetName(self):
        r"""
        GetName(Euler3DTransform self) -> std::string


        Name of this class


        """
        return _SimpleITK.Euler3DTransform_GetName(self)

    def SetCenter(self, params):
        r"""
        SetCenter(Euler3DTransform self, VectorDouble params)


        fixed parameter


        """
        return _SimpleITK.Euler3DTransform_SetCenter(self, params)

    def GetCenter(self):
        r"""
        GetCenter(Euler3DTransform self) -> VectorDouble


        """
        return _SimpleITK.Euler3DTransform_GetCenter(self)

    def GetAngleX(self):
        r"""
        GetAngleX(Euler3DTransform self) -> double


        """
        return _SimpleITK.Euler3DTransform_GetAngleX(self)

    def GetAngleY(self):
        r"""
        GetAngleY(Euler3DTransform self) -> double


        """
        return _SimpleITK.Euler3DTransform_GetAngleY(self)

    def GetAngleZ(self):
        r"""
        GetAngleZ(Euler3DTransform self) -> double


        """
        return _SimpleITK.Euler3DTransform_GetAngleZ(self)

    def SetRotation(self, angleX, angleY, angleZ):
        r"""
        SetRotation(Euler3DTransform self, double angleX, double angleY, double angleZ)


        parameter


        """
        return _SimpleITK.Euler3DTransform_SetRotation(
            self, angleX, angleY, angleZ
        )

    def GetTranslation(self):
        r"""
        GetTranslation(Euler3DTransform self) -> VectorDouble


        """
        return _SimpleITK.Euler3DTransform_GetTranslation(self)

    def SetTranslation(self, translation):
        r"""
        SetTranslation(Euler3DTransform self, VectorDouble translation)


        """
        return _SimpleITK.Euler3DTransform_SetTranslation(self, translation)

    def SetComputeZYX(self, _arg):
        r"""
        SetComputeZYX(Euler3DTransform self, bool _arg)


        """
        return _SimpleITK.Euler3DTransform_SetComputeZYX(self, _arg)

    def GetComputeZYX(self):
        r"""
        GetComputeZYX(Euler3DTransform self) -> bool


        """
        return _SimpleITK.Euler3DTransform_GetComputeZYX(self)

    def ComputeZYXOn(self):
        r"""
        ComputeZYXOn(Euler3DTransform self)


        """
        return _SimpleITK.Euler3DTransform_ComputeZYXOn(self)

    def ComputeZYXOff(self):
        r"""
        ComputeZYXOff(Euler3DTransform self)


        """
        return _SimpleITK.Euler3DTransform_ComputeZYXOff(self)

    def GetMatrix(self):
        r"""
        GetMatrix(Euler3DTransform self) -> VectorDouble


        additional methods


        """
        return _SimpleITK.Euler3DTransform_GetMatrix(self)

    def SetMatrix(self, matrix, tolerance=1e-10):
        r"""
        SetMatrix(Euler3DTransform self, VectorDouble matrix, double tolerance=1e-10)


        """
        return _SimpleITK.Euler3DTransform_SetMatrix(self, matrix, tolerance)


# Register Euler3DTransform in _SimpleITK:
_SimpleITK.Euler3DTransform_swigregister(Euler3DTransform)


class Euler2DTransform(Transform):
    r"""


    A rigid 2D transform with rotation in radians around a fixed center
    with translation.



    See:
     itk::Euler2DTransform


    C++ includes: sitkEuler2DTransform.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_Euler2DTransform

    def __init__(self, *args):
        r"""
        __init__(Euler2DTransform self) -> Euler2DTransform
        __init__(Euler2DTransform self, VectorDouble fixedCenter, double angle=0.0, VectorDouble translation=std::vector< double >(2, 0.0)) -> Euler2DTransform
        __init__(Euler2DTransform self, Euler2DTransform arg2) -> Euler2DTransform
        __init__(Euler2DTransform self, Transform arg2) -> Euler2DTransform


        """
        _SimpleITK.Euler2DTransform_swiginit(
            self, _SimpleITK.new_Euler2DTransform(*args)
        )

    def GetName(self):
        r"""
        GetName(Euler2DTransform self) -> std::string


        Name of this class


        """
        return _SimpleITK.Euler2DTransform_GetName(self)

    def SetCenter(self, params):
        r"""
        SetCenter(Euler2DTransform self, VectorDouble params)


        fixed parameter


        """
        return _SimpleITK.Euler2DTransform_SetCenter(self, params)

    def GetCenter(self):
        r"""
        GetCenter(Euler2DTransform self) -> VectorDouble


        """
        return _SimpleITK.Euler2DTransform_GetCenter(self)

    def SetAngle(self, angle):
        r"""
        SetAngle(Euler2DTransform self, double angle)


        parameter


        """
        return _SimpleITK.Euler2DTransform_SetAngle(self, angle)

    def GetAngle(self):
        r"""
        GetAngle(Euler2DTransform self) -> double


        """
        return _SimpleITK.Euler2DTransform_GetAngle(self)

    def GetTranslation(self):
        r"""
        GetTranslation(Euler2DTransform self) -> VectorDouble


        """
        return _SimpleITK.Euler2DTransform_GetTranslation(self)

    def SetTranslation(self, translation):
        r"""
        SetTranslation(Euler2DTransform self, VectorDouble translation)


        """
        return _SimpleITK.Euler2DTransform_SetTranslation(self, translation)

    def GetMatrix(self):
        r"""
        GetMatrix(Euler2DTransform self) -> VectorDouble


        additional methods


        """
        return _SimpleITK.Euler2DTransform_GetMatrix(self)

    def SetMatrix(self, matrix, tolerance=1e-10):
        r"""
        SetMatrix(Euler2DTransform self, VectorDouble matrix, double tolerance=1e-10)


        """
        return _SimpleITK.Euler2DTransform_SetMatrix(self, matrix, tolerance)


# Register Euler2DTransform in _SimpleITK:
_SimpleITK.Euler2DTransform_swigregister(Euler2DTransform)


class ScaleTransform(Transform):
    r"""


    A 2D or 3D anisotropic scale of coordinate space around a fixed
    center.



    See:
     itk::ScaleTransform


    C++ includes: sitkScaleTransform.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ScaleTransform

    def __init__(self, *args):
        r"""
        __init__(ScaleTransform self, unsigned int dimensions, VectorDouble scale=std::vector< double >(3, 1.0)) -> ScaleTransform
        __init__(ScaleTransform self, ScaleTransform arg2) -> ScaleTransform
        __init__(ScaleTransform self, Transform arg2) -> ScaleTransform


        """
        _SimpleITK.ScaleTransform_swiginit(
            self, _SimpleITK.new_ScaleTransform(*args)
        )

    def GetName(self):
        r"""
        GetName(ScaleTransform self) -> std::string


        Name of this class


        """
        return _SimpleITK.ScaleTransform_GetName(self)

    def SetScale(self, params):
        r"""
        SetScale(ScaleTransform self, VectorDouble params)


        """
        return _SimpleITK.ScaleTransform_SetScale(self, params)

    def GetScale(self):
        r"""
        GetScale(ScaleTransform self) -> VectorDouble


        """
        return _SimpleITK.ScaleTransform_GetScale(self)

    def SetCenter(self, params):
        r"""
        SetCenter(ScaleTransform self, VectorDouble params)


        fixed parameter


        """
        return _SimpleITK.ScaleTransform_SetCenter(self, params)

    def GetCenter(self):
        r"""
        GetCenter(ScaleTransform self) -> VectorDouble


        """
        return _SimpleITK.ScaleTransform_GetCenter(self)

    def GetMatrix(self):
        r"""
        GetMatrix(ScaleTransform self) -> VectorDouble


        additional methods


        """
        return _SimpleITK.ScaleTransform_GetMatrix(self)


# Register ScaleTransform in _SimpleITK:
_SimpleITK.ScaleTransform_swigregister(ScaleTransform)


class ScaleSkewVersor3DTransform(Transform):
    r"""


    A over parameterized 3D Affine transform composed of the addition of a
    versor rotation matrix, a scale matrix and a skew matrix around a
    fixed center with translation.



    See:
     itk::ScaleSkewVersor3DTransform


    C++ includes: sitkScaleSkewVersor3DTransform.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ScaleSkewVersor3DTransform

    def __init__(self, *args):
        r"""
        __init__(ScaleSkewVersor3DTransform self) -> ScaleSkewVersor3DTransform
        __init__(ScaleSkewVersor3DTransform self, ScaleSkewVersor3DTransform arg2) -> ScaleSkewVersor3DTransform
        __init__(ScaleSkewVersor3DTransform self, Transform arg2) -> ScaleSkewVersor3DTransform
        __init__(ScaleSkewVersor3DTransform self, VectorDouble scale, VectorDouble skew, VectorDouble versor, VectorDouble translation=std::vector< double >(3, 0.0), VectorDouble fixedCenter=std::vector< double >(3, 0.0)) -> ScaleSkewVersor3DTransform
        __init__(ScaleSkewVersor3DTransform self, VectorDouble scale, VectorDouble skew, VectorDouble axis, double angle, VectorDouble translation=std::vector< double >(3, 0.0), VectorDouble fixedCenter=std::vector< double >(3, 0.0)) -> ScaleSkewVersor3DTransform


        """
        _SimpleITK.ScaleSkewVersor3DTransform_swiginit(
            self, _SimpleITK.new_ScaleSkewVersor3DTransform(*args)
        )

    def GetName(self):
        r"""
        GetName(ScaleSkewVersor3DTransform self) -> std::string


        Name of this class


        """
        return _SimpleITK.ScaleSkewVersor3DTransform_GetName(self)

    def SetCenter(self, params):
        r"""
        SetCenter(ScaleSkewVersor3DTransform self, VectorDouble params)


        fixed parameter


        """
        return _SimpleITK.ScaleSkewVersor3DTransform_SetCenter(self, params)

    def GetCenter(self):
        r"""
        GetCenter(ScaleSkewVersor3DTransform self) -> VectorDouble


        """
        return _SimpleITK.ScaleSkewVersor3DTransform_GetCenter(self)

    def SetRotation(self, *args):
        r"""
        SetRotation(ScaleSkewVersor3DTransform self, VectorDouble versor)
        SetRotation(ScaleSkewVersor3DTransform self, VectorDouble axis, double angle)


        parameter


        """
        return _SimpleITK.ScaleSkewVersor3DTransform_SetRotation(self, *args)

    def GetVersor(self):
        r"""
        GetVersor(ScaleSkewVersor3DTransform self) -> VectorDouble


        """
        return _SimpleITK.ScaleSkewVersor3DTransform_GetVersor(self)

    def GetTranslation(self):
        r"""
        GetTranslation(ScaleSkewVersor3DTransform self) -> VectorDouble


        """
        return _SimpleITK.ScaleSkewVersor3DTransform_GetTranslation(self)

    def SetTranslation(self, translation):
        r"""
        SetTranslation(ScaleSkewVersor3DTransform self, VectorDouble translation)


        """
        return _SimpleITK.ScaleSkewVersor3DTransform_SetTranslation(
            self, translation
        )

    def GetScale(self):
        r"""
        GetScale(ScaleSkewVersor3DTransform self) -> VectorDouble


        """
        return _SimpleITK.ScaleSkewVersor3DTransform_GetScale(self)

    def SetScale(self, scale):
        r"""
        SetScale(ScaleSkewVersor3DTransform self, VectorDouble scale)


        """
        return _SimpleITK.ScaleSkewVersor3DTransform_SetScale(self, scale)

    def GetSkew(self):
        r"""
        GetSkew(ScaleSkewVersor3DTransform self) -> VectorDouble


        """
        return _SimpleITK.ScaleSkewVersor3DTransform_GetSkew(self)

    def SetSkew(self, skew):
        r"""
        SetSkew(ScaleSkewVersor3DTransform self, VectorDouble skew)


        """
        return _SimpleITK.ScaleSkewVersor3DTransform_SetSkew(self, skew)

    def Translate(self, offset):
        r"""
        Translate(ScaleSkewVersor3DTransform self, VectorDouble offset)


        additional methods


        """
        return _SimpleITK.ScaleSkewVersor3DTransform_Translate(self, offset)

    def GetMatrix(self):
        r"""
        GetMatrix(ScaleSkewVersor3DTransform self) -> VectorDouble


        """
        return _SimpleITK.ScaleSkewVersor3DTransform_GetMatrix(self)


# Register ScaleSkewVersor3DTransform in _SimpleITK:
_SimpleITK.ScaleSkewVersor3DTransform_swigregister(ScaleSkewVersor3DTransform)


class ComposeScaleSkewVersor3DTransform(Transform):
    r"""


    This transform applies a versor rotation and translation & scale/skew
    to the space.


    The transform can be described as: $ (\\textbf{R}_v * \\textbf{S} * \\textbf{K})\\textbf{x} $ where $\\textbf{R}_v$ is the rotation matrix given the versor, where $\\textbf{S}$ is the diagonal scale matrix. where $\\textbf{K}$ is the upper triangle skew (shear) matrix.


    See:
     itk::ComposeScaleSkewVersor3DTransform


    C++ includes: sitkComposeScaleSkewVersor3DTransform.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ComposeScaleSkewVersor3DTransform

    def __init__(self, *args):
        r"""
        __init__(ComposeScaleSkewVersor3DTransform self) -> ComposeScaleSkewVersor3DTransform
        __init__(ComposeScaleSkewVersor3DTransform self, ComposeScaleSkewVersor3DTransform arg2) -> ComposeScaleSkewVersor3DTransform
        __init__(ComposeScaleSkewVersor3DTransform self, Transform arg2) -> ComposeScaleSkewVersor3DTransform
        __init__(ComposeScaleSkewVersor3DTransform self, VectorDouble scale, VectorDouble skew, VectorDouble versor, VectorDouble translation=std::vector< double >(3, 0.0), VectorDouble fixedCenter=std::vector< double >(3, 0.0)) -> ComposeScaleSkewVersor3DTransform
        __init__(ComposeScaleSkewVersor3DTransform self, VectorDouble scale, VectorDouble skew, VectorDouble axis, double angle, VectorDouble translation=std::vector< double >(3, 0.0), VectorDouble fixedCenter=std::vector< double >(3, 0.0)) -> ComposeScaleSkewVersor3DTransform


        """
        _SimpleITK.ComposeScaleSkewVersor3DTransform_swiginit(
            self, _SimpleITK.new_ComposeScaleSkewVersor3DTransform(*args)
        )

    def GetName(self):
        r"""
        GetName(ComposeScaleSkewVersor3DTransform self) -> std::string


        Name of this class


        """
        return _SimpleITK.ComposeScaleSkewVersor3DTransform_GetName(self)

    def SetCenter(self, params):
        r"""
        SetCenter(ComposeScaleSkewVersor3DTransform self, VectorDouble params)


        fixed parameter


        """
        return _SimpleITK.ComposeScaleSkewVersor3DTransform_SetCenter(
            self, params
        )

    def GetCenter(self):
        r"""
        GetCenter(ComposeScaleSkewVersor3DTransform self) -> VectorDouble


        """
        return _SimpleITK.ComposeScaleSkewVersor3DTransform_GetCenter(self)

    def SetRotation(self, *args):
        r"""
        SetRotation(ComposeScaleSkewVersor3DTransform self, VectorDouble versor)
        SetRotation(ComposeScaleSkewVersor3DTransform self, VectorDouble axis, double angle)


        parameter


        """
        return _SimpleITK.ComposeScaleSkewVersor3DTransform_SetRotation(
            self, *args
        )

    def GetVersor(self):
        r"""
        GetVersor(ComposeScaleSkewVersor3DTransform self) -> VectorDouble


        """
        return _SimpleITK.ComposeScaleSkewVersor3DTransform_GetVersor(self)

    def GetTranslation(self):
        r"""
        GetTranslation(ComposeScaleSkewVersor3DTransform self) -> VectorDouble


        """
        return _SimpleITK.ComposeScaleSkewVersor3DTransform_GetTranslation(
            self
        )

    def SetTranslation(self, translation):
        r"""
        SetTranslation(ComposeScaleSkewVersor3DTransform self, VectorDouble translation)


        """
        return _SimpleITK.ComposeScaleSkewVersor3DTransform_SetTranslation(
            self, translation
        )

    def GetScale(self):
        r"""
        GetScale(ComposeScaleSkewVersor3DTransform self) -> VectorDouble


        """
        return _SimpleITK.ComposeScaleSkewVersor3DTransform_GetScale(self)

    def SetScale(self, scale):
        r"""
        SetScale(ComposeScaleSkewVersor3DTransform self, VectorDouble scale)


        """
        return _SimpleITK.ComposeScaleSkewVersor3DTransform_SetScale(
            self, scale
        )

    def GetSkew(self):
        r"""
        GetSkew(ComposeScaleSkewVersor3DTransform self) -> VectorDouble


        """
        return _SimpleITK.ComposeScaleSkewVersor3DTransform_GetSkew(self)

    def SetSkew(self, skew):
        r"""
        SetSkew(ComposeScaleSkewVersor3DTransform self, VectorDouble skew)


        """
        return _SimpleITK.ComposeScaleSkewVersor3DTransform_SetSkew(self, skew)

    def Translate(self, offset):
        r"""
        Translate(ComposeScaleSkewVersor3DTransform self, VectorDouble offset)


        additional methods


        """
        return _SimpleITK.ComposeScaleSkewVersor3DTransform_Translate(
            self, offset
        )

    def GetMatrix(self):
        r"""
        GetMatrix(ComposeScaleSkewVersor3DTransform self) -> VectorDouble


        """
        return _SimpleITK.ComposeScaleSkewVersor3DTransform_GetMatrix(self)


# Register ComposeScaleSkewVersor3DTransform in _SimpleITK:
_SimpleITK.ComposeScaleSkewVersor3DTransform_swigregister(
    ComposeScaleSkewVersor3DTransform
)


class ScaleVersor3DTransform(Transform):
    r"""


    A parameterized 3D transform composed of the addition of a versor
    rotation matrix and a scale matrix around a fixed center with
    translation.



    See:
     itk::ScaleVersor3DTransform


    C++ includes: sitkScaleVersor3DTransform.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ScaleVersor3DTransform

    def __init__(self, *args):
        r"""
        __init__(ScaleVersor3DTransform self) -> ScaleVersor3DTransform
        __init__(ScaleVersor3DTransform self, ScaleVersor3DTransform arg2) -> ScaleVersor3DTransform
        __init__(ScaleVersor3DTransform self, Transform arg2) -> ScaleVersor3DTransform
        __init__(ScaleVersor3DTransform self, VectorDouble scale, VectorDouble versor, VectorDouble translation=std::vector< double >(3, 0.0), VectorDouble fixedCenter=std::vector< double >(3, 0.0)) -> ScaleVersor3DTransform
        __init__(ScaleVersor3DTransform self, VectorDouble scale, VectorDouble axis, double angle, VectorDouble translation=std::vector< double >(3, 0.0), VectorDouble fixedCenter=std::vector< double >(3, 0.0)) -> ScaleVersor3DTransform


        """
        _SimpleITK.ScaleVersor3DTransform_swiginit(
            self, _SimpleITK.new_ScaleVersor3DTransform(*args)
        )

    def GetName(self):
        r"""
        GetName(ScaleVersor3DTransform self) -> std::string


        Name of this class


        """
        return _SimpleITK.ScaleVersor3DTransform_GetName(self)

    def SetCenter(self, params):
        r"""
        SetCenter(ScaleVersor3DTransform self, VectorDouble params)


        fixed parameter


        """
        return _SimpleITK.ScaleVersor3DTransform_SetCenter(self, params)

    def GetCenter(self):
        r"""
        GetCenter(ScaleVersor3DTransform self) -> VectorDouble


        """
        return _SimpleITK.ScaleVersor3DTransform_GetCenter(self)

    def SetRotation(self, *args):
        r"""
        SetRotation(ScaleVersor3DTransform self, VectorDouble versor)
        SetRotation(ScaleVersor3DTransform self, VectorDouble axis, double angle)


        parameter


        """
        return _SimpleITK.ScaleVersor3DTransform_SetRotation(self, *args)

    def GetVersor(self):
        r"""
        GetVersor(ScaleVersor3DTransform self) -> VectorDouble


        """
        return _SimpleITK.ScaleVersor3DTransform_GetVersor(self)

    def GetTranslation(self):
        r"""
        GetTranslation(ScaleVersor3DTransform self) -> VectorDouble


        """
        return _SimpleITK.ScaleVersor3DTransform_GetTranslation(self)

    def SetTranslation(self, translation):
        r"""
        SetTranslation(ScaleVersor3DTransform self, VectorDouble translation)


        """
        return _SimpleITK.ScaleVersor3DTransform_SetTranslation(
            self, translation
        )

    def GetScale(self):
        r"""
        GetScale(ScaleVersor3DTransform self) -> VectorDouble


        """
        return _SimpleITK.ScaleVersor3DTransform_GetScale(self)

    def SetScale(self, scale):
        r"""
        SetScale(ScaleVersor3DTransform self, VectorDouble scale)


        """
        return _SimpleITK.ScaleVersor3DTransform_SetScale(self, scale)

    def Translate(self, offset):
        r"""
        Translate(ScaleVersor3DTransform self, VectorDouble offset)


        additional methods


        """
        return _SimpleITK.ScaleVersor3DTransform_Translate(self, offset)

    def GetMatrix(self):
        r"""
        GetMatrix(ScaleVersor3DTransform self) -> VectorDouble


        """
        return _SimpleITK.ScaleVersor3DTransform_GetMatrix(self)


# Register ScaleVersor3DTransform in _SimpleITK:
_SimpleITK.ScaleVersor3DTransform_swigregister(ScaleVersor3DTransform)


class Similarity2DTransform(Transform):
    r"""


    A similarity 2D transform with rotation in radians and isotropic
    scaling around a fixed center with translation.



    See:
     itk::Similarity2DTransform


    C++ includes: sitkSimilarity2DTransform.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_Similarity2DTransform

    def __init__(self, *args):
        r"""
        __init__(Similarity2DTransform self) -> Similarity2DTransform
        __init__(Similarity2DTransform self, double scaleFactor, double angle=0.0, VectorDouble translation=std::vector< double >(2, 0.0), VectorDouble fixedCenter=std::vector< double >(2, 0.0)) -> Similarity2DTransform
        __init__(Similarity2DTransform self, Similarity2DTransform arg2) -> Similarity2DTransform
        __init__(Similarity2DTransform self, Transform arg2) -> Similarity2DTransform


        """
        _SimpleITK.Similarity2DTransform_swiginit(
            self, _SimpleITK.new_Similarity2DTransform(*args)
        )

    def GetName(self):
        r"""
        GetName(Similarity2DTransform self) -> std::string


        Name of this class


        """
        return _SimpleITK.Similarity2DTransform_GetName(self)

    def SetCenter(self, params):
        r"""
        SetCenter(Similarity2DTransform self, VectorDouble params)


        fixed parameter


        """
        return _SimpleITK.Similarity2DTransform_SetCenter(self, params)

    def GetCenter(self):
        r"""
        GetCenter(Similarity2DTransform self) -> VectorDouble


        """
        return _SimpleITK.Similarity2DTransform_GetCenter(self)

    def SetAngle(self, angle):
        r"""
        SetAngle(Similarity2DTransform self, double angle)


        parameter


        """
        return _SimpleITK.Similarity2DTransform_SetAngle(self, angle)

    def GetAngle(self):
        r"""
        GetAngle(Similarity2DTransform self) -> double


        """
        return _SimpleITK.Similarity2DTransform_GetAngle(self)

    def GetTranslation(self):
        r"""
        GetTranslation(Similarity2DTransform self) -> VectorDouble


        """
        return _SimpleITK.Similarity2DTransform_GetTranslation(self)

    def SetTranslation(self, translation):
        r"""
        SetTranslation(Similarity2DTransform self, VectorDouble translation)


        """
        return _SimpleITK.Similarity2DTransform_SetTranslation(
            self, translation
        )

    def SetScale(self, scale):
        r"""
        SetScale(Similarity2DTransform self, double scale)


        """
        return _SimpleITK.Similarity2DTransform_SetScale(self, scale)

    def GetScale(self):
        r"""
        GetScale(Similarity2DTransform self) -> double


        """
        return _SimpleITK.Similarity2DTransform_GetScale(self)

    def GetMatrix(self):
        r"""
        GetMatrix(Similarity2DTransform self) -> VectorDouble


        additional methods


        """
        return _SimpleITK.Similarity2DTransform_GetMatrix(self)

    def SetMatrix(self, matrix, tolerance=1e-10):
        r"""
        SetMatrix(Similarity2DTransform self, VectorDouble matrix, double tolerance=1e-10)


        """
        return _SimpleITK.Similarity2DTransform_SetMatrix(
            self, matrix, tolerance
        )


# Register Similarity2DTransform in _SimpleITK:
_SimpleITK.Similarity2DTransform_swigregister(Similarity2DTransform)


class Similarity3DTransform(Transform):
    r"""


    A similarity 3D transform with rotation as a versor, and isotropic
    scaling around a fixed center with translation.



    See:
     itk::Similarity3DTransform


    C++ includes: sitkSimilarity3DTransform.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_Similarity3DTransform

    def __init__(self, *args):
        r"""
        __init__(Similarity3DTransform self) -> Similarity3DTransform
        __init__(Similarity3DTransform self, Similarity3DTransform arg2) -> Similarity3DTransform
        __init__(Similarity3DTransform self, Transform arg2) -> Similarity3DTransform
        __init__(Similarity3DTransform self, double scaleFactor, VectorDouble versor, VectorDouble translation=std::vector< double >(3, 0.0), VectorDouble fixedCenter=std::vector< double >(3, 0.0)) -> Similarity3DTransform
        __init__(Similarity3DTransform self, double scaleFactor, VectorDouble axis, double angle, VectorDouble translation=std::vector< double >(3, 0.0), VectorDouble fixedCenter=std::vector< double >(3, 0.0)) -> Similarity3DTransform


        """
        _SimpleITK.Similarity3DTransform_swiginit(
            self, _SimpleITK.new_Similarity3DTransform(*args)
        )

    def GetName(self):
        r"""
        GetName(Similarity3DTransform self) -> std::string


        Name of this class


        """
        return _SimpleITK.Similarity3DTransform_GetName(self)

    def SetCenter(self, params):
        r"""
        SetCenter(Similarity3DTransform self, VectorDouble params)


        fixed parameter


        """
        return _SimpleITK.Similarity3DTransform_SetCenter(self, params)

    def GetCenter(self):
        r"""
        GetCenter(Similarity3DTransform self) -> VectorDouble


        """
        return _SimpleITK.Similarity3DTransform_GetCenter(self)

    def SetRotation(self, *args):
        r"""
        SetRotation(Similarity3DTransform self, VectorDouble versor)
        SetRotation(Similarity3DTransform self, VectorDouble axis, double angle)


        parameter


        """
        return _SimpleITK.Similarity3DTransform_SetRotation(self, *args)

    def GetVersor(self):
        r"""
        GetVersor(Similarity3DTransform self) -> VectorDouble


        """
        return _SimpleITK.Similarity3DTransform_GetVersor(self)

    def SetScale(self, scale):
        r"""
        SetScale(Similarity3DTransform self, double scale)


        """
        return _SimpleITK.Similarity3DTransform_SetScale(self, scale)

    def GetScale(self):
        r"""
        GetScale(Similarity3DTransform self) -> double


        """
        return _SimpleITK.Similarity3DTransform_GetScale(self)

    def GetTranslation(self):
        r"""
        GetTranslation(Similarity3DTransform self) -> VectorDouble


        """
        return _SimpleITK.Similarity3DTransform_GetTranslation(self)

    def SetTranslation(self, translation):
        r"""
        SetTranslation(Similarity3DTransform self, VectorDouble translation)


        """
        return _SimpleITK.Similarity3DTransform_SetTranslation(
            self, translation
        )

    def Translate(self, offset):
        r"""
        Translate(Similarity3DTransform self, VectorDouble offset)


        additional methods


        """
        return _SimpleITK.Similarity3DTransform_Translate(self, offset)

    def GetMatrix(self):
        r"""
        GetMatrix(Similarity3DTransform self) -> VectorDouble


        """
        return _SimpleITK.Similarity3DTransform_GetMatrix(self)

    def SetMatrix(self, matrix, tolerance=1e-10):
        r"""
        SetMatrix(Similarity3DTransform self, VectorDouble matrix, double tolerance=1e-10)


        """
        return _SimpleITK.Similarity3DTransform_SetMatrix(
            self, matrix, tolerance
        )


# Register Similarity3DTransform in _SimpleITK:
_SimpleITK.Similarity3DTransform_swigregister(Similarity3DTransform)


class TranslationTransform(Transform):
    r"""


    Translation of a 2D or 3D coordinate space.



    See:
     itk::TranslationTransform


    C++ includes: sitkTranslationTransform.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_TranslationTransform

    def __init__(self, *args):
        r"""
        __init__(TranslationTransform self, unsigned int dimensions, VectorDouble offset=std::vector< double >(3, 0.0)) -> TranslationTransform
        __init__(TranslationTransform self, TranslationTransform arg2) -> TranslationTransform
        __init__(TranslationTransform self, Transform arg2) -> TranslationTransform


        """
        _SimpleITK.TranslationTransform_swiginit(
            self, _SimpleITK.new_TranslationTransform(*args)
        )

    def GetName(self):
        r"""
        GetName(TranslationTransform self) -> std::string


        Name of this class


        """
        return _SimpleITK.TranslationTransform_GetName(self)

    def SetOffset(self, params):
        r"""
        SetOffset(TranslationTransform self, VectorDouble params)


        """
        return _SimpleITK.TranslationTransform_SetOffset(self, params)

    def GetOffset(self):
        r"""
        GetOffset(TranslationTransform self) -> VectorDouble


        """
        return _SimpleITK.TranslationTransform_GetOffset(self)


# Register TranslationTransform in _SimpleITK:
_SimpleITK.TranslationTransform_swigregister(TranslationTransform)


class VersorTransform(Transform):
    r"""


    A 3D rotation transform with rotation as a versor around a fixed
    center.



    See:
     itk::VersorTransform


    C++ includes: sitkVersorTransform.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_VersorTransform

    def __init__(self, *args):
        r"""
        __init__(VersorTransform self) -> VersorTransform
        __init__(VersorTransform self, VersorTransform arg2) -> VersorTransform
        __init__(VersorTransform self, Transform arg2) -> VersorTransform
        __init__(VersorTransform self, VectorDouble versor, VectorDouble fixedCenter=std::vector< double >(3, 0.0)) -> VersorTransform
        __init__(VersorTransform self, VectorDouble axis, double angle, VectorDouble fixedCenter=std::vector< double >(3, 0.0)) -> VersorTransform


        """
        _SimpleITK.VersorTransform_swiginit(
            self, _SimpleITK.new_VersorTransform(*args)
        )

    def GetName(self):
        r"""
        GetName(VersorTransform self) -> std::string


        Name of this class


        """
        return _SimpleITK.VersorTransform_GetName(self)

    def SetCenter(self, params):
        r"""
        SetCenter(VersorTransform self, VectorDouble params)


        fixed parameter


        """
        return _SimpleITK.VersorTransform_SetCenter(self, params)

    def GetCenter(self):
        r"""
        GetCenter(VersorTransform self) -> VectorDouble


        """
        return _SimpleITK.VersorTransform_GetCenter(self)

    def SetRotation(self, *args):
        r"""
        SetRotation(VersorTransform self, VectorDouble versor)
        SetRotation(VersorTransform self, VectorDouble axis, double angle)


        parameter


        """
        return _SimpleITK.VersorTransform_SetRotation(self, *args)

    def GetVersor(self):
        r"""
        GetVersor(VersorTransform self) -> VectorDouble


        """
        return _SimpleITK.VersorTransform_GetVersor(self)

    def GetMatrix(self):
        r"""
        GetMatrix(VersorTransform self) -> VectorDouble


        additional methods


        """
        return _SimpleITK.VersorTransform_GetMatrix(self)

    def SetMatrix(self, matrix, tolerance=1e-10):
        r"""
        SetMatrix(VersorTransform self, VectorDouble matrix, double tolerance=1e-10)


        """
        return _SimpleITK.VersorTransform_SetMatrix(self, matrix, tolerance)


# Register VersorTransform in _SimpleITK:
_SimpleITK.VersorTransform_swigregister(VersorTransform)


class VersorRigid3DTransform(Transform):
    r"""


    A rotation as a versor around a fixed center with translation of a 3D
    coordinate space.



    See:
     itk::VersorRigid3DTransform


    C++ includes: sitkVersorRigid3DTransform.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_VersorRigid3DTransform

    def __init__(self, *args):
        r"""
        __init__(VersorRigid3DTransform self) -> VersorRigid3DTransform
        __init__(VersorRigid3DTransform self, VersorRigid3DTransform arg2) -> VersorRigid3DTransform
        __init__(VersorRigid3DTransform self, Transform arg2) -> VersorRigid3DTransform
        __init__(VersorRigid3DTransform self, VectorDouble versor, VectorDouble translation=std::vector< double >(3, 0.0), VectorDouble fixedCenter=std::vector< double >(3, 0.0)) -> VersorRigid3DTransform
        __init__(VersorRigid3DTransform self, VectorDouble axis, double angle, VectorDouble translation=std::vector< double >(3, 0.0), VectorDouble fixedCenter=std::vector< double >(3, 0.0)) -> VersorRigid3DTransform


        """
        _SimpleITK.VersorRigid3DTransform_swiginit(
            self, _SimpleITK.new_VersorRigid3DTransform(*args)
        )

    def GetName(self):
        r"""
        GetName(VersorRigid3DTransform self) -> std::string


        Name of this class


        """
        return _SimpleITK.VersorRigid3DTransform_GetName(self)

    def SetCenter(self, params):
        r"""
        SetCenter(VersorRigid3DTransform self, VectorDouble params)


        fixed parameter


        """
        return _SimpleITK.VersorRigid3DTransform_SetCenter(self, params)

    def GetCenter(self):
        r"""
        GetCenter(VersorRigid3DTransform self) -> VectorDouble


        """
        return _SimpleITK.VersorRigid3DTransform_GetCenter(self)

    def SetRotation(self, *args):
        r"""
        SetRotation(VersorRigid3DTransform self, VectorDouble versor)
        SetRotation(VersorRigid3DTransform self, VectorDouble axis, double angle)


        parameter


        """
        return _SimpleITK.VersorRigid3DTransform_SetRotation(self, *args)

    def GetVersor(self):
        r"""
        GetVersor(VersorRigid3DTransform self) -> VectorDouble


        """
        return _SimpleITK.VersorRigid3DTransform_GetVersor(self)

    def GetTranslation(self):
        r"""
        GetTranslation(VersorRigid3DTransform self) -> VectorDouble


        """
        return _SimpleITK.VersorRigid3DTransform_GetTranslation(self)

    def SetTranslation(self, translation):
        r"""
        SetTranslation(VersorRigid3DTransform self, VectorDouble translation)


        """
        return _SimpleITK.VersorRigid3DTransform_SetTranslation(
            self, translation
        )

    def Translate(self, offset):
        r"""
        Translate(VersorRigid3DTransform self, VectorDouble offset)


        additional methods


        """
        return _SimpleITK.VersorRigid3DTransform_Translate(self, offset)

    def GetMatrix(self):
        r"""
        GetMatrix(VersorRigid3DTransform self) -> VectorDouble


        """
        return _SimpleITK.VersorRigid3DTransform_GetMatrix(self)

    def SetMatrix(self, matrix, tolerance=1e-10):
        r"""
        SetMatrix(VersorRigid3DTransform self, VectorDouble matrix, double tolerance=1e-10)


        """
        return _SimpleITK.VersorRigid3DTransform_SetMatrix(
            self, matrix, tolerance
        )


# Register VersorRigid3DTransform in _SimpleITK:
_SimpleITK.VersorRigid3DTransform_swigregister(VersorRigid3DTransform)


class CompositeTransform(Transform):
    r"""


    This class contains a stack of transforms and concatenates them by
    composition.


    The transforms are composed in reverse order with the back being applied first: $ T_0 o T_1 = T_0(T_1(x)) $ Transforms are stored in a queue, in the following order: $ T_0, T_1, ... , T_N-1 $

    Transforms are added via AddTransform(). This adds the transforms to the back of the queue.

    The only parameters of the transform at the back of the queue are
    exposed and optimizable for registration.

    Inverse: The inverse transform is created by retrieving the inverse
    from each sub transform and adding them to a composite transform in
    reverse order. The m_TransformsToOptimizeFlags is copied in reverse
    for the inverse.


    See:
     itk::CompositeTransform


    C++ includes: sitkCompositeTransform.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(CompositeTransform self, unsigned int dimensions) -> CompositeTransform
        __init__(CompositeTransform self, Transform arg2) -> CompositeTransform
        __init__(CompositeTransform self, CompositeTransform arg2) -> CompositeTransform
        __init__(CompositeTransform self, VectorOfTransform arg2) -> CompositeTransform


        Construct an empty CompositeTransform.


        The created CompositeTransform is initialized with zero transforms. Additional transforms of
        dimensions can be added.


        """
        _SimpleITK.CompositeTransform_swiginit(
            self, _SimpleITK.new_CompositeTransform(*args)
        )

    __swig_destroy__ = _SimpleITK.delete_CompositeTransform

    def GetName(self):
        r"""
        GetName(CompositeTransform self) -> std::string


        Name of this class


        """
        return _SimpleITK.CompositeTransform_GetName(self)

    def FlattenTransform(self):
        r"""
        FlattenTransform(CompositeTransform self)


        Removes nested composite transforms.


        If this transform contains additional composite transforms, then these
        nested composite transformed are removed, while preserving the order
        of the regular transforms and transferring ownership to the parent CompositeTransform.

        Nested composite transform may not be written to a file.


        """
        return _SimpleITK.CompositeTransform_FlattenTransform(self)

    def AddTransform(self, t):
        r"""
        AddTransform(CompositeTransform self, Transform t)


        Add a transform to the back of the stack.


        A deep-copy of the transform is performed. The added transform will
        have the optimizable parameters, while the other parameters are part
        of the fixed parameters.


        """
        return _SimpleITK.CompositeTransform_AddTransform(self, t)

    def GetNumberOfTransforms(self):
        r"""
        GetNumberOfTransforms(CompositeTransform self) -> unsigned int


        The number of transforms in the stack.


        """
        return _SimpleITK.CompositeTransform_GetNumberOfTransforms(self)

    def ClearTransforms(self):
        r"""
        ClearTransforms(CompositeTransform self)


        Remove all transforms from the stack.


        """
        return _SimpleITK.CompositeTransform_ClearTransforms(self)

    def RemoveTransform(self):
        r"""
        RemoveTransform(CompositeTransform self)


        Remove the active transform at the back.


        If the stack is empty an exception will be thrown.


        """
        return _SimpleITK.CompositeTransform_RemoveTransform(self)

    def GetBackTransform(self):
        r"""
        GetBackTransform(CompositeTransform self) -> Transform


        Get a copy of the back transform.


        If the stack is empty an exception will be thrown.


        """
        val = _SimpleITK.CompositeTransform_GetBackTransform(self)

        val = val.Downcast()

        return val

    def GetNthTransform(self, n):
        r"""
        GetNthTransform(CompositeTransform self, unsigned int n) -> Transform


        Get a copy of a transform in the stack.


        If n is equal or greater than the number of transforms, then an
        exception will be thrown.


        """
        val = _SimpleITK.CompositeTransform_GetNthTransform(self, n)

        val = val.Downcast()

        return val


# Register CompositeTransform in _SimpleITK:
_SimpleITK.CompositeTransform_swigregister(CompositeTransform)


class ProcessObject(object):
    r"""


    Base class for SimpleITK classes based on ProcessObject.

    C++ includes: sitkProcessObject.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ProcessObject

    def __str__(self):
        r"""
        __str__(ProcessObject self) -> std::string


        """
        return _SimpleITK.ProcessObject___str__(self)

    def GetName(self):
        r"""
        GetName(ProcessObject self) -> std::string


        return user readable name for the filter


        """
        return _SimpleITK.ProcessObject_GetName(self)

    def DebugOn(self):
        r"""DebugOn(ProcessObject self)"""
        return _SimpleITK.ProcessObject_DebugOn(self)

    def DebugOff(self):
        r"""DebugOff(ProcessObject self)"""
        return _SimpleITK.ProcessObject_DebugOff(self)

    def GetDebug(self):
        r"""GetDebug(ProcessObject self) -> bool"""
        return _SimpleITK.ProcessObject_GetDebug(self)

    def SetDebug(self, debugFlag):
        r"""SetDebug(ProcessObject self, bool debugFlag)"""
        return _SimpleITK.ProcessObject_SetDebug(self, debugFlag)

    @staticmethod
    def GlobalDefaultDebugOn():
        r"""GlobalDefaultDebugOn()"""
        return _SimpleITK.ProcessObject_GlobalDefaultDebugOn()

    @staticmethod
    def GlobalDefaultDebugOff():
        r"""GlobalDefaultDebugOff()"""
        return _SimpleITK.ProcessObject_GlobalDefaultDebugOff()

    @staticmethod
    def GetGlobalDefaultDebug():
        r"""GetGlobalDefaultDebug() -> bool"""
        return _SimpleITK.ProcessObject_GetGlobalDefaultDebug()

    @staticmethod
    def SetGlobalDefaultDebug(debugFlag):
        r"""SetGlobalDefaultDebug(bool debugFlag)"""
        return _SimpleITK.ProcessObject_SetGlobalDefaultDebug(debugFlag)

    @staticmethod
    def GlobalWarningDisplayOn():
        r"""GlobalWarningDisplayOn()"""
        return _SimpleITK.ProcessObject_GlobalWarningDisplayOn()

    @staticmethod
    def GlobalWarningDisplayOff():
        r"""GlobalWarningDisplayOff()"""
        return _SimpleITK.ProcessObject_GlobalWarningDisplayOff()

    @staticmethod
    def SetGlobalWarningDisplay(flag):
        r"""SetGlobalWarningDisplay(bool flag)"""
        return _SimpleITK.ProcessObject_SetGlobalWarningDisplay(flag)

    @staticmethod
    def GetGlobalWarningDisplay():
        r"""GetGlobalWarningDisplay() -> bool"""
        return _SimpleITK.ProcessObject_GetGlobalWarningDisplay()

    @staticmethod
    def GetGlobalDefaultCoordinateTolerance():
        r"""GetGlobalDefaultCoordinateTolerance() -> double"""
        return _SimpleITK.ProcessObject_GetGlobalDefaultCoordinateTolerance()

    @staticmethod
    def SetGlobalDefaultCoordinateTolerance(arg1):
        r"""SetGlobalDefaultCoordinateTolerance(double arg1)"""
        return _SimpleITK.ProcessObject_SetGlobalDefaultCoordinateTolerance(
            arg1
        )

    @staticmethod
    def GetGlobalDefaultDirectionTolerance():
        r"""GetGlobalDefaultDirectionTolerance() -> double"""
        return _SimpleITK.ProcessObject_GetGlobalDefaultDirectionTolerance()

    @staticmethod
    def SetGlobalDefaultDirectionTolerance(arg1):
        r"""SetGlobalDefaultDirectionTolerance(double arg1)"""
        return _SimpleITK.ProcessObject_SetGlobalDefaultDirectionTolerance(
            arg1
        )

    @staticmethod
    def SetGlobalDefaultThreader(threader):
        r"""SetGlobalDefaultThreader(std::string const & threader) -> bool"""
        return _SimpleITK.ProcessObject_SetGlobalDefaultThreader(threader)

    @staticmethod
    def GetGlobalDefaultThreader():
        r"""GetGlobalDefaultThreader() -> std::string"""
        return _SimpleITK.ProcessObject_GetGlobalDefaultThreader()

    @staticmethod
    def SetGlobalDefaultNumberOfThreads(n):
        r"""SetGlobalDefaultNumberOfThreads(unsigned int n)"""
        return _SimpleITK.ProcessObject_SetGlobalDefaultNumberOfThreads(n)

    @staticmethod
    def GetGlobalDefaultNumberOfThreads():
        r"""GetGlobalDefaultNumberOfThreads() -> unsigned int"""
        return _SimpleITK.ProcessObject_GetGlobalDefaultNumberOfThreads()

    def SetNumberOfThreads(self, n):
        r"""SetNumberOfThreads(ProcessObject self, unsigned int n)"""
        return _SimpleITK.ProcessObject_SetNumberOfThreads(self, n)

    def GetNumberOfThreads(self):
        r"""GetNumberOfThreads(ProcessObject self) -> unsigned int"""
        return _SimpleITK.ProcessObject_GetNumberOfThreads(self)

    def SetNumberOfWorkUnits(self, n):
        r"""SetNumberOfWorkUnits(ProcessObject self, unsigned int n)"""
        return _SimpleITK.ProcessObject_SetNumberOfWorkUnits(self, n)

    def GetNumberOfWorkUnits(self):
        r"""GetNumberOfWorkUnits(ProcessObject self) -> unsigned int"""
        return _SimpleITK.ProcessObject_GetNumberOfWorkUnits(self)

    def RemoveAllCommands(self):
        r"""
        RemoveAllCommands(ProcessObject self)


        Remove all registered commands.


        Calling when this object is invoking anther command will produce
        undefined behavior.


        """
        return _SimpleITK.ProcessObject_RemoveAllCommands(self)

    def HasCommand(self, event):
        r"""
        HasCommand(ProcessObject self, itk::simple::EventEnum event) -> bool


        Query of this object has any registered commands for event.


        """
        return _SimpleITK.ProcessObject_HasCommand(self, event)

    def GetProgress(self):
        r"""
        GetProgress(ProcessObject self) -> float


        An Active Measurement of the progress of execution.


        Get the execution progress of the current process object. The progress
        is a floating number in [0,1] with 0 meaning no progress and 1 meaning
        the filter has completed execution (or aborted).

        This is an Active Measurement so it can be accessed during Events
        during the execution.


        """
        return _SimpleITK.ProcessObject_GetProgress(self)

    def Abort(self):
        r"""
        Abort(ProcessObject self)


        Sets an abort flag on the active process.

        Requests the current active process to abort. Additional, progress or
        iteration event may occur. If aborted then, an AbortEvent should
        occur. The Progress should be set to 1.0 after aborting.

        The expected behavior is that not exception should be throw out of
        this processes Execute method. Additionally, the results returned are
        valid but undefined content. The content may be only partially
        updated, uninitialized or the a of size zero.

        If there is no active process the method has no effect.


        """
        return _SimpleITK.ProcessObject_Abort(self)

    def AddCommand(self, *args):
        r"""
        AddCommand(ProcessObject self, itk::simple::EventEnum event, Command cmd) -> int
        AddCommand(ProcessObject self, itk::simple::EventEnum e, PyObject * obj) -> int


        Add a Command Object to observer the event.


        The Command object's Execute method will be invoked when the internal ITK Object has the event. These events only occur during this ProcessObject's Execute method when the ITK filter is running. The command occurs
        in the same thread as this objects Execute methods was called in.

        An internal reference is made between the Command and this ProcessObject which enable automatic removal of the command when deleted. This
        enables both object to exist as stack based object and be
        automatically cleaned up.

        Unless specified otherwise, it's safe to get any value during
        execution. "Measurements" will have valid values only after the
        Execute method has returned. "Active Measurements" will have valid
        values during events, and access the underlying ITK object.

        Deleting a command this object has during a command call-back will
        produce undefined behavior.

        For more information see the page CommandPage.


        The return value is reserved for latter usage.



        """
        return _SimpleITK.ProcessObject_AddCommand(self, *args)


# Register ProcessObject in _SimpleITK:
_SimpleITK.ProcessObject_swigregister(ProcessObject)


def ProcessObject_GlobalDefaultDebugOn():
    r"""ProcessObject_GlobalDefaultDebugOn()"""
    return _SimpleITK.ProcessObject_GlobalDefaultDebugOn()


def ProcessObject_GlobalDefaultDebugOff():
    r"""ProcessObject_GlobalDefaultDebugOff()"""
    return _SimpleITK.ProcessObject_GlobalDefaultDebugOff()


def ProcessObject_GetGlobalDefaultDebug():
    r"""ProcessObject_GetGlobalDefaultDebug() -> bool"""
    return _SimpleITK.ProcessObject_GetGlobalDefaultDebug()


def ProcessObject_SetGlobalDefaultDebug(debugFlag):
    r"""ProcessObject_SetGlobalDefaultDebug(bool debugFlag)"""
    return _SimpleITK.ProcessObject_SetGlobalDefaultDebug(debugFlag)


def ProcessObject_GlobalWarningDisplayOn():
    r"""ProcessObject_GlobalWarningDisplayOn()"""
    return _SimpleITK.ProcessObject_GlobalWarningDisplayOn()


def ProcessObject_GlobalWarningDisplayOff():
    r"""ProcessObject_GlobalWarningDisplayOff()"""
    return _SimpleITK.ProcessObject_GlobalWarningDisplayOff()


def ProcessObject_SetGlobalWarningDisplay(flag):
    r"""ProcessObject_SetGlobalWarningDisplay(bool flag)"""
    return _SimpleITK.ProcessObject_SetGlobalWarningDisplay(flag)


def ProcessObject_GetGlobalWarningDisplay():
    r"""ProcessObject_GetGlobalWarningDisplay() -> bool"""
    return _SimpleITK.ProcessObject_GetGlobalWarningDisplay()


def ProcessObject_GetGlobalDefaultCoordinateTolerance():
    r"""ProcessObject_GetGlobalDefaultCoordinateTolerance() -> double"""
    return _SimpleITK.ProcessObject_GetGlobalDefaultCoordinateTolerance()


def ProcessObject_SetGlobalDefaultCoordinateTolerance(arg1):
    r"""ProcessObject_SetGlobalDefaultCoordinateTolerance(double arg1)"""
    return _SimpleITK.ProcessObject_SetGlobalDefaultCoordinateTolerance(arg1)


def ProcessObject_GetGlobalDefaultDirectionTolerance():
    r"""ProcessObject_GetGlobalDefaultDirectionTolerance() -> double"""
    return _SimpleITK.ProcessObject_GetGlobalDefaultDirectionTolerance()


def ProcessObject_SetGlobalDefaultDirectionTolerance(arg1):
    r"""ProcessObject_SetGlobalDefaultDirectionTolerance(double arg1)"""
    return _SimpleITK.ProcessObject_SetGlobalDefaultDirectionTolerance(arg1)


def ProcessObject_SetGlobalDefaultThreader(threader):
    r"""ProcessObject_SetGlobalDefaultThreader(std::string const & threader) -> bool"""
    return _SimpleITK.ProcessObject_SetGlobalDefaultThreader(threader)


def ProcessObject_GetGlobalDefaultThreader():
    r"""ProcessObject_GetGlobalDefaultThreader() -> std::string"""
    return _SimpleITK.ProcessObject_GetGlobalDefaultThreader()


def ProcessObject_SetGlobalDefaultNumberOfThreads(n):
    r"""ProcessObject_SetGlobalDefaultNumberOfThreads(unsigned int n)"""
    return _SimpleITK.ProcessObject_SetGlobalDefaultNumberOfThreads(n)


def ProcessObject_GetGlobalDefaultNumberOfThreads():
    r"""ProcessObject_GetGlobalDefaultNumberOfThreads() -> unsigned int"""
    return _SimpleITK.ProcessObject_GetGlobalDefaultNumberOfThreads()


class ImageFilter(ProcessObject):
    r"""


    The base interface for SimpleITK filters that take one input image.


    All SimpleITK filters which take one input image should inherit from
    this class

    C++ includes: sitkImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ImageFilter


# Register ImageFilter in _SimpleITK:
_SimpleITK.ImageFilter_swigregister(ImageFilter)


def Show(*args, **kwargs):
    r"""
    Show(Image image, std::string const & title="", bool const debugOn=itk::simple::ProcessObject::GetGlobalDefaultDebug())


    Display an image in an external viewer (Fiji by default)

    This function directly calls the execute method of ImageViewer in order to support a procedural API


    """
    return _SimpleITK.Show(*args, **kwargs)


class ImageFileWriter(ProcessObject):
    r"""


    Write out a SimpleITK image to the specified file location.


    This writer tries to write the image out using the image's type to the
    location specified in FileName. If writing fails, an ITK exception is
    thrown.


    See:
     itk::simple::WriteImage for the procedural interface


    C++ includes: sitkImageFileWriter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ImageFileWriter

    def __init__(self):
        r"""
        __init__(ImageFileWriter self) -> ImageFileWriter


        """
        _SimpleITK.ImageFileWriter_swiginit(
            self, _SimpleITK.new_ImageFileWriter()
        )

    def __str__(self):
        r"""
        __str__(ImageFileWriter self) -> std::string


        Print ourselves to string


        """
        return _SimpleITK.ImageFileWriter___str__(self)

    def GetName(self):
        r"""
        GetName(ImageFileWriter self) -> std::string


        return user readable name of the filter


        """
        return _SimpleITK.ImageFileWriter_GetName(self)

    def GetRegisteredImageIOs(self):
        r"""
        GetRegisteredImageIOs(ImageFileWriter self) -> VectorString


        Get a vector of the names of registered itk ImageIOs.


        """
        return _SimpleITK.ImageFileWriter_GetRegisteredImageIOs(self)

    def SetUseCompression(self, UseCompression):
        r"""SetUseCompression(ImageFileWriter self, bool UseCompression)"""
        return _SimpleITK.ImageFileWriter_SetUseCompression(
            self, UseCompression
        )

    def GetUseCompression(self):
        r"""GetUseCompression(ImageFileWriter self) -> bool"""
        return _SimpleITK.ImageFileWriter_GetUseCompression(self)

    def UseCompressionOn(self):
        r"""UseCompressionOn(ImageFileWriter self)"""
        return _SimpleITK.ImageFileWriter_UseCompressionOn(self)

    def UseCompressionOff(self):
        r"""UseCompressionOff(ImageFileWriter self)"""
        return _SimpleITK.ImageFileWriter_UseCompressionOff(self)

    def SetCompressionLevel(self, arg2):
        r"""SetCompressionLevel(ImageFileWriter self, int arg2)"""
        return _SimpleITK.ImageFileWriter_SetCompressionLevel(self, arg2)

    def GetCompressionLevel(self):
        r"""GetCompressionLevel(ImageFileWriter self) -> int"""
        return _SimpleITK.ImageFileWriter_GetCompressionLevel(self)

    def SetCompressor(self, arg2):
        r"""SetCompressor(ImageFileWriter self, std::string const & arg2)"""
        return _SimpleITK.ImageFileWriter_SetCompressor(self, arg2)

    def GetCompressor(self):
        r"""GetCompressor(ImageFileWriter self) -> std::string"""
        return _SimpleITK.ImageFileWriter_GetCompressor(self)

    def SetImageIO(self, imageio):
        r"""SetImageIO(ImageFileWriter self, std::string const & imageio)"""
        return _SimpleITK.ImageFileWriter_SetImageIO(self, imageio)

    def GetImageIO(self):
        r"""GetImageIO(ImageFileWriter self) -> std::string"""
        return _SimpleITK.ImageFileWriter_GetImageIO(self)

    def SetKeepOriginalImageUID(self, KeepOriginalImageUID):
        r"""SetKeepOriginalImageUID(ImageFileWriter self, bool KeepOriginalImageUID)"""
        return _SimpleITK.ImageFileWriter_SetKeepOriginalImageUID(
            self, KeepOriginalImageUID
        )

    def GetKeepOriginalImageUID(self):
        r"""GetKeepOriginalImageUID(ImageFileWriter self) -> bool"""
        return _SimpleITK.ImageFileWriter_GetKeepOriginalImageUID(self)

    def KeepOriginalImageUIDOn(self):
        r"""KeepOriginalImageUIDOn(ImageFileWriter self)"""
        return _SimpleITK.ImageFileWriter_KeepOriginalImageUIDOn(self)

    def KeepOriginalImageUIDOff(self):
        r"""KeepOriginalImageUIDOff(ImageFileWriter self)"""
        return _SimpleITK.ImageFileWriter_KeepOriginalImageUIDOff(self)

    def SetFileName(self, fileName):
        r"""
        SetFileName(ImageFileWriter self, itk::simple::PathType const & fileName)


        """
        return _SimpleITK.ImageFileWriter_SetFileName(self, fileName)

    def GetFileName(self):
        r"""
        GetFileName(ImageFileWriter self) -> itk::simple::PathType


        """
        return _SimpleITK.ImageFileWriter_GetFileName(self)

    def Execute(self, *args):
        r"""
        Execute(ImageFileWriter self, Image arg2)
        Execute(ImageFileWriter self, Image arg2, itk::simple::PathType const & inFileName, bool useCompression, int compressionLevel)


        """
        return _SimpleITK.ImageFileWriter_Execute(self, *args)


# Register ImageFileWriter in _SimpleITK:
_SimpleITK.ImageFileWriter_swigregister(ImageFileWriter)


class ImageSeriesWriter(ProcessObject):
    r"""


    Writer series of image from a SimpleITK image.


    The ImageSeriesWriter is for writing a 3D image as a series of 2D images. A list of names
    for the series of 2D images must be provided, and an exception will be
    generated if the number of file names does not match the size of the
    image in the z-direction.

    DICOM series cannot be written with this class, as an exception will
    be generated. To write a DICOM series the individual slices must be
    extracted, proper DICOM tags must be added to the dictionaries, then
    written with the ImageFileWriter.


    See:
     itk::simple::WriteImage for the procedural interface


    C++ includes: sitkImageSeriesWriter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ImageSeriesWriter

    def __init__(self):
        r"""
        __init__(ImageSeriesWriter self) -> ImageSeriesWriter


        """
        _SimpleITK.ImageSeriesWriter_swiginit(
            self, _SimpleITK.new_ImageSeriesWriter()
        )

    def __str__(self):
        r"""
        __str__(ImageSeriesWriter self) -> std::string


        Print ourselves to string


        """
        return _SimpleITK.ImageSeriesWriter___str__(self)

    def GetRegisteredImageIOs(self):
        r"""
        GetRegisteredImageIOs(ImageSeriesWriter self) -> VectorString


        Get a vector of the names of registered itk ImageIOs.


        """
        return _SimpleITK.ImageSeriesWriter_GetRegisteredImageIOs(self)

    def SetImageIO(self, imageio):
        r"""SetImageIO(ImageSeriesWriter self, std::string const & imageio)"""
        return _SimpleITK.ImageSeriesWriter_SetImageIO(self, imageio)

    def GetImageIO(self):
        r"""GetImageIO(ImageSeriesWriter self) -> std::string"""
        return _SimpleITK.ImageSeriesWriter_GetImageIO(self)

    def GetName(self):
        r"""
        GetName(ImageSeriesWriter self) -> std::string


        return user readable name for the filter


        """
        return _SimpleITK.ImageSeriesWriter_GetName(self)

    def SetUseCompression(self, UseCompression):
        r"""SetUseCompression(ImageSeriesWriter self, bool UseCompression)"""
        return _SimpleITK.ImageSeriesWriter_SetUseCompression(
            self, UseCompression
        )

    def GetUseCompression(self):
        r"""GetUseCompression(ImageSeriesWriter self) -> bool"""
        return _SimpleITK.ImageSeriesWriter_GetUseCompression(self)

    def UseCompressionOn(self):
        r"""UseCompressionOn(ImageSeriesWriter self)"""
        return _SimpleITK.ImageSeriesWriter_UseCompressionOn(self)

    def UseCompressionOff(self):
        r"""UseCompressionOff(ImageSeriesWriter self)"""
        return _SimpleITK.ImageSeriesWriter_UseCompressionOff(self)

    def SetCompressionLevel(self, arg2):
        r"""SetCompressionLevel(ImageSeriesWriter self, int arg2)"""
        return _SimpleITK.ImageSeriesWriter_SetCompressionLevel(self, arg2)

    def GetCompressionLevel(self):
        r"""GetCompressionLevel(ImageSeriesWriter self) -> int"""
        return _SimpleITK.ImageSeriesWriter_GetCompressionLevel(self)

    def SetCompressor(self, arg2):
        r"""SetCompressor(ImageSeriesWriter self, std::string const & arg2)"""
        return _SimpleITK.ImageSeriesWriter_SetCompressor(self, arg2)

    def GetCompressor(self):
        r"""GetCompressor(ImageSeriesWriter self) -> std::string"""
        return _SimpleITK.ImageSeriesWriter_GetCompressor(self)

    def SetFileNames(self, fileNames):
        r"""SetFileNames(ImageSeriesWriter self, VectorString fileNames)"""
        return _SimpleITK.ImageSeriesWriter_SetFileNames(self, fileNames)

    def GetFileNames(self):
        r"""GetFileNames(ImageSeriesWriter self) -> VectorString"""
        return _SimpleITK.ImageSeriesWriter_GetFileNames(self)

    def Execute(self, *args):
        r"""
        Execute(ImageSeriesWriter self, Image arg2)
        Execute(ImageSeriesWriter self, Image image, VectorString inFileNames, bool useCompression, int compressionLevel)


        """
        return _SimpleITK.ImageSeriesWriter_Execute(self, *args)


# Register ImageSeriesWriter in _SimpleITK:
_SimpleITK.ImageSeriesWriter_swigregister(ImageSeriesWriter)


class ImageReaderBase(ProcessObject):
    r"""


    An abstract base class for image readers.

    C++ includes: sitkImageReaderBase.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ImageReaderBase

    def SetOutputPixelType(self, pixelID):
        r"""SetOutputPixelType(ImageReaderBase self, itk::simple::PixelIDValueEnum pixelID)"""
        return _SimpleITK.ImageReaderBase_SetOutputPixelType(self, pixelID)

    def GetOutputPixelType(self):
        r"""GetOutputPixelType(ImageReaderBase self) -> itk::simple::PixelIDValueEnum"""
        return _SimpleITK.ImageReaderBase_GetOutputPixelType(self)

    def Execute(self):
        r"""Execute(ImageReaderBase self) -> Image"""
        return _SimpleITK.ImageReaderBase_Execute(self)

    def __str__(self):
        r"""
        __str__(ImageReaderBase self) -> std::string


        """
        return _SimpleITK.ImageReaderBase___str__(self)

    def GetRegisteredImageIOs(self):
        r"""GetRegisteredImageIOs(ImageReaderBase self) -> VectorString"""
        return _SimpleITK.ImageReaderBase_GetRegisteredImageIOs(self)

    def SetLoadPrivateTags(self, loadPrivateTags):
        r"""SetLoadPrivateTags(ImageReaderBase self, bool loadPrivateTags)"""
        return _SimpleITK.ImageReaderBase_SetLoadPrivateTags(
            self, loadPrivateTags
        )

    def GetLoadPrivateTags(self):
        r"""GetLoadPrivateTags(ImageReaderBase self) -> bool"""
        return _SimpleITK.ImageReaderBase_GetLoadPrivateTags(self)

    def LoadPrivateTagsOn(self):
        r"""LoadPrivateTagsOn(ImageReaderBase self)"""
        return _SimpleITK.ImageReaderBase_LoadPrivateTagsOn(self)

    def LoadPrivateTagsOff(self):
        r"""LoadPrivateTagsOff(ImageReaderBase self)"""
        return _SimpleITK.ImageReaderBase_LoadPrivateTagsOff(self)

    def SetImageIO(self, imageio):
        r"""SetImageIO(ImageReaderBase self, std::string const & imageio)"""
        return _SimpleITK.ImageReaderBase_SetImageIO(self, imageio)

    def GetImageIO(self):
        r"""GetImageIO(ImageReaderBase self) -> std::string"""
        return _SimpleITK.ImageReaderBase_GetImageIO(self)

    @staticmethod
    def GetImageIOFromFileName(fileName):
        r"""GetImageIOFromFileName(itk::simple::PathType const & fileName) -> std::string"""
        return _SimpleITK.ImageReaderBase_GetImageIOFromFileName(fileName)


# Register ImageReaderBase in _SimpleITK:
_SimpleITK.ImageReaderBase_swigregister(ImageReaderBase)


def ImageReaderBase_GetImageIOFromFileName(fileName):
    r"""ImageReaderBase_GetImageIOFromFileName(itk::simple::PathType const & fileName) -> std::string"""
    return _SimpleITK.ImageReaderBase_GetImageIOFromFileName(fileName)


class ImageSeriesReader(ImageReaderBase):
    r"""


    Read series of image files into a SimpleITK image.


    For some image formats such as DICOM, images also contain associated
    meta-data (e.g. imaging modality, patient name etc.). By default the
    reader does not load this information (saves time). To load the meta-
    data you will need to explicitly configure the reader,
    MetaDataDictionaryArrayUpdateOn, and possibly specify that you also
    want to load the private meta-data LoadPrivateTagsOn.

    Once the image series is read the meta-data is directly accessible
    from the reader.


    DICOM tags are represented as strings in the meta-data dictionary(s),
    therefore "0020|000D" and "0020|000d" are different when accessing
    the tag value. This differs from the hexadecimal numbers they
    represent, 0020|000D and 0020|000d are equivalent. The ITK meta-data
    dictionary is string based and uses lower case to represent the
    hexadecimal number read from disk, so 0020|000d will work as a key and
    0020|000D will not be found in the dictionary (results in an exception
    if attempting to access). It is recommended to use lower case when
    setting and accessing DICOM tags.

    If the pixel type for the returned image is not specified it is
    deduced from the first image in the series. This approach is
    computationally efficient and assumes that all images in a series have
    the same pixel type. In rare situations this is not the case, not all
    images have the same pixel type. If this leads to a narrowing
    conversion (e.g. first image pixel type is unsigned int and others are
    float) the returned image does not represent the data correctly. To
    resolve such situations, explicitly specify the expected pixel type
    via the SetOutputPixelType method before reading the series.

    See:
     itk::simple::ReadImage for the procedural interface


    C++ includes: sitkImageSeriesReader.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ImageSeriesReader

    def __init__(self):
        r"""
        __init__(ImageSeriesReader self) -> ImageSeriesReader


        """
        _SimpleITK.ImageSeriesReader_swiginit(
            self, _SimpleITK.new_ImageSeriesReader()
        )

    def __str__(self):
        r"""
        __str__(ImageSeriesReader self) -> std::string


        Print ourselves to string


        """
        return _SimpleITK.ImageSeriesReader___str__(self)

    def GetName(self):
        r"""
        GetName(ImageSeriesReader self) -> std::string


        return user readable name of the filter


        """
        return _SimpleITK.ImageSeriesReader_GetName(self)

    def SetMetaDataDictionaryArrayUpdate(self, metaDataDictionaryArrayUpdate):
        r"""
        SetMetaDataDictionaryArrayUpdate(ImageSeriesReader self, bool metaDataDictionaryArrayUpdate)


        Set/Get whether the meta-data dictionaries for the slices should be
        read. Default value is false, because of the additional computation
        time.


        """
        return _SimpleITK.ImageSeriesReader_SetMetaDataDictionaryArrayUpdate(
            self, metaDataDictionaryArrayUpdate
        )

    def GetMetaDataDictionaryArrayUpdate(self):
        r"""
        GetMetaDataDictionaryArrayUpdate(ImageSeriesReader self) -> bool


        """
        return _SimpleITK.ImageSeriesReader_GetMetaDataDictionaryArrayUpdate(
            self
        )

    def MetaDataDictionaryArrayUpdateOn(self):
        r"""
        MetaDataDictionaryArrayUpdateOn(ImageSeriesReader self)


        Set the value of MetaDataDictionaryArrayUpdate to true or false
        respectively.


        """
        return _SimpleITK.ImageSeriesReader_MetaDataDictionaryArrayUpdateOn(
            self
        )

    def MetaDataDictionaryArrayUpdateOff(self):
        r"""
        MetaDataDictionaryArrayUpdateOff(ImageSeriesReader self)


        """
        return _SimpleITK.ImageSeriesReader_MetaDataDictionaryArrayUpdateOff(
            self
        )

    @staticmethod
    def GetGDCMSeriesFileNames(*args, **kwargs):
        r"""GetGDCMSeriesFileNames(itk::simple::PathType const & directory, std::string const & seriesID="", bool useSeriesDetails=False, bool recursive=False, bool loadSequences=False) -> VectorString"""
        return _SimpleITK.ImageSeriesReader_GetGDCMSeriesFileNames(
            *args, **kwargs
        )

    @staticmethod
    def GetGDCMSeriesIDs(directory, useSeriesDetails=False):
        r"""GetGDCMSeriesIDs(itk::simple::PathType const & directory, bool useSeriesDetails=False) -> VectorString"""
        return _SimpleITK.ImageSeriesReader_GetGDCMSeriesIDs(
            directory, useSeriesDetails
        )

    def SetFileNames(self, fileNames):
        r"""
        SetFileNames(ImageSeriesReader self, VectorString fileNames)


        """
        return _SimpleITK.ImageSeriesReader_SetFileNames(self, fileNames)

    def GetFileNames(self):
        r"""
        GetFileNames(ImageSeriesReader self) -> VectorString


        """
        return _SimpleITK.ImageSeriesReader_GetFileNames(self)

    def SetSpacingWarningRelThreshold(self, spacingWarningRelThreshold):
        r"""
        SetSpacingWarningRelThreshold(ImageSeriesReader self, double spacingWarningRelThreshold)


        Set the relative threshold for issuing warnings about non-uniform
        sampling.


        """
        return _SimpleITK.ImageSeriesReader_SetSpacingWarningRelThreshold(
            self, spacingWarningRelThreshold
        )

    def GetSpacingWarningRelThreshold(self):
        r"""
        GetSpacingWarningRelThreshold(ImageSeriesReader self) -> double


        """
        return _SimpleITK.ImageSeriesReader_GetSpacingWarningRelThreshold(self)

    def Execute(self):
        r"""
        Execute(ImageSeriesReader self) -> Image


        Set/Get The output PixelType of the image.


        By default the value is sitkUnknown, which enable the output pixel
        type to be same as the file. If the pixel type is specified then the itk::ConvertPixelBuffer will be used to convert the pixels.


        """
        return _SimpleITK.ImageSeriesReader_Execute(self)

    def GetMetaDataKeys(self, slice):
        r"""
        GetMetaDataKeys(ImageSeriesReader self, unsigned int slice) -> VectorString


        Get the meta-data dictionary keys for a slice.


        This is only valid after successful execution of this filter and when
        MetaDataDictionaryArrayUpdate is true. Each element in the array
        corresponds to a "slice" or filename read during execution.

        If the slice index is out of range, an exception will be thrown.

        Returns a vector of keys to the key/value entries in the file's meta-
        data dictionary. Iterate through with these keys to get the values.


        """
        return _SimpleITK.ImageSeriesReader_GetMetaDataKeys(self, slice)

    def HasMetaDataKey(self, slice, key):
        r"""
        HasMetaDataKey(ImageSeriesReader self, unsigned int slice, std::string const & key) -> bool


        Query a meta-data dictionary for the existence of a key.


        """
        return _SimpleITK.ImageSeriesReader_HasMetaDataKey(self, slice, key)

    def GetMetaData(self, slice, key):
        r"""
        GetMetaData(ImageSeriesReader self, unsigned int slice, std::string const & key) -> std::string


        Get the value of a meta-data dictionary entry as a string.


        If the key is not in the dictionary then an exception is thrown.

        string types in the dictionary are returned as their native string.
        Other types are printed to string before returning.


        """
        return _SimpleITK.ImageSeriesReader_GetMetaData(self, slice, key)


# Register ImageSeriesReader in _SimpleITK:
_SimpleITK.ImageSeriesReader_swigregister(ImageSeriesReader)


def ImageSeriesReader_GetGDCMSeriesFileNames(*args, **kwargs):
    r"""ImageSeriesReader_GetGDCMSeriesFileNames(itk::simple::PathType const & directory, std::string const & seriesID="", bool useSeriesDetails=False, bool recursive=False, bool loadSequences=False) -> VectorString"""
    return _SimpleITK.ImageSeriesReader_GetGDCMSeriesFileNames(*args, **kwargs)


def ImageSeriesReader_GetGDCMSeriesIDs(directory, useSeriesDetails=False):
    r"""ImageSeriesReader_GetGDCMSeriesIDs(itk::simple::PathType const & directory, bool useSeriesDetails=False) -> VectorString"""
    return _SimpleITK.ImageSeriesReader_GetGDCMSeriesIDs(
        directory, useSeriesDetails
    )


class ImageFileReader(ImageReaderBase):
    r"""


    Read an image file and return a SimpleITK Image.


    The reader can handle scalar images, and vector images. Pixel types
    such as RGB, RGBA are loaded as multi-component images with vector
    pixel types. Additionally, tensor images are loaded with the pixel
    type being a 1-d vector.

    An interface is also provided to access the information from the
    underlying itk::ImageIO. This information can be loaded with the
    ReadImageInformation method. The information is from the itk::ImageIO
    interface. In some degenerate cases reading the bulk data may produce
    different results. Please see itk::ImageFileReader for more details.

    Reading takes place by the ITK ImageIO factory mechanism. ITK contains
    many ImageIO classes which are responsible for reading separate file
    formats. By default, each ImageIO is asked if it "can read" the
    file, and the first one which "can read" the format is used. The
    list of available ImageIOs can be obtained using the
    GetRegisteredImageIOs method. The ImageIO used can be overridden with
    the SetImageIO method. This is useful in cases when multiple ImageIOs
    "can read" the file and the user wants to select a specific IO (not
    the first).


    DICOM tags are represented as strings in the meta-data dictionary(s),
    therefore "0020|000D" and "0020|000d" are different when accessing
    the tag value. This differs from the hexadecimal numbers they
    represent, 0020|000D and 0020|000d are equivalent. The ITK meta-data
    dictionary is string based and uses lower case to represent the
    hexadecimal number read from disk, so 0020|000d will work as a key and
    0020|000D will not be found in the dictionary (results in an exception
    if attempting to access). It is recommended to use lower case when
    setting and accessing DICOM tags.

    See:
     itk::simple::ReadImage for the procedural interface


    C++ includes: sitkImageFileReader.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ImageFileReader

    def __init__(self):
        r"""
        __init__(ImageFileReader self) -> ImageFileReader


        """
        _SimpleITK.ImageFileReader_swiginit(
            self, _SimpleITK.new_ImageFileReader()
        )

    def __str__(self):
        r"""
        __str__(ImageFileReader self) -> std::string


        Print ourselves to string


        """
        return _SimpleITK.ImageFileReader___str__(self)

    def GetName(self):
        r"""
        GetName(ImageFileReader self) -> std::string


        return user readable name of the filter


        """
        return _SimpleITK.ImageFileReader_GetName(self)

    def SetFileName(self, fn):
        r"""
        SetFileName(ImageFileReader self, itk::simple::PathType const & fn)


        """
        return _SimpleITK.ImageFileReader_SetFileName(self, fn)

    def GetFileName(self):
        r"""
        GetFileName(ImageFileReader self) -> itk::simple::PathType


        """
        return _SimpleITK.ImageFileReader_GetFileName(self)

    def Execute(self):
        r"""
        Execute(ImageFileReader self) -> Image


        Set/Get The output PixelType of the image.


        By default the value is sitkUnknown, which enable the output pixel
        type to be same as the file. If the pixel type is specified then the itk::ConvertPixelBuffer will be used to convert the pixels.


        """
        return _SimpleITK.ImageFileReader_Execute(self)

    def ReadImageInformation(self):
        r"""
        ReadImageInformation(ImageFileReader self)


        Read only the meta-data and image information in the file.


        This method can be used to determine what the size and pixel type of
        an image file is without reading the whole image. Even if SimpleITK
        does not support an image of a certain dimension or type, the meta-
        information can still be read.


        """
        return _SimpleITK.ImageFileReader_ReadImageInformation(self)

    def GetPixelID(self):
        r"""GetPixelID(ImageFileReader self) -> itk::simple::PixelIDValueEnum"""
        return _SimpleITK.ImageFileReader_GetPixelID(self)

    def GetPixelIDValue(self):
        r"""GetPixelIDValue(ImageFileReader self) -> itk::simple::PixelIDValueType"""
        return _SimpleITK.ImageFileReader_GetPixelIDValue(self)

    def GetDimension(self):
        r"""GetDimension(ImageFileReader self) -> unsigned int"""
        return _SimpleITK.ImageFileReader_GetDimension(self)

    def GetNumberOfComponents(self):
        r"""GetNumberOfComponents(ImageFileReader self) -> unsigned int"""
        return _SimpleITK.ImageFileReader_GetNumberOfComponents(self)

    def GetOrigin(self):
        r"""GetOrigin(ImageFileReader self) -> VectorDouble"""
        return _SimpleITK.ImageFileReader_GetOrigin(self)

    def GetSpacing(self):
        r"""GetSpacing(ImageFileReader self) -> VectorDouble"""
        return _SimpleITK.ImageFileReader_GetSpacing(self)

    def GetDirection(self):
        r"""GetDirection(ImageFileReader self) -> VectorDouble"""
        return _SimpleITK.ImageFileReader_GetDirection(self)

    def GetSize(self):
        r"""GetSize(ImageFileReader self) -> VectorUInt64"""
        return _SimpleITK.ImageFileReader_GetSize(self)

    def GetMetaDataKeys(self):
        r"""
        GetMetaDataKeys(ImageFileReader self) -> VectorString


        Get the meta-data dictionary keys.


        This is only valid after successful ReadImageInformation or Execute of
        this filter.

        Returns a vector of keys to the key/value entries in the file's meta-
        data dictionary. Iterate through with these keys to get the values.


        """
        return _SimpleITK.ImageFileReader_GetMetaDataKeys(self)

    def HasMetaDataKey(self, key):
        r"""
        HasMetaDataKey(ImageFileReader self, std::string const & key) -> bool


        Query a meta-data dictionary for the existence of a key.


        """
        return _SimpleITK.ImageFileReader_HasMetaDataKey(self, key)

    def GetMetaData(self, key):
        r"""
        GetMetaData(ImageFileReader self, std::string const & key) -> std::string


        Get the value of a meta-data dictionary entry as a string.


        If the key is not in the dictionary then an exception is thrown.

        String types in the dictionary are returned as their native string.
        Other types are printed to string before returning.


        """
        return _SimpleITK.ImageFileReader_GetMetaData(self, key)

    def SetExtractSize(self, size):
        r"""
        SetExtractSize(ImageFileReader self, VectorUInt32 size)


        size of image to extract from file.


        By default the reader loads the entire image, this is specified when
        the size has zero length.

        If specified, then the image returned from Execute will be of this size. If the ImageIO and file support reading just a
        region, then the reader will perform streaming.

        The dimension of the image can be reduced by specifying a dimension's
        size as 0. For example a size of $[10,20,30,0,0]$ results in a 3D
        image with size of $[10,20,30]$. This enables reading a 5D image into
        a 3D image. If the length of the specified size is greater than the
        dimension of the image file, an exception will be generated. If the
        size's length is less than the image's dimension then the missing
        values are assumed to be zero.

        When the dimension of the image is reduced, the direction cosine
        matrix will be set to the identity. However, the spacing for the
        selected axis will remain. The matrix from the file can still be
        obtained by ImageFileReader::GetDirection.


        See:
         ExtractImageFilter



        """
        return _SimpleITK.ImageFileReader_SetExtractSize(self, size)

    def GetExtractSize(self):
        r"""
        GetExtractSize(ImageFileReader self) -> VectorUInt32


        """
        return _SimpleITK.ImageFileReader_GetExtractSize(self)

    def SetExtractIndex(self, index):
        r"""
        SetExtractIndex(ImageFileReader self, VectorInt32 index)


        starting index from the image on disk to extract.


        Missing dimensions are treated the same as 0.


        See:
         ExtractImageFilter



        """
        return _SimpleITK.ImageFileReader_SetExtractIndex(self, index)

    def GetExtractIndex(self):
        r"""
        GetExtractIndex(ImageFileReader self) -> VectorInt32


        """
        return _SimpleITK.ImageFileReader_GetExtractIndex(self)


# Register ImageFileReader in _SimpleITK:
_SimpleITK.ImageFileReader_swigregister(ImageFileReader)


class ImageViewer(object):
    r"""


    Display an image in an external viewer (Fiji by default)


    The ImageViewer class displays an image with an external image display application.
    By default the class will search for a Fiji executable. The image is written out to a temporary file and then
    passed to the application.

    When the first ImageViewer object is constructed the following environment variables are queried
    to set up the external viewer:

    SITK_SHOW_EXTENSION: file format extension of the temporary image
    file. The default is '.mha', the MetaIO file format.

    SITK_SHOW_COMMAND: The user can specify an application other than Fiji
    to view images.

    The environment variables are not checked for subsequent ImageViewer objects.

    C++ includes: sitkImageViewer.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(ImageViewer self) -> ImageViewer


        """
        _SimpleITK.ImageViewer_swiginit(self, _SimpleITK.new_ImageViewer())

    def GetName(self):
        r"""
        GetName(ImageViewer self) -> std::string


        Return the user readable name of the class


        """
        return _SimpleITK.ImageViewer_GetName(self)

    @staticmethod
    def SetGlobalDefaultSearchPath(path):
        r"""SetGlobalDefaultSearchPath(VectorString path)"""
        return _SimpleITK.ImageViewer_SetGlobalDefaultSearchPath(path)

    @staticmethod
    def GetGlobalDefaultSearchPath():
        r"""GetGlobalDefaultSearchPath() -> VectorString"""
        return _SimpleITK.ImageViewer_GetGlobalDefaultSearchPath()

    @staticmethod
    def SetGlobalDefaultExecutableNames(names):
        r"""SetGlobalDefaultExecutableNames(VectorString names)"""
        return _SimpleITK.ImageViewer_SetGlobalDefaultExecutableNames(names)

    @staticmethod
    def GetGlobalDefaultExecutableNames():
        r"""GetGlobalDefaultExecutableNames() -> VectorString"""
        return _SimpleITK.ImageViewer_GetGlobalDefaultExecutableNames()

    @staticmethod
    def SetGlobalDefaultFileExtension(ext):
        r"""SetGlobalDefaultFileExtension(std::string const & ext)"""
        return _SimpleITK.ImageViewer_SetGlobalDefaultFileExtension(ext)

    @staticmethod
    def GetGlobalDefaultFileExtension():
        r"""GetGlobalDefaultFileExtension() -> std::string const &"""
        return _SimpleITK.ImageViewer_GetGlobalDefaultFileExtension()

    @staticmethod
    def SetGlobalDefaultApplication(app):
        r"""SetGlobalDefaultApplication(itk::simple::PathType const & app)"""
        return _SimpleITK.ImageViewer_SetGlobalDefaultApplication(app)

    @staticmethod
    def GetGlobalDefaultApplication():
        r"""GetGlobalDefaultApplication() -> itk::simple::PathType const &"""
        return _SimpleITK.ImageViewer_GetGlobalDefaultApplication()

    def SetApplication(self, *args, **kwargs):
        r"""
        SetApplication(ImageViewer self, itk::simple::PathType const & app, std::string const & command="%a %f")


        Set the full path to the viewing application used in the command
        string.


        The SetApplication method expects the app parameter to be a full path name to the display application's
        executable. For instance, on Windows when using Fiji, one would use
        the full path to the ImageJ-win64.exe such as:'C:\\Users\\dave\\Fiji.app\\ImageJ-win64.exe'

        On Linux, app would be set to something like:'/home/dave/bin/Fiji.app/ImageJ-linux64'

        Using this method overrides the default application search.

        By default, when this method is called, the command string is set to "%a %f" which simply means the application path followed by the temporary image file.


        """
        return _SimpleITK.ImageViewer_SetApplication(self, *args, **kwargs)

    def GetApplication(self):
        r"""
        GetApplication(ImageViewer self) -> itk::simple::PathType const &


        Get the full path to the viewing application used in the command
        string.


        """
        return _SimpleITK.ImageViewer_GetApplication(self)

    def SetCommand(self, command):
        r"""
        SetCommand(ImageViewer self, std::string const & command)


        Set the command string used to launch the viewing application.


        This command string may include the following tokens:


        'a' for the image viewing application (Fiji by default)

        'f' for SimpleITK's temporary image file
         For example, the default command string on Linux systems is:


        After token substitution it may become:


        For another example, the default command string on Mac OS X is:


        After token substitution the string may become:


        The string after '-eval' is an ImageJ macro the opens the file and sets the title of the
        window.

        If the 'f' token is not found in the command string, the temporary file name is
        automatically appended to the command argument list.

        Note: Using the ImageViewer::SetCommand method overrides the default command and/or the SITK_SHOW_COMMAND
        environment variable.


        """
        return _SimpleITK.ImageViewer_SetCommand(self, command)

    def GetCommand(self):
        r"""
        GetCommand(ImageViewer self) -> std::string const &


        """
        return _SimpleITK.ImageViewer_GetCommand(self)

    def SetFileExtension(self, ext):
        r"""SetFileExtension(ImageViewer self, std::string const & ext)"""
        return _SimpleITK.ImageViewer_SetFileExtension(self, ext)

    def GetFileExtension(self):
        r"""GetFileExtension(ImageViewer self) -> std::string const &"""
        return _SimpleITK.ImageViewer_GetFileExtension(self)

    @staticmethod
    def SetGlobalDefaultDebug(dbg):
        r"""SetGlobalDefaultDebug(bool const dbg)"""
        return _SimpleITK.ImageViewer_SetGlobalDefaultDebug(dbg)

    @staticmethod
    def GetGlobalDefaultDebug():
        r"""GetGlobalDefaultDebug() -> bool"""
        return _SimpleITK.ImageViewer_GetGlobalDefaultDebug()

    @staticmethod
    def SetGlobalDefaultDebugOn():
        r"""SetGlobalDefaultDebugOn()"""
        return _SimpleITK.ImageViewer_SetGlobalDefaultDebugOn()

    @staticmethod
    def SetGlobalDefaultDebugOff():
        r"""SetGlobalDefaultDebugOff()"""
        return _SimpleITK.ImageViewer_SetGlobalDefaultDebugOff()

    @staticmethod
    def SetProcessDelay(delay):
        r"""SetProcessDelay(unsigned int const delay)"""
        return _SimpleITK.ImageViewer_SetProcessDelay(delay)

    @staticmethod
    def GetProcessDelay():
        r"""GetProcessDelay() -> unsigned int"""
        return _SimpleITK.ImageViewer_GetProcessDelay()

    def SetTitle(self, t):
        r"""SetTitle(ImageViewer self, std::string const & t)"""
        return _SimpleITK.ImageViewer_SetTitle(self, t)

    def GetTitle(self):
        r"""GetTitle(ImageViewer self) -> std::string const &"""
        return _SimpleITK.ImageViewer_GetTitle(self)

    def Execute(self, image):
        r"""
        Execute(ImageViewer self, Image image)


        Launch the viewing application to display the given image.


        """
        return _SimpleITK.ImageViewer_Execute(self, image)

    def __str__(self):
        r"""
        __str__(ImageViewer self) -> std::string


        Print ourself out to a string.


        """
        return _SimpleITK.ImageViewer___str__(self)

    __swig_destroy__ = _SimpleITK.delete_ImageViewer


# Register ImageViewer in _SimpleITK:
_SimpleITK.ImageViewer_swigregister(ImageViewer)


def ImageViewer_SetGlobalDefaultSearchPath(path):
    r"""ImageViewer_SetGlobalDefaultSearchPath(VectorString path)"""
    return _SimpleITK.ImageViewer_SetGlobalDefaultSearchPath(path)


def ImageViewer_GetGlobalDefaultSearchPath():
    r"""ImageViewer_GetGlobalDefaultSearchPath() -> VectorString"""
    return _SimpleITK.ImageViewer_GetGlobalDefaultSearchPath()


def ImageViewer_SetGlobalDefaultExecutableNames(names):
    r"""ImageViewer_SetGlobalDefaultExecutableNames(VectorString names)"""
    return _SimpleITK.ImageViewer_SetGlobalDefaultExecutableNames(names)


def ImageViewer_GetGlobalDefaultExecutableNames():
    r"""ImageViewer_GetGlobalDefaultExecutableNames() -> VectorString"""
    return _SimpleITK.ImageViewer_GetGlobalDefaultExecutableNames()


def ImageViewer_SetGlobalDefaultFileExtension(ext):
    r"""ImageViewer_SetGlobalDefaultFileExtension(std::string const & ext)"""
    return _SimpleITK.ImageViewer_SetGlobalDefaultFileExtension(ext)


def ImageViewer_GetGlobalDefaultFileExtension():
    r"""ImageViewer_GetGlobalDefaultFileExtension() -> std::string const &"""
    return _SimpleITK.ImageViewer_GetGlobalDefaultFileExtension()


def ImageViewer_SetGlobalDefaultApplication(app):
    r"""ImageViewer_SetGlobalDefaultApplication(itk::simple::PathType const & app)"""
    return _SimpleITK.ImageViewer_SetGlobalDefaultApplication(app)


def ImageViewer_GetGlobalDefaultApplication():
    r"""ImageViewer_GetGlobalDefaultApplication() -> itk::simple::PathType const &"""
    return _SimpleITK.ImageViewer_GetGlobalDefaultApplication()


def ImageViewer_SetGlobalDefaultDebug(dbg):
    r"""ImageViewer_SetGlobalDefaultDebug(bool const dbg)"""
    return _SimpleITK.ImageViewer_SetGlobalDefaultDebug(dbg)


def ImageViewer_GetGlobalDefaultDebug():
    r"""ImageViewer_GetGlobalDefaultDebug() -> bool"""
    return _SimpleITK.ImageViewer_GetGlobalDefaultDebug()


def ImageViewer_SetGlobalDefaultDebugOn():
    r"""ImageViewer_SetGlobalDefaultDebugOn()"""
    return _SimpleITK.ImageViewer_SetGlobalDefaultDebugOn()


def ImageViewer_SetGlobalDefaultDebugOff():
    r"""ImageViewer_SetGlobalDefaultDebugOff()"""
    return _SimpleITK.ImageViewer_SetGlobalDefaultDebugOff()


def ImageViewer_SetProcessDelay(delay):
    r"""ImageViewer_SetProcessDelay(unsigned int const delay)"""
    return _SimpleITK.ImageViewer_SetProcessDelay(delay)


def ImageViewer_GetProcessDelay():
    r"""ImageViewer_GetProcessDelay() -> unsigned int"""
    return _SimpleITK.ImageViewer_GetProcessDelay()


class HashImageFilter(ProcessObject):
    r"""


    Compute the sha1 or md5 hash of an image.



    See:
     itk::simple::Hash for the procedural interface


    C++ includes: sitkHashImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_HashImageFilter

    def __init__(self):
        r"""
        __init__(HashImageFilter self) -> HashImageFilter


        """
        _SimpleITK.HashImageFilter_swiginit(
            self, _SimpleITK.new_HashImageFilter()
        )

    SHA1 = _SimpleITK.HashImageFilter_SHA1

    MD5 = _SimpleITK.HashImageFilter_MD5

    def SetHashFunction(self, hashFunction):
        r"""
        SetHashFunction(HashImageFilter self, itk::simple::HashImageFilter::HashFunction hashFunction)


        """
        return _SimpleITK.HashImageFilter_SetHashFunction(self, hashFunction)

    def GetHashFunction(self):
        r"""
        GetHashFunction(HashImageFilter self) -> itk::simple::HashImageFilter::HashFunction


        """
        return _SimpleITK.HashImageFilter_GetHashFunction(self)

    def GetName(self):
        r"""
        GetName(HashImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.HashImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(HashImageFilter self) -> std::string


        """
        return _SimpleITK.HashImageFilter___str__(self)

    def Execute(self, arg2):
        r"""
        Execute(HashImageFilter self, Image arg2) -> std::string


        """
        return _SimpleITK.HashImageFilter_Execute(self, arg2)


# Register HashImageFilter in _SimpleITK:
_SimpleITK.HashImageFilter_swigregister(HashImageFilter)


def Hash(*args, **kwargs):
    r"""
    Hash(Image image, itk::simple::HashImageFilter::HashFunction function=SHA1) -> std::string


    """
    return _SimpleITK.Hash(*args, **kwargs)


class BSplineTransformInitializerFilter(ProcessObject):
    r"""


    BSplineTransformInitializerFilter is a helper class intended to initialize the control point grid such
    that it has a physically consistent definition. It sets the transform
    domain origin, physical dimensions and direction from information
    obtained from the image. It also sets the mesh size if asked to do so
    by calling SetTransformDomainMeshSize() before calling InitializeTransform().



    Luis Ibanez Nick Tustison

    See:
     itk::simple::BSplineTransformInitializer for the procedural interface

     itk::BSplineTransformInitializer for the Doxygen on the original ITK class.


    C++ includes: sitkBSplineTransformInitializerFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def __init__(self):
        r"""
        __init__(BSplineTransformInitializerFilter self) -> BSplineTransformInitializerFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BSplineTransformInitializerFilter_swiginit(
            self, _SimpleITK.new_BSplineTransformInitializerFilter()
        )

    __swig_destroy__ = _SimpleITK.delete_BSplineTransformInitializerFilter

    def SetTransformDomainMeshSize(self, TransformDomainMeshSize):
        r"""
        SetTransformDomainMeshSize(BSplineTransformInitializerFilter self, VectorUInt32 TransformDomainMeshSize)


        Allow the user to set the mesh size of the transform via the
        initializer even though the initializer does not do anything with that
        information. Default = 1^ImageDimension.


        """
        return _SimpleITK.BSplineTransformInitializerFilter_SetTransformDomainMeshSize(
            self, TransformDomainMeshSize
        )

    def GetTransformDomainMeshSize(self):
        r"""
        GetTransformDomainMeshSize(BSplineTransformInitializerFilter self) -> VectorUInt32


        """
        return _SimpleITK.BSplineTransformInitializerFilter_GetTransformDomainMeshSize(
            self
        )

    def SetOrder(self, order):
        r"""
        SetOrder(BSplineTransformInitializerFilter self, unsigned int order)


        The order of the bspline in the output BSplineTransform. This value effects the number of control points.


        """
        return _SimpleITK.BSplineTransformInitializerFilter_SetOrder(
            self, order
        )

    def GetOrder(self):
        r"""
        GetOrder(BSplineTransformInitializerFilter self) -> unsigned int


        """
        return _SimpleITK.BSplineTransformInitializerFilter_GetOrder(self)

    def GetName(self):
        r"""
        GetName(BSplineTransformInitializerFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BSplineTransformInitializerFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BSplineTransformInitializerFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BSplineTransformInitializerFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BSplineTransformInitializerFilter self, Image image1) -> BSplineTransform


        Execute the filter on the input image


        """
        return _SimpleITK.BSplineTransformInitializerFilter_Execute(
            self, image1
        )


# Register BSplineTransformInitializerFilter in _SimpleITK:
_SimpleITK.BSplineTransformInitializerFilter_swigregister(
    BSplineTransformInitializerFilter
)


def BSplineTransformInitializer(*args, **kwargs):
    r"""
    BSplineTransformInitializer(Image image1, VectorUInt32 transformDomainMeshSize=std::vector< uint32_t >(3, 1u), unsigned int order=3) -> BSplineTransform


    BSplineTransformInitializerFilter is a helper class intended to initialize the control point grid such
    that it has a physically consistent definition. It sets the transform
    domain origin, physical dimensions and direction from information
    obtained from the image. It also sets the mesh size if asked to do so
    by calling SetTransformDomainMeshSize() before calling
    InitializeTransform().


    This function directly calls the execute method of BSplineTransformInitializerFilter in order to support a procedural API


    See:
     itk::simple::BSplineTransformInitializerFilter for the object oriented interface



    """
    return _SimpleITK.BSplineTransformInitializer(*args, **kwargs)


class CenteredTransformInitializerFilter(ProcessObject):
    r"""


    CenteredTransformInitializerFilter is a helper class intended to initialize the center of rotation and
    the translation of Transforms having the center of rotation among
    their parameters.


    This class is connected to the fixed image, moving image and transform
    involved in the registration. Two modes of operation are possible:


    Geometrical,

    Center of mass
     In the first mode, the geometrical center of the moving image is
    passed as initial center of rotation to the transform and the vector
    from the center of the fixed image to the center of the moving image
    is passed as the initial translation. This mode basically assumes that
    the anatomical objects to be registered are centered in their
    respective images. Hence the best initial guess for the registration
    is the one that superimposes those two centers.

    In the second mode, the moments of gray level values are computed for
    both images. The center of mass of the moving image is then used as
    center of rotation. The vector between the two centers of mass is
    passes as the initial translation to the transform. This second
    approach assumes that the moments of the anatomical objects are
    similar for both images and hence the best initial guess for
    registration is to superimpose both mass centers. Note that this
    assumption will probably not hold in multi-modality registration.


    See:
     itk::CenteredTransformInitializer


    C++ includes: sitkCenteredTransformInitializerFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_CenteredTransformInitializerFilter

    def __init__(self):
        r"""
        __init__(CenteredTransformInitializerFilter self) -> CenteredTransformInitializerFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.CenteredTransformInitializerFilter_swiginit(
            self, _SimpleITK.new_CenteredTransformInitializerFilter()
        )

    GEOMETRY = _SimpleITK.CenteredTransformInitializerFilter_GEOMETRY

    MOMENTS = _SimpleITK.CenteredTransformInitializerFilter_MOMENTS

    def SetOperationMode(self, OperationMode):
        r"""
        SetOperationMode(CenteredTransformInitializerFilter self, itk::simple::CenteredTransformInitializerFilter::OperationModeType OperationMode)


        """
        return _SimpleITK.CenteredTransformInitializerFilter_SetOperationMode(
            self, OperationMode
        )

    def GetOperationMode(self):
        r"""
        GetOperationMode(CenteredTransformInitializerFilter self) -> itk::simple::CenteredTransformInitializerFilter::OperationModeType


        """
        return _SimpleITK.CenteredTransformInitializerFilter_GetOperationMode(
            self
        )

    def GetName(self):
        r"""
        GetName(CenteredTransformInitializerFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.CenteredTransformInitializerFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(CenteredTransformInitializerFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.CenteredTransformInitializerFilter___str__(self)

    def Execute(self, fixedImage, movingImage, transform):
        r"""
        Execute(CenteredTransformInitializerFilter self, Image fixedImage, Image movingImage, Transform transform) -> Transform


        Execute the filter on the input image


        """
        val = _SimpleITK.CenteredTransformInitializerFilter_Execute(
            self, fixedImage, movingImage, transform
        )

        val = val.Downcast()

        return val

    def MomentsOn(self):
        r"""
        MomentsOn(CenteredTransformInitializerFilter self)


        Select between using the geometrical center of the images or using the
        center of mass given by the image intensities.


        """
        return _SimpleITK.CenteredTransformInitializerFilter_MomentsOn(self)

    def GeometryOn(self):
        r"""
        GeometryOn(CenteredTransformInitializerFilter self)


        Select between using the geometrical center of the images or using the
        center of mass given by the image intensities.


        """
        return _SimpleITK.CenteredTransformInitializerFilter_GeometryOn(self)


# Register CenteredTransformInitializerFilter in _SimpleITK:
_SimpleITK.CenteredTransformInitializerFilter_swigregister(
    CenteredTransformInitializerFilter
)


def CenteredTransformInitializer(*args, **kwargs):
    r"""
    CenteredTransformInitializer(Image fixedImage, Image movingImage, Transform transform, itk::simple::CenteredTransformInitializerFilter::OperationModeType operationMode=MOMENTS) -> Transform


    CenteredTransformInitializer is a helper class intended to initialize the center of rotation and
    the translation of Transforms having the center of rotation among
    their parameters.


    This function directly calls the execute method of CenteredTransformInitializerFilter in order to support a procedural API


    See:
     itk::simple::CenteredTransformInitializerFilter for the object oriented interface



    """
    val = _SimpleITK.CenteredTransformInitializer(*args, **kwargs)

    val = val.Downcast()

    return val


class CenteredVersorTransformInitializerFilter(ProcessObject):
    r"""


    CenteredVersorTransformInitializerFilter is a helper class intended to initialize the center of rotation,
    versor, and translation of the VersorRigid3DTransform.


    This class is derived from the CenteredTransformInitializerFilter and uses it in a more constrained context. It always uses the Moments
    mode, and also takes advantage of the second order moments in order to
    initialize the Versor representing rotation.


    See:
     itk::CenteredVersorTransformInitializer for the Doxygen on the original ITK class.


    C++ includes: sitkCenteredVersorTransformInitializerFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_CenteredVersorTransformInitializerFilter
    )

    def __init__(self):
        r"""
        __init__(CenteredVersorTransformInitializerFilter self) -> CenteredVersorTransformInitializerFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.CenteredVersorTransformInitializerFilter_swiginit(
            self, _SimpleITK.new_CenteredVersorTransformInitializerFilter()
        )

    def SetComputeRotation(self, ComputeRotation):
        r"""
        SetComputeRotation(CenteredVersorTransformInitializerFilter self, bool ComputeRotation)


        Enable the use of the principal axes of each image to compute an
        initial rotation that will align them.


        """
        return _SimpleITK.CenteredVersorTransformInitializerFilter_SetComputeRotation(
            self, ComputeRotation
        )

    def ComputeRotationOn(self):
        r"""
        ComputeRotationOn(CenteredVersorTransformInitializerFilter self)


        Set the value of ComputeRotation to true or false respectfully.


        """
        return _SimpleITK.CenteredVersorTransformInitializerFilter_ComputeRotationOn(
            self
        )

    def ComputeRotationOff(self):
        r"""
        ComputeRotationOff(CenteredVersorTransformInitializerFilter self)


        """
        return _SimpleITK.CenteredVersorTransformInitializerFilter_ComputeRotationOff(
            self
        )

    def GetComputeRotation(self):
        r"""
        GetComputeRotation(CenteredVersorTransformInitializerFilter self) -> bool


        Enable the use of the principal axes of each image to compute an
        initial rotation that will align them.


        """
        return _SimpleITK.CenteredVersorTransformInitializerFilter_GetComputeRotation(
            self
        )

    def GetName(self):
        r"""
        GetName(CenteredVersorTransformInitializerFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.CenteredVersorTransformInitializerFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(CenteredVersorTransformInitializerFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.CenteredVersorTransformInitializerFilter___str__(
            self
        )

    def Execute(self, fixedImage, movingImage, transform):
        r"""
        Execute(CenteredVersorTransformInitializerFilter self, Image fixedImage, Image movingImage, Transform transform) -> Transform


        Execute the filter on the input image


        """
        return _SimpleITK.CenteredVersorTransformInitializerFilter_Execute(
            self, fixedImage, movingImage, transform
        )


# Register CenteredVersorTransformInitializerFilter in _SimpleITK:
_SimpleITK.CenteredVersorTransformInitializerFilter_swigregister(
    CenteredVersorTransformInitializerFilter
)


def CenteredVersorTransformInitializer(
    fixedImage, movingImage, transform, computeRotation=False
):
    r"""
    CenteredVersorTransformInitializer(Image fixedImage, Image movingImage, Transform transform, bool computeRotation=False) -> Transform


    CenteredVersorTransformInitializer is a helper class intended to initialize the center of rotation,
    versor, and translation of the VersorRigid3DTransform.


    This function directly calls the execute method of
    CenteredVectorTransformInitializerFilter in order to support a
    procedural API.


    See:
     itk::simple::CenteredVersorTransformInitializerFilter for the object oriented interface



    """
    return _SimpleITK.CenteredVersorTransformInitializer(
        fixedImage, movingImage, transform, computeRotation
    )


class LandmarkBasedTransformInitializerFilter(ImageFilter):
    r"""


    This class computes the transform that aligns the fixed and moving
    images given a set of pair landmarks. The class is templated over the Transform type as well as fixed image and moving image types. The transform
    computed gives the best fit transform that maps the fixed and moving
    images in a least squares sense. The indices are taken to correspond,
    so point 1 in the first set will get mapped close to point 1 in the
    second set, etc.

    Currently, the following transforms are supported by the class:
    VersorRigid3DTransform

    Similarity3DTransform

    Rigid2DTransform

    AffineTransform

    BSplineTransform


    An equal number of fixed and moving landmarks need to be specified
    using SetFixedLandmarks() and SetMovingLandmarks() . Any number of landmarks may be specified. In the case of using
    Affine or BSpline transforms, each landmark pair can contribute in the
    final transform based on its defined weight. Number of weights should
    be equal to the number of landmarks and can be specified using SetLandmarkWeight() . By defaults are weights are set to one. Call InitializeTransform()
    to initialize the transform.

    The class is based in part on Hybrid/vtkLandmarkTransform originally
    implemented in python by David G. Gobbi.

    The solution is based on Berthold K. P. Horn (1987), "Closed-form
    solution of absolute orientation using unit quaternions," http://people.csail.mit.edu/bkph/papers/Absolute_Orientation.pdf

    The Affine Transform initializer is based on an algorithm by H Spaeth, and is described in
    the Insight Journal Article "Affine Transformation for Landmark Based
    Registration Initializer in ITK" by Kim E.Y., Johnson H., Williams N.
    available at https://www.midasjournal.org/browse/publication/825

    Wiki Examples:

    All Examples

    Rigidly register one image to another using manually specified
    landmarks
    See:
     itk::simple::LandmarkBasedTransformInitializerFilter for the procedural interface

     itk::LandmarkBasedTransformInitializer for the Doxygen on the original ITK class.



    C++ includes: sitkLandmarkBasedTransformInitializerFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_LandmarkBasedTransformInitializerFilter
    )

    def __init__(self):
        r"""
        __init__(LandmarkBasedTransformInitializerFilter self) -> LandmarkBasedTransformInitializerFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LandmarkBasedTransformInitializerFilter_swiginit(
            self, _SimpleITK.new_LandmarkBasedTransformInitializerFilter()
        )

    def SetFixedLandmarks(self, FixedLandmarks):
        r"""
        SetFixedLandmarks(LandmarkBasedTransformInitializerFilter self, VectorDouble FixedLandmarks)


        Set the Fixed landmark point containers


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_SetFixedLandmarks(
            self, FixedLandmarks
        )

    def GetFixedLandmarks(self):
        r"""
        GetFixedLandmarks(LandmarkBasedTransformInitializerFilter self) -> VectorDouble


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_GetFixedLandmarks(
            self
        )

    def SetMovingLandmarks(self, MovingLandmarks):
        r"""
        SetMovingLandmarks(LandmarkBasedTransformInitializerFilter self, VectorDouble MovingLandmarks)


        Set the Moving landmark point containers


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_SetMovingLandmarks(
            self, MovingLandmarks
        )

    def GetMovingLandmarks(self):
        r"""
        GetMovingLandmarks(LandmarkBasedTransformInitializerFilter self) -> VectorDouble


        Get the shrink factors.


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_GetMovingLandmarks(
            self
        )

    def SetLandmarkWeight(self, LandmarkWeight):
        r"""
        SetLandmarkWeight(LandmarkBasedTransformInitializerFilter self, VectorDouble LandmarkWeight)


        Set the landmark weight point containers Weight includes diagonal
        elements of weight matrix


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_SetLandmarkWeight(
            self, LandmarkWeight
        )

    def GetLandmarkWeight(self):
        r"""
        GetLandmarkWeight(LandmarkBasedTransformInitializerFilter self) -> VectorDouble


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_GetLandmarkWeight(
            self
        )

    def SetReferenceImage(self, ReferenceImage):
        r"""
        SetReferenceImage(LandmarkBasedTransformInitializerFilter self, Image ReferenceImage)


        Set the reference image to define the parametric domain for the
        BSpline transform


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_SetReferenceImage(
            self, ReferenceImage
        )

    def GetReferenceImage(self):
        r"""
        GetReferenceImage(LandmarkBasedTransformInitializerFilter self) -> Image


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_GetReferenceImage(
            self
        )

    def SetBSplineNumberOfControlPoints(self, BSplineNumberOfControlPoints):
        r"""
        SetBSplineNumberOfControlPoints(LandmarkBasedTransformInitializerFilter self, unsigned int BSplineNumberOfControlPoints)


        Set/Get the number of control points


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_SetBSplineNumberOfControlPoints(
            self, BSplineNumberOfControlPoints
        )

    def GetBSplineNumberOfControlPoints(self):
        r"""
        GetBSplineNumberOfControlPoints(LandmarkBasedTransformInitializerFilter self) -> unsigned int


        Set/Get the number of control points


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_GetBSplineNumberOfControlPoints(
            self
        )

    def GetName(self):
        r"""
        GetName(LandmarkBasedTransformInitializerFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LandmarkBasedTransformInitializerFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter___str__(self)

    def Execute(self, transform):
        r"""
        Execute(LandmarkBasedTransformInitializerFilter self, Transform transform) -> Transform


        Execute the filter on the input image


        """
        val = _SimpleITK.LandmarkBasedTransformInitializerFilter_Execute(
            self, transform
        )

        val = val.Downcast()

        return val


# Register LandmarkBasedTransformInitializerFilter in _SimpleITK:
_SimpleITK.LandmarkBasedTransformInitializerFilter_swigregister(
    LandmarkBasedTransformInitializerFilter
)


def LandmarkBasedTransformInitializer(*args, **kwargs):
    r"""
    LandmarkBasedTransformInitializer(Transform transform, VectorDouble fixedLandmarks=std::vector< double >(), VectorDouble movingLandmarks=std::vector< double >(), VectorDouble landmarkWeight=std::vector< double >(), Image referenceImage=itk::simple::Image(), unsigned int numberOfControlPoints=4) -> Transform


    itk::simple::LandmarkBasedTransformInitializerFilter Procedural Interface


    This function directly calls the execute method of LandmarkBasedTransformInitializerFilter in order to support a procedural API


    See:
     itk::simple::LandmarkBasedTransformInitializerFilter for the object oriented interface



    """
    val = _SimpleITK.LandmarkBasedTransformInitializer(*args, **kwargs)

    val = val.Downcast()

    return val


class CastImageFilter(ImageFilter):
    r"""


    A hybrid cast image filter to convert images to other types of images.


    Several different ITK classes are implemented under the hood, to
    convert between different image types.


    See:
     itk::simple::Cast for the procedural interface


    C++ includes: sitkCastImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def SetOutputPixelType(self, pixelID):
        r"""
        SetOutputPixelType(CastImageFilter self, itk::simple::PixelIDValueEnum pixelID)


        Set/Get the output pixel type


        """
        return _SimpleITK.CastImageFilter_SetOutputPixelType(self, pixelID)

    def GetOutputPixelType(self):
        r"""
        GetOutputPixelType(CastImageFilter self) -> itk::simple::PixelIDValueEnum


        """
        return _SimpleITK.CastImageFilter_GetOutputPixelType(self)

    __swig_destroy__ = _SimpleITK.delete_CastImageFilter

    def __init__(self):
        r"""
        __init__(CastImageFilter self) -> CastImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.CastImageFilter_swiginit(
            self, _SimpleITK.new_CastImageFilter()
        )

    def GetName(self):
        r"""
        GetName(CastImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.CastImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(CastImageFilter self) -> std::string


        """
        return _SimpleITK.CastImageFilter___str__(self)

    def Execute(self, arg2):
        r"""
        Execute(CastImageFilter self, Image arg2) -> Image


        """
        return _SimpleITK.CastImageFilter_Execute(self, arg2)


# Register CastImageFilter in _SimpleITK:
_SimpleITK.CastImageFilter_swigregister(CastImageFilter)


def Cast(image, pixelID):
    r"""
    Cast(Image image, itk::simple::PixelIDValueEnum pixelID) -> Image


    """
    return _SimpleITK.Cast(image, pixelID)


class ExtractImageFilter(ImageFilter):
    r"""


    Decrease the image size by cropping the image to the selected region
    bounds.


    ExtractImageFilter changes the image boundary of an image by removing pixels outside the
    target region. The region is specified as a Size and Index. The Size must be specified, while the Index defaults to zeros.

    ExtractImageFilter can collapses dimensions so that the input image may have more
    dimensions than the output image (i.e. 4-D input image to a 3-D output
    image). To specify what dimensions to collapse, the Size must be specified. For any dimension dim where the Size[dim] == 0, that dimension is collapsed. The index to collapse on is
    specified by Index[dim]. For example, we have a image 4D = a 4x4x4x4 image, and we want
    to get a 3D image, 3D = a 4x4x4 image, specified as [x,y,z,2] from 4D
    (i.e. the 3rd "time" slice from 4D). The Size = [4,4,4,0] and Index = [0,0,0,2].

    The number of dimension in Size and Index must at least dimension of the input image. The number of non-zero
    dimensions in Size determines the output dimension.

    Determining the direction of the collapsed output image from an larger
    dimensional input space is an ill defined problem in general. It is
    required that the application developer select the desired
    transformation strategy for collapsing direction cosines. The strategy
    defaults to the guess approach. Direction Collapsing Strategies: 1)
    DirectionCollapseToUnknown(); This is the default in ITK and the
    filter can not run when this is set. 1) DirectionCollapseToIdentity();
    Output has identity direction no matter what 2)
    DirectionCollapseToSubmatrix(); Output direction is the sub-matrix if
    it is positive definite, else throw an exception.

    This filter is implemented as a multithreaded filter. It provides a
    DynamicThreadedGenerateData() method for its implementation.


    See:
     CropImageFilter

     itk::simple::Extract for the procedural interface

     itk::ExtractImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkExtractImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ExtractImageFilter

    def __init__(self):
        r"""
        __init__(ExtractImageFilter self) -> ExtractImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ExtractImageFilter_swiginit(
            self, _SimpleITK.new_ExtractImageFilter()
        )

    def SetSize(self, Size):
        r"""
        SetSize(ExtractImageFilter self, VectorUInt32 Size)


        Set the size of the region to extract.


        The size of the region to extract should be specified. Dimensions
        which have a size of 0 are collapsed. The number of non-zero sized
        determines the output dimension.


        """
        return _SimpleITK.ExtractImageFilter_SetSize(self, Size)

    def GetSize(self):
        r"""
        GetSize(ExtractImageFilter self) -> VectorUInt32


        Get the size of the region to extract.


        """
        return _SimpleITK.ExtractImageFilter_GetSize(self)

    def SetIndex(self, Index):
        r"""
        SetIndex(ExtractImageFilter self, VectorInt32 Index)


        Set the starting index of the input image to extract.


        The index defaults to all zeros.


        """
        return _SimpleITK.ExtractImageFilter_SetIndex(self, Index)

    def GetIndex(self):
        r"""
        GetIndex(ExtractImageFilter self) -> VectorInt32


        Get the starting index to extract.


        """
        return _SimpleITK.ExtractImageFilter_GetIndex(self)

    DIRECTIONCOLLAPSETOUNKOWN = (
        _SimpleITK.ExtractImageFilter_DIRECTIONCOLLAPSETOUNKOWN
    )

    DIRECTIONCOLLAPSETOIDENTITY = (
        _SimpleITK.ExtractImageFilter_DIRECTIONCOLLAPSETOIDENTITY
    )

    DIRECTIONCOLLAPSETOSUBMATRIX = (
        _SimpleITK.ExtractImageFilter_DIRECTIONCOLLAPSETOSUBMATRIX
    )

    DIRECTIONCOLLAPSETOGUESS = (
        _SimpleITK.ExtractImageFilter_DIRECTIONCOLLAPSETOGUESS
    )

    def SetDirectionCollapseToStrategy(self, DirectionCollapseToStrategy):
        r"""
        SetDirectionCollapseToStrategy(ExtractImageFilter self, itk::simple::ExtractImageFilter::DirectionCollapseToStrategyType DirectionCollapseToStrategy)


        Set the strategy to be used to collapse physical space dimensions.


        DIRECTIONCOLLAPSETOIDENTITY Set the strategy so that all collapsed
        images have an identity direction. Use this strategy when you know
        that retention of the physical space orientation of the collapsed
        image is not important.

        DIRECTIONCOLLAPSETOGUESS Set the strategy so that all collapsed images
        where output direction is the sub-matrix if it is positive definite,
        else return identity. This is backwards compatible with ITKv3, but is
        highly discouraged because the results are difficult to anticipate
        under differing data scenarios.

        DIRECTIONCOLLAPSETOSUBMATRIX Set the strategy so that all collapsed
        images where output direction is the sub-matrix if it is positive
        definite, else throw an exception. Use this strategy when it is known
        that properly identified physical space sub-volumes can be reliably
        extracted from a higher dimensional space. For example when the
        application programmer knows that a 4D image is 3D+time, and that the
        3D sub-space is properly defined.


        """
        return _SimpleITK.ExtractImageFilter_SetDirectionCollapseToStrategy(
            self, DirectionCollapseToStrategy
        )

    def GetDirectionCollapseToStrategy(self):
        r"""
        GetDirectionCollapseToStrategy(ExtractImageFilter self) -> itk::simple::ExtractImageFilter::DirectionCollapseToStrategyType


        Get the currently set strategy for collapsing directions of physical
        space.


        """
        return _SimpleITK.ExtractImageFilter_GetDirectionCollapseToStrategy(
            self
        )

    def GetName(self):
        r"""
        GetName(ExtractImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ExtractImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ExtractImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ExtractImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ExtractImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ExtractImageFilter_Execute(self, image1)


# Register ExtractImageFilter in _SimpleITK:
_SimpleITK.ExtractImageFilter_swigregister(ExtractImageFilter)


def Extract(*args, **kwargs):
    r"""Extract(Image image1, VectorUInt32 size=std::vector< unsigned int >(5, 1), VectorInt32 index=std::vector< int >(5, 0), itk::simple::ExtractImageFilter::DirectionCollapseToStrategyType directionCollapseToStrategy=DIRECTIONCOLLAPSETOGUESS) -> Image"""
    return _SimpleITK.Extract(*args, **kwargs)


class PasteImageFilter(ImageFilter):
    r"""


    Paste an image (or a constant value) into another image.


    PasteImageFilter allows a region in a destination image to be filled with a source
    image or a constant pixel value. The SetDestinationIndex() method prescribes where in the destination input to start pasting
    data from the source input. The SetSourceRegion method prescribes the
    section of the second image to paste into the first. When a constant
    pixel value is set, the SourceRegion describes the size of the region
    filled. If the output requested region does not include the
    SourceRegion after it has been repositioned to DestinationIndex, then
    the output will just be a copy of the input.

    This filter supports running "InPlace" to efficiently reuses the
    destination image buffer for the output, removing the need to copy the
    destination pixels to the output.

    When the source image is a lower dimension than the destination image
    then the DestinationSkipAxes parameter specifies which axes in the
    destination image are set to 1 when copying the region or filling with
    a constant.

    C++ includes: sitkPasteImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_PasteImageFilter

    def __init__(self):
        r"""
        __init__(PasteImageFilter self) -> PasteImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.PasteImageFilter_swiginit(
            self, _SimpleITK.new_PasteImageFilter()
        )

    def SetSourceSize(self, SourceSize):
        r"""
        SetSourceSize(PasteImageFilter self, VectorUInt32 SourceSize)


        """
        return _SimpleITK.PasteImageFilter_SetSourceSize(self, SourceSize)

    def GetSourceSize(self):
        r"""
        GetSourceSize(PasteImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.PasteImageFilter_GetSourceSize(self)

    def SetSourceIndex(self, SourceIndex):
        r"""
        SetSourceIndex(PasteImageFilter self, VectorInt32 SourceIndex)


        """
        return _SimpleITK.PasteImageFilter_SetSourceIndex(self, SourceIndex)

    def GetSourceIndex(self):
        r"""
        GetSourceIndex(PasteImageFilter self) -> VectorInt32


        """
        return _SimpleITK.PasteImageFilter_GetSourceIndex(self)

    def SetDestinationIndex(self, DestinationIndex):
        r"""
        SetDestinationIndex(PasteImageFilter self, VectorInt32 DestinationIndex)


        Set/Get the destination index (where in the first input the second
        input will be pasted.


        """
        return _SimpleITK.PasteImageFilter_SetDestinationIndex(
            self, DestinationIndex
        )

    def GetDestinationIndex(self):
        r"""
        GetDestinationIndex(PasteImageFilter self) -> VectorInt32


        Set/Get the destination index (where in the first input the second
        input will be pasted.


        """
        return _SimpleITK.PasteImageFilter_GetDestinationIndex(self)

    def SetDestinationSkipAxes(self, DestinationSkipAxes):
        r"""
        SetDestinationSkipAxes(PasteImageFilter self, VectorBool DestinationSkipAxes)


        Set/Get the array describing which axes in the destination image to
        skip

        The axes with true values are set to 1, to fill the difference between
        the dimension of the input and source image. The number of true value
        in DestinationSkipAxes plus the DestinationImageDimension must equal
        the InputImageDimension.

        By default this array contains SourceImageDimension false values
        followed by true values for the remainder.


        """
        return _SimpleITK.PasteImageFilter_SetDestinationSkipAxes(
            self, DestinationSkipAxes
        )

    def GetDestinationSkipAxes(self):
        r"""
        GetDestinationSkipAxes(PasteImageFilter self) -> VectorBool


        Set/Get the array describing which axes in the destination image to
        skip

        The axes with true values are set to 1, to fill the difference between
        the dimension of the input and source image. The number of true values
        in DestinationSkipAxes plus the DestinationImageDimension must equal
        the InputImageDimension.

        By default this array contains SourceImageDimension false values
        followed by true values for the remainder.


        """
        return _SimpleITK.PasteImageFilter_GetDestinationSkipAxes(self)

    def GetName(self):
        r"""
        GetName(PasteImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.PasteImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(PasteImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.PasteImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(PasteImageFilter self, Image destinationImage, Image sourceImage) -> Image
        Execute(PasteImageFilter self, Image destinationImage, double constant) -> Image


        """
        return _SimpleITK.PasteImageFilter_Execute(self, *args)


# Register PasteImageFilter in _SimpleITK:
_SimpleITK.PasteImageFilter_swigregister(PasteImageFilter)


def Paste(*args, **kwargs):
    r"""Paste(Image destinationImage, Image sourceImage, VectorUInt32 sourceSize=std::vector< unsigned int >(5, 1), VectorInt32 sourceIndex=std::vector< int >(5, 0), VectorInt32 destinationIndex=std::vector< int >(5, 0), VectorBool DestinationSkipAxes=std::vector< bool >()) -> Image"""
    return _SimpleITK.Paste(*args, **kwargs)


def PatchBasedDenoising(*args):
    r"""
    PatchBasedDenoising(Image image1, itk::simple::PatchBasedDenoisingImageFilter::NoiseModelType noiseModel, double kernelBandwidthSigma=400.0, uint32_t patchRadius=4, uint32_t numberOfIterations=1, uint32_t numberOfSamplePatches=200, double sampleVariance=400.0, double noiseSigma=0.0, double noiseModelFidelityWeight=0.0) -> Image
    PatchBasedDenoising(Image image1, double kernelBandwidthSigma=400.0, uint32_t patchRadius=4, uint32_t numberOfIterations=1, uint32_t numberOfSamplePatches=200, double sampleVariance=400.0) -> Image


    itk::simple::PatchBasedDenoisingImageFilter Procedural Interface


    This function directly calls the execute method of PatchBasedDenoisingImageFilter in order to support a procedural API


    See:
     itk::simple::PatchBasedDenoisingImageFilter for the object oriented interface



    """
    return _SimpleITK.PatchBasedDenoising(*args)


class ImageRegistrationMethod(ProcessObject):
    r"""


    An interface method to the modular ITKv4 registration framework.


    This interface method class encapsulates typical registration usage by
    incorporating all the necessary elements for performing a simple image
    registration between two images. This method also allows for
    multistage registration whereby each stage is characterized by
    possibly different transforms and different image metrics. For
    example, many users will want to perform a linear registration
    followed by deformable registration where both stages are performed in
    multiple levels. Each level can be characterized by:


    the resolution of the virtual domain image (see below)

    smoothing of the fixed and moving images
     Multiple stages are handled by linking multiple instantiations of
    this class where the output transform is added to the optional
    composite transform input.


    See:
     itk::ImageRegistrationMethodv4

     itk::ImageToImageMetricv4

     itk::ObjectToObjectOptimizerBaseTemplate


    C++ includes: sitkImageRegistrationMethod.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ImageRegistrationMethod

    def __init__(self):
        r"""
        __init__(ImageRegistrationMethod self) -> ImageRegistrationMethod


        """
        _SimpleITK.ImageRegistrationMethod_swiginit(
            self, _SimpleITK.new_ImageRegistrationMethod()
        )

    def GetName(self):
        r"""
        GetName(ImageRegistrationMethod self) -> std::string


        return user readable name for the filter


        """
        return _SimpleITK.ImageRegistrationMethod_GetName(self)

    def __str__(self):
        r"""
        __str__(ImageRegistrationMethod self) -> std::string


        Print the information about the object to a string.


        If called when the process is being executed ( during a callback ),
        the ITK Optimizer and Transform objects will be printed.


        """
        return _SimpleITK.ImageRegistrationMethod___str__(self)

    def GetInterpolator(self):
        r"""GetInterpolator(ImageRegistrationMethod self) -> itk::simple::InterpolatorEnum"""
        return _SimpleITK.ImageRegistrationMethod_GetInterpolator(self)

    def SetInterpolator(self, Interpolator):
        r"""SetInterpolator(ImageRegistrationMethod self, itk::simple::InterpolatorEnum Interpolator)"""
        return _SimpleITK.ImageRegistrationMethod_SetInterpolator(
            self, Interpolator
        )

    def SetInitialTransform(self, transform, inPlace=True):
        r"""SetInitialTransform(ImageRegistrationMethod self, Transform transform, bool inPlace=True)"""
        return _SimpleITK.ImageRegistrationMethod_SetInitialTransform(
            self, transform, inPlace
        )

    def GetInitialTransform(self):
        r"""GetInitialTransform(ImageRegistrationMethod self) -> Transform"""
        return _SimpleITK.ImageRegistrationMethod_GetInitialTransform(self)

    def GetInitialTransformInPlace(self):
        r"""GetInitialTransformInPlace(ImageRegistrationMethod self) -> bool"""
        return _SimpleITK.ImageRegistrationMethod_GetInitialTransformInPlace(
            self
        )

    def SetInitialTransformAsBSpline(self, *args, **kwargs):
        r"""
        SetInitialTransformAsBSpline(ImageRegistrationMethod self, BSplineTransform transform, bool inPlace=True, VectorUInt32 scaleFactors=std::vector< unsigned int >())


        Set an initial BSpline transform to optimize.


        A specialization of SetInitialTransform for BSplineTransforms which
        can take an additional scaleFactors parameter. The scaleFactors
        specifies the a isotropic scaling factor per level for the BSpline
        transform mesh size with respect to the initial transform. For example
        to double the BSpline mesh resolution at each of 3 levels the vector
        [1,2,4] should be provided.

        If a per level scale factor is 0 or omitted than no transform adapter
        will be created for that level.


        See:
         itk::BSplineTransformParametersAdaptor



        """
        return _SimpleITK.ImageRegistrationMethod_SetInitialTransformAsBSpline(
            self, *args, **kwargs
        )

    def SetMovingInitialTransform(self, transform):
        r"""SetMovingInitialTransform(ImageRegistrationMethod self, Transform transform)"""
        return _SimpleITK.ImageRegistrationMethod_SetMovingInitialTransform(
            self, transform
        )

    def GetMovingInitialTransform(self):
        r"""GetMovingInitialTransform(ImageRegistrationMethod self) -> Transform"""
        return _SimpleITK.ImageRegistrationMethod_GetMovingInitialTransform(
            self
        )

    def SetFixedInitialTransform(self, transform):
        r"""SetFixedInitialTransform(ImageRegistrationMethod self, Transform transform)"""
        return _SimpleITK.ImageRegistrationMethod_SetFixedInitialTransform(
            self, transform
        )

    def GetFixedInitialTransform(self):
        r"""GetFixedInitialTransform(ImageRegistrationMethod self) -> Transform"""
        return _SimpleITK.ImageRegistrationMethod_GetFixedInitialTransform(
            self
        )

    def SetVirtualDomain(
        self, virtualSize, virtualOrigin, virtualSpacing, virtualDirection
    ):
        r"""SetVirtualDomain(ImageRegistrationMethod self, VectorUInt32 virtualSize, VectorDouble virtualOrigin, VectorDouble virtualSpacing, VectorDouble virtualDirection)"""
        return _SimpleITK.ImageRegistrationMethod_SetVirtualDomain(
            self, virtualSize, virtualOrigin, virtualSpacing, virtualDirection
        )

    def SetVirtualDomainFromImage(self, virtualImage):
        r"""SetVirtualDomainFromImage(ImageRegistrationMethod self, Image virtualImage)"""
        return _SimpleITK.ImageRegistrationMethod_SetVirtualDomainFromImage(
            self, virtualImage
        )

    def SetMetricAsANTSNeighborhoodCorrelation(self, radius):
        r"""
        SetMetricAsANTSNeighborhoodCorrelation(ImageRegistrationMethod self, unsigned int radius)


        Use normalized cross correlation using a small neighborhood for each
        voxel between two images, with speed optimizations for dense
        registration.



        See:
         itk::ANTSNeighborhoodCorrelationImageToImageMetricv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetMetricAsANTSNeighborhoodCorrelation(
            self, radius
        )

    def SetMetricAsCorrelation(self):
        r"""
        SetMetricAsCorrelation(ImageRegistrationMethod self)


        Use negative normalized cross correlation image metric.



        See:
         itk::CorrelationImageToImageMetricv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetMetricAsCorrelation(self)

    def SetMetricAsDemons(self, intensityDifferenceThreshold=0.001):
        r"""
        SetMetricAsDemons(ImageRegistrationMethod self, double intensityDifferenceThreshold=0.001)


        Use demons image metric.



        See:
         itk::DemonsImageToImageMetricv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetMetricAsDemons(
            self, intensityDifferenceThreshold
        )

    def SetMetricAsJointHistogramMutualInformation(
        self, numberOfHistogramBins=20, varianceForJointPDFSmoothing=1.5
    ):
        r"""
        SetMetricAsJointHistogramMutualInformation(ImageRegistrationMethod self, unsigned int numberOfHistogramBins=20, double varianceForJointPDFSmoothing=1.5)


        Use mutual information between two images.



        See:
         itk::JointHistogramMutualInformationImageToImageMetricv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetMetricAsJointHistogramMutualInformation(
            self, numberOfHistogramBins, varianceForJointPDFSmoothing
        )

    def SetMetricAsMeanSquares(self):
        r"""
        SetMetricAsMeanSquares(ImageRegistrationMethod self)


        Use negative means squares image metric.



        See:
         itk::MeanSquaresImageToImageMetricv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetMetricAsMeanSquares(self)

    def SetMetricAsMattesMutualInformation(self, numberOfHistogramBins=50):
        r"""
        SetMetricAsMattesMutualInformation(ImageRegistrationMethod self, unsigned int numberOfHistogramBins=50)


        Use the mutual information between two images to be registered using
        the method of Mattes et al.



        See:
         itk::MattesMutualInformationImageToImageMetricv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetMetricAsMattesMutualInformation(
            self, numberOfHistogramBins
        )

    Never = _SimpleITK.ImageRegistrationMethod_Never

    Once = _SimpleITK.ImageRegistrationMethod_Once

    EachIteration = _SimpleITK.ImageRegistrationMethod_EachIteration

    def SetOptimizerAsConjugateGradientLineSearch(self, *args, **kwargs):
        r"""
        SetOptimizerAsConjugateGradientLineSearch(ImageRegistrationMethod self, double learningRate, unsigned int numberOfIterations, double convergenceMinimumValue=1e-6, unsigned int convergenceWindowSize=10, double lineSearchLowerLimit=0, double lineSearchUpperLimit=5.0, double lineSearchEpsilon=0.01, unsigned int lineSearchMaximumIterations=20, itk::simple::ImageRegistrationMethod::EstimateLearningRateType estimateLearningRate=Once, double maximumStepSizeInPhysicalUnits=0.0)


        Conjugate gradient descent optimizer with a golden section line search
        for nonlinear optimization.



        See:
         itk::ConjugateGradientLineSearchOptimizerv4Template



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerAsConjugateGradientLineSearch(
            self, *args, **kwargs
        )

    def SetOptimizerAsRegularStepGradientDescent(self, *args, **kwargs):
        r"""
        SetOptimizerAsRegularStepGradientDescent(ImageRegistrationMethod self, double learningRate, double minStep, unsigned int numberOfIterations, double relaxationFactor=0.5, double gradientMagnitudeTolerance=1e-4, itk::simple::ImageRegistrationMethod::EstimateLearningRateType estimateLearningRate=Never, double maximumStepSizeInPhysicalUnits=0.0)


        Regular Step Gradient descent optimizer.



        See:
         itk::RegularStepGradientDescentOptimizerv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerAsRegularStepGradientDescent(
            self, *args, **kwargs
        )

    def SetOptimizerAsGradientDescent(self, *args, **kwargs):
        r"""
        SetOptimizerAsGradientDescent(ImageRegistrationMethod self, double learningRate, unsigned int numberOfIterations, double convergenceMinimumValue=1e-6, unsigned int convergenceWindowSize=10, itk::simple::ImageRegistrationMethod::EstimateLearningRateType estimateLearningRate=Once, double maximumStepSizeInPhysicalUnits=0.0)


        Gradient descent optimizer.



        See:
         itk::GradientDescentOptimizerv4Template



        """
        return (
            _SimpleITK.ImageRegistrationMethod_SetOptimizerAsGradientDescent(
                self, *args, **kwargs
            )
        )

    def SetOptimizerAsGradientDescentLineSearch(self, *args, **kwargs):
        r"""
        SetOptimizerAsGradientDescentLineSearch(ImageRegistrationMethod self, double learningRate, unsigned int numberOfIterations, double convergenceMinimumValue=1e-6, unsigned int convergenceWindowSize=10, double lineSearchLowerLimit=0, double lineSearchUpperLimit=5.0, double lineSearchEpsilon=0.01, unsigned int lineSearchMaximumIterations=20, itk::simple::ImageRegistrationMethod::EstimateLearningRateType estimateLearningRate=Once, double maximumStepSizeInPhysicalUnits=0.0)


        Gradient descent optimizer with a golden section line search.



        See:
         itk::GradientDescentLineSearchOptimizerv4Template



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerAsGradientDescentLineSearch(
            self, *args, **kwargs
        )

    def SetOptimizerAsLBFGSB(self, *args, **kwargs):
        r"""
        SetOptimizerAsLBFGSB(ImageRegistrationMethod self, double gradientConvergenceTolerance=1e-5, unsigned int numberOfIterations=500, unsigned int maximumNumberOfCorrections=5, unsigned int maximumNumberOfFunctionEvaluations=2000, double costFunctionConvergenceFactor=1e+7, double lowerBound=std::numeric_limits< double >::min(), double upperBound=std::numeric_limits< double >::max(), bool trace=False)


        Limited memory Broyden Fletcher Goldfarb Shannon minimization with
        simple bounds.


        The default parameters utilize LBFGSB in unbounded mode.


        See:
         itk::LBFGSBOptimizerv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerAsLBFGSB(
            self, *args, **kwargs
        )

    def SetOptimizerAsLBFGS2(
        self,
        solutionAccuracy=1e-5,
        numberOfIterations=0,
        hessianApproximateAccuracy=6,
        deltaConvergenceDistance=0,
        deltaConvergenceTolerance=1e-5,
        lineSearchMaximumEvaluations=40,
        lineSearchMinimumStep=1e-20,
        lineSearchMaximumStep=1e20,
        lineSearchAccuracy=1e-4,
    ):
        r"""
        SetOptimizerAsLBFGS2(ImageRegistrationMethod self, double solutionAccuracy=1e-5, unsigned int numberOfIterations=0, unsigned int hessianApproximateAccuracy=6, unsigned int deltaConvergenceDistance=0, double deltaConvergenceTolerance=1e-5, unsigned int lineSearchMaximumEvaluations=40, double lineSearchMinimumStep=1e-20, double lineSearchMaximumStep=1e20, double lineSearchAccuracy=1e-4)


        Limited memory Broyden Fletcher Goldfarb Shannon minimization without
        bounds.


        The default parameters utilize LBFGSB in unbounded mode. This version
        is from LibLBFGS.

        There are upto 3 stopping criteria:
        the solution accuracy which is the magnitude of the gradient

        the delta convergence which ensures the decrease of the metric

        maximum number of iterations



        See:
         itk::LBFGS2Optimizerv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerAsLBFGS2(
            self,
            solutionAccuracy,
            numberOfIterations,
            hessianApproximateAccuracy,
            deltaConvergenceDistance,
            deltaConvergenceTolerance,
            lineSearchMaximumEvaluations,
            lineSearchMinimumStep,
            lineSearchMaximumStep,
            lineSearchAccuracy,
        )

    def SetOptimizerAsExhaustive(self, numberOfSteps, stepLength=1.0):
        r"""
        SetOptimizerAsExhaustive(ImageRegistrationMethod self, VectorUInt32 numberOfSteps, double stepLength=1.0)


        Set the optimizer to sample the metric at regular steps.


        At each iteration the GetOptimizerIteration, can be used to index into
        the sampling grid along with the GetCurrentMetricValue.

        The resulting transform and value at the end of execution is the best
        location.

        The OptimizerScales can be used to perform anisotropic sampling.


        This optimizer is not suitable for use in conjunction with the
        multiple scales.

        See:
         itk::ExhaustiveOptimizerv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerAsExhaustive(
            self, numberOfSteps, stepLength
        )

    def SetOptimizerAsAmoeba(
        self,
        simplexDelta,
        numberOfIterations,
        parametersConvergenceTolerance=1e-8,
        functionConvergenceTolerance=1e-4,
        withRestarts=False,
    ):
        r"""
        SetOptimizerAsAmoeba(ImageRegistrationMethod self, double simplexDelta, unsigned int numberOfIterations, double parametersConvergenceTolerance=1e-8, double functionConvergenceTolerance=1e-4, bool withRestarts=False)


        Set optimizer to Nelder-Mead downhill simplex algorithm.


        The simplexDelta is the value that is added and subtracted to the
        initial parameters to create the initial simplex. The simplexDelta can
        be indirectly set per parameter by the optimizer parameter scaling
        either manually or by using an estimator.


        See:
         ImageRegistrationMethod::SetOptimizerScales

         itk::AmoebaOptimizerv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerAsAmoeba(
            self,
            simplexDelta,
            numberOfIterations,
            parametersConvergenceTolerance,
            functionConvergenceTolerance,
            withRestarts,
        )

    def SetOptimizerWeights(self, weights):
        r"""SetOptimizerWeights(ImageRegistrationMethod self, VectorDouble weights)"""
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerWeights(
            self, weights
        )

    def GetOptimizerWeights(self):
        r"""GetOptimizerWeights(ImageRegistrationMethod self) -> VectorDouble"""
        return _SimpleITK.ImageRegistrationMethod_GetOptimizerWeights(self)

    def SetOptimizerAsPowell(
        self,
        numberOfIterations=100,
        maximumLineIterations=100,
        stepLength=1,
        stepTolerance=1e-6,
        valueTolerance=1e-6,
    ):
        r"""
        SetOptimizerAsPowell(ImageRegistrationMethod self, unsigned int numberOfIterations=100, unsigned int maximumLineIterations=100, double stepLength=1, double stepTolerance=1e-6, double valueTolerance=1e-6)


        Powell optimization using Brent line search.



        See:
         itk::PowellOptimizerv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerAsPowell(
            self,
            numberOfIterations,
            maximumLineIterations,
            stepLength,
            stepTolerance,
            valueTolerance,
        )

    def SetOptimizerAsOnePlusOneEvolutionary(self, *args, **kwargs):
        r"""
        SetOptimizerAsOnePlusOneEvolutionary(ImageRegistrationMethod self, unsigned int numberOfIterations=100, double epsilon=1.5e-4, double initialRadius=1.01, double growthFactor=-1.0, double shrinkFactor=-1.0, unsigned int seed=sitkWallClock)


        1+1 evolutionary optimizer strategy.


        The seed parameter is used to seed the pseudo-random number generator.
        If the seed parameter is 0, then the wall clock is used to seed,
        otherwise the fixed seed is used for reproducible behavior.


        See:
         itk::OnePlusOneEvolutionaryOptimizerv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerAsOnePlusOneEvolutionary(
            self, *args, **kwargs
        )

    def SetOptimizerScales(self, scales):
        r"""
        SetOptimizerScales(ImageRegistrationMethod self, VectorDouble scales)


        Manually set per parameter weighting for the transform parameters.


        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerScales(
            self, scales
        )

    def SetOptimizerScalesFromJacobian(self, centralRegionRadius=5):
        r"""
        SetOptimizerScalesFromJacobian(ImageRegistrationMethod self, unsigned int centralRegionRadius=5)


        Estimate scales from Jacobian norms.


        This scales estimator works well with versor based transforms.


        See:
         itk::RegistrationParameterScalesFromJacobian



        """
        return (
            _SimpleITK.ImageRegistrationMethod_SetOptimizerScalesFromJacobian(
                self, centralRegionRadius
            )
        )

    def SetOptimizerScalesFromIndexShift(
        self, centralRegionRadius=5, smallParameterVariation=0.01
    ):
        r"""
        SetOptimizerScalesFromIndexShift(ImageRegistrationMethod self, unsigned int centralRegionRadius=5, double smallParameterVariation=0.01)


        Estimate scales from maximum voxel shift in index space cause by
        parameter change.



        See:
         itk::RegistrationParameterScalesFromIndexShift



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerScalesFromIndexShift(
            self, centralRegionRadius, smallParameterVariation
        )

    def SetOptimizerScalesFromPhysicalShift(
        self, centralRegionRadius=5, smallParameterVariation=0.01
    ):
        r"""
        SetOptimizerScalesFromPhysicalShift(ImageRegistrationMethod self, unsigned int centralRegionRadius=5, double smallParameterVariation=0.01)


        Estimating scales of transform parameters a step sizes, from the
        maximum voxel shift in physical space caused by a parameter change.



        See:
         itk::RegistrationParameterScalesFromPhysicalShift



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerScalesFromPhysicalShift(
            self, centralRegionRadius, smallParameterVariation
        )

    def SetMetricFixedMask(self, binaryMask):
        r"""
        SetMetricFixedMask(ImageRegistrationMethod self, Image binaryMask)


        Set an image mask in order to restrict the sampled points for the
        metric.


        The image is expected to be in the same physical space as the
        FixedImage, and if the pixel type is not UInt8 than the image will
        base cast.


        See:
         itk::ImageToImageMetricv4::SetFixedImageMask



        """
        return _SimpleITK.ImageRegistrationMethod_SetMetricFixedMask(
            self, binaryMask
        )

    def SetMetricMovingMask(self, binaryMask):
        r"""
        SetMetricMovingMask(ImageRegistrationMethod self, Image binaryMask)


        Set an image mask in order to restrict the sampled points for the
        metric in the moving image space.


        The image is expected to be in the same physical space as the
        MovingImage, and if the pixel type is not UInt8 than the image will
        base cast.


        See:
         itk::ImageToImageMetricv4::SetMovingImageMask



        """
        return _SimpleITK.ImageRegistrationMethod_SetMetricMovingMask(
            self, binaryMask
        )

    def SetMetricSamplingPercentage(self, *args, **kwargs):
        r"""SetMetricSamplingPercentage(ImageRegistrationMethod self, double percentage, unsigned int seed=sitkWallClock)"""
        return _SimpleITK.ImageRegistrationMethod_SetMetricSamplingPercentage(
            self, *args, **kwargs
        )

    def SetMetricSamplingPercentagePerLevel(self, *args, **kwargs):
        r"""SetMetricSamplingPercentagePerLevel(ImageRegistrationMethod self, VectorDouble percentage, unsigned int seed=sitkWallClock)"""
        return _SimpleITK.ImageRegistrationMethod_SetMetricSamplingPercentagePerLevel(
            self, *args, **kwargs
        )

    def GetMetricSamplingPercentagePerLevel(self):
        r"""
        GetMetricSamplingPercentagePerLevel(ImageRegistrationMethod self) -> VectorDouble


        Get the percentage of pixels used for metric evaluation.


        """
        return _SimpleITK.ImageRegistrationMethod_GetMetricSamplingPercentagePerLevel(
            self
        )

    NONE = _SimpleITK.ImageRegistrationMethod_NONE

    REGULAR = _SimpleITK.ImageRegistrationMethod_REGULAR

    RANDOM = _SimpleITK.ImageRegistrationMethod_RANDOM

    def SetMetricSamplingStrategy(self, strategy):
        r"""
        SetMetricSamplingStrategy(ImageRegistrationMethod self, itk::simple::ImageRegistrationMethod::MetricSamplingStrategyType strategy)


        Set sampling strategy for sample generation.



        See:
         itk::ImageRegistrationMethodv4::SetMetricSamplingStrategy



        """
        return _SimpleITK.ImageRegistrationMethod_SetMetricSamplingStrategy(
            self, strategy
        )

    def SetMetricUseFixedImageGradientFilter(self, arg2):
        r"""SetMetricUseFixedImageGradientFilter(ImageRegistrationMethod self, bool arg2)"""
        return _SimpleITK.ImageRegistrationMethod_SetMetricUseFixedImageGradientFilter(
            self, arg2
        )

    def MetricUseFixedImageGradientFilterOn(self):
        r"""MetricUseFixedImageGradientFilterOn(ImageRegistrationMethod self)"""
        return _SimpleITK.ImageRegistrationMethod_MetricUseFixedImageGradientFilterOn(
            self
        )

    def MetricUseFixedImageGradientFilterOff(self):
        r"""MetricUseFixedImageGradientFilterOff(ImageRegistrationMethod self)"""
        return _SimpleITK.ImageRegistrationMethod_MetricUseFixedImageGradientFilterOff(
            self
        )

    def SetMetricUseMovingImageGradientFilter(self, arg2):
        r"""SetMetricUseMovingImageGradientFilter(ImageRegistrationMethod self, bool arg2)"""
        return _SimpleITK.ImageRegistrationMethod_SetMetricUseMovingImageGradientFilter(
            self, arg2
        )

    def MetricUseMovingImageGradientFilterOn(self):
        r"""MetricUseMovingImageGradientFilterOn(ImageRegistrationMethod self)"""
        return _SimpleITK.ImageRegistrationMethod_MetricUseMovingImageGradientFilterOn(
            self
        )

    def MetricUseMovingImageGradientFilterOff(self):
        r"""MetricUseMovingImageGradientFilterOff(ImageRegistrationMethod self)"""
        return _SimpleITK.ImageRegistrationMethod_MetricUseMovingImageGradientFilterOff(
            self
        )

    def SetShrinkFactorsPerLevel(self, shrinkFactors):
        r"""
        SetShrinkFactorsPerLevel(ImageRegistrationMethod self, VectorUInt32 shrinkFactors)


        Set the isotropic shrink factors for each level.


        The virtual domain image is shrunk by this factor relative to the full
        size of the original virtual domain.


        See:
         itk::ImageRegistrationMethodv4::SetShrinkFactorsPerLevel



        """
        return _SimpleITK.ImageRegistrationMethod_SetShrinkFactorsPerLevel(
            self, shrinkFactors
        )

    def SetSmoothingSigmasPerLevel(self, smoothingSigmas):
        r"""
        SetSmoothingSigmasPerLevel(ImageRegistrationMethod self, VectorDouble smoothingSigmas)


        Set the sigmas of Gaussian used for smoothing.


        The smoothing is applied to both the fixed and the moving images at
        each level. The number of smoothing sigmas must match the number of
        shrink factors.


        See:
         itk::ImageRegistrationMethodv4::SetSmoothingSigmasPerLevel



        """
        return _SimpleITK.ImageRegistrationMethod_SetSmoothingSigmasPerLevel(
            self, smoothingSigmas
        )

    def SetSmoothingSigmasAreSpecifiedInPhysicalUnits(self, arg):
        r"""SetSmoothingSigmasAreSpecifiedInPhysicalUnits(ImageRegistrationMethod self, bool arg)"""
        return _SimpleITK.ImageRegistrationMethod_SetSmoothingSigmasAreSpecifiedInPhysicalUnits(
            self, arg
        )

    def SmoothingSigmasAreSpecifiedInPhysicalUnitsOn(self):
        r"""SmoothingSigmasAreSpecifiedInPhysicalUnitsOn(ImageRegistrationMethod self)"""
        return _SimpleITK.ImageRegistrationMethod_SmoothingSigmasAreSpecifiedInPhysicalUnitsOn(
            self
        )

    def SmoothingSigmasAreSpecifiedInPhysicalUnitsOff(self):
        r"""SmoothingSigmasAreSpecifiedInPhysicalUnitsOff(ImageRegistrationMethod self)"""
        return _SimpleITK.ImageRegistrationMethod_SmoothingSigmasAreSpecifiedInPhysicalUnitsOff(
            self
        )

    def Execute(self, fixed, moving):
        r"""
        Execute(ImageRegistrationMethod self, Image fixed, Image moving) -> Transform


        Optimize the configured registration problem.


        """
        val = _SimpleITK.ImageRegistrationMethod_Execute(self, fixed, moving)

        val = val.Downcast()

        return val

    def MetricEvaluate(self, fixed, moving):
        r"""
        MetricEvaluate(ImageRegistrationMethod self, Image fixed, Image moving) -> double


        Get the value of the metric given the state of the method.


        Passing a fixed and moving image, this method constructs and
        configures a metric object to obtain the value. This will take into
        consideration the current transforms, metric, interpolator, and image
        masks. It does not take into consideration the sampling strategy,
        smoothing sigmas, or the shrink factors.


        """
        return _SimpleITK.ImageRegistrationMethod_MetricEvaluate(
            self, fixed, moving
        )

    def GetOptimizerIteration(self):
        r"""
        GetOptimizerIteration(ImageRegistrationMethod self) -> unsigned int


        Active measurements which can be obtained during call backs.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ImageRegistrationMethod_GetOptimizerIteration(self)

    def GetOptimizerPosition(self):
        r"""
        GetOptimizerPosition(ImageRegistrationMethod self) -> VectorDouble


        """
        return _SimpleITK.ImageRegistrationMethod_GetOptimizerPosition(self)

    def GetOptimizerLearningRate(self):
        r"""
        GetOptimizerLearningRate(ImageRegistrationMethod self) -> double


        """
        return _SimpleITK.ImageRegistrationMethod_GetOptimizerLearningRate(
            self
        )

    def GetOptimizerConvergenceValue(self):
        r"""
        GetOptimizerConvergenceValue(ImageRegistrationMethod self) -> double


        """
        return _SimpleITK.ImageRegistrationMethod_GetOptimizerConvergenceValue(
            self
        )

    def GetMetricValue(self):
        r"""
        GetMetricValue(ImageRegistrationMethod self) -> double


        """
        return _SimpleITK.ImageRegistrationMethod_GetMetricValue(self)

    def GetMetricNumberOfValidPoints(self):
        r"""
        GetMetricNumberOfValidPoints(ImageRegistrationMethod self) -> uint64_t


        Current number of points used of metric evaluation

        This is a active measurement connected to the registration processes
        during registration. This number is number of point in the virtual
        domain which overlap the fixed image and the moving image. It is valid
        for sparse or dense sampling. After execution of registration this
        will contain the last value.


        """
        return _SimpleITK.ImageRegistrationMethod_GetMetricNumberOfValidPoints(
            self
        )

    def GetCurrentLevel(self):
        r"""
        GetCurrentLevel(ImageRegistrationMethod self) -> unsigned int


        """
        return _SimpleITK.ImageRegistrationMethod_GetCurrentLevel(self)

    def GetOptimizerScales(self):
        r"""
        GetOptimizerScales(ImageRegistrationMethod self) -> VectorDouble


        Get the OptimizerScales.


        If the scales are explicitly set then this method returns those
        values. If an estimator is used then this is an active measurement
        returning the scales estimated by the estimator and is only available
        during execution.


        """
        return _SimpleITK.ImageRegistrationMethod_GetOptimizerScales(self)

    def GetOptimizerStopConditionDescription(self):
        r"""
        GetOptimizerStopConditionDescription(ImageRegistrationMethod self) -> std::string


        Measurement updated at the end of execution.


        """
        return _SimpleITK.ImageRegistrationMethod_GetOptimizerStopConditionDescription(
            self
        )

    def StopRegistration(self):
        r"""
        StopRegistration(ImageRegistrationMethod self) -> bool


        Stop Registration if actively running.

        This is an active method which can be called during a callback.
        Invoking this method will halt the registration at the current
        iteration, if supported by the optimizer. The LBFGSB, LBFGS2, and the
        Amoeba optimizers do not support user stopping.

        If user stopping is not supported or the optimizer is available ( not
        executed ), then false will be returned.


        """
        return _SimpleITK.ImageRegistrationMethod_StopRegistration(self)


# Register ImageRegistrationMethod in _SimpleITK:
_SimpleITK.ImageRegistrationMethod_swigregister(ImageRegistrationMethod)


class AbsImageFilter(ImageFilter):
    r"""


    Computes the absolute value of each pixel.


    itk::Math::abs() is used to perform the computation.
    See:
     itk::simple::Abs for the procedural interface

     itk::AbsImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkAbsImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_AbsImageFilter

    def __init__(self):
        r"""
        __init__(AbsImageFilter self) -> AbsImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.AbsImageFilter_swiginit(
            self, _SimpleITK.new_AbsImageFilter()
        )

    def GetName(self):
        r"""
        GetName(AbsImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.AbsImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(AbsImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.AbsImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(AbsImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.AbsImageFilter_Execute(self, image1)


# Register AbsImageFilter in _SimpleITK:
_SimpleITK.AbsImageFilter_swigregister(AbsImageFilter)


def Abs(image1):
    r"""Abs(Image image1) -> Image"""
    return _SimpleITK.Abs(image1)


class AbsoluteValueDifferenceImageFilter(ImageFilter):
    r"""


    Implements pixel-wise the computation of absolute value difference.


    This filter is parameterized over the types of the two input images
    and the type of the output image.

    Numeric conversions (castings) are done by the C++ defaults.

    The filter will walk over all the pixels in the two input images, and
    for each one of them it will do the following:


    Cast the input 1 pixel value to double .

    Cast the input 2 pixel value to double .

    Compute the difference of the two pixel values.

    Compute the absolute value of the difference.

    Cast the double value resulting from the absolute value to the pixel
    type of the output image.

    Store the casted value into the output image.
     The filter expects all images to have the same dimension (e.g. all
    2D, or all 3D, or all ND).
    See:
     itk::simple::AbsoluteValueDifference for the procedural interface

     itk::AbsoluteValueDifferenceImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkAbsoluteValueDifferenceImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_AbsoluteValueDifferenceImageFilter

    def __init__(self):
        r"""
        __init__(AbsoluteValueDifferenceImageFilter self) -> AbsoluteValueDifferenceImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.AbsoluteValueDifferenceImageFilter_swiginit(
            self, _SimpleITK.new_AbsoluteValueDifferenceImageFilter()
        )

    def GetName(self):
        r"""
        GetName(AbsoluteValueDifferenceImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.AbsoluteValueDifferenceImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(AbsoluteValueDifferenceImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.AbsoluteValueDifferenceImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(AbsoluteValueDifferenceImageFilter self, Image image1, Image image2) -> Image
        Execute(AbsoluteValueDifferenceImageFilter self, Image image1, double constant) -> Image
        Execute(AbsoluteValueDifferenceImageFilter self, double constant, Image image2) -> Image


        """
        return _SimpleITK.AbsoluteValueDifferenceImageFilter_Execute(
            self, *args
        )


# Register AbsoluteValueDifferenceImageFilter in _SimpleITK:
_SimpleITK.AbsoluteValueDifferenceImageFilter_swigregister(
    AbsoluteValueDifferenceImageFilter
)


def AbsoluteValueDifference(*args):
    r"""
    AbsoluteValueDifference(Image image1, Image image2) -> Image
    AbsoluteValueDifference(Image image1, double constant) -> Image
    AbsoluteValueDifference(double constant, Image image2) -> Image


    """
    return _SimpleITK.AbsoluteValueDifference(*args)


class AcosImageFilter(ImageFilter):
    r"""


    Computes the inverse cosine of each pixel.


    This filter is templated over the pixel type of the input image and
    the pixel type of the output image.

    The filter walks over all the pixels in the input image, and for each
    pixel does do the following:


    cast the pixel value to double ,

    apply the std::acos() function to the double value

    cast the double value resulting from std::acos() to the pixel type of
    the output image

    store the casted value into the output image.
     The filter expects both images to have the same dimension (e.g. both
    2D, or both 3D, or both ND).
    See:
     itk::simple::Acos for the procedural interface

     itk::AcosImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkAcosImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_AcosImageFilter

    def __init__(self):
        r"""
        __init__(AcosImageFilter self) -> AcosImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.AcosImageFilter_swiginit(
            self, _SimpleITK.new_AcosImageFilter()
        )

    def GetName(self):
        r"""
        GetName(AcosImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.AcosImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(AcosImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.AcosImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(AcosImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.AcosImageFilter_Execute(self, image1)


# Register AcosImageFilter in _SimpleITK:
_SimpleITK.AcosImageFilter_swigregister(AcosImageFilter)


def Acos(image1):
    r"""Acos(Image image1) -> Image"""
    return _SimpleITK.Acos(image1)


class AdaptiveHistogramEqualizationImageFilter(ImageFilter):
    r"""


    Power Law Adaptive Histogram Equalization.


    Histogram equalization modifies the contrast in an image. The AdaptiveHistogramEqualizationImageFilter is a superset of many contrast enhancing filters. By modifying its
    parameters (alpha, beta, and window), the AdaptiveHistogramEqualizationImageFilter can produce an adaptively equalized histogram or a version of unsharp
    mask (local mean subtraction). Instead of applying a strict histogram
    equalization in a window about a pixel, this filter prescribes a
    mapping function (power law) controlled by the parameters alpha and
    beta.

    The parameter alpha controls how much the filter acts like the
    classical histogram equalization method (alpha=0) to how much the
    filter acts like an unsharp mask (alpha=1).

    The parameter beta controls how much the filter acts like an unsharp
    mask (beta=0) to much the filter acts like pass through (beta=1, with
    alpha=1).

    The parameter window controls the size of the region over which local
    statistics are calculated. The size of the window is controlled by
    SetRadius the default Radius is 5 in all directions.

    By altering alpha, beta and window, a host of equalization and unsharp
    masking filters is available.

    The boundary condition ignores the part of the neighborhood outside
    the image, and over-weights the valid part of the neighborhood.

    For detail description, reference "Adaptive Image Contrast
    Enhancement using Generalizations of Histogram Equalization." J.Alex
    Stark. IEEE Transactions on Image Processing, May 2000.
    See:
     itk::simple::AdaptiveHistogramEqualization for the procedural interface

     itk::AdaptiveHistogramEqualizationImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkAdaptiveHistogramEqualizationImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_AdaptiveHistogramEqualizationImageFilter
    )

    def __init__(self):
        r"""
        __init__(AdaptiveHistogramEqualizationImageFilter self) -> AdaptiveHistogramEqualizationImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.AdaptiveHistogramEqualizationImageFilter_swiginit(
            self, _SimpleITK.new_AdaptiveHistogramEqualizationImageFilter()
        )

    def SetRadius(self, *args):
        r"""
        SetRadius(AdaptiveHistogramEqualizationImageFilter self, VectorUInt32 Radius)
        SetRadius(AdaptiveHistogramEqualizationImageFilter self, unsigned int value)


        Set the values of the Radius vector all to value


        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter_SetRadius(
            self, *args
        )

    def GetRadius(self):
        r"""
        GetRadius(AdaptiveHistogramEqualizationImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter_GetRadius(
            self
        )

    def SetAlpha(self, Alpha):
        r"""
        SetAlpha(AdaptiveHistogramEqualizationImageFilter self, float Alpha)


        Set/Get the value of alpha. Alpha = 0 produces the adaptive histogram
        equalization (provided beta=0). Alpha = 1 produces an unsharp mask.
        Default is 0.3.


        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter_SetAlpha(
            self, Alpha
        )

    def GetAlpha(self):
        r"""
        GetAlpha(AdaptiveHistogramEqualizationImageFilter self) -> float


        Set/Get the value of alpha. Alpha = 0 produces the adaptive histogram
        equalization (provided beta=0). Alpha = 1 produces an unsharp mask.
        Default is 0.3.


        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter_GetAlpha(
            self
        )

    def SetBeta(self, Beta):
        r"""
        SetBeta(AdaptiveHistogramEqualizationImageFilter self, float Beta)


        Set/Get the value of beta. If beta = 1 (and alpha = 1), then the
        output image matches the input image. As beta approaches 0, the filter
        behaves as an unsharp mask. Default is 0.3.


        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter_SetBeta(
            self, Beta
        )

    def GetBeta(self):
        r"""
        GetBeta(AdaptiveHistogramEqualizationImageFilter self) -> float


        Set/Get the value of beta. If beta = 1 (and alpha = 1), then the
        output image matches the input image. As beta approaches 0, the filter
        behaves as an unsharp mask. Default is 0.3.


        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter_GetBeta(
            self
        )

    def GetName(self):
        r"""
        GetName(AdaptiveHistogramEqualizationImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(AdaptiveHistogramEqualizationImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter___str__(
            self
        )

    def Execute(self, image1):
        r"""
        Execute(AdaptiveHistogramEqualizationImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter_Execute(
            self, image1
        )


# Register AdaptiveHistogramEqualizationImageFilter in _SimpleITK:
_SimpleITK.AdaptiveHistogramEqualizationImageFilter_swigregister(
    AdaptiveHistogramEqualizationImageFilter
)


def AdaptiveHistogramEqualization(*args, **kwargs):
    r"""AdaptiveHistogramEqualization(Image image1, VectorUInt32 radius=std::vector< unsigned int >(3, 5), float alpha=0.3, float beta=0.3) -> Image"""
    return _SimpleITK.AdaptiveHistogramEqualization(*args, **kwargs)


class AddImageFilter(ImageFilter):
    r"""


    Pixel-wise addition of two images.


    This class is templated over the types of the two input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    The pixel type of the input 1 image must have a valid definition of
    the operator+ with a pixel type of the image 2. This condition is
    required because internally this filter will perform the operation


    Additionally the type resulting from the sum, will be cast to the
    pixel type of the output image.

    The total operation over one pixel will be

    For example, this filter could be used directly for adding images
    whose pixels are vectors of the same dimension, and to store the
    resulting vector in an output image of vector pixels.

    The images to be added are set using the methods:

    Additionally, this filter can be used to add a constant to every pixel
    of an image by using


    WARNING:
    No numeric overflow checking is performed in this filter.

    See:
     itk::simple::Add for the procedural interface

     itk::AddImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkAddImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_AddImageFilter

    def __init__(self):
        r"""
        __init__(AddImageFilter self) -> AddImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.AddImageFilter_swiginit(
            self, _SimpleITK.new_AddImageFilter()
        )

    def GetName(self):
        r"""
        GetName(AddImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.AddImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(AddImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.AddImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(AddImageFilter self, Image image1, Image image2) -> Image
        Execute(AddImageFilter self, Image image1, double constant) -> Image
        Execute(AddImageFilter self, double constant, Image image2) -> Image


        """
        return _SimpleITK.AddImageFilter_Execute(self, *args)


# Register AddImageFilter in _SimpleITK:
_SimpleITK.AddImageFilter_swigregister(AddImageFilter)


def Add(*args):
    r"""
    Add(Image image1, Image image2) -> Image
    Add(Image image1, double constant) -> Image
    Add(double constant, Image image2) -> Image


    """
    return _SimpleITK.Add(*args)


class AdditiveGaussianNoiseImageFilter(ImageFilter):
    r"""


    Alter an image with additive Gaussian white noise.


    Additive Gaussian white noise can be modeled as:


    $ I = I_0 + N $

    where $ I $ is the observed image, $ I_0 $ is the noise-free image and $ N $ is a normally distributed random variable of mean $ \\mu $ and variance $ \\sigma^2 $ :

    $ N \\sim \\mathcal{N}(\\mu, \\sigma^2) $
     The noise is independent of the pixel intensities.


    Gaetan Lehmann
     This code was contributed in the Insight Journal paper "Noise
    Simulation". https://doi.org/10.54294/vh6vbw
    See:
     itk::simple::AdditiveGaussianNoise for the procedural interface

     itk::AdditiveGaussianNoiseImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkAdditiveGaussianNoiseImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_AdditiveGaussianNoiseImageFilter

    def __init__(self):
        r"""
        __init__(AdditiveGaussianNoiseImageFilter self) -> AdditiveGaussianNoiseImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.AdditiveGaussianNoiseImageFilter_swiginit(
            self, _SimpleITK.new_AdditiveGaussianNoiseImageFilter()
        )

    def SetStandardDeviation(self, StandardDeviation):
        r"""
        SetStandardDeviation(AdditiveGaussianNoiseImageFilter self, double StandardDeviation)


        Set/Get the standard deviation of the Gaussian distribution. Defaults
        to 1.0.


        """
        return (
            _SimpleITK.AdditiveGaussianNoiseImageFilter_SetStandardDeviation(
                self, StandardDeviation
            )
        )

    def GetStandardDeviation(self):
        r"""
        GetStandardDeviation(AdditiveGaussianNoiseImageFilter self) -> double


        Set/Get the standard deviation of the Gaussian distribution. Defaults
        to 1.0.


        """
        return (
            _SimpleITK.AdditiveGaussianNoiseImageFilter_GetStandardDeviation(
                self
            )
        )

    def SetMean(self, Mean):
        r"""
        SetMean(AdditiveGaussianNoiseImageFilter self, double Mean)


        Set/Get the mean of the Gaussian distribution. Defaults to 0.0.


        """
        return _SimpleITK.AdditiveGaussianNoiseImageFilter_SetMean(self, Mean)

    def GetMean(self):
        r"""
        GetMean(AdditiveGaussianNoiseImageFilter self) -> double


        Set/Get the mean of the Gaussian distribution. Defaults to 0.0.


        """
        return _SimpleITK.AdditiveGaussianNoiseImageFilter_GetMean(self)

    def SetSeed(self, Seed):
        r"""
        SetSeed(AdditiveGaussianNoiseImageFilter self, uint32_t Seed)


        """
        return _SimpleITK.AdditiveGaussianNoiseImageFilter_SetSeed(self, Seed)

    def GetSeed(self):
        r"""
        GetSeed(AdditiveGaussianNoiseImageFilter self) -> uint32_t


        """
        return _SimpleITK.AdditiveGaussianNoiseImageFilter_GetSeed(self)

    def GetName(self):
        r"""
        GetName(AdditiveGaussianNoiseImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.AdditiveGaussianNoiseImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(AdditiveGaussianNoiseImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.AdditiveGaussianNoiseImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(AdditiveGaussianNoiseImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.AdditiveGaussianNoiseImageFilter_Execute(
            self, image1
        )


# Register AdditiveGaussianNoiseImageFilter in _SimpleITK:
_SimpleITK.AdditiveGaussianNoiseImageFilter_swigregister(
    AdditiveGaussianNoiseImageFilter
)


def AdditiveGaussianNoise(*args, **kwargs):
    r"""AdditiveGaussianNoise(Image image1, double standardDeviation=1.0, double mean=0.0, uint32_t seed=(uint32_t) itk::simple::sitkWallClock) -> Image"""
    return _SimpleITK.AdditiveGaussianNoise(*args, **kwargs)


class AggregateLabelMapFilter(ImageFilter):
    r"""


    Collapses all labels into the first label.


    This filter takes a label map as input and visits the pixels of all
    labels and assigns them to the first label of the label map. At the
    end of the execution of this filter, the map will contain a single
    filter.

    This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ShapeLabelObject , RelabelComponentImageFilter

     itk::simple::AggregateLabelMapFilter for the procedural interface

     itk::AggregateLabelMapFilter for the Doxygen on the original ITK class.


    C++ includes: sitkAggregateLabelMapFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_AggregateLabelMapFilter

    def __init__(self):
        r"""
        __init__(AggregateLabelMapFilter self) -> AggregateLabelMapFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.AggregateLabelMapFilter_swiginit(
            self, _SimpleITK.new_AggregateLabelMapFilter()
        )

    def GetName(self):
        r"""
        GetName(AggregateLabelMapFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.AggregateLabelMapFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(AggregateLabelMapFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.AggregateLabelMapFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(AggregateLabelMapFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.AggregateLabelMapFilter_Execute(self, image1)


# Register AggregateLabelMapFilter in _SimpleITK:
_SimpleITK.AggregateLabelMapFilter_swigregister(AggregateLabelMapFilter)


def AggregateLabelMap(image1):
    r"""AggregateLabelMap(Image image1) -> Image"""
    return _SimpleITK.AggregateLabelMap(image1)


class AndImageFilter(ImageFilter):
    r"""


    Implements the AND bitwise operator pixel-wise between two images.


    This class is templated over the types of the two input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    Since the bitwise AND operation is only defined in C++ for integer
    types, the images passed to this filter must comply with the
    requirement of using integer pixel type.

    The total operation over one pixel will be Where "&" is the bitwise AND operator in C++.
    See:
     itk::simple::And for the procedural interface

     itk::AndImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkAndImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_AndImageFilter

    def __init__(self):
        r"""
        __init__(AndImageFilter self) -> AndImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.AndImageFilter_swiginit(
            self, _SimpleITK.new_AndImageFilter()
        )

    def GetName(self):
        r"""
        GetName(AndImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.AndImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(AndImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.AndImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(AndImageFilter self, Image image1, Image image2) -> Image
        Execute(AndImageFilter self, Image image1, int constant) -> Image
        Execute(AndImageFilter self, int constant, Image image2) -> Image


        """
        return _SimpleITK.AndImageFilter_Execute(self, *args)


# Register AndImageFilter in _SimpleITK:
_SimpleITK.AndImageFilter_swigregister(AndImageFilter)


def And(*args):
    r"""
    And(Image image1, Image image2) -> Image
    And(Image image1, int constant) -> Image
    And(int constant, Image image2) -> Image


    """
    return _SimpleITK.And(*args)


class AntiAliasBinaryImageFilter(ImageFilter):
    r"""


    A method for estimation of a surface from a binary volume.



    This filter implements a surface-fitting method for estimation of a
    surface from a binary volume. This process can be used to reduce
    aliasing artifacts which result in visualization of binary partitioned
    surfaces.

    The binary volume (filter input) is used as a set of constraints in an
    iterative relaxation process of an estimated ND surface. The surface
    is described implicitly as the zero level set of a volume $ \\phi $ and allowed to deform under curvature flow. A set of constraints is
    imposed on this movement as follows:

    \\[ u_{i,j,k}^{n+1} = \\left\\{ \\begin{array}{ll}
    \\mbox{max} (u_{i,j,k}^{n} + \\Delta t H_{i,j,k}^{n}, 0) &
    \\mbox{\\f$B_{i,j,k} = 1\\f$} \\\\ \\mbox{min}
    (u_{i,j,k}^{n} + \\Delta t H_{i,j,k}^{n}, 0) &
    \\mbox{\\f$B_{i,j,k} = -1\\f$} \\end{array}\\right. \\]

    where $ u_{i,j,k}^{n} $ is the value of $ \\phi $ at discrete index $ (i,j,k) $ and iteration $ n $ , $ H $ is the gradient magnitude times mean curvature of $ \\phi $ , and $ B $ is the binary input volume, with 1 denoting an inside pixel and -1
    denoting an outside pixel.
    NOTES
    This implementation uses a sparse field level set solver instead of
    the narrow band implementation described in the reference below, which
    may introduce some differences in how fast and how accurately (in
    terms of RMS error) the solution converges.
    REFERENCES
    Whitaker, Ross. "Reducing Aliasing Artifacts In Iso-Surfaces of
    Binary Volumes" IEEE Volume Visualization and Graphics Symposium,
    October 2000, pp.23-32.
    PARAMETERS
    The MaximumRMSChange parameter is used to determine when the solution
    has converged. A lower value will result in a tighter-fitting
    solution, but will require more computations. Too low a value could
    put the solver into an infinite loop. Values should always be less
    than 1.0. A value of 0.07 is a good starting estimate.

    The MaximumIterations parameter can be used to halt the solution after
    a specified number of iterations.
    INPUT
    The input is an N-dimensional image of any type. It is assumed to be a
    binary image. The filter will use an isosurface value that is halfway
    between the min and max values in the image. A signed data type is not
    necessary for the input.
    OUTPUT
    The filter will output a level set image of real, signed values. The
    zero crossings of this (N-dimensional) image represent the position of
    the isosurface value of interest. Values outside the zero level set
    are negative and values inside the zero level set are positive values.
    IMPORTANT!
    The output image type you use to instantiate this filter should be a
    real valued scalar type. In other words: doubles or floats.
    USING THIS FILTER
    The filter is relatively straightforward to use. Tests and examples
    exist to illustrate. The important thing is to understand the input
    and output types so you can properly interpret your results.

    In the common case, the only parameter that will need to be set is the
    MaximumRMSChange parameter, which determines when the solver halts.

    See:
     itk::simple::AntiAliasBinary for the procedural interface

     itk::AntiAliasBinaryImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkAntiAliasBinaryImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_AntiAliasBinaryImageFilter

    def __init__(self):
        r"""
        __init__(AntiAliasBinaryImageFilter self) -> AntiAliasBinaryImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.AntiAliasBinaryImageFilter_swiginit(
            self, _SimpleITK.new_AntiAliasBinaryImageFilter()
        )

    def SetMaximumRMSError(self, MaximumRMSError):
        r"""
        SetMaximumRMSError(AntiAliasBinaryImageFilter self, double MaximumRMSError)


        """
        return _SimpleITK.AntiAliasBinaryImageFilter_SetMaximumRMSError(
            self, MaximumRMSError
        )

    def GetMaximumRMSError(self):
        r"""
        GetMaximumRMSError(AntiAliasBinaryImageFilter self) -> double


        """
        return _SimpleITK.AntiAliasBinaryImageFilter_GetMaximumRMSError(self)

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(AntiAliasBinaryImageFilter self, uint32_t NumberOfIterations)


        """
        return _SimpleITK.AntiAliasBinaryImageFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(AntiAliasBinaryImageFilter self) -> uint32_t


        """
        return _SimpleITK.AntiAliasBinaryImageFilter_GetNumberOfIterations(
            self
        )

    def GetElapsedIterations(self):
        r"""
        GetElapsedIterations(AntiAliasBinaryImageFilter self) -> uint32_t


        Number of iterations run.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.AntiAliasBinaryImageFilter_GetElapsedIterations(self)

    def GetRMSChange(self):
        r"""
        GetRMSChange(AntiAliasBinaryImageFilter self) -> double


        The Root Mean Square of the levelset upon termination.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.AntiAliasBinaryImageFilter_GetRMSChange(self)

    def GetName(self):
        r"""
        GetName(AntiAliasBinaryImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.AntiAliasBinaryImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(AntiAliasBinaryImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.AntiAliasBinaryImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(AntiAliasBinaryImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.AntiAliasBinaryImageFilter_Execute(self, image1)


# Register AntiAliasBinaryImageFilter in _SimpleITK:
_SimpleITK.AntiAliasBinaryImageFilter_swigregister(AntiAliasBinaryImageFilter)


def AntiAliasBinary(image1, maximumRMSError=0.07, numberOfIterations=1000):
    r"""AntiAliasBinary(Image image1, double maximumRMSError=0.07, uint32_t numberOfIterations=1000) -> Image"""
    return _SimpleITK.AntiAliasBinary(
        image1, maximumRMSError, numberOfIterations
    )


class ApproximateSignedDistanceMapImageFilter(ImageFilter):
    r"""


    Create a map of the approximate signed distance from the boundaries of
    a binary image.


    The ApproximateSignedDistanceMapImageFilter takes as input a binary image and produces a signed distance map.
    Each pixel value in the output contains the approximate distance from
    that pixel to the nearest "object" in the binary image. This filter
    differs from the DanielssonDistanceMapImageFilter in that it calculates the distance to the "object edge" for pixels
    within the object.

    Negative values in the output indicate that the pixel at that position
    is within an object in the input image. The absolute value of a
    negative pixel represents the approximate distance to the nearest
    object boundary pixel.

    WARNING: This filter requires that the output type be floating-point.
    Otherwise internal calculations will not be performed to the
    appropriate precision, resulting in completely incorrect (read: zero-
    valued) output.

    The distances computed by this filter are Chamfer distances, which are
    only an approximation to Euclidean distances, and are not as exact
    approximations as those calculated by the DanielssonDistanceMapImageFilter . On the other hand, this filter is faster.

    This filter requires that an "inside value" and "outside value" be
    set as parameters. The "inside value" is the intensity value of the
    binary image which corresponds to objects, and the "outside value"
    is the intensity of the background. (A typical binary image often
    represents objects as black (0) and background as white (usually 255),
    or vice-versa.) Note that this filter is slightly faster if the inside
    value is less than the outside value. Otherwise an extra iteration
    through the image is required.

    This filter uses the FastChamferDistanceImageFilter and the IsoContourDistanceImageFilter internally to perform the distance calculations.


    See:
     DanielssonDistanceMapImageFilter

     SignedDanielssonDistanceMapImageFilter

     SignedMaurerDistanceMapImageFilter

     FastChamferDistanceImageFilter

     IsoContourDistanceImageFilter

    Zach Pincus

    See:
     itk::simple::ApproximateSignedDistanceMap for the procedural interface

     itk::ApproximateSignedDistanceMapImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkApproximateSignedDistanceMapImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_ApproximateSignedDistanceMapImageFilter
    )

    def __init__(self):
        r"""
        __init__(ApproximateSignedDistanceMapImageFilter self) -> ApproximateSignedDistanceMapImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ApproximateSignedDistanceMapImageFilter_swiginit(
            self, _SimpleITK.new_ApproximateSignedDistanceMapImageFilter()
        )

    def SetInsideValue(self, InsideValue):
        r"""
        SetInsideValue(ApproximateSignedDistanceMapImageFilter self, double InsideValue)


        Set/Get intensity value representing the interior of objects in the
        mask.


        """
        return (
            _SimpleITK.ApproximateSignedDistanceMapImageFilter_SetInsideValue(
                self, InsideValue
            )
        )

    def GetInsideValue(self):
        r"""
        GetInsideValue(ApproximateSignedDistanceMapImageFilter self) -> double


        Set/Get intensity value representing the interior of objects in the
        mask.


        """
        return (
            _SimpleITK.ApproximateSignedDistanceMapImageFilter_GetInsideValue(
                self
            )
        )

    def SetOutsideValue(self, OutsideValue):
        r"""
        SetOutsideValue(ApproximateSignedDistanceMapImageFilter self, double OutsideValue)


        Set/Get intensity value representing non-objects in the mask.


        """
        return (
            _SimpleITK.ApproximateSignedDistanceMapImageFilter_SetOutsideValue(
                self, OutsideValue
            )
        )

    def GetOutsideValue(self):
        r"""
        GetOutsideValue(ApproximateSignedDistanceMapImageFilter self) -> double


        Set/Get intensity value representing non-objects in the mask.


        """
        return (
            _SimpleITK.ApproximateSignedDistanceMapImageFilter_GetOutsideValue(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(ApproximateSignedDistanceMapImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ApproximateSignedDistanceMapImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ApproximateSignedDistanceMapImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ApproximateSignedDistanceMapImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ApproximateSignedDistanceMapImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ApproximateSignedDistanceMapImageFilter_Execute(
            self, image1
        )


# Register ApproximateSignedDistanceMapImageFilter in _SimpleITK:
_SimpleITK.ApproximateSignedDistanceMapImageFilter_swigregister(
    ApproximateSignedDistanceMapImageFilter
)


def ApproximateSignedDistanceMap(image1, insideValue=1, outsideValue=0):
    r"""ApproximateSignedDistanceMap(Image image1, double insideValue=1, double outsideValue=0) -> Image"""
    return _SimpleITK.ApproximateSignedDistanceMap(
        image1, insideValue, outsideValue
    )


class AreaClosingImageFilter(ImageFilter):
    r"""


    Morphological closing by attributes.


    An attribute closing removes blobs according to criteria such as area.
    When applied to grayscale images they have the effect of filling
    valleys (regions darker than their surroundings) based on area while
    leaving the rest of the image unchanged.

    This code was contributed in the Insight Journal paper

    "Grayscale morphological attribute operations" by Beare R. https://doi.org/10.54294/ifvjls


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    See:
     itk::simple::AreaClosing for the procedural interface

     itk::AreaClosingImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkAreaClosingImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_AreaClosingImageFilter

    def __init__(self):
        r"""
        __init__(AreaClosingImageFilter self) -> AreaClosingImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.AreaClosingImageFilter_swiginit(
            self, _SimpleITK.new_AreaClosingImageFilter()
        )

    def SetLambda(self, Lambda):
        r"""
        SetLambda(AreaClosingImageFilter self, double Lambda)


        The size of the area opening.


        """
        return _SimpleITK.AreaClosingImageFilter_SetLambda(self, Lambda)

    def GetLambda(self):
        r"""
        GetLambda(AreaClosingImageFilter self) -> double


        """
        return _SimpleITK.AreaClosingImageFilter_GetLambda(self)

    def SetUseImageSpacing(self, UseImageSpacing):
        r"""
        SetUseImageSpacing(AreaClosingImageFilter self, bool UseImageSpacing)


        Set/Get whether the image spacing is used or not - defaults to true.


        """
        return _SimpleITK.AreaClosingImageFilter_SetUseImageSpacing(
            self, UseImageSpacing
        )

    def UseImageSpacingOn(self):
        r"""
        UseImageSpacingOn(AreaClosingImageFilter self)


        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.AreaClosingImageFilter_UseImageSpacingOn(self)

    def UseImageSpacingOff(self):
        r"""
        UseImageSpacingOff(AreaClosingImageFilter self)


        """
        return _SimpleITK.AreaClosingImageFilter_UseImageSpacingOff(self)

    def GetUseImageSpacing(self):
        r"""
        GetUseImageSpacing(AreaClosingImageFilter self) -> bool


        Set/Get whether the image spacing is used or not - defaults to true.


        """
        return _SimpleITK.AreaClosingImageFilter_GetUseImageSpacing(self)

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(AreaClosingImageFilter self, bool FullyConnected)


        """
        return _SimpleITK.AreaClosingImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(AreaClosingImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.AreaClosingImageFilter_FullyConnectedOn(self)

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(AreaClosingImageFilter self)


        """
        return _SimpleITK.AreaClosingImageFilter_FullyConnectedOff(self)

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(AreaClosingImageFilter self) -> bool


        """
        return _SimpleITK.AreaClosingImageFilter_GetFullyConnected(self)

    def GetName(self):
        r"""
        GetName(AreaClosingImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.AreaClosingImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(AreaClosingImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.AreaClosingImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(AreaClosingImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.AreaClosingImageFilter_Execute(self, image1)


# Register AreaClosingImageFilter in _SimpleITK:
_SimpleITK.AreaClosingImageFilter_swigregister(AreaClosingImageFilter)


def AreaClosing(
    image1, _lambda=0.0, useImageSpacing=True, fullyConnected=False
):
    r"""AreaClosing(Image image1, double _lambda=0.0, bool useImageSpacing=True, bool fullyConnected=False) -> Image"""
    return _SimpleITK.AreaClosing(
        image1, _lambda, useImageSpacing, fullyConnected
    )


class AreaOpeningImageFilter(ImageFilter):
    r"""


    Morphological opening by attributes.


    An attribute opening removes blobs according to criteria such as area.
    When applied to grayscale images they have the effect of trimming
    peaks (regions brighter than their surroundings) based on area while
    leaving the rest of the image unchanged.

    This code was contributed in the Insight Journal paper

    "Grayscale morphological attribute operations" by Beare R. https://doi.org/10.54294/ifvjls


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    See:
     itk::simple::AreaOpening for the procedural interface

     itk::AreaOpeningImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkAreaOpeningImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_AreaOpeningImageFilter

    def __init__(self):
        r"""
        __init__(AreaOpeningImageFilter self) -> AreaOpeningImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.AreaOpeningImageFilter_swiginit(
            self, _SimpleITK.new_AreaOpeningImageFilter()
        )

    def SetLambda(self, Lambda):
        r"""
        SetLambda(AreaOpeningImageFilter self, double Lambda)


        The size of the area opening.


        """
        return _SimpleITK.AreaOpeningImageFilter_SetLambda(self, Lambda)

    def GetLambda(self):
        r"""
        GetLambda(AreaOpeningImageFilter self) -> double


        """
        return _SimpleITK.AreaOpeningImageFilter_GetLambda(self)

    def SetUseImageSpacing(self, UseImageSpacing):
        r"""
        SetUseImageSpacing(AreaOpeningImageFilter self, bool UseImageSpacing)


        Set/Get whether the image spacing is used or not - defaults to true.


        """
        return _SimpleITK.AreaOpeningImageFilter_SetUseImageSpacing(
            self, UseImageSpacing
        )

    def UseImageSpacingOn(self):
        r"""
        UseImageSpacingOn(AreaOpeningImageFilter self)


        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.AreaOpeningImageFilter_UseImageSpacingOn(self)

    def UseImageSpacingOff(self):
        r"""
        UseImageSpacingOff(AreaOpeningImageFilter self)


        """
        return _SimpleITK.AreaOpeningImageFilter_UseImageSpacingOff(self)

    def GetUseImageSpacing(self):
        r"""
        GetUseImageSpacing(AreaOpeningImageFilter self) -> bool


        Set/Get whether the image spacing is used or not - defaults to true.


        """
        return _SimpleITK.AreaOpeningImageFilter_GetUseImageSpacing(self)

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(AreaOpeningImageFilter self, bool FullyConnected)


        """
        return _SimpleITK.AreaOpeningImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(AreaOpeningImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.AreaOpeningImageFilter_FullyConnectedOn(self)

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(AreaOpeningImageFilter self)


        """
        return _SimpleITK.AreaOpeningImageFilter_FullyConnectedOff(self)

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(AreaOpeningImageFilter self) -> bool


        """
        return _SimpleITK.AreaOpeningImageFilter_GetFullyConnected(self)

    def GetName(self):
        r"""
        GetName(AreaOpeningImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.AreaOpeningImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(AreaOpeningImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.AreaOpeningImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(AreaOpeningImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.AreaOpeningImageFilter_Execute(self, image1)


# Register AreaOpeningImageFilter in _SimpleITK:
_SimpleITK.AreaOpeningImageFilter_swigregister(AreaOpeningImageFilter)


def AreaOpening(
    image1, _lambda=0.0, useImageSpacing=True, fullyConnected=False
):
    r"""AreaOpening(Image image1, double _lambda=0.0, bool useImageSpacing=True, bool fullyConnected=False) -> Image"""
    return _SimpleITK.AreaOpening(
        image1, _lambda, useImageSpacing, fullyConnected
    )


class AsinImageFilter(ImageFilter):
    r"""


    Computes the sine of each pixel.


    This filter is templated over the pixel type of the input image and
    the pixel type of the output image.

    The filter walks over all the pixels in the input image, and for each
    pixel does the following:


    cast the pixel value to double ,

    apply the std::asin() function to the double value,

    cast the double value resulting from std::asin() to the pixel type of
    the output image,

    store the casted value into the output image.
     The filter expects both images to have the same dimension (e.g. both
    2D, or both 3D, or both ND)
    See:
     itk::simple::Asin for the procedural interface

     itk::AsinImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkAsinImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_AsinImageFilter

    def __init__(self):
        r"""
        __init__(AsinImageFilter self) -> AsinImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.AsinImageFilter_swiginit(
            self, _SimpleITK.new_AsinImageFilter()
        )

    def GetName(self):
        r"""
        GetName(AsinImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.AsinImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(AsinImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.AsinImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(AsinImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.AsinImageFilter_Execute(self, image1)


# Register AsinImageFilter in _SimpleITK:
_SimpleITK.AsinImageFilter_swigregister(AsinImageFilter)


def Asin(image1):
    r"""Asin(Image image1) -> Image"""
    return _SimpleITK.Asin(image1)


class Atan2ImageFilter(ImageFilter):
    r"""


    Computes two argument inverse tangent.


    The first argument to the atan function is provided by a pixel in the
    first input image (SetInput1() ) and the corresponding pixel in the
    second input image (SetInput2() ) is used as the second argument.

    This class is templated over the types of the two input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    Both pixel input types are cast to double in order to be used as
    parameters of std::atan2() . The resulting double value is cast to the
    output pixel type.
    See:
     itk::simple::Atan2 for the procedural interface

     itk::Atan2ImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkAtan2ImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_Atan2ImageFilter

    def __init__(self):
        r"""
        __init__(Atan2ImageFilter self) -> Atan2ImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.Atan2ImageFilter_swiginit(
            self, _SimpleITK.new_Atan2ImageFilter()
        )

    def GetName(self):
        r"""
        GetName(Atan2ImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.Atan2ImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(Atan2ImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.Atan2ImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(Atan2ImageFilter self, Image image1, Image image2) -> Image
        Execute(Atan2ImageFilter self, Image image1, double constant) -> Image
        Execute(Atan2ImageFilter self, double constant, Image image2) -> Image


        """
        return _SimpleITK.Atan2ImageFilter_Execute(self, *args)


# Register Atan2ImageFilter in _SimpleITK:
_SimpleITK.Atan2ImageFilter_swigregister(Atan2ImageFilter)


def Atan2(*args):
    r"""
    Atan2(Image image1, Image image2) -> Image
    Atan2(Image image1, double constant) -> Image
    Atan2(double constant, Image image2) -> Image


    """
    return _SimpleITK.Atan2(*args)


class AtanImageFilter(ImageFilter):
    r"""


    Computes the one-argument inverse tangent of each pixel.


    This filter is templated over the pixel type of the input image and
    the pixel type of the output image.

    The filter walks over all the pixels in the input image, and for each
    pixel does the following:


    cast the pixel value to double ,

    apply the std::atan() function to the double value,

    cast the double value resulting from std::atan() to the pixel type of
    the output image,

    store the cast value into the output image.
    See:
     itk::simple::Atan for the procedural interface

     itk::AtanImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkAtanImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_AtanImageFilter

    def __init__(self):
        r"""
        __init__(AtanImageFilter self) -> AtanImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.AtanImageFilter_swiginit(
            self, _SimpleITK.new_AtanImageFilter()
        )

    def GetName(self):
        r"""
        GetName(AtanImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.AtanImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(AtanImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.AtanImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(AtanImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.AtanImageFilter_Execute(self, image1)


# Register AtanImageFilter in _SimpleITK:
_SimpleITK.AtanImageFilter_swigregister(AtanImageFilter)


def Atan(image1):
    r"""Atan(Image image1) -> Image"""
    return _SimpleITK.Atan(image1)


class BSplineDecompositionImageFilter(ImageFilter):
    r"""


    Calculates the B-Spline coefficients of an image. Spline order may be
    from 0 to 5.


    This class defines N-Dimension B-Spline transformation. It is based
    on: [1] M. Unser, "Splines: A Perfect Fit for Signal and Image
    Processing," IEEE Signal Processing Magazine, vol. 16, no. 6, pp.
    22-38, November 1999. [2] M. Unser, A. Aldroubi and M. Eden,
    "B-Spline Signal Processing: Part I--Theory," IEEE Transactions on
    Signal Processing, vol. 41, no. 2, pp. 821-832, February 1993. [3] M.
    Unser, A. Aldroubi and M. Eden, "B-Spline Signal Processing: Part II
    --Efficient Design and Applications," IEEE Transactions on Signal
    Processing, vol. 41, no. 2, pp. 834-848, February 1993. And code obtained from bigwww.epfl.ch by Philippe Thevenaz

    Limitations: Spline order must be between 0 and 5. Spline order must
    be set before setting the image. Uses mirror boundary conditions.
    Requires the same order of Spline for each dimension. Can only process
    LargestPossibleRegion


    See:
     BSplineResampleImageFunction

     itk::simple::BSplineDecomposition for the procedural interface

     itk::BSplineDecompositionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBSplineDecompositionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BSplineDecompositionImageFilter

    def __init__(self):
        r"""
        __init__(BSplineDecompositionImageFilter self) -> BSplineDecompositionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BSplineDecompositionImageFilter_swiginit(
            self, _SimpleITK.new_BSplineDecompositionImageFilter()
        )

    def SetSplineOrder(self, SplineOrder):
        r"""
        SetSplineOrder(BSplineDecompositionImageFilter self, uint32_t SplineOrder)


        Get/Sets the Spline Order, supports 0th - 5th order splines. The
        default is a 3rd order spline.


        """
        return _SimpleITK.BSplineDecompositionImageFilter_SetSplineOrder(
            self, SplineOrder
        )

    def GetSplineOrder(self):
        r"""
        GetSplineOrder(BSplineDecompositionImageFilter self) -> uint32_t


        """
        return _SimpleITK.BSplineDecompositionImageFilter_GetSplineOrder(self)

    def GetSplinePoles(self):
        r"""
        GetSplinePoles(BSplineDecompositionImageFilter self) -> VectorDouble


        Get the poles calculated for a given spline order.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.BSplineDecompositionImageFilter_GetSplinePoles(self)

    def GetName(self):
        r"""
        GetName(BSplineDecompositionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BSplineDecompositionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BSplineDecompositionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BSplineDecompositionImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BSplineDecompositionImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BSplineDecompositionImageFilter_Execute(self, image1)


# Register BSplineDecompositionImageFilter in _SimpleITK:
_SimpleITK.BSplineDecompositionImageFilter_swigregister(
    BSplineDecompositionImageFilter
)


def BSplineDecomposition(image1, splineOrder=3):
    r"""BSplineDecomposition(Image image1, uint32_t splineOrder=3) -> Image"""
    return _SimpleITK.BSplineDecomposition(image1, splineOrder)


class BilateralImageFilter(ImageFilter):
    r"""


    Blurs an image while preserving edges.


    This filter uses bilateral filtering to blur an image using both
    domain and range "neighborhoods". Pixels that are close to a pixel
    in the image domain and similar to a pixel in the image range are used
    to calculate the filtered value. Two gaussian kernels (one in the
    image domain and one in the image range) are used to smooth the image.
    The result is an image that is smoothed in homogeneous regions yet has
    edges preserved. The result is similar to anisotropic diffusion but
    the implementation in non-iterative. Another benefit to bilateral
    filtering is that any distance metric can be used for kernel smoothing
    the image range. Hence, color images can be smoothed as vector images,
    using the CIE distances between intensity values as the similarity
    metric (the Gaussian kernel for the image domain is evaluated using
    CIE distances). A separate version of this filter will be designed for
    color and vector images.

    Bilateral filtering is capable of reducing the noise in an image by an
    order of magnitude while maintaining edges.

    The bilateral operator used here was described by Tomasi and Manduchi
    (Bilateral Filtering for Gray and ColorImages. IEEE ICCV. 1998.)


    See:
     GaussianOperator

     RecursiveGaussianImageFilter

     DiscreteGaussianImageFilter

     AnisotropicDiffusionImageFilter

     Image

     Neighborhood

     NeighborhoodOperator
     TodoSupport color images

    Support vector images
    See:
     itk::simple::Bilateral for the procedural interface

     itk::BilateralImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBilateralImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BilateralImageFilter

    def __init__(self):
        r"""
        __init__(BilateralImageFilter self) -> BilateralImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BilateralImageFilter_swiginit(
            self, _SimpleITK.new_BilateralImageFilter()
        )

    def SetDomainSigma(self, DomainSigma):
        r"""
        SetDomainSigma(BilateralImageFilter self, double DomainSigma)


        Convenience get/set methods for setting all domain parameters to the
        same values.


        """
        return _SimpleITK.BilateralImageFilter_SetDomainSigma(
            self, DomainSigma
        )

    def GetDomainSigma(self):
        r"""
        GetDomainSigma(BilateralImageFilter self) -> double


        Standard get/set macros for filter parameters. DomainSigma is
        specified in the same units as the Image spacing. RangeSigma is specified in the units of intensity.


        """
        return _SimpleITK.BilateralImageFilter_GetDomainSigma(self)

    def SetRangeSigma(self, RangeSigma):
        r"""
        SetRangeSigma(BilateralImageFilter self, double RangeSigma)


        Standard get/set macros for filter parameters. DomainSigma is
        specified in the same units as the Image spacing. RangeSigma is specified in the units of intensity.


        """
        return _SimpleITK.BilateralImageFilter_SetRangeSigma(self, RangeSigma)

    def GetRangeSigma(self):
        r"""
        GetRangeSigma(BilateralImageFilter self) -> double


        Standard get/set macros for filter parameters. DomainSigma is
        specified in the same units as the Image spacing. RangeSigma is specified in the units of intensity.


        """
        return _SimpleITK.BilateralImageFilter_GetRangeSigma(self)

    def SetNumberOfRangeGaussianSamples(self, NumberOfRangeGaussianSamples):
        r"""
        SetNumberOfRangeGaussianSamples(BilateralImageFilter self, unsigned int NumberOfRangeGaussianSamples)


        Set/Get the number of samples in the approximation to the Gaussian
        used for the range smoothing. Samples are only generated in the range
        of [0, 4*m_RangeSigma]. Default is 100.


        """
        return _SimpleITK.BilateralImageFilter_SetNumberOfRangeGaussianSamples(
            self, NumberOfRangeGaussianSamples
        )

    def GetNumberOfRangeGaussianSamples(self):
        r"""
        GetNumberOfRangeGaussianSamples(BilateralImageFilter self) -> unsigned int


        Set/Get the number of samples in the approximation to the Gaussian
        used for the range smoothing. Samples are only generated in the range
        of [0, 4*m_RangeSigma]. Default is 100.


        """
        return _SimpleITK.BilateralImageFilter_GetNumberOfRangeGaussianSamples(
            self
        )

    def GetName(self):
        r"""
        GetName(BilateralImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BilateralImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BilateralImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BilateralImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BilateralImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BilateralImageFilter_Execute(self, image1)


# Register BilateralImageFilter in _SimpleITK:
_SimpleITK.BilateralImageFilter_swigregister(BilateralImageFilter)


def Bilateral(
    image1, domainSigma=4.0, rangeSigma=50.0, numberOfRangeGaussianSamples=100
):
    r"""Bilateral(Image image1, double domainSigma=4.0, double rangeSigma=50.0, unsigned int numberOfRangeGaussianSamples=100) -> Image"""
    return _SimpleITK.Bilateral(
        image1, domainSigma, rangeSigma, numberOfRangeGaussianSamples
    )


class BinShrinkImageFilter(ImageFilter):
    r"""


    Reduce the size of an image by an integer factor in each dimension
    while performing averaging of an input neighborhood.


    The output image size in each dimension is given by:

    outputSize[j] = max( std::floor(inputSize[j]/shrinkFactor[j]), 1 );

    The algorithm implemented can be describe with the following equation
    for 2D: \\[ \\mathsf{I}_{out}(x_o,x_1) =
    \\frac{\\sum_{i=0}^{f_0}\\sum_{j=0}^{f_1}\\mathsf{I}_{in}(f_0
    x_o+i,f_1 x_1+j)}{f_0 f_1} \\]

    This filter is implemented so that the starting extent of the first
    pixel of the output matches that of the input.

    The change in image geometry from a 5x5 image binned by a factor of
    2x2.

    This code was contributed in the Insight Journal paper: "BinShrink: A
    multi-resolution filter with cache efficient averaging" by Lowekamp
    B., Chen D. https://doi.org/10.54294/p39qox
    See:
     itk::simple::BinShrink for the procedural interface

     itk::BinShrinkImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinShrinkImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BinShrinkImageFilter

    def __init__(self):
        r"""
        __init__(BinShrinkImageFilter self) -> BinShrinkImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinShrinkImageFilter_swiginit(
            self, _SimpleITK.new_BinShrinkImageFilter()
        )

    def SetShrinkFactor(self, s):
        r"""
        SetShrinkFactor(BinShrinkImageFilter self, unsigned int s)


        Custom public declarations


        """
        return _SimpleITK.BinShrinkImageFilter_SetShrinkFactor(self, s)

    def SetShrinkFactors(self, ShrinkFactors):
        r"""
        SetShrinkFactors(BinShrinkImageFilter self, VectorUInt32 ShrinkFactors)


        Set the shrink factors. Values are clamped to a minimum value of 1.
        Default is 1 for all dimensions.


        """
        return _SimpleITK.BinShrinkImageFilter_SetShrinkFactors(
            self, ShrinkFactors
        )

    def GetShrinkFactors(self):
        r"""
        GetShrinkFactors(BinShrinkImageFilter self) -> VectorUInt32


        Get the shrink factors.


        """
        return _SimpleITK.BinShrinkImageFilter_GetShrinkFactors(self)

    def GetName(self):
        r"""
        GetName(BinShrinkImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinShrinkImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BinShrinkImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinShrinkImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BinShrinkImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinShrinkImageFilter_Execute(self, image1)


# Register BinShrinkImageFilter in _SimpleITK:
_SimpleITK.BinShrinkImageFilter_swigregister(BinShrinkImageFilter)


def BinShrink(*args, **kwargs):
    r"""BinShrink(Image image1, VectorUInt32 shrinkFactors=std::vector< unsigned int >(3, 1)) -> Image"""
    return _SimpleITK.BinShrink(*args, **kwargs)


class BinaryClosingByReconstructionImageFilter(ImageFilter):
    r"""


    binary closing by reconstruction of an image.


    This filter removes small (i.e., smaller than the structuring element)
    holes in the image. It is defined as: Closing(f) =
    ReconstructionByErosion(Dilation(f)).

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4


    See:
     MorphologyImageFilter , ClosingByReconstructionImageFilter , BinaryOpeningByReconstructionImageFilter

     itk::simple::BinaryClosingByReconstruction for the procedural interface

     itk::BinaryClosingByReconstructionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryClosingByReconstructionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_BinaryClosingByReconstructionImageFilter
    )

    def __init__(self):
        r"""
        __init__(BinaryClosingByReconstructionImageFilter self) -> BinaryClosingByReconstructionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryClosingByReconstructionImageFilter_swiginit(
            self, _SimpleITK.new_BinaryClosingByReconstructionImageFilter()
        )

    def SetKernelRadius(self, *args):
        r"""
        SetKernelRadius(BinaryClosingByReconstructionImageFilter self, VectorUInt32 KernelRadius)
        SetKernelRadius(BinaryClosingByReconstructionImageFilter self, unsigned int value)


        Set the values of the KernelRadius vector all to value


        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_SetKernelRadius(
            self, *args
        )

    def GetKernelRadius(self):
        r"""
        GetKernelRadius(BinaryClosingByReconstructionImageFilter self) -> VectorUInt32


        Get the radius of the kernel structuring element.


        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_GetKernelRadius(
            self
        )

    def SetKernelType(self, KernelType):
        r"""
        SetKernelType(BinaryClosingByReconstructionImageFilter self, itk::simple::KernelEnum KernelType)


        Set the kernel or structuring element used for the morphology.


        """
        return (
            _SimpleITK.BinaryClosingByReconstructionImageFilter_SetKernelType(
                self, KernelType
            )
        )

    def GetKernelType(self):
        r"""
        GetKernelType(BinaryClosingByReconstructionImageFilter self) -> itk::simple::KernelEnum


        Get the kernel or structuring element used for the morphology.


        """
        return (
            _SimpleITK.BinaryClosingByReconstructionImageFilter_GetKernelType(
                self
            )
        )

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(BinaryClosingByReconstructionImageFilter self, double ForegroundValue)


        Set the value in the image to consider as "foreground". Defaults to
        maximum value of InputPixelType.


        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(BinaryClosingByReconstructionImageFilter self) -> double


        Get the value in the image considered as "foreground". Defaults to
        maximum value of InputPixelType.


        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_GetForegroundValue(
            self
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(BinaryClosingByReconstructionImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(BinaryClosingByReconstructionImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_FullyConnectedOn(
            self
        )

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(BinaryClosingByReconstructionImageFilter self)


        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_FullyConnectedOff(
            self
        )

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(BinaryClosingByReconstructionImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_GetFullyConnected(
            self
        )

    def GetName(self):
        r"""
        GetName(BinaryClosingByReconstructionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(BinaryClosingByReconstructionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter___str__(
            self
        )

    def Execute(self, image1):
        r"""
        Execute(BinaryClosingByReconstructionImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_Execute(
            self, image1
        )


# Register BinaryClosingByReconstructionImageFilter in _SimpleITK:
_SimpleITK.BinaryClosingByReconstructionImageFilter_swigregister(
    BinaryClosingByReconstructionImageFilter
)


def BinaryClosingByReconstruction(*args, **kwargs):
    r"""BinaryClosingByReconstruction(Image image1, VectorUInt32 kernelRadius=std::vector< uint32_t >(3, 1), itk::simple::KernelEnum kernelType=sitkBall, double foregroundValue=1.0, bool fullyConnected=False) -> Image"""
    return _SimpleITK.BinaryClosingByReconstruction(*args, **kwargs)


class BinaryContourImageFilter(ImageFilter):
    r"""


    Labels the pixels on the border of the objects in a binary image.


    BinaryContourImageFilter takes a binary image as input, where the pixels in the objects are
    the pixels with a value equal to ForegroundValue. Only the pixels on
    the contours of the objects are kept. The pixels not on the border are
    changed to BackgroundValue.

    The connectivity can be changed to minimum or maximum connectivity
    with SetFullyConnected() . Full connectivity produces thicker contours.

    https://doi.org/10.54294/c7d3gv


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     LabelContourImageFilter BinaryErodeImageFilter SimpleContourExtractorImageFilter

     itk::simple::BinaryContour for the procedural interface

     itk::BinaryContourImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryContourImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BinaryContourImageFilter

    def __init__(self):
        r"""
        __init__(BinaryContourImageFilter self) -> BinaryContourImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryContourImageFilter_swiginit(
            self, _SimpleITK.new_BinaryContourImageFilter()
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(BinaryContourImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryContourImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(BinaryContourImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.BinaryContourImageFilter_FullyConnectedOn(self)

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(BinaryContourImageFilter self)


        """
        return _SimpleITK.BinaryContourImageFilter_FullyConnectedOff(self)

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(BinaryContourImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryContourImageFilter_GetFullyConnected(self)

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(BinaryContourImageFilter self, double BackgroundValue)


        Set/Get the background value used to mark the pixels not on the border
        of the objects.


        """
        return _SimpleITK.BinaryContourImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(BinaryContourImageFilter self) -> double


        Set/Get the background value used to mark the pixels not on the border
        of the objects.


        """
        return _SimpleITK.BinaryContourImageFilter_GetBackgroundValue(self)

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(BinaryContourImageFilter self, double ForegroundValue)


        Set/Get the foreground value used to identify the objects in the input
        and output images.


        """
        return _SimpleITK.BinaryContourImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(BinaryContourImageFilter self) -> double


        Set/Get the foreground value used to identify the objects in the input
        and output images.


        """
        return _SimpleITK.BinaryContourImageFilter_GetForegroundValue(self)

    def GetName(self):
        r"""
        GetName(BinaryContourImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryContourImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BinaryContourImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryContourImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BinaryContourImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinaryContourImageFilter_Execute(self, image1)


# Register BinaryContourImageFilter in _SimpleITK:
_SimpleITK.BinaryContourImageFilter_swigregister(BinaryContourImageFilter)


def BinaryContour(
    image1, fullyConnected=False, backgroundValue=0.0, foregroundValue=1.0
):
    r"""BinaryContour(Image image1, bool fullyConnected=False, double backgroundValue=0.0, double foregroundValue=1.0) -> Image"""
    return _SimpleITK.BinaryContour(
        image1, fullyConnected, backgroundValue, foregroundValue
    )


class BinaryDilateImageFilter(ImageFilter):
    r"""


    Fast binary dilation of a single intensity value in the image.


    BinaryDilateImageFilter is a binary dilation morphologic operation on the foreground of an
    image. Only the value designated by the intensity value
    "SetForegroundValue()" (alias as SetDilateValue() ) is considered as
    foreground, and other intensity values are considered background.

    Grayscale images can be processed as binary images by selecting a
    "ForegroundValue" (alias "DilateValue"). Pixel values matching the
    dilate value are considered the "foreground" and all other pixels
    are "background". This is useful in processing segmented images
    where all pixels in segment #1 have value 1 and pixels in segment #2
    have value 2, etc. A particular "segment number" can be processed.
    ForegroundValue defaults to the maximum possible value of the
    PixelType.

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel. A reasonable choice
    of structuring element is itk::BinaryBallStructuringElement .

    This implementation is based on the papers:

    L.Vincent "Morphological transformations of binary images with
    arbitrary structuring elements", and

    N.Nikopoulos et al. "An efficient algorithm for 3d binary
    morphological transformations with 3d structuring elements for
    arbitrary size and shape". IEEE Transactions on Image Processing. Vol. 9. No. 3. 2000. pp. 283-286.


    See:
     ImageToImageFilter BinaryErodeImageFilter BinaryMorphologyImageFilter

     itk::simple::BinaryDilate for the procedural interface

     itk::BinaryDilateImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryDilateImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BinaryDilateImageFilter

    def __init__(self):
        r"""
        __init__(BinaryDilateImageFilter self) -> BinaryDilateImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryDilateImageFilter_swiginit(
            self, _SimpleITK.new_BinaryDilateImageFilter()
        )

    def SetKernelRadius(self, *args):
        r"""
        SetKernelRadius(BinaryDilateImageFilter self, VectorUInt32 KernelRadius)
        SetKernelRadius(BinaryDilateImageFilter self, unsigned int value)


        Set the values of the KernelRadius vector all to value


        """
        return _SimpleITK.BinaryDilateImageFilter_SetKernelRadius(self, *args)

    def GetKernelRadius(self):
        r"""
        GetKernelRadius(BinaryDilateImageFilter self) -> VectorUInt32


        Get the radius of the kernel structuring element.


        """
        return _SimpleITK.BinaryDilateImageFilter_GetKernelRadius(self)

    def SetKernelType(self, KernelType):
        r"""
        SetKernelType(BinaryDilateImageFilter self, itk::simple::KernelEnum KernelType)


        Set the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.BinaryDilateImageFilter_SetKernelType(
            self, KernelType
        )

    def GetKernelType(self):
        r"""
        GetKernelType(BinaryDilateImageFilter self) -> itk::simple::KernelEnum


        Get the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.BinaryDilateImageFilter_GetKernelType(self)

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(BinaryDilateImageFilter self, double BackgroundValue)


        """
        return _SimpleITK.BinaryDilateImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(BinaryDilateImageFilter self) -> double


        """
        return _SimpleITK.BinaryDilateImageFilter_GetBackgroundValue(self)

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(BinaryDilateImageFilter self, double ForegroundValue)


        """
        return _SimpleITK.BinaryDilateImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(BinaryDilateImageFilter self) -> double


        """
        return _SimpleITK.BinaryDilateImageFilter_GetForegroundValue(self)

    def SetBoundaryToForeground(self, BoundaryToForeground):
        r"""
        SetBoundaryToForeground(BinaryDilateImageFilter self, bool BoundaryToForeground)


        """
        return _SimpleITK.BinaryDilateImageFilter_SetBoundaryToForeground(
            self, BoundaryToForeground
        )

    def BoundaryToForegroundOn(self):
        r"""
        BoundaryToForegroundOn(BinaryDilateImageFilter self)


        Set the value of BoundaryToForeground to true or false respectfully.


        """
        return _SimpleITK.BinaryDilateImageFilter_BoundaryToForegroundOn(self)

    def BoundaryToForegroundOff(self):
        r"""
        BoundaryToForegroundOff(BinaryDilateImageFilter self)


        """
        return _SimpleITK.BinaryDilateImageFilter_BoundaryToForegroundOff(self)

    def GetBoundaryToForeground(self):
        r"""
        GetBoundaryToForeground(BinaryDilateImageFilter self) -> bool


        """
        return _SimpleITK.BinaryDilateImageFilter_GetBoundaryToForeground(self)

    def GetName(self):
        r"""
        GetName(BinaryDilateImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryDilateImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BinaryDilateImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryDilateImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BinaryDilateImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinaryDilateImageFilter_Execute(self, image1)


# Register BinaryDilateImageFilter in _SimpleITK:
_SimpleITK.BinaryDilateImageFilter_swigregister(BinaryDilateImageFilter)


def BinaryDilate(*args, **kwargs):
    r"""BinaryDilate(Image image1, VectorUInt32 kernelRadius=std::vector< uint32_t >(3, 1), itk::simple::KernelEnum kernelType=sitkBall, double backgroundValue=0.0, double foregroundValue=1.0, bool boundaryToForeground=False) -> Image"""
    return _SimpleITK.BinaryDilate(*args, **kwargs)


class BinaryErodeImageFilter(ImageFilter):
    r"""


    Fast binary erosion of a single intensity value in the image.


    BinaryErodeImageFilter is a binary erosion morphologic operation on the foreground of an
    image. Only the value designated by the intensity value
    "SetForegroundValue()" (alias as SetErodeValue() ) is considered as
    foreground, and other intensity values are considered background.

    Grayscale images can be processed as binary images by selecting a
    "ForegroundValue" (alias "ErodeValue"). Pixel values matching the
    erode value are considered the "foreground" and all other pixels are
    "background". This is useful in processing segmented images where
    all pixels in segment #1 have value 1 and pixels in segment #2 have
    value 2, etc. A particular "segment number" can be processed.
    ForegroundValue defaults to the maximum possible value of the
    PixelType. The eroded pixels will receive the BackgroundValue
    (defaults to NumericTraits::NonpositiveMin() ).

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel. A reasonable choice
    of structuring element is itk::BinaryBallStructuringElement .

    This implementation is based on the papers:

    L.Vincent "Morphological transformations of binary images with
    arbitrary structuring elements", and

    N.Nikopoulos et al. "An efficient algorithm for 3d binary
    morphological transformations with 3d structuring elements for
    arbitrary size and shape". IEEE Transactions on Image Processing. Vol. 9. No. 3. 2000. pp. 283-286.


    See:
     ImageToImageFilter BinaryDilateImageFilter BinaryMorphologyImageFilter

     itk::simple::BinaryErode for the procedural interface

     itk::BinaryErodeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryErodeImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BinaryErodeImageFilter

    def __init__(self):
        r"""
        __init__(BinaryErodeImageFilter self) -> BinaryErodeImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryErodeImageFilter_swiginit(
            self, _SimpleITK.new_BinaryErodeImageFilter()
        )

    def SetKernelRadius(self, *args):
        r"""
        SetKernelRadius(BinaryErodeImageFilter self, VectorUInt32 KernelRadius)
        SetKernelRadius(BinaryErodeImageFilter self, unsigned int value)


        Set the values of the KernelRadius vector all to value


        """
        return _SimpleITK.BinaryErodeImageFilter_SetKernelRadius(self, *args)

    def GetKernelRadius(self):
        r"""
        GetKernelRadius(BinaryErodeImageFilter self) -> VectorUInt32


        Get the radius of the kernel structuring element.


        """
        return _SimpleITK.BinaryErodeImageFilter_GetKernelRadius(self)

    def SetKernelType(self, KernelType):
        r"""
        SetKernelType(BinaryErodeImageFilter self, itk::simple::KernelEnum KernelType)


        Set the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.BinaryErodeImageFilter_SetKernelType(
            self, KernelType
        )

    def GetKernelType(self):
        r"""
        GetKernelType(BinaryErodeImageFilter self) -> itk::simple::KernelEnum


        Get the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.BinaryErodeImageFilter_GetKernelType(self)

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(BinaryErodeImageFilter self, double BackgroundValue)


        """
        return _SimpleITK.BinaryErodeImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(BinaryErodeImageFilter self) -> double


        """
        return _SimpleITK.BinaryErodeImageFilter_GetBackgroundValue(self)

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(BinaryErodeImageFilter self, double ForegroundValue)


        """
        return _SimpleITK.BinaryErodeImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(BinaryErodeImageFilter self) -> double


        """
        return _SimpleITK.BinaryErodeImageFilter_GetForegroundValue(self)

    def SetBoundaryToForeground(self, BoundaryToForeground):
        r"""
        SetBoundaryToForeground(BinaryErodeImageFilter self, bool BoundaryToForeground)


        """
        return _SimpleITK.BinaryErodeImageFilter_SetBoundaryToForeground(
            self, BoundaryToForeground
        )

    def BoundaryToForegroundOn(self):
        r"""
        BoundaryToForegroundOn(BinaryErodeImageFilter self)


        Set the value of BoundaryToForeground to true or false respectfully.


        """
        return _SimpleITK.BinaryErodeImageFilter_BoundaryToForegroundOn(self)

    def BoundaryToForegroundOff(self):
        r"""
        BoundaryToForegroundOff(BinaryErodeImageFilter self)


        """
        return _SimpleITK.BinaryErodeImageFilter_BoundaryToForegroundOff(self)

    def GetBoundaryToForeground(self):
        r"""
        GetBoundaryToForeground(BinaryErodeImageFilter self) -> bool


        """
        return _SimpleITK.BinaryErodeImageFilter_GetBoundaryToForeground(self)

    def GetName(self):
        r"""
        GetName(BinaryErodeImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryErodeImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BinaryErodeImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryErodeImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BinaryErodeImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinaryErodeImageFilter_Execute(self, image1)


# Register BinaryErodeImageFilter in _SimpleITK:
_SimpleITK.BinaryErodeImageFilter_swigregister(BinaryErodeImageFilter)


def BinaryErode(*args, **kwargs):
    r"""BinaryErode(Image image1, VectorUInt32 kernelRadius=std::vector< uint32_t >(3, 1), itk::simple::KernelEnum kernelType=sitkBall, double backgroundValue=0.0, double foregroundValue=1.0, bool boundaryToForeground=True) -> Image"""
    return _SimpleITK.BinaryErode(*args, **kwargs)


class BinaryFillholeImageFilter(ImageFilter):
    r"""


    Remove holes not connected to the boundary of the image.


    BinaryFillholeImageFilter fills holes in a binary image.

    Geodesic morphology and the Fillhole algorithm is described in Chapter
    6 of Pierre Soille's book "Morphological Image Analysis: Principles
    and Applications", Second Edition, Springer, 2003.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4


    See:
     GrayscaleFillholeImageFilter

     itk::simple::BinaryFillhole for the procedural interface

     itk::BinaryFillholeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryFillholeImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BinaryFillholeImageFilter

    def __init__(self):
        r"""
        __init__(BinaryFillholeImageFilter self) -> BinaryFillholeImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryFillholeImageFilter_swiginit(
            self, _SimpleITK.new_BinaryFillholeImageFilter()
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(BinaryFillholeImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryFillholeImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(BinaryFillholeImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.BinaryFillholeImageFilter_FullyConnectedOn(self)

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(BinaryFillholeImageFilter self)


        """
        return _SimpleITK.BinaryFillholeImageFilter_FullyConnectedOff(self)

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(BinaryFillholeImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryFillholeImageFilter_GetFullyConnected(self)

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(BinaryFillholeImageFilter self, double ForegroundValue)


        Set the value in the image to consider as "foreground". Defaults to
        maximum value of InputPixelType.


        """
        return _SimpleITK.BinaryFillholeImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(BinaryFillholeImageFilter self) -> double


        Get the value in the image considered as "foreground". Defaults to
        maximum value of InputPixelType.


        """
        return _SimpleITK.BinaryFillholeImageFilter_GetForegroundValue(self)

    def GetName(self):
        r"""
        GetName(BinaryFillholeImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryFillholeImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BinaryFillholeImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryFillholeImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BinaryFillholeImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinaryFillholeImageFilter_Execute(self, image1)


# Register BinaryFillholeImageFilter in _SimpleITK:
_SimpleITK.BinaryFillholeImageFilter_swigregister(BinaryFillholeImageFilter)


def BinaryFillhole(image1, fullyConnected=False, foregroundValue=1.0):
    r"""BinaryFillhole(Image image1, bool fullyConnected=False, double foregroundValue=1.0) -> Image"""
    return _SimpleITK.BinaryFillhole(image1, fullyConnected, foregroundValue)


class BinaryGrindPeakImageFilter(ImageFilter):
    r"""


    Remove the objects not connected to the boundary of the image.


    BinaryGrindPeakImageFilter grinds peaks in a grayscale image.

    Geodesic morphology and the grind peak algorithm is described in
    Chapter 6 of Pierre Soille's book "Morphological Image Analysis:
    Principles and Applications", Second Edition, Springer, 2003.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4


    See:
     GrayscaleGrindPeakImageFilter

     itk::simple::BinaryGrindPeak for the procedural interface

     itk::BinaryGrindPeakImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryGrindPeakImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BinaryGrindPeakImageFilter

    def __init__(self):
        r"""
        __init__(BinaryGrindPeakImageFilter self) -> BinaryGrindPeakImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryGrindPeakImageFilter_swiginit(
            self, _SimpleITK.new_BinaryGrindPeakImageFilter()
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(BinaryGrindPeakImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryGrindPeakImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(BinaryGrindPeakImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.BinaryGrindPeakImageFilter_FullyConnectedOn(self)

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(BinaryGrindPeakImageFilter self)


        """
        return _SimpleITK.BinaryGrindPeakImageFilter_FullyConnectedOff(self)

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(BinaryGrindPeakImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryGrindPeakImageFilter_GetFullyConnected(self)

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(BinaryGrindPeakImageFilter self, double ForegroundValue)


        Set the value in the image to consider as "foreground". Defaults to
        maximum value of InputPixelType.


        """
        return _SimpleITK.BinaryGrindPeakImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(BinaryGrindPeakImageFilter self) -> double


        Get the value in the image considered as "foreground". Defaults to
        maximum value of InputPixelType.


        """
        return _SimpleITK.BinaryGrindPeakImageFilter_GetForegroundValue(self)

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(BinaryGrindPeakImageFilter self, double BackgroundValue)


        Set the value in eroded part of the image. Defaults to zero


        """
        return _SimpleITK.BinaryGrindPeakImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(BinaryGrindPeakImageFilter self) -> double


        Set the value in eroded part of the image. Defaults to zero


        """
        return _SimpleITK.BinaryGrindPeakImageFilter_GetBackgroundValue(self)

    def GetName(self):
        r"""
        GetName(BinaryGrindPeakImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryGrindPeakImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BinaryGrindPeakImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryGrindPeakImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BinaryGrindPeakImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinaryGrindPeakImageFilter_Execute(self, image1)


# Register BinaryGrindPeakImageFilter in _SimpleITK:
_SimpleITK.BinaryGrindPeakImageFilter_swigregister(BinaryGrindPeakImageFilter)


def BinaryGrindPeak(
    image1, fullyConnected=False, foregroundValue=1.0, backgroundValue=0
):
    r"""BinaryGrindPeak(Image image1, bool fullyConnected=False, double foregroundValue=1.0, double backgroundValue=0) -> Image"""
    return _SimpleITK.BinaryGrindPeak(
        image1, fullyConnected, foregroundValue, backgroundValue
    )


class BinaryImageToLabelMapFilter(ImageFilter):
    r"""


    Label the connected components in a binary image and produce a collection
    of label objects.


    BinaryImageToLabelMapFilter labels the objects in a binary image. Each distinct object is
    assigned a unique label. The final object labels start with 1 and are
    consecutive. Objects that are reached earlier by a raster order scan
    have a lower label.

    The GetOutput() function of this class returns an itk::LabelMap .

    This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ConnectedComponentImageFilter , LabelImageToLabelMapFilter , LabelMap , LabelObject

     itk::simple::BinaryImageToLabelMapFilter for the procedural interface

     itk::BinaryImageToLabelMapFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryImageToLabelMapFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BinaryImageToLabelMapFilter

    def __init__(self):
        r"""
        __init__(BinaryImageToLabelMapFilter self) -> BinaryImageToLabelMapFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryImageToLabelMapFilter_swiginit(
            self, _SimpleITK.new_BinaryImageToLabelMapFilter()
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(BinaryImageToLabelMapFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryImageToLabelMapFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(BinaryImageToLabelMapFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.BinaryImageToLabelMapFilter_FullyConnectedOn(self)

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(BinaryImageToLabelMapFilter self)


        """
        return _SimpleITK.BinaryImageToLabelMapFilter_FullyConnectedOff(self)

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(BinaryImageToLabelMapFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryImageToLabelMapFilter_GetFullyConnected(self)

    def SetInputForegroundValue(self, InputForegroundValue):
        r"""
        SetInputForegroundValue(BinaryImageToLabelMapFilter self, double InputForegroundValue)


        Set/Get the value to be consider "foreground" in the input image.
        Defaults to NumericTraits<InputPixelType>::max() .


        """
        return _SimpleITK.BinaryImageToLabelMapFilter_SetInputForegroundValue(
            self, InputForegroundValue
        )

    def GetInputForegroundValue(self):
        r"""
        GetInputForegroundValue(BinaryImageToLabelMapFilter self) -> double


        Set/Get the value to be consider "foreground" in the input image.
        Defaults to NumericTraits<InputPixelType>::max() .


        """
        return _SimpleITK.BinaryImageToLabelMapFilter_GetInputForegroundValue(
            self
        )

    def SetOutputBackgroundValue(self, OutputBackgroundValue):
        r"""
        SetOutputBackgroundValue(BinaryImageToLabelMapFilter self, double OutputBackgroundValue)


        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<OutputPixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryImageToLabelMapFilter_SetOutputBackgroundValue(
            self, OutputBackgroundValue
        )

    def GetOutputBackgroundValue(self):
        r"""
        GetOutputBackgroundValue(BinaryImageToLabelMapFilter self) -> double


        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<OutputPixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryImageToLabelMapFilter_GetOutputBackgroundValue(
            self
        )

    def GetNumberOfObjects(self):
        r"""
        GetNumberOfObjects(BinaryImageToLabelMapFilter self) -> uint64_t


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.BinaryImageToLabelMapFilter_GetNumberOfObjects(self)

    def GetName(self):
        r"""
        GetName(BinaryImageToLabelMapFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryImageToLabelMapFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BinaryImageToLabelMapFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryImageToLabelMapFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BinaryImageToLabelMapFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinaryImageToLabelMapFilter_Execute(self, image1)


# Register BinaryImageToLabelMapFilter in _SimpleITK:
_SimpleITK.BinaryImageToLabelMapFilter_swigregister(
    BinaryImageToLabelMapFilter
)


def BinaryImageToLabelMap(
    image1,
    fullyConnected=False,
    inputForegroundValue=1.0,
    outputBackgroundValue=0.0,
):
    r"""BinaryImageToLabelMap(Image image1, bool fullyConnected=False, double inputForegroundValue=1.0, double outputBackgroundValue=0.0) -> Image"""
    return _SimpleITK.BinaryImageToLabelMap(
        image1, fullyConnected, inputForegroundValue, outputBackgroundValue
    )


class BinaryMagnitudeImageFilter(ImageFilter):
    r"""


    Computes the square root of the sum of squares of corresponding input
    pixels.


    This filter is templated over the types of the two input images and
    the type of the output image.

    Numeric conversions (castings) are done by the C++ defaults.

    The filter walks over all of the pixels in the two input images, and
    for each pixel does the following:


    cast the input 1 pixel value to double

    cast the input 2 pixel value to double

    compute the sum of squares of the two pixel values

    compute the square root of the sum

    cast the double value resulting from std::sqrt() to the pixel type of
    the output image

    store the cast value into the output image.
     The filter expects all images to have the same dimension (e.g. all
    2D, or all 3D, or all ND)
    See:
     itk::simple::BinaryMagnitude for the procedural interface

     itk::BinaryMagnitudeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryMagnitudeImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BinaryMagnitudeImageFilter

    def __init__(self):
        r"""
        __init__(BinaryMagnitudeImageFilter self) -> BinaryMagnitudeImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryMagnitudeImageFilter_swiginit(
            self, _SimpleITK.new_BinaryMagnitudeImageFilter()
        )

    def GetName(self):
        r"""
        GetName(BinaryMagnitudeImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryMagnitudeImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BinaryMagnitudeImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryMagnitudeImageFilter___str__(self)

    def Execute(self, image1, image2):
        r"""
        Execute(BinaryMagnitudeImageFilter self, Image image1, Image image2) -> Image


        Execute the filter on the input images


        """
        return _SimpleITK.BinaryMagnitudeImageFilter_Execute(
            self, image1, image2
        )


# Register BinaryMagnitudeImageFilter in _SimpleITK:
_SimpleITK.BinaryMagnitudeImageFilter_swigregister(BinaryMagnitudeImageFilter)


def BinaryMagnitude(image1, image2):
    r"""BinaryMagnitude(Image image1, Image image2) -> Image"""
    return _SimpleITK.BinaryMagnitude(image1, image2)


class BinaryMedianImageFilter(ImageFilter):
    r"""


    Applies a version of the median filter optimized for binary images.


    This filter was contributed by Bjorn Hanch Sollie after identifying
    that the generic Median filter performed unnecessary operations when
    the input image is binary.

    This filter computes an image where a given pixel is the median value
    of the pixels in a neighborhood about the corresponding input pixel.
    For the case of binary images the median can be obtained by simply
    counting the neighbors that are foreground.

    A median filter is one of the family of nonlinear filters. It is used
    to smooth an image without being biased by outliers or shot noise.


    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     itk::simple::BinaryMedian for the procedural interface

     itk::BinaryMedianImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryMedianImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BinaryMedianImageFilter

    def __init__(self):
        r"""
        __init__(BinaryMedianImageFilter self) -> BinaryMedianImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryMedianImageFilter_swiginit(
            self, _SimpleITK.new_BinaryMedianImageFilter()
        )

    def SetRadius(self, *args):
        r"""
        SetRadius(BinaryMedianImageFilter self, VectorUInt32 Radius)
        SetRadius(BinaryMedianImageFilter self, unsigned int value)


        Set the values of the Radius vector all to value


        """
        return _SimpleITK.BinaryMedianImageFilter_SetRadius(self, *args)

    def GetRadius(self):
        r"""
        GetRadius(BinaryMedianImageFilter self) -> VectorUInt32


        Get the radius of the neighborhood used to compute the median


        """
        return _SimpleITK.BinaryMedianImageFilter_GetRadius(self)

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(BinaryMedianImageFilter self, double ForegroundValue)


        Set the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.BinaryMedianImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(BinaryMedianImageFilter self) -> double


        Get the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.BinaryMedianImageFilter_GetForegroundValue(self)

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(BinaryMedianImageFilter self, double BackgroundValue)


        Set the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.BinaryMedianImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(BinaryMedianImageFilter self) -> double


        Get the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.BinaryMedianImageFilter_GetBackgroundValue(self)

    def GetName(self):
        r"""
        GetName(BinaryMedianImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryMedianImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BinaryMedianImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryMedianImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BinaryMedianImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinaryMedianImageFilter_Execute(self, image1)


# Register BinaryMedianImageFilter in _SimpleITK:
_SimpleITK.BinaryMedianImageFilter_swigregister(BinaryMedianImageFilter)


def BinaryMedian(*args, **kwargs):
    r"""BinaryMedian(Image image1, VectorUInt32 radius=std::vector< unsigned int >(3, 1), double foregroundValue=1.0, double backgroundValue=0.0) -> Image"""
    return _SimpleITK.BinaryMedian(*args, **kwargs)


class BinaryMinMaxCurvatureFlowImageFilter(ImageFilter):
    r"""


    Denoise a binary image using min/max curvature flow.


    BinaryMinMaxCurvatureFlowImageFilter implements a curvature driven image denoising algorithm. This filter
    assumes that the image is essentially binary: consisting of two
    classes. Iso-brightness contours in the input image are viewed as a
    level set. The level set is then evolved using a curvature-based speed
    function:

    \\[ I_t = F_{\\mbox{minmax}} |\\nabla I| \\]

    where $ F_{\\mbox{minmax}} = \\min(\\kappa,0) $ if $ \\mbox{Avg}_{\\mbox{stencil}}(x) $ is less than or equal to $ T_{threshold} $ and $ \\max(\\kappa,0) $ , otherwise. $ \\kappa $ is the mean curvature of the iso-brightness contour at point $ x $ .

    In min/max curvature flow, movement is turned on or off depending on
    the scale of the noise one wants to remove. Switching depends on the
    average image value of a region of radius $ R $ around each point. The choice of $ R $ , the stencil radius, governs the scale of the noise to be removed.

    The threshold value $ T_{threshold} $ is a user specified value which discriminates between the two pixel
    classes.

    This filter make use of the multi-threaded finite difference solver
    hierarchy. Updates are computed using a BinaryMinMaxCurvatureFlowFunction object. A zero flux Neumann boundary condition is used when computing
    derivatives near the data boundary.


    WARNING:
    This filter assumes that the input and output types have the same
    dimensions. This filter also requires that the output image pixels are
    of a real type. This filter works for any dimensional images.
     Reference: "Level Set Methods and Fast Marching Methods", J.A.
    Sethian, Cambridge Press, Chapter 16, Second edition, 1999.


    See:
     BinaryMinMaxCurvatureFlowFunction

     CurvatureFlowImageFilter

     MinMaxCurvatureFlowImageFilter

     itk::simple::BinaryMinMaxCurvatureFlow for the procedural interface

     itk::BinaryMinMaxCurvatureFlowImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryMinMaxCurvatureFlowImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BinaryMinMaxCurvatureFlowImageFilter

    def __init__(self):
        r"""
        __init__(BinaryMinMaxCurvatureFlowImageFilter self) -> BinaryMinMaxCurvatureFlowImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_swiginit(
            self, _SimpleITK.new_BinaryMinMaxCurvatureFlowImageFilter()
        )

    def SetTimeStep(self, TimeStep):
        r"""
        SetTimeStep(BinaryMinMaxCurvatureFlowImageFilter self, double TimeStep)


        """
        return _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_SetTimeStep(
            self, TimeStep
        )

    def GetTimeStep(self):
        r"""
        GetTimeStep(BinaryMinMaxCurvatureFlowImageFilter self) -> double


        """
        return _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_GetTimeStep(
            self
        )

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(BinaryMinMaxCurvatureFlowImageFilter self, uint32_t NumberOfIterations)


        """
        return _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(BinaryMinMaxCurvatureFlowImageFilter self) -> uint32_t


        """
        return _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_GetNumberOfIterations(
            self
        )

    def SetStencilRadius(self, StencilRadius):
        r"""
        SetStencilRadius(BinaryMinMaxCurvatureFlowImageFilter self, int StencilRadius)


        """
        return (
            _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_SetStencilRadius(
                self, StencilRadius
            )
        )

    def GetStencilRadius(self):
        r"""
        GetStencilRadius(BinaryMinMaxCurvatureFlowImageFilter self) -> int


        """
        return (
            _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_GetStencilRadius(
                self
            )
        )

    def SetThreshold(self, Threshold):
        r"""
        SetThreshold(BinaryMinMaxCurvatureFlowImageFilter self, double Threshold)


        Set/Get the threshold value.


        """
        return _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_SetThreshold(
            self, Threshold
        )

    def GetThreshold(self):
        r"""
        GetThreshold(BinaryMinMaxCurvatureFlowImageFilter self) -> double


        Set/Get the threshold value.


        """
        return _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_GetThreshold(
            self
        )

    def GetName(self):
        r"""
        GetName(BinaryMinMaxCurvatureFlowImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BinaryMinMaxCurvatureFlowImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BinaryMinMaxCurvatureFlowImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_Execute(
            self, image1
        )


# Register BinaryMinMaxCurvatureFlowImageFilter in _SimpleITK:
_SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_swigregister(
    BinaryMinMaxCurvatureFlowImageFilter
)


def BinaryMinMaxCurvatureFlow(
    image1, timeStep=0.05, numberOfIterations=5, stencilRadius=2, threshold=0.0
):
    r"""BinaryMinMaxCurvatureFlow(Image image1, double timeStep=0.05, uint32_t numberOfIterations=5, int stencilRadius=2, double threshold=0.0) -> Image"""
    return _SimpleITK.BinaryMinMaxCurvatureFlow(
        image1, timeStep, numberOfIterations, stencilRadius, threshold
    )


class BinaryMorphologicalClosingImageFilter(ImageFilter):
    r"""


    binary morphological closing of an image.


    This filter removes small (i.e., smaller than the structuring element)
    holes and tube like structures in the interior or at the boundaries of
    the image. The morphological closing of an image "f" is defined as:
    Closing(f) = Erosion(Dilation(f)).

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel.

    This code was contributed in the Insight Journal paper: "Binary
    morphological closing and opening image filters" by Lehmann G. https://doi.org/10.54294/bcwtvq


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleErodeImageFilter

     itk::simple::BinaryMorphologicalClosing for the procedural interface

     itk::BinaryMorphologicalClosingImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryMorphologicalClosingImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BinaryMorphologicalClosingImageFilter

    def __init__(self):
        r"""
        __init__(BinaryMorphologicalClosingImageFilter self) -> BinaryMorphologicalClosingImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryMorphologicalClosingImageFilter_swiginit(
            self, _SimpleITK.new_BinaryMorphologicalClosingImageFilter()
        )

    def SetKernelRadius(self, *args):
        r"""
        SetKernelRadius(BinaryMorphologicalClosingImageFilter self, VectorUInt32 KernelRadius)
        SetKernelRadius(BinaryMorphologicalClosingImageFilter self, unsigned int value)


        Set the values of the KernelRadius vector all to value


        """
        return (
            _SimpleITK.BinaryMorphologicalClosingImageFilter_SetKernelRadius(
                self, *args
            )
        )

    def GetKernelRadius(self):
        r"""
        GetKernelRadius(BinaryMorphologicalClosingImageFilter self) -> VectorUInt32


        Get the radius of the kernel structuring element.


        """
        return (
            _SimpleITK.BinaryMorphologicalClosingImageFilter_GetKernelRadius(
                self
            )
        )

    def SetKernelType(self, KernelType):
        r"""
        SetKernelType(BinaryMorphologicalClosingImageFilter self, itk::simple::KernelEnum KernelType)


        Set the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_SetKernelType(
            self, KernelType
        )

    def GetKernelType(self):
        r"""
        GetKernelType(BinaryMorphologicalClosingImageFilter self) -> itk::simple::KernelEnum


        Get the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_GetKernelType(
            self
        )

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(BinaryMorphologicalClosingImageFilter self, double ForegroundValue)


        Set the value in the image to consider as "foreground". Defaults to
        maximum value of InputPixelType.


        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(BinaryMorphologicalClosingImageFilter self) -> double


        Get the value in the image considered as "foreground". Defaults to
        maximum value of InputPixelType.


        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_GetForegroundValue(
            self
        )

    def SetSafeBorder(self, SafeBorder):
        r"""
        SetSafeBorder(BinaryMorphologicalClosingImageFilter self, bool SafeBorder)


        A safe border is added to input image to avoid borders effects and
        remove it once the closing is done


        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_SetSafeBorder(
            self, SafeBorder
        )

    def SafeBorderOn(self):
        r"""
        SafeBorderOn(BinaryMorphologicalClosingImageFilter self)


        Set the value of SafeBorder to true or false respectfully.


        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_SafeBorderOn(
            self
        )

    def SafeBorderOff(self):
        r"""
        SafeBorderOff(BinaryMorphologicalClosingImageFilter self)


        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_SafeBorderOff(
            self
        )

    def GetSafeBorder(self):
        r"""
        GetSafeBorder(BinaryMorphologicalClosingImageFilter self) -> bool


        A safe border is added to input image to avoid borders effects and
        remove it once the closing is done


        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_GetSafeBorder(
            self
        )

    def GetName(self):
        r"""
        GetName(BinaryMorphologicalClosingImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BinaryMorphologicalClosingImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BinaryMorphologicalClosingImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_Execute(
            self, image1
        )


# Register BinaryMorphologicalClosingImageFilter in _SimpleITK:
_SimpleITK.BinaryMorphologicalClosingImageFilter_swigregister(
    BinaryMorphologicalClosingImageFilter
)


def BinaryMorphologicalClosing(*args, **kwargs):
    r"""BinaryMorphologicalClosing(Image image1, VectorUInt32 kernelRadius=std::vector< uint32_t >(3, 1), itk::simple::KernelEnum kernelType=sitkBall, double foregroundValue=1.0, bool safeBorder=True) -> Image"""
    return _SimpleITK.BinaryMorphologicalClosing(*args, **kwargs)


class BinaryMorphologicalOpeningImageFilter(ImageFilter):
    r"""


    binary morphological opening of an image.


    This filter removes small (i.e., smaller than the structuring element)
    structures in the interior or at the boundaries of the image. The
    morphological opening of an image "f" is defined as: Opening(f) =
    Dilatation(Erosion(f)).

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel.

    This code was contributed in the Insight Journal paper: "Binary
    morphological closing and opening image filters" by Lehmann G. https://doi.org/10.54294/bcwtvq


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleErodeImageFilter

     itk::simple::BinaryMorphologicalOpening for the procedural interface

     itk::BinaryMorphologicalOpeningImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryMorphologicalOpeningImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BinaryMorphologicalOpeningImageFilter

    def __init__(self):
        r"""
        __init__(BinaryMorphologicalOpeningImageFilter self) -> BinaryMorphologicalOpeningImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryMorphologicalOpeningImageFilter_swiginit(
            self, _SimpleITK.new_BinaryMorphologicalOpeningImageFilter()
        )

    def SetKernelRadius(self, *args):
        r"""
        SetKernelRadius(BinaryMorphologicalOpeningImageFilter self, VectorUInt32 KernelRadius)
        SetKernelRadius(BinaryMorphologicalOpeningImageFilter self, unsigned int value)


        Set the values of the KernelRadius vector all to value


        """
        return (
            _SimpleITK.BinaryMorphologicalOpeningImageFilter_SetKernelRadius(
                self, *args
            )
        )

    def GetKernelRadius(self):
        r"""
        GetKernelRadius(BinaryMorphologicalOpeningImageFilter self) -> VectorUInt32


        Get the radius of the kernel structuring element.


        """
        return (
            _SimpleITK.BinaryMorphologicalOpeningImageFilter_GetKernelRadius(
                self
            )
        )

    def SetKernelType(self, KernelType):
        r"""
        SetKernelType(BinaryMorphologicalOpeningImageFilter self, itk::simple::KernelEnum KernelType)


        Set the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.BinaryMorphologicalOpeningImageFilter_SetKernelType(
            self, KernelType
        )

    def GetKernelType(self):
        r"""
        GetKernelType(BinaryMorphologicalOpeningImageFilter self) -> itk::simple::KernelEnum


        Get the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.BinaryMorphologicalOpeningImageFilter_GetKernelType(
            self
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(BinaryMorphologicalOpeningImageFilter self, double BackgroundValue)


        Set the value in eroded part of the image. Defaults to zero


        """
        return _SimpleITK.BinaryMorphologicalOpeningImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(BinaryMorphologicalOpeningImageFilter self) -> double


        Set the value in eroded part of the image. Defaults to zero


        """
        return _SimpleITK.BinaryMorphologicalOpeningImageFilter_GetBackgroundValue(
            self
        )

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(BinaryMorphologicalOpeningImageFilter self, double ForegroundValue)


        Set the value in the image to consider as "foreground". Defaults to
        maximum value of PixelType.


        """
        return _SimpleITK.BinaryMorphologicalOpeningImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(BinaryMorphologicalOpeningImageFilter self) -> double


        Get the value in the image considered as "foreground". Defaults to
        maximum value of PixelType.


        """
        return _SimpleITK.BinaryMorphologicalOpeningImageFilter_GetForegroundValue(
            self
        )

    def GetName(self):
        r"""
        GetName(BinaryMorphologicalOpeningImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryMorphologicalOpeningImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BinaryMorphologicalOpeningImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryMorphologicalOpeningImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BinaryMorphologicalOpeningImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinaryMorphologicalOpeningImageFilter_Execute(
            self, image1
        )


# Register BinaryMorphologicalOpeningImageFilter in _SimpleITK:
_SimpleITK.BinaryMorphologicalOpeningImageFilter_swigregister(
    BinaryMorphologicalOpeningImageFilter
)


def BinaryMorphologicalOpening(*args, **kwargs):
    r"""BinaryMorphologicalOpening(Image image1, VectorUInt32 kernelRadius=std::vector< uint32_t >(3, 1), itk::simple::KernelEnum kernelType=sitkBall, double backgroundValue=0.0, double foregroundValue=1.0) -> Image"""
    return _SimpleITK.BinaryMorphologicalOpening(*args, **kwargs)


class BinaryNotImageFilter(ImageFilter):
    r"""


    Implements the BinaryNot logical operator pixel-wise between two
    images.


    This class is parameterized over the types of the two input images and
    the type of the output image. Numeric conversions (castings) are done
    by the C++ defaults.

    The total operation over one pixel will be

    output_pixel = static_cast<PixelType>( input1_pixel != input2_pixel )

    Where "!=" is the equality operator in C++.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4
    See:
     itk::simple::BinaryNot for the procedural interface

     itk::BinaryNotImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryNotImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BinaryNotImageFilter

    def __init__(self):
        r"""
        __init__(BinaryNotImageFilter self) -> BinaryNotImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryNotImageFilter_swiginit(
            self, _SimpleITK.new_BinaryNotImageFilter()
        )

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(BinaryNotImageFilter self, double ForegroundValue)


        Set/Get the value in the image considered as "foreground". Defaults
        to maximum value of PixelType.


        """
        return _SimpleITK.BinaryNotImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(BinaryNotImageFilter self) -> double


        Set/Get the value in the image considered as "foreground". Defaults
        to maximum value of PixelType.


        """
        return _SimpleITK.BinaryNotImageFilter_GetForegroundValue(self)

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(BinaryNotImageFilter self, double BackgroundValue)


        Set/Get the value used as "background". Defaults to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryNotImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(BinaryNotImageFilter self) -> double


        Set/Get the value used as "background". Defaults to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryNotImageFilter_GetBackgroundValue(self)

    def GetName(self):
        r"""
        GetName(BinaryNotImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryNotImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BinaryNotImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryNotImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BinaryNotImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinaryNotImageFilter_Execute(self, image1)


# Register BinaryNotImageFilter in _SimpleITK:
_SimpleITK.BinaryNotImageFilter_swigregister(BinaryNotImageFilter)


def BinaryNot(image1, foregroundValue=1.0, backgroundValue=0.0):
    r"""BinaryNot(Image image1, double foregroundValue=1.0, double backgroundValue=0.0) -> Image"""
    return _SimpleITK.BinaryNot(image1, foregroundValue, backgroundValue)


class BinaryOpeningByReconstructionImageFilter(ImageFilter):
    r"""


    binary morphological closing of an image.


    This filter removes small (i.e., smaller than the structuring element)
    objects in the image. It is defined as: Opening(f) =
    ReconstructionByDilatation(Erosion(f)).

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4


    See:
     MorphologyImageFilter , OpeningByReconstructionImageFilter , BinaryClosingByReconstructionImageFilter

     itk::simple::BinaryOpeningByReconstruction for the procedural interface

     itk::BinaryOpeningByReconstructionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryOpeningByReconstructionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_BinaryOpeningByReconstructionImageFilter
    )

    def __init__(self):
        r"""
        __init__(BinaryOpeningByReconstructionImageFilter self) -> BinaryOpeningByReconstructionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryOpeningByReconstructionImageFilter_swiginit(
            self, _SimpleITK.new_BinaryOpeningByReconstructionImageFilter()
        )

    def SetKernelRadius(self, *args):
        r"""
        SetKernelRadius(BinaryOpeningByReconstructionImageFilter self, VectorUInt32 KernelRadius)
        SetKernelRadius(BinaryOpeningByReconstructionImageFilter self, unsigned int value)


        Set the values of the KernelRadius vector all to value


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_SetKernelRadius(
            self, *args
        )

    def GetKernelRadius(self):
        r"""
        GetKernelRadius(BinaryOpeningByReconstructionImageFilter self) -> VectorUInt32


        Get the radius of the kernel structuring element.


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_GetKernelRadius(
            self
        )

    def SetKernelType(self, KernelType):
        r"""
        SetKernelType(BinaryOpeningByReconstructionImageFilter self, itk::simple::KernelEnum KernelType)


        Set the kernel or structuring element used for the morphology.


        """
        return (
            _SimpleITK.BinaryOpeningByReconstructionImageFilter_SetKernelType(
                self, KernelType
            )
        )

    def GetKernelType(self):
        r"""
        GetKernelType(BinaryOpeningByReconstructionImageFilter self) -> itk::simple::KernelEnum


        Get the kernel or structuring element used for the morphology.


        """
        return (
            _SimpleITK.BinaryOpeningByReconstructionImageFilter_GetKernelType(
                self
            )
        )

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(BinaryOpeningByReconstructionImageFilter self, double ForegroundValue)


        Set the value in the image to consider as "foreground". Defaults to
        maximum value of PixelType.


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(BinaryOpeningByReconstructionImageFilter self) -> double


        Get the value in the image considered as "foreground". Defaults to
        maximum value of PixelType.


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_GetForegroundValue(
            self
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(BinaryOpeningByReconstructionImageFilter self, double BackgroundValue)


        Set the value in eroded part of the image. Defaults to zero


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(BinaryOpeningByReconstructionImageFilter self) -> double


        Set the value in eroded part of the image. Defaults to zero


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_GetBackgroundValue(
            self
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(BinaryOpeningByReconstructionImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(BinaryOpeningByReconstructionImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_FullyConnectedOn(
            self
        )

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(BinaryOpeningByReconstructionImageFilter self)


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_FullyConnectedOff(
            self
        )

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(BinaryOpeningByReconstructionImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_GetFullyConnected(
            self
        )

    def GetName(self):
        r"""
        GetName(BinaryOpeningByReconstructionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(BinaryOpeningByReconstructionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter___str__(
            self
        )

    def Execute(self, image1):
        r"""
        Execute(BinaryOpeningByReconstructionImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_Execute(
            self, image1
        )


# Register BinaryOpeningByReconstructionImageFilter in _SimpleITK:
_SimpleITK.BinaryOpeningByReconstructionImageFilter_swigregister(
    BinaryOpeningByReconstructionImageFilter
)


def BinaryOpeningByReconstruction(*args, **kwargs):
    r"""BinaryOpeningByReconstruction(Image image1, VectorUInt32 kernelRadius=std::vector< uint32_t >(3, 1), itk::simple::KernelEnum kernelType=sitkBall, double foregroundValue=1.0, double backgroundValue=0.0, bool fullyConnected=False) -> Image"""
    return _SimpleITK.BinaryOpeningByReconstruction(*args, **kwargs)


class BinaryProjectionImageFilter(ImageFilter):
    r"""


    Binary projection.


    This class was contributed to the Insight Journal by Gaetan Lehmann.
    The original paper can be found at https://doi.org/10.54294/0pjyho


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ProjectionImageFilter

     MedianProjectionImageFilter

     MeanProjectionImageFilter

     MeanProjectionImageFilter

     MaximumProjectionImageFilter

     MinimumProjectionImageFilter

     StandardDeviationProjectionImageFilter

     SumProjectionImageFilter

     itk::simple::BinaryProjection for the procedural interface

     itk::BinaryProjectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryProjectionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BinaryProjectionImageFilter

    def __init__(self):
        r"""
        __init__(BinaryProjectionImageFilter self) -> BinaryProjectionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryProjectionImageFilter_swiginit(
            self, _SimpleITK.new_BinaryProjectionImageFilter()
        )

    def SetProjectionDimension(self, ProjectionDimension):
        r"""
        SetProjectionDimension(BinaryProjectionImageFilter self, unsigned int ProjectionDimension)


        """
        return _SimpleITK.BinaryProjectionImageFilter_SetProjectionDimension(
            self, ProjectionDimension
        )

    def GetProjectionDimension(self):
        r"""
        GetProjectionDimension(BinaryProjectionImageFilter self) -> unsigned int


        """
        return _SimpleITK.BinaryProjectionImageFilter_GetProjectionDimension(
            self
        )

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(BinaryProjectionImageFilter self, double ForegroundValue)


        Set the value in the image to consider as "foreground". Defaults to
        maximum value of PixelType. Subclasses may alias this to DilateValue
        or ErodeValue.


        """
        return _SimpleITK.BinaryProjectionImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(BinaryProjectionImageFilter self) -> double


        Get the value in the image considered as "foreground". Defaults to
        maximum value of PixelType.


        """
        return _SimpleITK.BinaryProjectionImageFilter_GetForegroundValue(self)

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(BinaryProjectionImageFilter self, double BackgroundValue)


        Set the value used as "background". Any pixel value which is not
        DilateValue is considered background. BackgroundValue is used for
        defining boundary conditions. Defaults to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryProjectionImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(BinaryProjectionImageFilter self) -> double


        Get the value used as "background". Any pixel value which is not
        DilateValue is considered background. BackgroundValue is used for
        defining boundary conditions. Defaults to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryProjectionImageFilter_GetBackgroundValue(self)

    def GetName(self):
        r"""
        GetName(BinaryProjectionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryProjectionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BinaryProjectionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryProjectionImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BinaryProjectionImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinaryProjectionImageFilter_Execute(self, image1)


# Register BinaryProjectionImageFilter in _SimpleITK:
_SimpleITK.BinaryProjectionImageFilter_swigregister(
    BinaryProjectionImageFilter
)


def BinaryProjection(
    image1, projectionDimension=0, foregroundValue=1.0, backgroundValue=0.0
):
    r"""BinaryProjection(Image image1, unsigned int projectionDimension=0, double foregroundValue=1.0, double backgroundValue=0.0) -> Image"""
    return _SimpleITK.BinaryProjection(
        image1, projectionDimension, foregroundValue, backgroundValue
    )


class BinaryPruningImageFilter(ImageFilter):
    r"""


    This filter removes "spurs" of less than a certain length in the
    input image.


    This class is parameterized over the type of the input image and the
    type of the output image.

    The input is assumed to be a binary image.

    This filter is a sequential pruning algorithm and known to be
    computational time dependable of the image size. The algorithm is the
    N-dimensional version of that given for two dimensions in:

    Rafael C. Gonzales and Richard E. Woods. Digital Image Processing. Addison Wesley, 491-494, (1993).


    See:
     MorphologyImageFilter

     BinaryErodeImageFilter

     BinaryDilateImageFilter

     BinaryThinningImageFilter

     itk::simple::BinaryPruning for the procedural interface

     itk::BinaryPruningImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryPruningImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BinaryPruningImageFilter

    def __init__(self):
        r"""
        __init__(BinaryPruningImageFilter self) -> BinaryPruningImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryPruningImageFilter_swiginit(
            self, _SimpleITK.new_BinaryPruningImageFilter()
        )

    def SetIteration(self, Iteration):
        r"""
        SetIteration(BinaryPruningImageFilter self, uint32_t Iteration)


        Set/Get the iteration value


        """
        return _SimpleITK.BinaryPruningImageFilter_SetIteration(
            self, Iteration
        )

    def GetIteration(self):
        r"""
        GetIteration(BinaryPruningImageFilter self) -> uint32_t


        Set/Get the iteration value


        """
        return _SimpleITK.BinaryPruningImageFilter_GetIteration(self)

    def GetName(self):
        r"""
        GetName(BinaryPruningImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryPruningImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BinaryPruningImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryPruningImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BinaryPruningImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinaryPruningImageFilter_Execute(self, image1)


# Register BinaryPruningImageFilter in _SimpleITK:
_SimpleITK.BinaryPruningImageFilter_swigregister(BinaryPruningImageFilter)


def BinaryPruning(image1, iteration=3):
    r"""BinaryPruning(Image image1, uint32_t iteration=3) -> Image"""
    return _SimpleITK.BinaryPruning(image1, iteration)


class BinaryReconstructionByDilationImageFilter(ImageFilter):
    r"""


    binary reconstruction by dilation of an image


    Reconstruction by dilation operates on a "marker" image and a
    "mask" image, and is defined as the dilation of the marker image
    with respect to the mask image iterated until stability.

    Geodesic morphology is described in Chapter 6.2 of Pierre Soille's
    book "Morphological Image Analysis: Principles and Applications",
    Second Edition, Springer, 2003.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4


    See:
     MorphologyImageFilter , ReconstructionByDilationImageFilter , BinaryReconstructionByErosionImageFilter

     itk::simple::BinaryReconstructionByDilation for the procedural interface

     itk::BinaryReconstructionByDilationImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryReconstructionByDilationImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_BinaryReconstructionByDilationImageFilter
    )

    def __init__(self):
        r"""
        __init__(BinaryReconstructionByDilationImageFilter self) -> BinaryReconstructionByDilationImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryReconstructionByDilationImageFilter_swiginit(
            self, _SimpleITK.new_BinaryReconstructionByDilationImageFilter()
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(BinaryReconstructionByDilationImageFilter self, double BackgroundValue)


        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(BinaryReconstructionByDilationImageFilter self) -> double


        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter_GetBackgroundValue(
            self
        )

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(BinaryReconstructionByDilationImageFilter self, double ForegroundValue)


        Set/Get the value used as "foreground" in the output image. Defaults
        to NumericTraits<PixelType>::max() .


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(BinaryReconstructionByDilationImageFilter self) -> double


        Set/Get the value used as "foreground" in the output image. Defaults
        to NumericTraits<PixelType>::max() .


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter_GetForegroundValue(
            self
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(BinaryReconstructionByDilationImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(BinaryReconstructionByDilationImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter_FullyConnectedOn(
            self
        )

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(BinaryReconstructionByDilationImageFilter self)


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter_FullyConnectedOff(
            self
        )

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(BinaryReconstructionByDilationImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter_GetFullyConnected(
            self
        )

    def GetName(self):
        r"""
        GetName(BinaryReconstructionByDilationImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(BinaryReconstructionByDilationImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter___str__(
            self
        )

    def Execute(self, markerImage, maskImage):
        r"""
        Execute(BinaryReconstructionByDilationImageFilter self, Image markerImage, Image maskImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter_Execute(
            self, markerImage, maskImage
        )


# Register BinaryReconstructionByDilationImageFilter in _SimpleITK:
_SimpleITK.BinaryReconstructionByDilationImageFilter_swigregister(
    BinaryReconstructionByDilationImageFilter
)


def BinaryReconstructionByDilation(
    markerImage,
    maskImage,
    backgroundValue=0.0,
    foregroundValue=1.0,
    fullyConnected=False,
):
    r"""BinaryReconstructionByDilation(Image markerImage, Image maskImage, double backgroundValue=0.0, double foregroundValue=1.0, bool fullyConnected=False) -> Image"""
    return _SimpleITK.BinaryReconstructionByDilation(
        markerImage,
        maskImage,
        backgroundValue,
        foregroundValue,
        fullyConnected,
    )


class BinaryReconstructionByErosionImageFilter(ImageFilter):
    r"""


    binary reconstruction by erosion of an image


    Reconstruction by erosion operates on a "marker" image and a
    "mask" image, and is defined as the erosion of the marker image with
    respect to the mask image iterated until stability.

    Geodesic morphology is described in Chapter 6.2 of Pierre Soille's
    book "Morphological Image Analysis: Principles and Applications",
    Second Edition, Springer, 2003.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4


    See:
     MorphologyImageFilter , ReconstructionByErosionImageFilter , BinaryReconstructionByDilationImageFilter

     itk::simple::BinaryReconstructionByErosion for the procedural interface

     itk::BinaryReconstructionByErosionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryReconstructionByErosionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_BinaryReconstructionByErosionImageFilter
    )

    def __init__(self):
        r"""
        __init__(BinaryReconstructionByErosionImageFilter self) -> BinaryReconstructionByErosionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryReconstructionByErosionImageFilter_swiginit(
            self, _SimpleITK.new_BinaryReconstructionByErosionImageFilter()
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(BinaryReconstructionByErosionImageFilter self, double BackgroundValue)


        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(BinaryReconstructionByErosionImageFilter self) -> double


        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter_GetBackgroundValue(
            self
        )

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(BinaryReconstructionByErosionImageFilter self, double ForegroundValue)


        Set/Get the value used as "foreground" in the output image. Defaults
        to NumericTraits<PixelType>::max() .


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(BinaryReconstructionByErosionImageFilter self) -> double


        Set/Get the value used as "foreground" in the output image. Defaults
        to NumericTraits<PixelType>::max() .


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter_GetForegroundValue(
            self
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(BinaryReconstructionByErosionImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(BinaryReconstructionByErosionImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter_FullyConnectedOn(
            self
        )

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(BinaryReconstructionByErosionImageFilter self)


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter_FullyConnectedOff(
            self
        )

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(BinaryReconstructionByErosionImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter_GetFullyConnected(
            self
        )

    def GetName(self):
        r"""
        GetName(BinaryReconstructionByErosionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(BinaryReconstructionByErosionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter___str__(
            self
        )

    def Execute(self, markerImage, maskImage):
        r"""
        Execute(BinaryReconstructionByErosionImageFilter self, Image markerImage, Image maskImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter_Execute(
            self, markerImage, maskImage
        )


# Register BinaryReconstructionByErosionImageFilter in _SimpleITK:
_SimpleITK.BinaryReconstructionByErosionImageFilter_swigregister(
    BinaryReconstructionByErosionImageFilter
)


def BinaryReconstructionByErosion(
    markerImage,
    maskImage,
    backgroundValue=0.0,
    foregroundValue=1.0,
    fullyConnected=False,
):
    r"""BinaryReconstructionByErosion(Image markerImage, Image maskImage, double backgroundValue=0.0, double foregroundValue=1.0, bool fullyConnected=False) -> Image"""
    return _SimpleITK.BinaryReconstructionByErosion(
        markerImage,
        maskImage,
        backgroundValue,
        foregroundValue,
        fullyConnected,
    )


class BinaryThinningImageFilter(ImageFilter):
    r"""


    This filter computes one-pixel-wide edges of the input image.


    This class is parameterized over the type of the input image and the
    type of the output image.

    The input is assumed to be a binary image. If the foreground pixels of
    the input image do not have a value of 1, they are rescaled to 1
    internally to simplify the computation.

    The filter will produce a skeleton of the object. The output
    background values are 0, and the foreground values are 1.

    This filter is a sequential thinning algorithm and known to be
    computational time dependable on the image size. The algorithm
    corresponds with the 2D implementation described in:

    Rafael C. Gonzales and Richard E. Woods. Digital Image Processing. Addison Wesley, 491-494, (1993).

    To do: Make this filter ND.


    See:
     MorphologyImageFilter

     itk::simple::BinaryThinning for the procedural interface

     itk::BinaryThinningImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryThinningImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BinaryThinningImageFilter

    def __init__(self):
        r"""
        __init__(BinaryThinningImageFilter self) -> BinaryThinningImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryThinningImageFilter_swiginit(
            self, _SimpleITK.new_BinaryThinningImageFilter()
        )

    def GetName(self):
        r"""
        GetName(BinaryThinningImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryThinningImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BinaryThinningImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryThinningImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BinaryThinningImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinaryThinningImageFilter_Execute(self, image1)


# Register BinaryThinningImageFilter in _SimpleITK:
_SimpleITK.BinaryThinningImageFilter_swigregister(BinaryThinningImageFilter)


def BinaryThinning(image1):
    r"""BinaryThinning(Image image1) -> Image"""
    return _SimpleITK.BinaryThinning(image1)


class BinaryThresholdImageFilter(ImageFilter):
    r"""


    Binarize an input image by thresholding.


    This filter produces an output image whose pixels are either one of
    two values ( OutsideValue or InsideValue ), depending on whether the
    corresponding input image pixels lie between the two thresholds (
    LowerThreshold and UpperThreshold ). Values equal to either threshold
    is considered to be between the thresholds.

    More precisely \\[ Output(x_i) = \\begin{cases} InsideValue & \\text{if
    \\f$LowerThreshold \\leq x_i \\leq UpperThreshold\\f$}
    \\\\ OutsideValue & \\text{otherwise} \\end{cases} \\]

    This filter is templated over the input image type and the output
    image type.

    The filter expect both images to have the same number of dimensions.

    The default values for LowerThreshold and UpperThreshold are:
    LowerThreshold = NumericTraits<TInput>::NonpositiveMin() ; UpperThreshold = NumericTraits<TInput>::max() ; Therefore, generally only one of these needs to be set, depending
    on whether the user wants to threshold above or below the desired
    threshold.
    See:
     itk::simple::BinaryThreshold for the procedural interface

     itk::BinaryThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryThresholdImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BinaryThresholdImageFilter

    def __init__(self):
        r"""
        __init__(BinaryThresholdImageFilter self) -> BinaryThresholdImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryThresholdImageFilter_swiginit(
            self, _SimpleITK.new_BinaryThresholdImageFilter()
        )

    def SetLowerThreshold(self, LowerThreshold):
        r"""
        SetLowerThreshold(BinaryThresholdImageFilter self, double LowerThreshold)


        """
        return _SimpleITK.BinaryThresholdImageFilter_SetLowerThreshold(
            self, LowerThreshold
        )

    def GetLowerThreshold(self):
        r"""
        GetLowerThreshold(BinaryThresholdImageFilter self) -> double


        """
        return _SimpleITK.BinaryThresholdImageFilter_GetLowerThreshold(self)

    def SetUpperThreshold(self, UpperThreshold):
        r"""
        SetUpperThreshold(BinaryThresholdImageFilter self, double UpperThreshold)


        Set the thresholds. The default lower threshold is NumericTraits<InputPixelType>::NonpositiveMin() . The default upper threshold is NumericTraits<InputPixelType>::max . An exception is thrown if the lower threshold is greater than the
        upper threshold.


        """
        return _SimpleITK.BinaryThresholdImageFilter_SetUpperThreshold(
            self, UpperThreshold
        )

    def GetUpperThreshold(self):
        r"""
        GetUpperThreshold(BinaryThresholdImageFilter self) -> double


        Get the threshold values.


        """
        return _SimpleITK.BinaryThresholdImageFilter_GetUpperThreshold(self)

    def SetInsideValue(self, InsideValue):
        r"""
        SetInsideValue(BinaryThresholdImageFilter self, uint8_t InsideValue)


        Set the "inside" pixel value. The default value NumericTraits<OutputPixelType>::max()


        """
        return _SimpleITK.BinaryThresholdImageFilter_SetInsideValue(
            self, InsideValue
        )

    def GetInsideValue(self):
        r"""
        GetInsideValue(BinaryThresholdImageFilter self) -> uint8_t


        Get the "inside" pixel value.


        """
        return _SimpleITK.BinaryThresholdImageFilter_GetInsideValue(self)

    def SetOutsideValue(self, OutsideValue):
        r"""
        SetOutsideValue(BinaryThresholdImageFilter self, uint8_t OutsideValue)


        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::ZeroValue() .


        """
        return _SimpleITK.BinaryThresholdImageFilter_SetOutsideValue(
            self, OutsideValue
        )

    def GetOutsideValue(self):
        r"""
        GetOutsideValue(BinaryThresholdImageFilter self) -> uint8_t


        Get the "outside" pixel value.


        """
        return _SimpleITK.BinaryThresholdImageFilter_GetOutsideValue(self)

    def GetName(self):
        r"""
        GetName(BinaryThresholdImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryThresholdImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BinaryThresholdImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryThresholdImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BinaryThresholdImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinaryThresholdImageFilter_Execute(self, image1)


# Register BinaryThresholdImageFilter in _SimpleITK:
_SimpleITK.BinaryThresholdImageFilter_swigregister(BinaryThresholdImageFilter)


def BinaryThreshold(
    image1,
    lowerThreshold=0.0,
    upperThreshold=255.0,
    insideValue=1,
    outsideValue=0,
):
    r"""BinaryThreshold(Image image1, double lowerThreshold=0.0, double upperThreshold=255.0, uint8_t insideValue=1, uint8_t outsideValue=0) -> Image"""
    return _SimpleITK.BinaryThreshold(
        image1, lowerThreshold, upperThreshold, insideValue, outsideValue
    )


class BinaryThresholdProjectionImageFilter(ImageFilter):
    r"""


    BinaryThreshold projection.


    This class was contributed to the Insight Journal by Gaetan Lehmann.
    the original paper can be found at https://doi.org/10.54294/0pjyho


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ProjectionImageFilter

     MedianProjectionImageFilter

     MeanProjectionImageFilter

     MeanProjectionImageFilter

     MaximumProjectionImageFilter

     MinimumProjectionImageFilter

     StandardDeviationProjectionImageFilter

     SumProjectionImageFilter

     itk::simple::BinaryThresholdProjection for the procedural interface

     itk::BinaryThresholdProjectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryThresholdProjectionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BinaryThresholdProjectionImageFilter

    def __init__(self):
        r"""
        __init__(BinaryThresholdProjectionImageFilter self) -> BinaryThresholdProjectionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinaryThresholdProjectionImageFilter_swiginit(
            self, _SimpleITK.new_BinaryThresholdProjectionImageFilter()
        )

    def SetProjectionDimension(self, ProjectionDimension):
        r"""
        SetProjectionDimension(BinaryThresholdProjectionImageFilter self, unsigned int ProjectionDimension)


        """
        return _SimpleITK.BinaryThresholdProjectionImageFilter_SetProjectionDimension(
            self, ProjectionDimension
        )

    def GetProjectionDimension(self):
        r"""
        GetProjectionDimension(BinaryThresholdProjectionImageFilter self) -> unsigned int


        """
        return _SimpleITK.BinaryThresholdProjectionImageFilter_GetProjectionDimension(
            self
        )

    def SetThresholdValue(self, ThresholdValue):
        r"""
        SetThresholdValue(BinaryThresholdProjectionImageFilter self, double ThresholdValue)


        Set/Get the input value consider as "threshold". Defaults to NumericTraits<InputPixelType>::max()


        """
        return (
            _SimpleITK.BinaryThresholdProjectionImageFilter_SetThresholdValue(
                self, ThresholdValue
            )
        )

    def GetThresholdValue(self):
        r"""
        GetThresholdValue(BinaryThresholdProjectionImageFilter self) -> double


        Set/Get the input value consider as "threshold". Defaults to NumericTraits<InputPixelType>::max()


        """
        return (
            _SimpleITK.BinaryThresholdProjectionImageFilter_GetThresholdValue(
                self
            )
        )

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(BinaryThresholdProjectionImageFilter self, uint8_t ForegroundValue)


        Set/Get the output value used as "foreground". Defaults to maximum
        value of PixelType.


        """
        return (
            _SimpleITK.BinaryThresholdProjectionImageFilter_SetForegroundValue(
                self, ForegroundValue
            )
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(BinaryThresholdProjectionImageFilter self) -> uint8_t


        Set/Get the output value used as "foreground". Defaults to maximum
        value of PixelType.


        """
        return (
            _SimpleITK.BinaryThresholdProjectionImageFilter_GetForegroundValue(
                self
            )
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(BinaryThresholdProjectionImageFilter self, uint8_t BackgroundValue)


        Set/Get the output value used as "background". Defaults to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return (
            _SimpleITK.BinaryThresholdProjectionImageFilter_SetBackgroundValue(
                self, BackgroundValue
            )
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(BinaryThresholdProjectionImageFilter self) -> uint8_t


        Set/Get the output value used as "background". Defaults to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return (
            _SimpleITK.BinaryThresholdProjectionImageFilter_GetBackgroundValue(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(BinaryThresholdProjectionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinaryThresholdProjectionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BinaryThresholdProjectionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinaryThresholdProjectionImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BinaryThresholdProjectionImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinaryThresholdProjectionImageFilter_Execute(
            self, image1
        )


# Register BinaryThresholdProjectionImageFilter in _SimpleITK:
_SimpleITK.BinaryThresholdProjectionImageFilter_swigregister(
    BinaryThresholdProjectionImageFilter
)


def BinaryThresholdProjection(
    image1,
    projectionDimension=0,
    thresholdValue=0.0,
    foregroundValue=1,
    backgroundValue=0,
):
    r"""BinaryThresholdProjection(Image image1, unsigned int projectionDimension=0, double thresholdValue=0.0, uint8_t foregroundValue=1, uint8_t backgroundValue=0) -> Image"""
    return _SimpleITK.BinaryThresholdProjection(
        image1,
        projectionDimension,
        thresholdValue,
        foregroundValue,
        backgroundValue,
    )


class BinomialBlurImageFilter(ImageFilter):
    r"""


    Performs a separable blur on each dimension of an image.


    The binomial blur consists of a nearest neighbor average along each
    image dimension. The net result after n-iterations approaches
    convolution with a gaussian.
    See:
     itk::simple::BinomialBlur for the procedural interface

     itk::BinomialBlurImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinomialBlurImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BinomialBlurImageFilter

    def __init__(self):
        r"""
        __init__(BinomialBlurImageFilter self) -> BinomialBlurImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BinomialBlurImageFilter_swiginit(
            self, _SimpleITK.new_BinomialBlurImageFilter()
        )

    def SetRepetitions(self, Repetitions):
        r"""
        SetRepetitions(BinomialBlurImageFilter self, unsigned int Repetitions)


        Get and set the number of times to repeat the filter.


        """
        return _SimpleITK.BinomialBlurImageFilter_SetRepetitions(
            self, Repetitions
        )

    def GetRepetitions(self):
        r"""
        GetRepetitions(BinomialBlurImageFilter self) -> unsigned int


        Get and set the number of times to repeat the filter.


        """
        return _SimpleITK.BinomialBlurImageFilter_GetRepetitions(self)

    def GetName(self):
        r"""
        GetName(BinomialBlurImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BinomialBlurImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BinomialBlurImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BinomialBlurImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BinomialBlurImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BinomialBlurImageFilter_Execute(self, image1)


# Register BinomialBlurImageFilter in _SimpleITK:
_SimpleITK.BinomialBlurImageFilter_swigregister(BinomialBlurImageFilter)


def BinomialBlur(image1, repetitions=1):
    r"""BinomialBlur(Image image1, unsigned int repetitions=1) -> Image"""
    return _SimpleITK.BinomialBlur(image1, repetitions)


class BitwiseNotImageFilter(ImageFilter):
    r"""


    Implements pixel-wise generic operation on one image.


    This class is parameterized over the type of the input image and the
    type of the output image. It is also parameterized by the operation to
    be applied, using a Functor style.

    UnaryFunctorImageFilter allows the output dimension of the filter to be larger than the input
    dimension. Thus subclasses of the UnaryFunctorImageFilter (like the CastImageFilter ) can be used to promote a 2D image to a 3D image, etc.


    See:
     UnaryGeneratorImageFilter

     BinaryFunctorImageFilter TernaryFunctorImageFilter

     itk::simple::BitwiseNot for the procedural interface

     itk::UnaryFunctorImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBitwiseNotImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BitwiseNotImageFilter

    def __init__(self):
        r"""
        __init__(BitwiseNotImageFilter self) -> BitwiseNotImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BitwiseNotImageFilter_swiginit(
            self, _SimpleITK.new_BitwiseNotImageFilter()
        )

    def GetName(self):
        r"""
        GetName(BitwiseNotImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BitwiseNotImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BitwiseNotImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BitwiseNotImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BitwiseNotImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BitwiseNotImageFilter_Execute(self, image1)


# Register BitwiseNotImageFilter in _SimpleITK:
_SimpleITK.BitwiseNotImageFilter_swigregister(BitwiseNotImageFilter)


def BitwiseNot(image1):
    r"""BitwiseNot(Image image1) -> Image"""
    return _SimpleITK.BitwiseNot(image1)


class BlackTopHatImageFilter(ImageFilter):
    r"""


    Black top hat extracts local minima that are smaller than the
    structuring element.


    Black top hat extracts local minima that are smaller than the
    structuring element. It subtracts the background from the input image.
    The output of the filter transforms the black valleys into white
    peaks.

    Top-hats are described in Chapter 4.5 of Pierre Soille's book
    "Morphological Image Analysis: Principles and Applications", Second
    Edition, Springer, 2003.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     itk::simple::BlackTopHat for the procedural interface

     itk::BlackTopHatImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBlackTopHatImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BlackTopHatImageFilter

    def __init__(self):
        r"""
        __init__(BlackTopHatImageFilter self) -> BlackTopHatImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BlackTopHatImageFilter_swiginit(
            self, _SimpleITK.new_BlackTopHatImageFilter()
        )

    def SetKernelRadius(self, *args):
        r"""
        SetKernelRadius(BlackTopHatImageFilter self, VectorUInt32 KernelRadius)
        SetKernelRadius(BlackTopHatImageFilter self, unsigned int value)


        Set the values of the KernelRadius vector all to value


        """
        return _SimpleITK.BlackTopHatImageFilter_SetKernelRadius(self, *args)

    def GetKernelRadius(self):
        r"""
        GetKernelRadius(BlackTopHatImageFilter self) -> VectorUInt32


        Get the radius of the kernel structuring element.


        """
        return _SimpleITK.BlackTopHatImageFilter_GetKernelRadius(self)

    def SetKernelType(self, KernelType):
        r"""
        SetKernelType(BlackTopHatImageFilter self, itk::simple::KernelEnum KernelType)


        Set the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.BlackTopHatImageFilter_SetKernelType(
            self, KernelType
        )

    def GetKernelType(self):
        r"""
        GetKernelType(BlackTopHatImageFilter self) -> itk::simple::KernelEnum


        Get the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.BlackTopHatImageFilter_GetKernelType(self)

    def SetSafeBorder(self, SafeBorder):
        r"""
        SetSafeBorder(BlackTopHatImageFilter self, bool SafeBorder)


        A safe border is added to input image to avoid borders effects and
        remove it once the closing is done


        """
        return _SimpleITK.BlackTopHatImageFilter_SetSafeBorder(
            self, SafeBorder
        )

    def SafeBorderOn(self):
        r"""
        SafeBorderOn(BlackTopHatImageFilter self)


        Set the value of SafeBorder to true or false respectfully.


        """
        return _SimpleITK.BlackTopHatImageFilter_SafeBorderOn(self)

    def SafeBorderOff(self):
        r"""
        SafeBorderOff(BlackTopHatImageFilter self)


        """
        return _SimpleITK.BlackTopHatImageFilter_SafeBorderOff(self)

    def GetSafeBorder(self):
        r"""
        GetSafeBorder(BlackTopHatImageFilter self) -> bool


        A safe border is added to input image to avoid borders effects and
        remove it once the closing is done


        """
        return _SimpleITK.BlackTopHatImageFilter_GetSafeBorder(self)

    def GetName(self):
        r"""
        GetName(BlackTopHatImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BlackTopHatImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BlackTopHatImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BlackTopHatImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BlackTopHatImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BlackTopHatImageFilter_Execute(self, image1)


# Register BlackTopHatImageFilter in _SimpleITK:
_SimpleITK.BlackTopHatImageFilter_swigregister(BlackTopHatImageFilter)


def BlackTopHat(*args, **kwargs):
    r"""BlackTopHat(Image image1, VectorUInt32 kernelRadius=std::vector< uint32_t >(3, 1), itk::simple::KernelEnum kernelType=sitkBall, bool safeBorder=True) -> Image"""
    return _SimpleITK.BlackTopHat(*args, **kwargs)


class BoundedReciprocalImageFilter(ImageFilter):
    r"""


    Computes 1/(1+x) for each pixel in the image.


    The filter expects both the input and output images to have the same
    number of dimensions, and both of a scalar image type.
    See:
     itk::simple::BoundedReciprocal for the procedural interface

     itk::BoundedReciprocalImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBoundedReciprocalImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BoundedReciprocalImageFilter

    def __init__(self):
        r"""
        __init__(BoundedReciprocalImageFilter self) -> BoundedReciprocalImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BoundedReciprocalImageFilter_swiginit(
            self, _SimpleITK.new_BoundedReciprocalImageFilter()
        )

    def GetName(self):
        r"""
        GetName(BoundedReciprocalImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BoundedReciprocalImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BoundedReciprocalImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BoundedReciprocalImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BoundedReciprocalImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BoundedReciprocalImageFilter_Execute(self, image1)


# Register BoundedReciprocalImageFilter in _SimpleITK:
_SimpleITK.BoundedReciprocalImageFilter_swigregister(
    BoundedReciprocalImageFilter
)


def BoundedReciprocal(image1):
    r"""BoundedReciprocal(Image image1) -> Image"""
    return _SimpleITK.BoundedReciprocal(image1)


class BoxMeanImageFilter(ImageFilter):
    r"""


    Implements a fast rectangular mean filter using the accumulator
    approach.


    This code was contributed in the Insight Journal paper: "Efficient
    implementation of kernel filtering" by Beare R., Lehmann G https://doi.org/10.54294/igq8fn


    Richard Beare

    See:
     itk::simple::BoxMean for the procedural interface

     itk::BoxMeanImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBoxMeanImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BoxMeanImageFilter

    def __init__(self):
        r"""
        __init__(BoxMeanImageFilter self) -> BoxMeanImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BoxMeanImageFilter_swiginit(
            self, _SimpleITK.new_BoxMeanImageFilter()
        )

    def SetRadius(self, *args):
        r"""
        SetRadius(BoxMeanImageFilter self, VectorUInt32 Radius)
        SetRadius(BoxMeanImageFilter self, unsigned int value)


        Set the values of the Radius vector all to value


        """
        return _SimpleITK.BoxMeanImageFilter_SetRadius(self, *args)

    def GetRadius(self):
        r"""
        GetRadius(BoxMeanImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.BoxMeanImageFilter_GetRadius(self)

    def GetName(self):
        r"""
        GetName(BoxMeanImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BoxMeanImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BoxMeanImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BoxMeanImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BoxMeanImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BoxMeanImageFilter_Execute(self, image1)


# Register BoxMeanImageFilter in _SimpleITK:
_SimpleITK.BoxMeanImageFilter_swigregister(BoxMeanImageFilter)


def BoxMean(*args, **kwargs):
    r"""BoxMean(Image image1, VectorUInt32 radius=std::vector< unsigned int >(3, 1)) -> Image"""
    return _SimpleITK.BoxMean(*args, **kwargs)


class BoxSigmaImageFilter(ImageFilter):
    r"""


    Implements a fast rectangular sigma filter using the accumulator
    approach.


    This code was contributed in the Insight Journal paper: "Efficient
    implementation of kernel filtering" by Beare R., Lehmann G https://doi.org/10.54294/igq8fn


    Gaetan Lehmann

    See:
     itk::simple::BoxSigma for the procedural interface

     itk::BoxSigmaImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBoxSigmaImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_BoxSigmaImageFilter

    def __init__(self):
        r"""
        __init__(BoxSigmaImageFilter self) -> BoxSigmaImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.BoxSigmaImageFilter_swiginit(
            self, _SimpleITK.new_BoxSigmaImageFilter()
        )

    def SetRadius(self, *args):
        r"""
        SetRadius(BoxSigmaImageFilter self, VectorUInt32 Radius)
        SetRadius(BoxSigmaImageFilter self, unsigned int value)


        Set the values of the Radius vector all to value


        """
        return _SimpleITK.BoxSigmaImageFilter_SetRadius(self, *args)

    def GetRadius(self):
        r"""
        GetRadius(BoxSigmaImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.BoxSigmaImageFilter_GetRadius(self)

    def GetName(self):
        r"""
        GetName(BoxSigmaImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.BoxSigmaImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(BoxSigmaImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.BoxSigmaImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(BoxSigmaImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.BoxSigmaImageFilter_Execute(self, image1)


# Register BoxSigmaImageFilter in _SimpleITK:
_SimpleITK.BoxSigmaImageFilter_swigregister(BoxSigmaImageFilter)


def BoxSigma(*args, **kwargs):
    r"""BoxSigma(Image image1, VectorUInt32 radius=std::vector< unsigned int >(3, 1)) -> Image"""
    return _SimpleITK.BoxSigma(*args, **kwargs)


class CannyEdgeDetectionImageFilter(ImageFilter):
    r"""


    This filter is an implementation of a Canny edge detector for scalar-
    valued images.


    Based on John Canny's paper "A Computational Approach to Edge
    Detection"(IEEE Transactions on Pattern Analysis and Machine
    Intelligence, Vol. PAMI-8, No.6, November 1986), there are four major
    steps used in the edge-detection scheme: (1) Smooth the input image
    with Gaussian filter. (2) Calculate the second directional derivatives
    of the smoothed image. (3) Non-Maximum Suppression: the zero-crossings
    of 2nd derivative are found, and the sign of third derivative is used
    to find the correct extrema. (4) The hysteresis thresholding is
    applied to the gradient magnitude (multiplied with zero-crossings) of
    the smoothed image to find and link edges.

    Inputs and Outputs
    The input to this filter should be a scalar, real-valued Itk image of
    arbitrary dimension. The output should also be a scalar, real-value
    Itk image of the same dimensionality.
    Parameters
    There are four parameters for this filter that control the sub-filters
    used by the algorithm.

    Variance and Maximum error are used in the Gaussian smoothing of the
    input image. See itkDiscreteGaussianImageFilter for information on
    these parameters.

    Threshold is the lowest allowed value in the output image. Its data
    type is the same as the data type of the output image. Any values
    below the Threshold level will be replaced with the OutsideValue
    parameter value, whose default is zero.
     TodoEdge-linking will be added when an itk connected component
    labeling algorithm is available.


    See:
     DiscreteGaussianImageFilter

     ZeroCrossingImageFilter

     ThresholdImageFilter

     itk::simple::CannyEdgeDetection for the procedural interface

     itk::CannyEdgeDetectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkCannyEdgeDetectionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_CannyEdgeDetectionImageFilter

    def __init__(self):
        r"""
        __init__(CannyEdgeDetectionImageFilter self) -> CannyEdgeDetectionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.CannyEdgeDetectionImageFilter_swiginit(
            self, _SimpleITK.new_CannyEdgeDetectionImageFilter()
        )

    def SetLowerThreshold(self, LowerThreshold):
        r"""
        SetLowerThreshold(CannyEdgeDetectionImageFilter self, double LowerThreshold)


        Set the lower threshold value for detected edges.


        """
        return _SimpleITK.CannyEdgeDetectionImageFilter_SetLowerThreshold(
            self, LowerThreshold
        )

    def GetLowerThreshold(self):
        r"""
        GetLowerThreshold(CannyEdgeDetectionImageFilter self) -> double


        """
        return _SimpleITK.CannyEdgeDetectionImageFilter_GetLowerThreshold(self)

    def SetUpperThreshold(self, UpperThreshold):
        r"""
        SetUpperThreshold(CannyEdgeDetectionImageFilter self, double UpperThreshold)


        Set the upper threshold value for detected edges.


        """
        return _SimpleITK.CannyEdgeDetectionImageFilter_SetUpperThreshold(
            self, UpperThreshold
        )

    def GetUpperThreshold(self):
        r"""
        GetUpperThreshold(CannyEdgeDetectionImageFilter self) -> double


        """
        return _SimpleITK.CannyEdgeDetectionImageFilter_GetUpperThreshold(self)

    def SetVariance(self, *args):
        r"""
        SetVariance(CannyEdgeDetectionImageFilter self, VectorDouble Variance)
        SetVariance(CannyEdgeDetectionImageFilter self, double value)


        Set/Get the variance of the Gaussian smoothing filter.


        """
        return _SimpleITK.CannyEdgeDetectionImageFilter_SetVariance(
            self, *args
        )

    def GetVariance(self):
        r"""
        GetVariance(CannyEdgeDetectionImageFilter self) -> VectorDouble


        Set/Get the variance of the Gaussian smoothing filter.


        """
        return _SimpleITK.CannyEdgeDetectionImageFilter_GetVariance(self)

    def SetMaximumError(self, *args):
        r"""
        SetMaximumError(CannyEdgeDetectionImageFilter self, VectorDouble MaximumError)
        SetMaximumError(CannyEdgeDetectionImageFilter self, double value)


        Set/Get the MaximumError parameter used by the Gaussian smoothing
        filter in this algorithm


        """
        return _SimpleITK.CannyEdgeDetectionImageFilter_SetMaximumError(
            self, *args
        )

    def GetMaximumError(self):
        r"""
        GetMaximumError(CannyEdgeDetectionImageFilter self) -> VectorDouble


        Set/Get the maximum error of the Gaussian smoothing kernel in each
        dimensional direction.


        """
        return _SimpleITK.CannyEdgeDetectionImageFilter_GetMaximumError(self)

    def GetName(self):
        r"""
        GetName(CannyEdgeDetectionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.CannyEdgeDetectionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(CannyEdgeDetectionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.CannyEdgeDetectionImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(CannyEdgeDetectionImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.CannyEdgeDetectionImageFilter_Execute(self, image1)


# Register CannyEdgeDetectionImageFilter in _SimpleITK:
_SimpleITK.CannyEdgeDetectionImageFilter_swigregister(
    CannyEdgeDetectionImageFilter
)


def CannyEdgeDetection(*args, **kwargs):
    r"""CannyEdgeDetection(Image image1, double lowerThreshold=0.0, double upperThreshold=0.0, VectorDouble variance=std::vector< double >(3, 0.0), VectorDouble maximumError=std::vector< double >(3, 0.01)) -> Image"""
    return _SimpleITK.CannyEdgeDetection(*args, **kwargs)


class CannySegmentationLevelSetImageFilter(ImageFilter):
    r"""


    Segments structures in images based on image features derived from
    pseudo-canny-edges.


    IMPORTANT
    The SegmentationLevelSetImageFilter class and the CannySegmentationLevelSetFunction class contain additional information necessary to the full
    understanding of how to use this filter.
    OVERVIEW
    This class is a level set method segmentation filter. It constructs a
    speed function which is designed to lock onto edges as detected by a
    Canny filter.

    The CannySegmentationLevelSetImageFilter can be a tool for refining an existing segmentation, or it can be
    used to try to segment a region by itself. Like all other level-set
    based segmentation filters (see SegmentationLevelSetImageFilter ), it works by first constructing a scalar speed term and a vector
    advection field based on edge features in the image. The level set
    front is then moved according to these two terms with the addition of
    a third curvature term to control the smoothness of the solution.

    The speed term is constructed as the Danielsson distance transform of
    the Canny edge image, as calculated by the CannyEdgeDetectionImageFilter . This scalar speed can be tuned in and out of the final evolution
    equation by setting the PropagationScaling parameter (a value of 0
    removes the speed term).

    The advection field term is constructed by minimizing Danielsson
    distance squared. i.e. $ \\mbox{min} \\int D^2 \\Rightarrow D \\nabla D $ . This term moves the level set down the gradient of the distance
    transform.

    In practice, you may set the speed (propagation) term to zero if your
    initialization is already close to the edge you are interested in. If
    you are trying to segment a region by seeding with a small surface
    (blob, sphere) then you will likely want to add speed (propagation) to
    the equation so that the levelsets can expand along zero gradients.
    The relative influence of these two terms are controlled by the
    SetPropagationScaling and SetAdvectionScaling parameters.
    INPUTS
    This filter requires two inputs. The first input is a seed image. This
    seed image must contain an isosurface that you want to use as the seed
    for your segmentation. It can be a binary, graylevel, or floating
    point image. The only requirement is that it contain a closed
    isosurface that you will identify as the seed by setting the
    IsosurfaceValue parameter of the filter. For a binary image you will
    want to set your isosurface value halfway between your on and off
    values (i.e. for 0's and 1's, use an isosurface value of 0.5).

    The second input is the feature image. This is the image from which
    the speed function will be calculated. For most applications, this is
    the image that you want to segment. The desired isosurface in your
    seed image should lie within the region of your feature image that you
    are trying to segment.

    See SegmentationLevelSetImageFilter for more information on Inputs.
    OUTPUTS
    The filter outputs a single, scalar, real-valued image. Positive
    *values in the output image are inside the segmented region and
    negative *values in the image are outside of the inside region. The
    zero crossings of *the image correspond to the position of the level
    set front.

    See SparseFieldLevelSetImageFilter and SegmentationLevelSetImageFilter for more information.
    PARAMETERS
    There are five parameters important for controlling the behavior of
    this filter.

    (1) Threshold. Sets the thresholding value of the Canny edge
    detection. See CannyEdgeDetectionImageFilter for more information.

    (2) Variance. Controls the smoothing parameter of the gaussian
    filtering done during Canny edge detection.

    (3) CurvatureScaling. Controls the degree to which curvature
    influences the evolution of the level set. Higher values relative to
    Propagation and Advection scalings will yield a smoother surface.

    (4) PropagationScaling. Scales the propagation (speed) term of the
    level set equation. Set this term to zero to allow the level set to
    flow only down the gradient of the distance transform.

    (5) AdvectionScaling. Scales influence of the advection field relative
    to curvature and propagation terms.

    See:
     SegmentationLevelSetImageFilter

     CannySegmentationLevelSetFunction ,

     SparseFieldLevelSetImageFilter

     itk::simple::CannySegmentationLevelSet for the procedural interface

     itk::CannySegmentationLevelSetImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkCannySegmentationLevelSetImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_CannySegmentationLevelSetImageFilter

    def __init__(self):
        r"""
        __init__(CannySegmentationLevelSetImageFilter self) -> CannySegmentationLevelSetImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.CannySegmentationLevelSetImageFilter_swiginit(
            self, _SimpleITK.new_CannySegmentationLevelSetImageFilter()
        )

    def SetThreshold(self, Threshold):
        r"""
        SetThreshold(CannySegmentationLevelSetImageFilter self, double Threshold)


        Set the Threshold parameter of the CannyEdgeDetectionImageFilter used by the underlying level set function.


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_SetThreshold(
            self, Threshold
        )

    def GetThreshold(self):
        r"""
        GetThreshold(CannySegmentationLevelSetImageFilter self) -> double


        Set the Threshold parameter of the CannyEdgeDetectionImageFilter used by the underlying level set function.


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_GetThreshold(
            self
        )

    def SetVariance(self, Variance):
        r"""
        SetVariance(CannySegmentationLevelSetImageFilter self, double Variance)


        Set the Variance parameter of the CannyEdgeDetectionImageFilter used by the underlying level set function.


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_SetVariance(
            self, Variance
        )

    def GetVariance(self):
        r"""
        GetVariance(CannySegmentationLevelSetImageFilter self) -> double


        Set the Variance parameter of the CannyEdgeDetectionImageFilter used by the underlying level set function.


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_GetVariance(
            self
        )

    def SetMaximumRMSError(self, MaximumRMSError):
        r"""
        SetMaximumRMSError(CannySegmentationLevelSetImageFilter self, double MaximumRMSError)


        """
        return (
            _SimpleITK.CannySegmentationLevelSetImageFilter_SetMaximumRMSError(
                self, MaximumRMSError
            )
        )

    def GetMaximumRMSError(self):
        r"""
        GetMaximumRMSError(CannySegmentationLevelSetImageFilter self) -> double


        """
        return (
            _SimpleITK.CannySegmentationLevelSetImageFilter_GetMaximumRMSError(
                self
            )
        )

    def SetPropagationScaling(self, PropagationScaling):
        r"""
        SetPropagationScaling(CannySegmentationLevelSetImageFilter self, double PropagationScaling)


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_SetPropagationScaling(
            self, PropagationScaling
        )

    def GetPropagationScaling(self):
        r"""
        GetPropagationScaling(CannySegmentationLevelSetImageFilter self) -> double


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_GetPropagationScaling(
            self
        )

    def SetCurvatureScaling(self, CurvatureScaling):
        r"""
        SetCurvatureScaling(CannySegmentationLevelSetImageFilter self, double CurvatureScaling)


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_SetCurvatureScaling(
            self, CurvatureScaling
        )

    def GetCurvatureScaling(self):
        r"""
        GetCurvatureScaling(CannySegmentationLevelSetImageFilter self) -> double


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_GetCurvatureScaling(
            self
        )

    def SetAdvectionScaling(self, AdvectionScaling):
        r"""
        SetAdvectionScaling(CannySegmentationLevelSetImageFilter self, double AdvectionScaling)


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_SetAdvectionScaling(
            self, AdvectionScaling
        )

    def GetAdvectionScaling(self):
        r"""
        GetAdvectionScaling(CannySegmentationLevelSetImageFilter self) -> double


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_GetAdvectionScaling(
            self
        )

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(CannySegmentationLevelSetImageFilter self, uint32_t NumberOfIterations)


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(CannySegmentationLevelSetImageFilter self) -> uint32_t


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_GetNumberOfIterations(
            self
        )

    def SetReverseExpansionDirection(self, ReverseExpansionDirection):
        r"""
        SetReverseExpansionDirection(CannySegmentationLevelSetImageFilter self, bool ReverseExpansionDirection)


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_SetReverseExpansionDirection(
            self, ReverseExpansionDirection
        )

    def ReverseExpansionDirectionOn(self):
        r"""
        ReverseExpansionDirectionOn(CannySegmentationLevelSetImageFilter self)


        Set the value of ReverseExpansionDirection to true or false
        respectfully.


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_ReverseExpansionDirectionOn(
            self
        )

    def ReverseExpansionDirectionOff(self):
        r"""
        ReverseExpansionDirectionOff(CannySegmentationLevelSetImageFilter self)


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_ReverseExpansionDirectionOff(
            self
        )

    def GetReverseExpansionDirection(self):
        r"""
        GetReverseExpansionDirection(CannySegmentationLevelSetImageFilter self) -> bool


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_GetReverseExpansionDirection(
            self
        )

    def SetIsoSurfaceValue(self, IsoSurfaceValue):
        r"""
        SetIsoSurfaceValue(CannySegmentationLevelSetImageFilter self, double IsoSurfaceValue)


        """
        return (
            _SimpleITK.CannySegmentationLevelSetImageFilter_SetIsoSurfaceValue(
                self, IsoSurfaceValue
            )
        )

    def GetIsoSurfaceValue(self):
        r"""
        GetIsoSurfaceValue(CannySegmentationLevelSetImageFilter self) -> double


        """
        return (
            _SimpleITK.CannySegmentationLevelSetImageFilter_GetIsoSurfaceValue(
                self
            )
        )

    def GetElapsedIterations(self):
        r"""
        GetElapsedIterations(CannySegmentationLevelSetImageFilter self) -> uint32_t


        Number of iterations run.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_GetElapsedIterations(
            self
        )

    def GetRMSChange(self):
        r"""
        GetRMSChange(CannySegmentationLevelSetImageFilter self) -> double


        The Root Mean Square of the levelset upon termination.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_GetRMSChange(
            self
        )

    def GetCannyImage(self):
        r"""
        GetCannyImage(CannySegmentationLevelSetImageFilter self) -> Image


        Get the Canny image that was used to create the speed and advection
        images

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_GetCannyImage(
            self
        )

    def GetName(self):
        r"""
        GetName(CannySegmentationLevelSetImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(CannySegmentationLevelSetImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter___str__(self)

    def Execute(self, initialImage, featureImage):
        r"""
        Execute(CannySegmentationLevelSetImageFilter self, Image initialImage, Image featureImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.CannySegmentationLevelSetImageFilter_Execute(
            self, initialImage, featureImage
        )


# Register CannySegmentationLevelSetImageFilter in _SimpleITK:
_SimpleITK.CannySegmentationLevelSetImageFilter_swigregister(
    CannySegmentationLevelSetImageFilter
)


def CannySegmentationLevelSet(
    initialImage,
    featureImage,
    threshold=0.0,
    variance=0.0,
    maximumRMSError=0.02,
    propagationScaling=1.0,
    curvatureScaling=1.0,
    advectionScaling=1.0,
    numberOfIterations=1000,
    reverseExpansionDirection=False,
    isoSurfaceValue=0.0,
):
    r"""CannySegmentationLevelSet(Image initialImage, Image featureImage, double threshold=0.0, double variance=0.0, double maximumRMSError=0.02, double propagationScaling=1.0, double curvatureScaling=1.0, double advectionScaling=1.0, uint32_t numberOfIterations=1000, bool reverseExpansionDirection=False, double isoSurfaceValue=0.0) -> Image"""
    return _SimpleITK.CannySegmentationLevelSet(
        initialImage,
        featureImage,
        threshold,
        variance,
        maximumRMSError,
        propagationScaling,
        curvatureScaling,
        advectionScaling,
        numberOfIterations,
        reverseExpansionDirection,
        isoSurfaceValue,
    )


class ChangeLabelImageFilter(ImageFilter):
    r"""


    Change Sets of Labels.


    This filter produces an output image whose pixels are either copied
    from the input if they are not being changed or are rewritten based on
    the change parameters

    This filter is templated over the input image type and the output
    image type.

    The filter expect both images to have the same number of dimensions.


    Tim Kelliher. GE Research, Niskayuna, NY.

    This work was supported by a grant from DARPA, executed by the U.S.
    Army Medical Research and Materiel Command/TATRC Assistance Agreement,
    Contract::W81XWH-05-2-0059.

    See:
     itk::simple::ChangeLabel for the procedural interface

     itk::ChangeLabelImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkChangeLabelImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ChangeLabelImageFilter

    def __init__(self):
        r"""
        __init__(ChangeLabelImageFilter self) -> ChangeLabelImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ChangeLabelImageFilter_swiginit(
            self, _SimpleITK.new_ChangeLabelImageFilter()
        )

    def SetChangeMap(self, ChangeMap):
        r"""
        SetChangeMap(ChangeLabelImageFilter self, DoubleDoubleMap ChangeMap)


        Set the entire change map


        """
        return _SimpleITK.ChangeLabelImageFilter_SetChangeMap(self, ChangeMap)

    def GetChangeMap(self):
        r"""
        GetChangeMap(ChangeLabelImageFilter self) -> DoubleDoubleMap


        """
        return _SimpleITK.ChangeLabelImageFilter_GetChangeMap(self)

    def GetName(self):
        r"""
        GetName(ChangeLabelImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ChangeLabelImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ChangeLabelImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ChangeLabelImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ChangeLabelImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ChangeLabelImageFilter_Execute(self, image1)


# Register ChangeLabelImageFilter in _SimpleITK:
_SimpleITK.ChangeLabelImageFilter_swigregister(ChangeLabelImageFilter)


def ChangeLabel(*args, **kwargs):
    r"""ChangeLabel(Image image1, DoubleDoubleMap changeMap=std::map< double,double >()) -> Image"""
    return _SimpleITK.ChangeLabel(*args, **kwargs)


class ChangeLabelLabelMapFilter(ImageFilter):
    r"""


    Replace the label Ids of selected LabelObjects with new label Ids.


    This filter takes as input a label map and a list of pairs of Label Ids, to produce as output a new label map where the label Ids have
    been replaced according to the pairs in the list.

    Labels that are relabeled to the same label Id are automatically
    merged and optimized into a single LabelObject . The background label can also be changed. Any object relabeled to
    the output background will automatically be removed.

    This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ShapeLabelObject , RelabelComponentImageFilter , ChangeLabelImageFilter

     itk::simple::ChangeLabelLabelMapFilter for the procedural interface

     itk::ChangeLabelLabelMapFilter for the Doxygen on the original ITK class.


    C++ includes: sitkChangeLabelLabelMapFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ChangeLabelLabelMapFilter

    def __init__(self):
        r"""
        __init__(ChangeLabelLabelMapFilter self) -> ChangeLabelLabelMapFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ChangeLabelLabelMapFilter_swiginit(
            self, _SimpleITK.new_ChangeLabelLabelMapFilter()
        )

    def SetChangeMap(self, ChangeMap):
        r"""
        SetChangeMap(ChangeLabelLabelMapFilter self, DoubleDoubleMap ChangeMap)


        """
        return _SimpleITK.ChangeLabelLabelMapFilter_SetChangeMap(
            self, ChangeMap
        )

    def GetChangeMap(self):
        r"""
        GetChangeMap(ChangeLabelLabelMapFilter self) -> DoubleDoubleMap


        """
        return _SimpleITK.ChangeLabelLabelMapFilter_GetChangeMap(self)

    def GetName(self):
        r"""
        GetName(ChangeLabelLabelMapFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ChangeLabelLabelMapFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ChangeLabelLabelMapFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ChangeLabelLabelMapFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ChangeLabelLabelMapFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ChangeLabelLabelMapFilter_Execute(self, image1)


# Register ChangeLabelLabelMapFilter in _SimpleITK:
_SimpleITK.ChangeLabelLabelMapFilter_swigregister(ChangeLabelLabelMapFilter)


def ChangeLabelLabelMap(*args, **kwargs):
    r"""ChangeLabelLabelMap(Image image1, DoubleDoubleMap changeMap=std::map< double,double >()) -> Image"""
    return _SimpleITK.ChangeLabelLabelMap(*args, **kwargs)


class CheckerBoardImageFilter(ImageFilter):
    r"""


    Combines two images in a checkerboard pattern.


    CheckerBoardImageFilter takes two input images that must have the same dimension, size,
    origin and spacing and produces an output image of the same size by
    combining the pixels from the two input images in a checkerboard
    pattern. This filter is commonly used for visually comparing two
    images, in particular for evaluating the results of an image
    registration process.

    This filter is implemented as a multithreaded filter. It provides a
    DynamicThreadedGenerateData() method for its implementation.
    See:
     itk::simple::CheckerBoard for the procedural interface

     itk::CheckerBoardImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkCheckerBoardImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_CheckerBoardImageFilter

    def __init__(self):
        r"""
        __init__(CheckerBoardImageFilter self) -> CheckerBoardImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.CheckerBoardImageFilter_swiginit(
            self, _SimpleITK.new_CheckerBoardImageFilter()
        )

    def SetCheckerPattern(self, *args):
        r"""
        SetCheckerPattern(CheckerBoardImageFilter self, VectorUInt32 CheckerPattern)
        SetCheckerPattern(CheckerBoardImageFilter self, uint32_t value)


        Set the values of the CheckerPattern vector all to value


        """
        return _SimpleITK.CheckerBoardImageFilter_SetCheckerPattern(
            self, *args
        )

    def GetCheckerPattern(self):
        r"""
        GetCheckerPattern(CheckerBoardImageFilter self) -> VectorUInt32


        Set/Get the checker pattern array, i.e. the number of checker boxes
        per image dimension.


        """
        return _SimpleITK.CheckerBoardImageFilter_GetCheckerPattern(self)

    def GetName(self):
        r"""
        GetName(CheckerBoardImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.CheckerBoardImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(CheckerBoardImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.CheckerBoardImageFilter___str__(self)

    def Execute(self, image1, image2):
        r"""
        Execute(CheckerBoardImageFilter self, Image image1, Image image2) -> Image


        Execute the filter on the input images


        """
        return _SimpleITK.CheckerBoardImageFilter_Execute(self, image1, image2)


# Register CheckerBoardImageFilter in _SimpleITK:
_SimpleITK.CheckerBoardImageFilter_swigregister(CheckerBoardImageFilter)


def CheckerBoard(*args, **kwargs):
    r"""CheckerBoard(Image image1, Image image2, VectorUInt32 checkerPattern=std::vector< uint32_t >(3, 4)) -> Image"""
    return _SimpleITK.CheckerBoard(*args, **kwargs)


class ClampImageFilter(ImageFilter):
    r"""


    Casts input pixels to output pixel type and clamps the output pixel
    values to a specified range.


    Default range corresponds to the range supported by the pixel type of
    the output image.

    This filter is templated over the input image type and the output
    image type.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     UnaryFunctorImageFilter

     CastImageFilter

     itk::simple::Clamp for the procedural interface

     itk::ClampImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkClampImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ClampImageFilter

    def __init__(self):
        r"""
        __init__(ClampImageFilter self) -> ClampImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ClampImageFilter_swiginit(
            self, _SimpleITK.new_ClampImageFilter()
        )

    def SetOutputPixelType(self, OutputPixelType):
        r"""
        SetOutputPixelType(ClampImageFilter self, itk::simple::PixelIDValueEnum OutputPixelType)


        """
        return _SimpleITK.ClampImageFilter_SetOutputPixelType(
            self, OutputPixelType
        )

    def GetOutputPixelType(self):
        r"""
        GetOutputPixelType(ClampImageFilter self) -> itk::simple::PixelIDValueEnum


        """
        return _SimpleITK.ClampImageFilter_GetOutputPixelType(self)

    def SetLowerBound(self, LowerBound):
        r"""
        SetLowerBound(ClampImageFilter self, double LowerBound)


        """
        return _SimpleITK.ClampImageFilter_SetLowerBound(self, LowerBound)

    def GetLowerBound(self):
        r"""
        GetLowerBound(ClampImageFilter self) -> double


        """
        return _SimpleITK.ClampImageFilter_GetLowerBound(self)

    def SetUpperBound(self, UpperBound):
        r"""
        SetUpperBound(ClampImageFilter self, double UpperBound)


        """
        return _SimpleITK.ClampImageFilter_SetUpperBound(self, UpperBound)

    def GetUpperBound(self):
        r"""
        GetUpperBound(ClampImageFilter self) -> double


        """
        return _SimpleITK.ClampImageFilter_GetUpperBound(self)

    def GetName(self):
        r"""
        GetName(ClampImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ClampImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ClampImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ClampImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ClampImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ClampImageFilter_Execute(self, image1)


# Register ClampImageFilter in _SimpleITK:
_SimpleITK.ClampImageFilter_swigregister(ClampImageFilter)


def Clamp(*args, **kwargs):
    r"""Clamp(Image image1, itk::simple::PixelIDValueEnum outputPixelType=sitkUnknown, double lowerBound=-std::numeric_limits< double >::max(), double upperBound=std::numeric_limits< double >::max()) -> Image"""
    return _SimpleITK.Clamp(*args, **kwargs)


class ClosingByReconstructionImageFilter(ImageFilter):
    r"""


    Closing by reconstruction of an image.


    This filter is similar to the morphological closing, but contrary to
    the morphological closing, the closing by reconstruction preserves the
    shape of the components. The closing by reconstruction of an image
    "f" is defined as:

    ClosingByReconstruction(f) = ErosionByReconstruction(f, Dilation(f)).

    Closing by reconstruction not only preserves structures preserved by
    the dilation, but also levels raises the contrast of the darkest
    regions. If PreserveIntensities is on, a subsequent reconstruction by
    dilation using a marker image that is the original image for all
    unaffected pixels.

    Closing by reconstruction is described in Chapter 6.3.9 of Pierre
    Soille's book "Morphological Image Analysis: Principles and
    Applications", Second Edition, Springer, 2003.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     GrayscaleMorphologicalClosingImageFilter

     itk::simple::ClosingByReconstruction for the procedural interface

     itk::ClosingByReconstructionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkClosingByReconstructionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ClosingByReconstructionImageFilter

    def __init__(self):
        r"""
        __init__(ClosingByReconstructionImageFilter self) -> ClosingByReconstructionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ClosingByReconstructionImageFilter_swiginit(
            self, _SimpleITK.new_ClosingByReconstructionImageFilter()
        )

    def SetKernelRadius(self, *args):
        r"""
        SetKernelRadius(ClosingByReconstructionImageFilter self, VectorUInt32 KernelRadius)
        SetKernelRadius(ClosingByReconstructionImageFilter self, unsigned int value)


        Set the values of the KernelRadius vector all to value


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_SetKernelRadius(
            self, *args
        )

    def GetKernelRadius(self):
        r"""
        GetKernelRadius(ClosingByReconstructionImageFilter self) -> VectorUInt32


        Get the radius of the kernel structuring element.


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_GetKernelRadius(
            self
        )

    def SetKernelType(self, KernelType):
        r"""
        SetKernelType(ClosingByReconstructionImageFilter self, itk::simple::KernelEnum KernelType)


        Set the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_SetKernelType(
            self, KernelType
        )

    def GetKernelType(self):
        r"""
        GetKernelType(ClosingByReconstructionImageFilter self) -> itk::simple::KernelEnum


        Get the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_GetKernelType(
            self
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(ClosingByReconstructionImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(ClosingByReconstructionImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_FullyConnectedOn(
            self
        )

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(ClosingByReconstructionImageFilter self)


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_FullyConnectedOff(
            self
        )

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(ClosingByReconstructionImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_GetFullyConnected(
            self
        )

    def SetPreserveIntensities(self, PreserveIntensities):
        r"""
        SetPreserveIntensities(ClosingByReconstructionImageFilter self, bool PreserveIntensities)


        Set/Get whether the original intensities of the image retained for
        those pixels unaffected by the opening by reconstruction. If Off, the
        output pixel contrast will be reduced.


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_SetPreserveIntensities(
            self, PreserveIntensities
        )

    def PreserveIntensitiesOn(self):
        r"""
        PreserveIntensitiesOn(ClosingByReconstructionImageFilter self)


        Set the value of PreserveIntensities to true or false respectfully.


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_PreserveIntensitiesOn(
            self
        )

    def PreserveIntensitiesOff(self):
        r"""
        PreserveIntensitiesOff(ClosingByReconstructionImageFilter self)


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_PreserveIntensitiesOff(
            self
        )

    def GetPreserveIntensities(self):
        r"""
        GetPreserveIntensities(ClosingByReconstructionImageFilter self) -> bool


        Set/Get whether the original intensities of the image retained for
        those pixels unaffected by the opening by reconstruction. If Off, the
        output pixel contrast will be reduced.


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_GetPreserveIntensities(
            self
        )

    def GetName(self):
        r"""
        GetName(ClosingByReconstructionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ClosingByReconstructionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ClosingByReconstructionImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ClosingByReconstructionImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_Execute(
            self, image1
        )


# Register ClosingByReconstructionImageFilter in _SimpleITK:
_SimpleITK.ClosingByReconstructionImageFilter_swigregister(
    ClosingByReconstructionImageFilter
)


def ClosingByReconstruction(*args, **kwargs):
    r"""ClosingByReconstruction(Image image1, VectorUInt32 kernelRadius=std::vector< uint32_t >(3, 1), itk::simple::KernelEnum kernelType=sitkBall, bool fullyConnected=False, bool preserveIntensities=False) -> Image"""
    return _SimpleITK.ClosingByReconstruction(*args, **kwargs)


class CollidingFrontsImageFilter(ImageFilter):
    r"""


    Selects a region of space where two independent fronts run towards
    each other.


    The filter can be used to quickly segment anatomical structures (e.g.
    for level set initialization).

    The filter uses two instances of FastMarchingUpwindGradientImageFilter to compute the gradients of arrival times of two wavefronts
    propagating from two sets of seeds. The input of the filter is used as
    the speed of the two wavefronts. The output is the dot product between
    the two gradient vector fields.

    The filter works on the following basic idea. In the regions where the
    dot product between the two gradient fields is negative, the two
    fronts propagate in opposite directions. In the regions where the dot
    product is positive, the two fronts propagate in the same direction.
    This can be used to extract the region of space between two sets of
    points.

    If StopOnTargets is On, then each front will stop as soon as all seeds
    of the other front have been reached. This can markedly speed up the
    execution of the filter, since wave propagation does not take place on
    the complete image.

    Optionally, a connectivity criterion can be applied to the resulting
    dot product image. In this case, the only negative region in the
    output image is the one connected to the seeds.


    Luca Antiga Ph.D. Biomedical Technologies Laboratory, Bioengineering
    Department, Mario Negri Institute, Italy.

    See:
     itk::simple::CollidingFronts for the procedural interface

     itk::CollidingFrontsImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkCollidingFrontsImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_CollidingFrontsImageFilter

    def __init__(self):
        r"""
        __init__(CollidingFrontsImageFilter self) -> CollidingFrontsImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.CollidingFrontsImageFilter_swiginit(
            self, _SimpleITK.new_CollidingFrontsImageFilter()
        )

    def SetSeedPoints1(self, SeedPoints1):
        r"""
        SetSeedPoints1(CollidingFrontsImageFilter self, VectorUIntList SeedPoints1)


        Set the container of Seed Points representing the first initial front.
        Seed points are represented as a VectorContainer of LevelSetNodes.


        """
        return _SimpleITK.CollidingFrontsImageFilter_SetSeedPoints1(
            self, SeedPoints1
        )

    def GetSeedPoints1(self):
        r"""
        GetSeedPoints1(CollidingFrontsImageFilter self) -> VectorUIntList


        Get the container of Seed Points representing the first initial front.


        """
        return _SimpleITK.CollidingFrontsImageFilter_GetSeedPoints1(self)

    def AddSeedPoint1(self, point):
        r"""
        AddSeedPoint1(CollidingFrontsImageFilter self, VectorUInt32 point)


        Add SeedPoints1 point.


        """
        return _SimpleITK.CollidingFrontsImageFilter_AddSeedPoint1(self, point)

    def ClearSeedPoints1(self):
        r"""
        ClearSeedPoints1(CollidingFrontsImageFilter self)


        Remove all SeedPoints1 points.


        """
        return _SimpleITK.CollidingFrontsImageFilter_ClearSeedPoints1(self)

    def SetSeedPoints2(self, SeedPoints2):
        r"""
        SetSeedPoints2(CollidingFrontsImageFilter self, VectorUIntList SeedPoints2)


        Set the container of Seed Points representing the second initial
        front. Seed points are represented as a VectorContainer of LevelSetNodes.


        """
        return _SimpleITK.CollidingFrontsImageFilter_SetSeedPoints2(
            self, SeedPoints2
        )

    def GetSeedPoints2(self):
        r"""
        GetSeedPoints2(CollidingFrontsImageFilter self) -> VectorUIntList


        Get the container of Seed Points representing the second initial
        front.


        """
        return _SimpleITK.CollidingFrontsImageFilter_GetSeedPoints2(self)

    def AddSeedPoint2(self, point):
        r"""
        AddSeedPoint2(CollidingFrontsImageFilter self, VectorUInt32 point)


        Add SeedPoints2 point.


        """
        return _SimpleITK.CollidingFrontsImageFilter_AddSeedPoint2(self, point)

    def ClearSeedPoints2(self):
        r"""
        ClearSeedPoints2(CollidingFrontsImageFilter self)


        Remove all SeedPoints2 points.


        """
        return _SimpleITK.CollidingFrontsImageFilter_ClearSeedPoints2(self)

    def SetApplyConnectivity(self, ApplyConnectivity):
        r"""
        SetApplyConnectivity(CollidingFrontsImageFilter self, bool ApplyConnectivity)


        """
        return _SimpleITK.CollidingFrontsImageFilter_SetApplyConnectivity(
            self, ApplyConnectivity
        )

    def ApplyConnectivityOn(self):
        r"""
        ApplyConnectivityOn(CollidingFrontsImageFilter self)


        Set the value of ApplyConnectivity to true or false respectfully.


        """
        return _SimpleITK.CollidingFrontsImageFilter_ApplyConnectivityOn(self)

    def ApplyConnectivityOff(self):
        r"""
        ApplyConnectivityOff(CollidingFrontsImageFilter self)


        """
        return _SimpleITK.CollidingFrontsImageFilter_ApplyConnectivityOff(self)

    def GetApplyConnectivity(self):
        r"""
        GetApplyConnectivity(CollidingFrontsImageFilter self) -> bool


        """
        return _SimpleITK.CollidingFrontsImageFilter_GetApplyConnectivity(self)

    def SetNegativeEpsilon(self, NegativeEpsilon):
        r"""
        SetNegativeEpsilon(CollidingFrontsImageFilter self, double NegativeEpsilon)


        """
        return _SimpleITK.CollidingFrontsImageFilter_SetNegativeEpsilon(
            self, NegativeEpsilon
        )

    def GetNegativeEpsilon(self):
        r"""
        GetNegativeEpsilon(CollidingFrontsImageFilter self) -> double


        """
        return _SimpleITK.CollidingFrontsImageFilter_GetNegativeEpsilon(self)

    def SetStopOnTargets(self, StopOnTargets):
        r"""
        SetStopOnTargets(CollidingFrontsImageFilter self, bool StopOnTargets)


        """
        return _SimpleITK.CollidingFrontsImageFilter_SetStopOnTargets(
            self, StopOnTargets
        )

    def StopOnTargetsOn(self):
        r"""
        StopOnTargetsOn(CollidingFrontsImageFilter self)


        Set the value of StopOnTargets to true or false respectfully.


        """
        return _SimpleITK.CollidingFrontsImageFilter_StopOnTargetsOn(self)

    def StopOnTargetsOff(self):
        r"""
        StopOnTargetsOff(CollidingFrontsImageFilter self)


        """
        return _SimpleITK.CollidingFrontsImageFilter_StopOnTargetsOff(self)

    def GetStopOnTargets(self):
        r"""
        GetStopOnTargets(CollidingFrontsImageFilter self) -> bool


        """
        return _SimpleITK.CollidingFrontsImageFilter_GetStopOnTargets(self)

    def GetName(self):
        r"""
        GetName(CollidingFrontsImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.CollidingFrontsImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(CollidingFrontsImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.CollidingFrontsImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(CollidingFrontsImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.CollidingFrontsImageFilter_Execute(self, image1)


# Register CollidingFrontsImageFilter in _SimpleITK:
_SimpleITK.CollidingFrontsImageFilter_swigregister(CollidingFrontsImageFilter)


def CollidingFronts(*args, **kwargs):
    r"""CollidingFronts(Image image1, VectorUIntList seedPoints1=std::vector< std::vector< unsigned int > >(), VectorUIntList seedPoints2=std::vector< std::vector< unsigned int > >(), bool applyConnectivity=True, double negativeEpsilon=-1e-6, bool stopOnTargets=False) -> Image"""
    return _SimpleITK.CollidingFronts(*args, **kwargs)


class ComplexToImaginaryImageFilter(ImageFilter):
    r"""


    Computes pixel-wise the imaginary part of a complex image.



    See:
     itk::simple::ComplexToImaginary for the procedural interface

     itk::ComplexToImaginaryImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkComplexToImaginaryImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ComplexToImaginaryImageFilter

    def __init__(self):
        r"""
        __init__(ComplexToImaginaryImageFilter self) -> ComplexToImaginaryImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ComplexToImaginaryImageFilter_swiginit(
            self, _SimpleITK.new_ComplexToImaginaryImageFilter()
        )

    def GetName(self):
        r"""
        GetName(ComplexToImaginaryImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ComplexToImaginaryImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ComplexToImaginaryImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ComplexToImaginaryImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ComplexToImaginaryImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ComplexToImaginaryImageFilter_Execute(self, image1)


# Register ComplexToImaginaryImageFilter in _SimpleITK:
_SimpleITK.ComplexToImaginaryImageFilter_swigregister(
    ComplexToImaginaryImageFilter
)


def ComplexToImaginary(image1):
    r"""ComplexToImaginary(Image image1) -> Image"""
    return _SimpleITK.ComplexToImaginary(image1)


class ComplexToModulusImageFilter(ImageFilter):
    r"""


    Computes pixel-wise the Modulus of a complex image.



    See:
     itk::simple::ComplexToModulus for the procedural interface

     itk::ComplexToModulusImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkComplexToModulusImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ComplexToModulusImageFilter

    def __init__(self):
        r"""
        __init__(ComplexToModulusImageFilter self) -> ComplexToModulusImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ComplexToModulusImageFilter_swiginit(
            self, _SimpleITK.new_ComplexToModulusImageFilter()
        )

    def GetName(self):
        r"""
        GetName(ComplexToModulusImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ComplexToModulusImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ComplexToModulusImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ComplexToModulusImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ComplexToModulusImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ComplexToModulusImageFilter_Execute(self, image1)


# Register ComplexToModulusImageFilter in _SimpleITK:
_SimpleITK.ComplexToModulusImageFilter_swigregister(
    ComplexToModulusImageFilter
)


def ComplexToModulus(image1):
    r"""ComplexToModulus(Image image1) -> Image"""
    return _SimpleITK.ComplexToModulus(image1)


class ComplexToPhaseImageFilter(ImageFilter):
    r"""


    Computes pixel-wise the modulus of a complex image.



    See:
     itk::simple::ComplexToPhase for the procedural interface

     itk::ComplexToPhaseImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkComplexToPhaseImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ComplexToPhaseImageFilter

    def __init__(self):
        r"""
        __init__(ComplexToPhaseImageFilter self) -> ComplexToPhaseImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ComplexToPhaseImageFilter_swiginit(
            self, _SimpleITK.new_ComplexToPhaseImageFilter()
        )

    def GetName(self):
        r"""
        GetName(ComplexToPhaseImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ComplexToPhaseImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ComplexToPhaseImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ComplexToPhaseImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ComplexToPhaseImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ComplexToPhaseImageFilter_Execute(self, image1)


# Register ComplexToPhaseImageFilter in _SimpleITK:
_SimpleITK.ComplexToPhaseImageFilter_swigregister(ComplexToPhaseImageFilter)


def ComplexToPhase(image1):
    r"""ComplexToPhase(Image image1) -> Image"""
    return _SimpleITK.ComplexToPhase(image1)


class ComplexToRealImageFilter(ImageFilter):
    r"""


    Computes pixel-wise the real(x) part of a complex image.



    See:
     itk::simple::ComplexToReal for the procedural interface

     itk::ComplexToRealImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkComplexToRealImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ComplexToRealImageFilter

    def __init__(self):
        r"""
        __init__(ComplexToRealImageFilter self) -> ComplexToRealImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ComplexToRealImageFilter_swiginit(
            self, _SimpleITK.new_ComplexToRealImageFilter()
        )

    def GetName(self):
        r"""
        GetName(ComplexToRealImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ComplexToRealImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ComplexToRealImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ComplexToRealImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ComplexToRealImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ComplexToRealImageFilter_Execute(self, image1)


# Register ComplexToRealImageFilter in _SimpleITK:
_SimpleITK.ComplexToRealImageFilter_swigregister(ComplexToRealImageFilter)


def ComplexToReal(image1):
    r"""ComplexToReal(Image image1) -> Image"""
    return _SimpleITK.ComplexToReal(image1)


class ComposeImageFilter(ImageFilter):
    r"""


    ComposeImageFilter combine several scalar images into a multicomponent image.


    ComposeImageFilter combine several scalar images into an itk::Image of vector pixel ( itk::Vector , itk::RGBPixel , ...), of std::complex pixel, or in an itk::VectorImage .

    Inputs and Usage
     All input images are expected to have the same template parameters
    and have the same size and origin.

    See:
     VectorImage

     VectorIndexSelectionCastImageFilter

     itk::simple::Compose for the procedural interface


    C++ includes: sitkComposeImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ComposeImageFilter

    def __init__(self):
        r"""
        __init__(ComposeImageFilter self) -> ComposeImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ComposeImageFilter_swiginit(
            self, _SimpleITK.new_ComposeImageFilter()
        )

    def GetName(self):
        r"""
        GetName(ComposeImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ComposeImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ComposeImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ComposeImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(ComposeImageFilter self, VectorOfImage images) -> Image
        Execute(ComposeImageFilter self, Image image1) -> Image
        Execute(ComposeImageFilter self, Image image1, Image image2) -> Image
        Execute(ComposeImageFilter self, Image image1, Image image2, Image image3) -> Image
        Execute(ComposeImageFilter self, Image image1, Image image2, Image image3, Image image4) -> Image
        Execute(ComposeImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5) -> Image


        Execute the filter on the input images


        """
        return _SimpleITK.ComposeImageFilter_Execute(self, *args)


# Register ComposeImageFilter in _SimpleITK:
_SimpleITK.ComposeImageFilter_swigregister(ComposeImageFilter)


def Compose(*args):
    r"""
    Compose(VectorOfImage images) -> Image
    Compose(Image image1) -> Image
    Compose(Image image1, Image image2) -> Image
    Compose(Image image1, Image image2, Image image3) -> Image
    Compose(Image image1, Image image2, Image image3, Image image4) -> Image
    Compose(Image image1, Image image2, Image image3, Image image4, Image image5) -> Image
    """
    return _SimpleITK.Compose(*args)


class ConfidenceConnectedImageFilter(ImageFilter):
    r"""


    Segment pixels with similar statistics using connectivity.


    This filter extracts a connected set of pixels whose pixel intensities
    are consistent with the pixel statistics of a seed point. The mean and
    variance across a neighborhood (8-connected, 26-connected, etc.) are
    calculated for a seed point. Then pixels connected to this seed point
    whose values are within the confidence interval for the seed point are
    grouped. The width of the confidence interval is controlled by the
    "Multiplier" variable (the confidence interval is the mean plus or
    minus the "Multiplier" times the standard deviation). If the
    intensity variations across a segment were gaussian, a "Multiplier"
    setting of 2.5 would define a confidence interval wide enough to
    capture 99% of samples in the segment.

    After this initial segmentation is calculated, the mean and variance
    are re-calculated. All the pixels in the previous segmentation are
    used to calculate the mean the standard deviation (as opposed to using
    the pixels in the neighborhood of the seed point). The segmentation is
    then recalculated using these refined estimates for the mean and
    variance of the pixel values. This process is repeated for the
    specified number of iterations. Setting the "NumberOfIterations" to
    zero stops the algorithm after the initial segmentation from the seed
    point.

    NOTE: the lower and upper threshold are restricted to lie within the
    valid numeric limits of the input data pixel type. Also, the limits
    may be adjusted to contain the seed point's intensity.
    See:
     itk::simple::ConfidenceConnected for the procedural interface

     itk::ConfidenceConnectedImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkConfidenceConnectedImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ConfidenceConnectedImageFilter

    def __init__(self):
        r"""
        __init__(ConfidenceConnectedImageFilter self) -> ConfidenceConnectedImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ConfidenceConnectedImageFilter_swiginit(
            self, _SimpleITK.new_ConfidenceConnectedImageFilter()
        )

    def SetSeedList(self, SeedList):
        r"""
        SetSeedList(ConfidenceConnectedImageFilter self, VectorUIntList SeedList)


        Set list of image indexes for seeds.


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_SetSeedList(
            self, SeedList
        )

    def GetSeedList(self):
        r"""
        GetSeedList(ConfidenceConnectedImageFilter self) -> VectorUIntList


        Get list of seeds.


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_GetSeedList(self)

    def AddSeed(self, point):
        r"""
        AddSeed(ConfidenceConnectedImageFilter self, VectorUInt32 point)


        Add SeedList point.


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_AddSeed(self, point)

    def ClearSeeds(self):
        r"""
        ClearSeeds(ConfidenceConnectedImageFilter self)


        Remove all SeedList points.


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_ClearSeeds(self)

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(ConfidenceConnectedImageFilter self, unsigned int NumberOfIterations)


        Set/Get the number of iterations


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(ConfidenceConnectedImageFilter self) -> unsigned int


        Set/Get the number of iterations


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_GetNumberOfIterations(
            self
        )

    def SetMultiplier(self, Multiplier):
        r"""
        SetMultiplier(ConfidenceConnectedImageFilter self, double Multiplier)


        Set/Get the multiplier to define the confidence interval. Multiplier
        can be anything greater than zero. A typical value is 2.5


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_SetMultiplier(
            self, Multiplier
        )

    def GetMultiplier(self):
        r"""
        GetMultiplier(ConfidenceConnectedImageFilter self) -> double


        Set/Get the multiplier to define the confidence interval. Multiplier
        can be anything greater than zero. A typical value is 2.5


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_GetMultiplier(self)

    def SetInitialNeighborhoodRadius(self, InitialNeighborhoodRadius):
        r"""
        SetInitialNeighborhoodRadius(ConfidenceConnectedImageFilter self, unsigned int InitialNeighborhoodRadius)


        Get/Set the radius of the neighborhood over which the statistics are
        evaluated


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_SetInitialNeighborhoodRadius(
            self, InitialNeighborhoodRadius
        )

    def GetInitialNeighborhoodRadius(self):
        r"""
        GetInitialNeighborhoodRadius(ConfidenceConnectedImageFilter self) -> unsigned int


        Get/Set the radius of the neighborhood over which the statistics are
        evaluated


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_GetInitialNeighborhoodRadius(
            self
        )

    def SetReplaceValue(self, ReplaceValue):
        r"""
        SetReplaceValue(ConfidenceConnectedImageFilter self, uint8_t ReplaceValue)


        Set/Get value to replace thresholded pixels


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_SetReplaceValue(
            self, ReplaceValue
        )

    def GetReplaceValue(self):
        r"""
        GetReplaceValue(ConfidenceConnectedImageFilter self) -> uint8_t


        Set/Get value to replace thresholded pixels


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_GetReplaceValue(self)

    def GetMean(self):
        r"""
        GetMean(ConfidenceConnectedImageFilter self) -> double


        Method to get access to the mean of the pixels accepted in the output
        region. This method should only be invoked after the filter has been
        executed using the Update() method.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_GetMean(self)

    def GetVariance(self):
        r"""
        GetVariance(ConfidenceConnectedImageFilter self) -> double


        Method to get access to the variance of the pixels accepted in the
        output region. This method should only be invoked after the filter has
        been executed using the Update() method.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_GetVariance(self)

    def GetName(self):
        r"""
        GetName(ConfidenceConnectedImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ConfidenceConnectedImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ConfidenceConnectedImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ConfidenceConnectedImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_Execute(self, image1)


# Register ConfidenceConnectedImageFilter in _SimpleITK:
_SimpleITK.ConfidenceConnectedImageFilter_swigregister(
    ConfidenceConnectedImageFilter
)


def ConfidenceConnected(*args, **kwargs):
    r"""ConfidenceConnected(Image image1, VectorUIntList seedList=std::vector< std::vector< unsigned int > >(), unsigned int numberOfIterations=4, double multiplier=4.5, unsigned int initialNeighborhoodRadius=1, uint8_t replaceValue=1) -> Image"""
    return _SimpleITK.ConfidenceConnected(*args, **kwargs)


class ConnectedComponentImageFilter(ImageFilter):
    r"""


    Label the objects in a binary image.


    ConnectedComponentImageFilter labels the objects in a binary image (non-zero pixels are considered
    to be objects, zero-valued pixels are considered to be background).
    Each distinct object is assigned a unique label. The filter
    experiments with some improvements to the existing implementation, and
    is based on run length encoding along raster lines. If the output
    background value is set to zero (the default), the final object labels
    start with 1 and are consecutive. If the output background is set to a
    non-zero value (by calling the SetBackgroundValue() routine of the
    filter), the final labels start at 0, and remain consecutive except
    for skipping the background value as needed. Objects that are reached
    earlier by a raster order scan have a lower label. This is different
    to the behaviour of the original connected component image filter
    which did not produce consecutive labels or impose any particular
    ordering.

    After the filter is executed, ObjectCount holds the number of
    connected components.


    See:
     ImageToImageFilter

     itk::simple::ConnectedComponent for the procedural interface

     itk::ConnectedComponentImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkConnectedComponentImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ConnectedComponentImageFilter

    def __init__(self):
        r"""
        __init__(ConnectedComponentImageFilter self) -> ConnectedComponentImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ConnectedComponentImageFilter_swiginit(
            self, _SimpleITK.new_ConnectedComponentImageFilter()
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(ConnectedComponentImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.ConnectedComponentImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(ConnectedComponentImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.ConnectedComponentImageFilter_FullyConnectedOn(self)

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(ConnectedComponentImageFilter self)


        """
        return _SimpleITK.ConnectedComponentImageFilter_FullyConnectedOff(self)

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(ConnectedComponentImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.ConnectedComponentImageFilter_GetFullyConnected(self)

    def GetObjectCount(self):
        r"""
        GetObjectCount(ConnectedComponentImageFilter self) -> uint32_t


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ConnectedComponentImageFilter_GetObjectCount(self)

    def GetName(self):
        r"""
        GetName(ConnectedComponentImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ConnectedComponentImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ConnectedComponentImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ConnectedComponentImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(ConnectedComponentImageFilter self, Image image, Image maskImage) -> Image
        Execute(ConnectedComponentImageFilter self, Image image) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ConnectedComponentImageFilter_Execute(self, *args)


# Register ConnectedComponentImageFilter in _SimpleITK:
_SimpleITK.ConnectedComponentImageFilter_swigregister(
    ConnectedComponentImageFilter
)


def ConnectedComponent(*args):
    r"""
    ConnectedComponent(Image image, Image maskImage, bool fullyConnected=False) -> Image
    ConnectedComponent(Image image, bool fullyConnected=False) -> Image
    """
    return _SimpleITK.ConnectedComponent(*args)


class ConnectedThresholdImageFilter(ImageFilter):
    r"""


    Label pixels that are connected to a seed and lie within a range of values.


    ConnectedThresholdImageFilter labels pixels with ReplaceValue that are connected to an initial Seed
    AND lie within a Lower and Upper threshold range.
    See:
     itk::simple::ConnectedThreshold for the procedural interface

     itk::ConnectedThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkConnectedThresholdImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ConnectedThresholdImageFilter

    def __init__(self):
        r"""
        __init__(ConnectedThresholdImageFilter self) -> ConnectedThresholdImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ConnectedThresholdImageFilter_swiginit(
            self, _SimpleITK.new_ConnectedThresholdImageFilter()
        )

    def SetSeedList(self, SeedList):
        r"""
        SetSeedList(ConnectedThresholdImageFilter self, VectorUIntList SeedList)


        Set list of image indexes for seeds.


        """
        return _SimpleITK.ConnectedThresholdImageFilter_SetSeedList(
            self, SeedList
        )

    def GetSeedList(self):
        r"""
        GetSeedList(ConnectedThresholdImageFilter self) -> VectorUIntList


        Get list of seeds.


        """
        return _SimpleITK.ConnectedThresholdImageFilter_GetSeedList(self)

    def AddSeed(self, point):
        r"""
        AddSeed(ConnectedThresholdImageFilter self, VectorUInt32 point)


        Add SeedList point.


        """
        return _SimpleITK.ConnectedThresholdImageFilter_AddSeed(self, point)

    def ClearSeeds(self):
        r"""
        ClearSeeds(ConnectedThresholdImageFilter self)


        Remove all SeedList points.


        """
        return _SimpleITK.ConnectedThresholdImageFilter_ClearSeeds(self)

    def SetLower(self, Lower):
        r"""
        SetLower(ConnectedThresholdImageFilter self, double Lower)


        Set Upper and Lower Threshold inputs as values


        """
        return _SimpleITK.ConnectedThresholdImageFilter_SetLower(self, Lower)

    def GetLower(self):
        r"""
        GetLower(ConnectedThresholdImageFilter self) -> double


        Get Upper and Lower Threshold inputs as values.


        """
        return _SimpleITK.ConnectedThresholdImageFilter_GetLower(self)

    def SetUpper(self, Upper):
        r"""
        SetUpper(ConnectedThresholdImageFilter self, double Upper)


        Set Upper and Lower Threshold inputs as values


        """
        return _SimpleITK.ConnectedThresholdImageFilter_SetUpper(self, Upper)

    def GetUpper(self):
        r"""
        GetUpper(ConnectedThresholdImageFilter self) -> double


        Get Upper and Lower Threshold inputs as values.


        """
        return _SimpleITK.ConnectedThresholdImageFilter_GetUpper(self)

    def SetReplaceValue(self, ReplaceValue):
        r"""
        SetReplaceValue(ConnectedThresholdImageFilter self, uint8_t ReplaceValue)


        Set/Get value to replace thresholded pixels. Pixels that lie * within
        Lower and Upper (inclusive) will be replaced with this value. The
        default is 1.


        """
        return _SimpleITK.ConnectedThresholdImageFilter_SetReplaceValue(
            self, ReplaceValue
        )

    def GetReplaceValue(self):
        r"""
        GetReplaceValue(ConnectedThresholdImageFilter self) -> uint8_t


        Set/Get value to replace thresholded pixels. Pixels that lie * within
        Lower and Upper (inclusive) will be replaced with this value. The
        default is 1.


        """
        return _SimpleITK.ConnectedThresholdImageFilter_GetReplaceValue(self)

    FaceConnectivity = (
        _SimpleITK.ConnectedThresholdImageFilter_FaceConnectivity
    )

    FullConnectivity = (
        _SimpleITK.ConnectedThresholdImageFilter_FullConnectivity
    )

    def SetConnectivity(self, Connectivity):
        r"""
        SetConnectivity(ConnectedThresholdImageFilter self, itk::simple::ConnectedThresholdImageFilter::ConnectivityType Connectivity)


        Type of connectivity to use (fully connected OR 4(2D), 6(3D), 2*N(ND)
        connectivity).


        """
        return _SimpleITK.ConnectedThresholdImageFilter_SetConnectivity(
            self, Connectivity
        )

    def GetConnectivity(self):
        r"""
        GetConnectivity(ConnectedThresholdImageFilter self) -> itk::simple::ConnectedThresholdImageFilter::ConnectivityType


        Type of connectivity to use (fully connected OR 4(2D), 6(3D), 2*N(ND)
        connectivity).


        """
        return _SimpleITK.ConnectedThresholdImageFilter_GetConnectivity(self)

    def GetName(self):
        r"""
        GetName(ConnectedThresholdImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ConnectedThresholdImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ConnectedThresholdImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ConnectedThresholdImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ConnectedThresholdImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ConnectedThresholdImageFilter_Execute(self, image1)


# Register ConnectedThresholdImageFilter in _SimpleITK:
_SimpleITK.ConnectedThresholdImageFilter_swigregister(
    ConnectedThresholdImageFilter
)


def ConnectedThreshold(*args, **kwargs):
    r"""ConnectedThreshold(Image image1, VectorUIntList seedList=std::vector< std::vector< unsigned int > >(), double lower=0, double upper=1, uint8_t replaceValue=1, itk::simple::ConnectedThresholdImageFilter::ConnectivityType connectivity=FaceConnectivity) -> Image"""
    return _SimpleITK.ConnectedThreshold(*args, **kwargs)


class ConstantPadImageFilter(ImageFilter):
    r"""


    Increase the image size by padding with a constant value.


    ConstantPadImageFilter changes the output image region. If the output image region is larger
    than the input image region, the extra pixels are filled in by a
    constant value. The output image region must be specified.

    Visual explanation of padding regions.

    This filter is implemented as a multithreaded filter. It provides a
    DynamicThreadedGenerateData() method for its implementation.


    See:
     WrapPadImageFilter , MirrorPadImageFilter

     itk::simple::ConstantPad for the procedural interface

     itk::ConstantPadImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkConstantPadImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ConstantPadImageFilter

    def __init__(self):
        r"""
        __init__(ConstantPadImageFilter self) -> ConstantPadImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ConstantPadImageFilter_swiginit(
            self, _SimpleITK.new_ConstantPadImageFilter()
        )

    def SetPadLowerBound(self, PadLowerBound):
        r"""
        SetPadLowerBound(ConstantPadImageFilter self, VectorUInt32 PadLowerBound)


        """
        return _SimpleITK.ConstantPadImageFilter_SetPadLowerBound(
            self, PadLowerBound
        )

    def GetPadLowerBound(self):
        r"""
        GetPadLowerBound(ConstantPadImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.ConstantPadImageFilter_GetPadLowerBound(self)

    def SetPadUpperBound(self, PadUpperBound):
        r"""
        SetPadUpperBound(ConstantPadImageFilter self, VectorUInt32 PadUpperBound)


        """
        return _SimpleITK.ConstantPadImageFilter_SetPadUpperBound(
            self, PadUpperBound
        )

    def GetPadUpperBound(self):
        r"""
        GetPadUpperBound(ConstantPadImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.ConstantPadImageFilter_GetPadUpperBound(self)

    def SetConstant(self, Constant):
        r"""
        SetConstant(ConstantPadImageFilter self, double Constant)


        Set/Get the pad value. Default is Zero.


        """
        return _SimpleITK.ConstantPadImageFilter_SetConstant(self, Constant)

    def GetConstant(self):
        r"""
        GetConstant(ConstantPadImageFilter self) -> double


        Set/Get the pad value. Default is Zero.


        """
        return _SimpleITK.ConstantPadImageFilter_GetConstant(self)

    def GetName(self):
        r"""
        GetName(ConstantPadImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ConstantPadImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ConstantPadImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ConstantPadImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ConstantPadImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ConstantPadImageFilter_Execute(self, image1)


# Register ConstantPadImageFilter in _SimpleITK:
_SimpleITK.ConstantPadImageFilter_swigregister(ConstantPadImageFilter)


def ConstantPad(*args, **kwargs):
    r"""ConstantPad(Image image1, VectorUInt32 padLowerBound=std::vector< unsigned int >(3, 0), VectorUInt32 padUpperBound=std::vector< unsigned int >(3, 0), double constant=0.0) -> Image"""
    return _SimpleITK.ConstantPad(*args, **kwargs)


class ConvolutionImageFilter(ImageFilter):
    r"""


    Convolve a given image with an arbitrary image kernel.


    This filter operates by centering the flipped kernel at each pixel in
    the image and computing the inner product between pixel values in the
    image and pixel values in the kernel. The center of the kernel is
    defined as $ \\lfloor (2*i+s-1)/2 \\rfloor $ where $i$ is the index and $s$ is the size of the largest possible region of the kernel image. For
    kernels with odd sizes in all dimensions, this corresponds to the
    center pixel. If a dimension of the kernel image has an even size,
    then the center index of the kernel in that dimension will be the
    largest integral index that is less than the continuous index of the
    image center.

    The kernel can optionally be normalized to sum to 1 using NormalizeOn() . Normalization is off by default.


    WARNING:
    This filter ignores the spacing, origin, and orientation of the kernel
    image and treats them as identical to those in the input image.
     This code was contributed in the Insight Journal paper:

    "Image Kernel Convolution" by Tustison N., Gee J. https://doi.org/10.54294/e292kx


    Nicholas J. Tustison

    James C. Gee

    See:
     itk::simple::Convolution for the procedural interface

     itk::ConvolutionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkConvolutionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ConvolutionImageFilter

    def __init__(self):
        r"""
        __init__(ConvolutionImageFilter self) -> ConvolutionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ConvolutionImageFilter_swiginit(
            self, _SimpleITK.new_ConvolutionImageFilter()
        )

    def SetNormalize(self, Normalize):
        r"""
        SetNormalize(ConvolutionImageFilter self, bool Normalize)


        Normalize the output image by the sum of the kernel components


        """
        return _SimpleITK.ConvolutionImageFilter_SetNormalize(self, Normalize)

    def NormalizeOn(self):
        r"""
        NormalizeOn(ConvolutionImageFilter self)


        Set the value of Normalize to true or false respectfully.


        """
        return _SimpleITK.ConvolutionImageFilter_NormalizeOn(self)

    def NormalizeOff(self):
        r"""
        NormalizeOff(ConvolutionImageFilter self)


        """
        return _SimpleITK.ConvolutionImageFilter_NormalizeOff(self)

    def GetNormalize(self):
        r"""
        GetNormalize(ConvolutionImageFilter self) -> bool


        """
        return _SimpleITK.ConvolutionImageFilter_GetNormalize(self)

    ZERO_PAD = _SimpleITK.ConvolutionImageFilter_ZERO_PAD

    ZERO_FLUX_NEUMANN_PAD = (
        _SimpleITK.ConvolutionImageFilter_ZERO_FLUX_NEUMANN_PAD
    )

    PERIODIC_PAD = _SimpleITK.ConvolutionImageFilter_PERIODIC_PAD

    def SetBoundaryCondition(self, BoundaryCondition):
        r"""
        SetBoundaryCondition(ConvolutionImageFilter self, itk::simple::ConvolutionImageFilter::BoundaryConditionType BoundaryCondition)


        """
        return _SimpleITK.ConvolutionImageFilter_SetBoundaryCondition(
            self, BoundaryCondition
        )

    def GetBoundaryCondition(self):
        r"""
        GetBoundaryCondition(ConvolutionImageFilter self) -> itk::simple::ConvolutionImageFilter::BoundaryConditionType


        """
        return _SimpleITK.ConvolutionImageFilter_GetBoundaryCondition(self)

    SAME = _SimpleITK.ConvolutionImageFilter_SAME

    VALID = _SimpleITK.ConvolutionImageFilter_VALID

    def SetOutputRegionMode(self, OutputRegionMode):
        r"""
        SetOutputRegionMode(ConvolutionImageFilter self, itk::simple::ConvolutionImageFilter::OutputRegionModeType OutputRegionMode)


        """
        return _SimpleITK.ConvolutionImageFilter_SetOutputRegionMode(
            self, OutputRegionMode
        )

    def GetOutputRegionMode(self):
        r"""
        GetOutputRegionMode(ConvolutionImageFilter self) -> itk::simple::ConvolutionImageFilter::OutputRegionModeType


        """
        return _SimpleITK.ConvolutionImageFilter_GetOutputRegionMode(self)

    def GetName(self):
        r"""
        GetName(ConvolutionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ConvolutionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ConvolutionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ConvolutionImageFilter___str__(self)

    def Execute(self, image, kernelImage):
        r"""
        Execute(ConvolutionImageFilter self, Image image, Image kernelImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ConvolutionImageFilter_Execute(
            self, image, kernelImage
        )


# Register ConvolutionImageFilter in _SimpleITK:
_SimpleITK.ConvolutionImageFilter_swigregister(ConvolutionImageFilter)


def Convolution(*args, **kwargs):
    r"""Convolution(Image image, Image kernelImage, bool normalize=False, itk::simple::ConvolutionImageFilter::BoundaryConditionType boundaryCondition=ZERO_FLUX_NEUMANN_PAD, itk::simple::ConvolutionImageFilter::OutputRegionModeType outputRegionMode=SAME) -> Image"""
    return _SimpleITK.Convolution(*args, **kwargs)


class CosImageFilter(ImageFilter):
    r"""


    Computes the cosine of each pixel.


    This filter is templated over the pixel type of the input image and
    the pixel type of the output image.

    The filter walks over all of the pixels in the input image, and for
    each pixel does the following:


    cast the pixel value to double ,

    apply the std::cos() function to the double value,

    cast the double value resulting from std::cos() to the pixel type of
    the output image,

    store the cast value into the output image.
     The filter expects both images to have the same dimension (e.g. both
    2D, or both 3D, or both ND)
    See:
     itk::simple::Cos for the procedural interface

     itk::CosImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkCosImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_CosImageFilter

    def __init__(self):
        r"""
        __init__(CosImageFilter self) -> CosImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.CosImageFilter_swiginit(
            self, _SimpleITK.new_CosImageFilter()
        )

    def GetName(self):
        r"""
        GetName(CosImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.CosImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(CosImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.CosImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(CosImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.CosImageFilter_Execute(self, image1)


# Register CosImageFilter in _SimpleITK:
_SimpleITK.CosImageFilter_swigregister(CosImageFilter)


def Cos(image1):
    r"""Cos(Image image1) -> Image"""
    return _SimpleITK.Cos(image1)


class CropImageFilter(ImageFilter):
    r"""


    Decrease the image size by cropping the image by an itk::Size at both the upper and lower bounds of the largest possible region.


    CropImageFilter changes the image boundary of an image by removing pixels outside the
    target region. The target region is not specified in advance, but
    calculated in BeforeThreadedGenerateData() .

    This filter uses ExtractImageFilter to perform the cropping.
    See:
     itk::simple::Crop for the procedural interface

     itk::CropImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkCropImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_CropImageFilter

    def __init__(self):
        r"""
        __init__(CropImageFilter self) -> CropImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.CropImageFilter_swiginit(
            self, _SimpleITK.new_CropImageFilter()
        )

    def SetLowerBoundaryCropSize(self, LowerBoundaryCropSize):
        r"""
        SetLowerBoundaryCropSize(CropImageFilter self, VectorUInt32 LowerBoundaryCropSize)


        Set/Get the cropping sizes for the upper and lower boundaries.


        """
        return _SimpleITK.CropImageFilter_SetLowerBoundaryCropSize(
            self, LowerBoundaryCropSize
        )

    def GetLowerBoundaryCropSize(self):
        r"""
        GetLowerBoundaryCropSize(CropImageFilter self) -> VectorUInt32


        Set/Get the cropping sizes for the upper and lower boundaries.


        """
        return _SimpleITK.CropImageFilter_GetLowerBoundaryCropSize(self)

    def SetUpperBoundaryCropSize(self, UpperBoundaryCropSize):
        r"""
        SetUpperBoundaryCropSize(CropImageFilter self, VectorUInt32 UpperBoundaryCropSize)


        Set/Get the cropping sizes for the upper and lower boundaries.


        """
        return _SimpleITK.CropImageFilter_SetUpperBoundaryCropSize(
            self, UpperBoundaryCropSize
        )

    def GetUpperBoundaryCropSize(self):
        r"""
        GetUpperBoundaryCropSize(CropImageFilter self) -> VectorUInt32


        Set/Get the cropping sizes for the upper and lower boundaries.


        """
        return _SimpleITK.CropImageFilter_GetUpperBoundaryCropSize(self)

    def GetName(self):
        r"""
        GetName(CropImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.CropImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(CropImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.CropImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(CropImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.CropImageFilter_Execute(self, image1)


# Register CropImageFilter in _SimpleITK:
_SimpleITK.CropImageFilter_swigregister(CropImageFilter)


def Crop(*args, **kwargs):
    r"""Crop(Image image1, VectorUInt32 lowerBoundaryCropSize=std::vector< unsigned int >(3, 0), VectorUInt32 upperBoundaryCropSize=std::vector< unsigned int >(3, 0)) -> Image"""
    return _SimpleITK.Crop(*args, **kwargs)


class CurvatureAnisotropicDiffusionImageFilter(ImageFilter):
    r"""


    This filter performs anisotropic diffusion on a scalar itk::Image using the modified curvature diffusion equation (MCDE).


    For detailed information on anisotropic diffusion and the MCDE see
    itkAnisotropicDiffusionFunction and
    itkCurvatureNDAnisotropicDiffusionFunction.

    Inputs and Outputs
    The input and output to this filter must be a scalar itk::Image with numerical pixel types (float or double). A user defined type
    which correctly defines arithmetic operations with floating point
    accuracy should also give correct results.
    Parameters
    Please first read all the documentation found in AnisotropicDiffusionImageFilter and AnisotropicDiffusionFunction . Also see CurvatureNDAnisotropicDiffusionFunction .
     The default time step for this filter is set to the maximum
    theoretically stable value: 0.5 / 2^N, where N is the dimensionality
    of the image. For a 2D image, this means valid time steps are below
    0.1250. For a 3D image, valid time steps are below 0.0625.


    See:
     AnisotropicDiffusionImageFilter

     AnisotropicDiffusionFunction

     CurvatureNDAnisotropicDiffusionFunction

     itk::simple::CurvatureAnisotropicDiffusion for the procedural interface

     itk::CurvatureAnisotropicDiffusionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkCurvatureAnisotropicDiffusionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_CurvatureAnisotropicDiffusionImageFilter
    )

    def __init__(self):
        r"""
        __init__(CurvatureAnisotropicDiffusionImageFilter self) -> CurvatureAnisotropicDiffusionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_swiginit(
            self, _SimpleITK.new_CurvatureAnisotropicDiffusionImageFilter()
        )

    def SetTimeStep(self, TimeStep):
        r"""
        SetTimeStep(CurvatureAnisotropicDiffusionImageFilter self, double TimeStep)


        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_SetTimeStep(
            self, TimeStep
        )

    def GetTimeStep(self):
        r"""
        GetTimeStep(CurvatureAnisotropicDiffusionImageFilter self) -> double


        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_GetTimeStep(
            self
        )

    def SetConductanceParameter(self, ConductanceParameter):
        r"""
        SetConductanceParameter(CurvatureAnisotropicDiffusionImageFilter self, double ConductanceParameter)


        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_SetConductanceParameter(
            self, ConductanceParameter
        )

    def GetConductanceParameter(self):
        r"""
        GetConductanceParameter(CurvatureAnisotropicDiffusionImageFilter self) -> double


        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_GetConductanceParameter(
            self
        )

    def SetConductanceScalingUpdateInterval(
        self, ConductanceScalingUpdateInterval
    ):
        r"""
        SetConductanceScalingUpdateInterval(CurvatureAnisotropicDiffusionImageFilter self, unsigned int ConductanceScalingUpdateInterval)


        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_SetConductanceScalingUpdateInterval(
            self, ConductanceScalingUpdateInterval
        )

    def GetConductanceScalingUpdateInterval(self):
        r"""
        GetConductanceScalingUpdateInterval(CurvatureAnisotropicDiffusionImageFilter self) -> unsigned int


        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_GetConductanceScalingUpdateInterval(
            self
        )

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(CurvatureAnisotropicDiffusionImageFilter self, uint32_t NumberOfIterations)


        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(CurvatureAnisotropicDiffusionImageFilter self) -> uint32_t


        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_GetNumberOfIterations(
            self
        )

    def GetName(self):
        r"""
        GetName(CurvatureAnisotropicDiffusionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(CurvatureAnisotropicDiffusionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter___str__(
            self
        )

    def Execute(self, image1):
        r"""
        Execute(CurvatureAnisotropicDiffusionImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_Execute(
            self, image1
        )

    def EstimateOptimalTimeStep(self, inImage):
        r"""
        EstimateOptimalTimeStep(CurvatureAnisotropicDiffusionImageFilter self, Image inImage) -> double


        This method autmatically sets the optimal timestep for an image given
        its spacing.


        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_EstimateOptimalTimeStep(
            self, inImage
        )


# Register CurvatureAnisotropicDiffusionImageFilter in _SimpleITK:
_SimpleITK.CurvatureAnisotropicDiffusionImageFilter_swigregister(
    CurvatureAnisotropicDiffusionImageFilter
)


def CurvatureAnisotropicDiffusion(
    image1,
    timeStep=0.0625,
    conductanceParameter=3.0,
    conductanceScalingUpdateInterval=1,
    numberOfIterations=5,
):
    r"""CurvatureAnisotropicDiffusion(Image image1, double timeStep=0.0625, double conductanceParameter=3.0, unsigned int conductanceScalingUpdateInterval=1, uint32_t numberOfIterations=5) -> Image"""
    return _SimpleITK.CurvatureAnisotropicDiffusion(
        image1,
        timeStep,
        conductanceParameter,
        conductanceScalingUpdateInterval,
        numberOfIterations,
    )


class CurvatureFlowImageFilter(ImageFilter):
    r"""


    Denoise an image using curvature driven flow.


    CurvatureFlowImageFilter implements a curvature driven image denoising algorithm. Iso-
    brightness contours in the grayscale input image are viewed as a level
    set. The level set is then evolved using a curvature-based speed
    function:

    \\[ I_t = \\kappa |\\nabla I| \\] where $ \\kappa $ is the curvature.

    The advantage of this approach is that sharp boundaries are preserved
    with smoothing occurring only within a region. However, it should be
    noted that continuous application of this scheme will result in the
    eventual removal of all information as each contour shrinks to zero
    and disappear.

    Note that unlike level set segmentation algorithms, the image to be
    denoised is already the level set and can be set directly as the input
    using the SetInput() method.

    This filter has two parameters: the number of update iterations to be
    performed and the timestep between each update.

    The timestep should be "small enough" to ensure numerical stability.
    Stability is guarantee when the timestep meets the CFL (Courant-
    Friedrichs-Levy) condition. Broadly speaking, this condition ensures
    that each contour does not move more than one grid position at each
    timestep. In the literature, the timestep is typically user specified
    and have to manually tuned to the application.

    This filter make use of the multi-threaded finite difference solver
    hierarchy. Updates are computed using a CurvatureFlowFunction object. A zero flux Neumann boundary condition when computing
    derivatives near the data boundary.

    This filter may be streamed. To support streaming this filter produces
    a padded output which takes into account edge effects. The size of the
    padding is m_NumberOfIterations on each edge. Users of this filter
    should only make use of the center valid central region.


    WARNING:
    This filter assumes that the input and output types have the same
    dimensions. This filter also requires that the output image pixels are
    of a floating point type. This filter works for any dimensional
    images.
     Reference: "Level Set Methods and Fast Marching Methods", J.A.
    Sethian, Cambridge Press, Chapter 16, Second edition, 1999.


    See:
     DenseFiniteDifferenceImageFilter

     CurvatureFlowFunction

     MinMaxCurvatureFlowImageFilter

     BinaryMinMaxCurvatureFlowImageFilter

     itk::simple::CurvatureFlow for the procedural interface

     itk::CurvatureFlowImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkCurvatureFlowImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_CurvatureFlowImageFilter

    def __init__(self):
        r"""
        __init__(CurvatureFlowImageFilter self) -> CurvatureFlowImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.CurvatureFlowImageFilter_swiginit(
            self, _SimpleITK.new_CurvatureFlowImageFilter()
        )

    def SetTimeStep(self, TimeStep):
        r"""
        SetTimeStep(CurvatureFlowImageFilter self, double TimeStep)


        Set the timestep parameter.


        """
        return _SimpleITK.CurvatureFlowImageFilter_SetTimeStep(self, TimeStep)

    def GetTimeStep(self):
        r"""
        GetTimeStep(CurvatureFlowImageFilter self) -> double


        Get the timestep parameter.


        """
        return _SimpleITK.CurvatureFlowImageFilter_GetTimeStep(self)

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(CurvatureFlowImageFilter self, uint32_t NumberOfIterations)


        """
        return _SimpleITK.CurvatureFlowImageFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(CurvatureFlowImageFilter self) -> uint32_t


        """
        return _SimpleITK.CurvatureFlowImageFilter_GetNumberOfIterations(self)

    def GetName(self):
        r"""
        GetName(CurvatureFlowImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.CurvatureFlowImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(CurvatureFlowImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.CurvatureFlowImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(CurvatureFlowImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.CurvatureFlowImageFilter_Execute(self, image1)


# Register CurvatureFlowImageFilter in _SimpleITK:
_SimpleITK.CurvatureFlowImageFilter_swigregister(CurvatureFlowImageFilter)


def CurvatureFlow(image1, timeStep=0.05, numberOfIterations=5):
    r"""CurvatureFlow(Image image1, double timeStep=0.05, uint32_t numberOfIterations=5) -> Image"""
    return _SimpleITK.CurvatureFlow(image1, timeStep, numberOfIterations)


class CyclicShiftImageFilter(ImageFilter):
    r"""


    Perform a cyclic spatial shift of image intensities on the image grid.


    This filter supports arbitrary cyclic shifts of pixel values on the
    image grid. If the Shift is set to [xOff, yOff], the value of the
    pixel at [0, 0] in the input image will be the value of the pixel in
    the output image at index [xOff modulo xSize, yOff modulo ySize] where
    xSize and ySize are the sizes of the image in the x and y dimensions,
    respectively. If a pixel value is moved across a boundary, the pixel
    value is wrapped around that boundary. For example, if the image is
    40-by-40 and the Shift is [13, 47], then the value of the pixel at [0,
    0] in the input image will be the value of the pixel in the output
    image at index [13, 7].

    Negative Shifts are supported. This filter also works with images
    whose largest possible region starts at a non-zero index.
    See:
     itk::simple::CyclicShift for the procedural interface

     itk::CyclicShiftImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkCyclicShiftImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_CyclicShiftImageFilter

    def __init__(self):
        r"""
        __init__(CyclicShiftImageFilter self) -> CyclicShiftImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.CyclicShiftImageFilter_swiginit(
            self, _SimpleITK.new_CyclicShiftImageFilter()
        )

    def SetShift(self, *args):
        r"""
        SetShift(CyclicShiftImageFilter self, VectorInt32 Shift)
        SetShift(CyclicShiftImageFilter self, int value)


        Set/get the shift. Shifts may be positive or negative.


        """
        return _SimpleITK.CyclicShiftImageFilter_SetShift(self, *args)

    def GetShift(self):
        r"""
        GetShift(CyclicShiftImageFilter self) -> VectorInt32


        Set/get the shift. Shifts may be positive or negative.


        """
        return _SimpleITK.CyclicShiftImageFilter_GetShift(self)

    def GetName(self):
        r"""
        GetName(CyclicShiftImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.CyclicShiftImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(CyclicShiftImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.CyclicShiftImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(CyclicShiftImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.CyclicShiftImageFilter_Execute(self, image1)


# Register CyclicShiftImageFilter in _SimpleITK:
_SimpleITK.CyclicShiftImageFilter_swigregister(CyclicShiftImageFilter)


def CyclicShift(*args, **kwargs):
    r"""CyclicShift(Image image1, VectorInt32 shift=std::vector< int >(3, 0)) -> Image"""
    return _SimpleITK.CyclicShift(*args, **kwargs)


class DICOMOrientImageFilter(ImageFilter):
    r"""


    Permute axes and flip images as needed to obtain an approximation to
    the desired orientation.


    The physical location of all pixels in the image remains the same, but
    the meta-data and the ordering of the stored pixels may change.

    DICOMOrientImageFilter depends on a set of constants that describe all possible labels.
    Directions are labeled in terms of following pairs:


    Left and Right (Subject's left and right)

    Anterior and Posterior (Subject's front and back)

    Inferior and Superior (Subject's bottom and top, i.e. feet and head)
     The initials of these directions are used in a 3 letter code in the
    enumerated type OrientationEnum. The initials are given fastest moving
    index first, second fastest second, third fastest third, where the
    label's direction indicates increasing values.

    An ITK image with an identity direction cosine matrix is in LPS (Left,
    Posterior, Superior) orientation as defined by the DICOM standard.

    \\[ LPS = \\begin{Bmatrix} from\\ right\\ to\\
    \\textbf{L}eft \\\\ from\\ anterior\\ towards\\
    \\textbf{P}osterior \\\\ from\\ inferior\\ towards\\
    \\textbf{S}uperior \\end{Bmatrix} \\]

    The output orientation is specified with
    SetDesiredCoordinateOrientation. The input coordinate orientation is
    computed from the input image's direction cosine matrix.
    See:
     itk::simple::DICOMOrient for the procedural interface

     itk::DICOMOrientImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkDICOMOrientImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_DICOMOrientImageFilter

    def __init__(self):
        r"""
        __init__(DICOMOrientImageFilter self) -> DICOMOrientImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.DICOMOrientImageFilter_swiginit(
            self, _SimpleITK.new_DICOMOrientImageFilter()
        )

    @staticmethod
    def GetOrientationFromDirectionCosines(direction):
        r"""GetOrientationFromDirectionCosines(VectorDouble direction) -> std::string"""
        return _SimpleITK.DICOMOrientImageFilter_GetOrientationFromDirectionCosines(
            direction
        )

    @staticmethod
    def GetDirectionCosinesFromOrientation(str):
        r"""GetDirectionCosinesFromOrientation(std::string const & str) -> VectorDouble"""
        return _SimpleITK.DICOMOrientImageFilter_GetDirectionCosinesFromOrientation(
            str
        )

    def SetDesiredCoordinateOrientation(self, DesiredCoordinateOrientation):
        r"""
        SetDesiredCoordinateOrientation(DICOMOrientImageFilter self, std::string DesiredCoordinateOrientation)


        Set/Get the desired coordinate orientation for the output image


        """
        return (
            _SimpleITK.DICOMOrientImageFilter_SetDesiredCoordinateOrientation(
                self, DesiredCoordinateOrientation
            )
        )

    def GetDesiredCoordinateOrientation(self):
        r"""
        GetDesiredCoordinateOrientation(DICOMOrientImageFilter self) -> std::string


        Set/Get the desired coordinate orientation for the output image


        """
        return (
            _SimpleITK.DICOMOrientImageFilter_GetDesiredCoordinateOrientation(
                self
            )
        )

    def GetFlipAxes(self):
        r"""
        GetFlipAxes(DICOMOrientImageFilter self) -> VectorBool


            Get flip axes.

        This value is computed during Update.    This is a measurement. Its value is updated in the Execute
        methods, so the value will only be valid after an execution.


        """
        return _SimpleITK.DICOMOrientImageFilter_GetFlipAxes(self)

    def GetPermuteOrder(self):
        r"""
        GetPermuteOrder(DICOMOrientImageFilter self) -> VectorUInt32


            Get axes permute order.

        This value is computed during Update.    This is a measurement. Its value is updated in the Execute
        methods, so the value will only be valid after an execution.


        """
        return _SimpleITK.DICOMOrientImageFilter_GetPermuteOrder(self)

    def GetName(self):
        r"""
        GetName(DICOMOrientImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.DICOMOrientImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(DICOMOrientImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.DICOMOrientImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(DICOMOrientImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.DICOMOrientImageFilter_Execute(self, image1)


# Register DICOMOrientImageFilter in _SimpleITK:
_SimpleITK.DICOMOrientImageFilter_swigregister(DICOMOrientImageFilter)


def DICOMOrientImageFilter_GetOrientationFromDirectionCosines(direction):
    r"""DICOMOrientImageFilter_GetOrientationFromDirectionCosines(VectorDouble direction) -> std::string"""
    return (
        _SimpleITK.DICOMOrientImageFilter_GetOrientationFromDirectionCosines(
            direction
        )
    )


def DICOMOrientImageFilter_GetDirectionCosinesFromOrientation(str):
    r"""DICOMOrientImageFilter_GetDirectionCosinesFromOrientation(std::string const & str) -> VectorDouble"""
    return (
        _SimpleITK.DICOMOrientImageFilter_GetDirectionCosinesFromOrientation(
            str
        )
    )


def DICOMOrient(*args, **kwargs):
    r"""DICOMOrient(Image image1, std::string desiredCoordinateOrientation=std::string("LPS")) -> Image"""
    return _SimpleITK.DICOMOrient(*args, **kwargs)


class DanielssonDistanceMapImageFilter(ImageFilter):
    r"""


    This filter computes the distance map of the input image as an
    approximation with pixel accuracy to the Euclidean distance.


    TInputImage

    Input Image Type

    TOutputImage

    Output Image Type

    TVoronoiImage

    Voronoi Image Type. Note the default value is TInputImage.

    The input is assumed to contain numeric codes defining objects. The
    filter will produce as output the following images:


    A Voronoi partition using the same numeric codes as the input.

    A distance map with the approximation to the euclidean distance. from
    a particular pixel to the nearest object to this pixel in the input
    image.

    A vector map containing the component of the vector relating the
    current pixel with the closest point of the closest object to this
    pixel. Given that the components of the distance are computed in
    "pixels", the vector is represented by an itk::Offset . That is, physical coordinates are not used.
     This filter is N-dimensional and known to be efficient in
    computational time. The algorithm is the N-dimensional version of the
    4SED algorithm given for two dimensions in:

    Danielsson, Per-Erik. Euclidean Distance Mapping. Computer Graphics
    and Image Processing 14, 227-248 (1980).
    See:
     itk::simple::DanielssonDistanceMap for the procedural interface

     itk::DanielssonDistanceMapImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkDanielssonDistanceMapImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_DanielssonDistanceMapImageFilter

    def __init__(self):
        r"""
        __init__(DanielssonDistanceMapImageFilter self) -> DanielssonDistanceMapImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.DanielssonDistanceMapImageFilter_swiginit(
            self, _SimpleITK.new_DanielssonDistanceMapImageFilter()
        )

    def SetInputIsBinary(self, InputIsBinary):
        r"""
        SetInputIsBinary(DanielssonDistanceMapImageFilter self, bool InputIsBinary)


        Set/Get if the input is binary. If this variable is set, each nonzero
        pixel in the input image will be given a unique numeric code to be
        used by the Voronoi partition. If the image is binary but you are not
        interested in the Voronoi regions of the different nonzero pixels,
        then you need not set this.


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_SetInputIsBinary(
            self, InputIsBinary
        )

    def InputIsBinaryOn(self):
        r"""
        InputIsBinaryOn(DanielssonDistanceMapImageFilter self)


        Set the value of InputIsBinary to true or false respectfully.


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_InputIsBinaryOn(
            self
        )

    def InputIsBinaryOff(self):
        r"""
        InputIsBinaryOff(DanielssonDistanceMapImageFilter self)


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_InputIsBinaryOff(
            self
        )

    def GetInputIsBinary(self):
        r"""
        GetInputIsBinary(DanielssonDistanceMapImageFilter self) -> bool


        Set/Get if the input is binary. If this variable is set, each nonzero
        pixel in the input image will be given a unique numeric code to be
        used by the Voronoi partition. If the image is binary but you are not
        interested in the Voronoi regions of the different nonzero pixels,
        then you need not set this.


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_GetInputIsBinary(
            self
        )

    def SetSquaredDistance(self, SquaredDistance):
        r"""
        SetSquaredDistance(DanielssonDistanceMapImageFilter self, bool SquaredDistance)


        Set/Get if the distance should be squared.


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_SetSquaredDistance(
            self, SquaredDistance
        )

    def SquaredDistanceOn(self):
        r"""
        SquaredDistanceOn(DanielssonDistanceMapImageFilter self)


        Set the value of SquaredDistance to true or false respectfully.


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_SquaredDistanceOn(
            self
        )

    def SquaredDistanceOff(self):
        r"""
        SquaredDistanceOff(DanielssonDistanceMapImageFilter self)


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_SquaredDistanceOff(
            self
        )

    def GetSquaredDistance(self):
        r"""
        GetSquaredDistance(DanielssonDistanceMapImageFilter self) -> bool


        Set/Get if the distance should be squared.


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_GetSquaredDistance(
            self
        )

    def SetUseImageSpacing(self, UseImageSpacing):
        r"""
        SetUseImageSpacing(DanielssonDistanceMapImageFilter self, bool UseImageSpacing)


        Set/Get if image spacing should be used in computing distances.


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_SetUseImageSpacing(
            self, UseImageSpacing
        )

    def UseImageSpacingOn(self):
        r"""
        UseImageSpacingOn(DanielssonDistanceMapImageFilter self)


        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_UseImageSpacingOn(
            self
        )

    def UseImageSpacingOff(self):
        r"""
        UseImageSpacingOff(DanielssonDistanceMapImageFilter self)


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_UseImageSpacingOff(
            self
        )

    def GetUseImageSpacing(self):
        r"""
        GetUseImageSpacing(DanielssonDistanceMapImageFilter self) -> bool


        Set/Get if image spacing should be used in computing distances.


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_GetUseImageSpacing(
            self
        )

    def GetVoronoiMap(self):
        r"""
        GetVoronoiMap(DanielssonDistanceMapImageFilter self) -> Image


        Get Voronoi Map This map shows for each pixel what object is closest
        to it. Each object should be labeled by a number (larger than 0), so
        the map has a value for each pixel corresponding to the label of the
        closest object.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_GetVoronoiMap(self)

    def GetVectorDistanceMap(self):
        r"""
        GetVectorDistanceMap(DanielssonDistanceMapImageFilter self) -> Image


        Get vector field of distances.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return (
            _SimpleITK.DanielssonDistanceMapImageFilter_GetVectorDistanceMap(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(DanielssonDistanceMapImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(DanielssonDistanceMapImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(DanielssonDistanceMapImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_Execute(
            self, image1
        )


# Register DanielssonDistanceMapImageFilter in _SimpleITK:
_SimpleITK.DanielssonDistanceMapImageFilter_swigregister(
    DanielssonDistanceMapImageFilter
)


def DanielssonDistanceMap(
    image1, inputIsBinary=False, squaredDistance=False, useImageSpacing=False
):
    r"""DanielssonDistanceMap(Image image1, bool inputIsBinary=False, bool squaredDistance=False, bool useImageSpacing=False) -> Image"""
    return _SimpleITK.DanielssonDistanceMap(
        image1, inputIsBinary, squaredDistance, useImageSpacing
    )


class DemonsRegistrationFilter(ImageFilter):
    r"""


    Deformably register two images using the demons algorithm.


    DemonsRegistrationFilter implements the demons deformable algorithm that register two images
    by computing the displacement field which will map a moving image onto
    a fixed image.

    A displacement field is represented as a image whose pixel type is
    some vector type with at least N elements, where N is the dimension of
    the fixed image. The vector type must support element access via
    operator []. It is assumed that the vector elements behave like
    floating point scalars.

    This class is templated over the fixed image type, moving image type
    and the displacement field type.

    The input fixed and moving images are set via methods SetFixedImage
    and SetMovingImage respectively. An initial displacement field maybe
    set via SetInitialDisplacementField or SetInput. If no initial field
    is set, a zero field is used as the initial condition.

    The algorithm has one parameters: the number of iteration to be
    performed.

    The output displacement field can be obtained via methods GetOutput or
    GetDisplacementField.

    This class make use of the finite difference solver hierarchy. Update
    for each iteration is computed in DemonsRegistrationFunction .


    WARNING:
    This filter assumes that the fixed image type, moving image type and
    displacement field type all have the same number of dimensions.

    See:
     DemonsRegistrationFunction

     itk::DemonsRegistrationFilter for the Doxygen on the original ITK class.


    C++ includes: sitkDemonsRegistrationFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_DemonsRegistrationFilter

    def __init__(self):
        r"""
        __init__(DemonsRegistrationFilter self) -> DemonsRegistrationFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.DemonsRegistrationFilter_swiginit(
            self, _SimpleITK.new_DemonsRegistrationFilter()
        )

    def SetStandardDeviations(self, *args):
        r"""
        SetStandardDeviations(DemonsRegistrationFilter self, VectorDouble StandardDeviations)
        SetStandardDeviations(DemonsRegistrationFilter self, double value)


        Set/Get the Gaussian smoothing standard deviations for the
        displacement field. The values are set with respect to pixel
        coordinates.


        """
        return _SimpleITK.DemonsRegistrationFilter_SetStandardDeviations(
            self, *args
        )

    def GetStandardDeviations(self):
        r"""
        GetStandardDeviations(DemonsRegistrationFilter self) -> VectorDouble


        Set/Get the Gaussian smoothing standard deviations for the
        displacement field. The values are set with respect to pixel
        coordinates.


        """
        return _SimpleITK.DemonsRegistrationFilter_GetStandardDeviations(self)

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(DemonsRegistrationFilter self, uint32_t NumberOfIterations)


        """
        return _SimpleITK.DemonsRegistrationFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(DemonsRegistrationFilter self) -> uint32_t


        """
        return _SimpleITK.DemonsRegistrationFilter_GetNumberOfIterations(self)

    def SetMaximumRMSError(self, MaximumRMSError):
        r"""
        SetMaximumRMSError(DemonsRegistrationFilter self, double MaximumRMSError)


        """
        return _SimpleITK.DemonsRegistrationFilter_SetMaximumRMSError(
            self, MaximumRMSError
        )

    def GetMaximumRMSError(self):
        r"""
        GetMaximumRMSError(DemonsRegistrationFilter self) -> double


        """
        return _SimpleITK.DemonsRegistrationFilter_GetMaximumRMSError(self)

    def SetUseMovingImageGradient(self, UseMovingImageGradient):
        r"""
        SetUseMovingImageGradient(DemonsRegistrationFilter self, bool UseMovingImageGradient)


        Switch between using the fixed image and moving image gradient for
        computing the displacement field updates.


        """
        return _SimpleITK.DemonsRegistrationFilter_SetUseMovingImageGradient(
            self, UseMovingImageGradient
        )

    def UseMovingImageGradientOn(self):
        r"""
        UseMovingImageGradientOn(DemonsRegistrationFilter self)


        Set the value of UseMovingImageGradient to true or false respectfully.


        """
        return _SimpleITK.DemonsRegistrationFilter_UseMovingImageGradientOn(
            self
        )

    def UseMovingImageGradientOff(self):
        r"""
        UseMovingImageGradientOff(DemonsRegistrationFilter self)


        """
        return _SimpleITK.DemonsRegistrationFilter_UseMovingImageGradientOff(
            self
        )

    def GetUseMovingImageGradient(self):
        r"""
        GetUseMovingImageGradient(DemonsRegistrationFilter self) -> bool


        Switch between using the fixed image and moving image gradient for
        computing the displacement field updates.


        """
        return _SimpleITK.DemonsRegistrationFilter_GetUseMovingImageGradient(
            self
        )

    def SetSmoothDisplacementField(self, SmoothDisplacementField):
        r"""
        SetSmoothDisplacementField(DemonsRegistrationFilter self, bool SmoothDisplacementField)


        Set/Get whether the displacement field is smoothed (regularized).
        Smoothing the displacement yields a solution elastic in nature. If
        SmoothDisplacementField is on, then the displacement field is smoothed
        with a Gaussian whose standard deviations are specified with SetStandardDeviations()


        """
        return _SimpleITK.DemonsRegistrationFilter_SetSmoothDisplacementField(
            self, SmoothDisplacementField
        )

    def SmoothDisplacementFieldOn(self):
        r"""
        SmoothDisplacementFieldOn(DemonsRegistrationFilter self)


        Set the value of SmoothDisplacementField to true or false
        respectfully.


        """
        return _SimpleITK.DemonsRegistrationFilter_SmoothDisplacementFieldOn(
            self
        )

    def SmoothDisplacementFieldOff(self):
        r"""
        SmoothDisplacementFieldOff(DemonsRegistrationFilter self)


        """
        return _SimpleITK.DemonsRegistrationFilter_SmoothDisplacementFieldOff(
            self
        )

    def GetSmoothDisplacementField(self):
        r"""
        GetSmoothDisplacementField(DemonsRegistrationFilter self) -> bool


        Set/Get whether the displacement field is smoothed (regularized).
        Smoothing the displacement yields a solution elastic in nature. If
        SmoothDisplacementField is on, then the displacement field is smoothed
        with a Gaussian whose standard deviations are specified with SetStandardDeviations()


        """
        return _SimpleITK.DemonsRegistrationFilter_GetSmoothDisplacementField(
            self
        )

    def SetSmoothUpdateField(self, SmoothUpdateField):
        r"""
        SetSmoothUpdateField(DemonsRegistrationFilter self, bool SmoothUpdateField)


        Set/Get whether the update field is smoothed (regularized). Smoothing
        the update field yields a solution viscous in nature. If
        SmoothUpdateField is on, then the update field is smoothed with a
        Gaussian whose standard deviations are specified with SetUpdateFieldStandardDeviations()


        """
        return _SimpleITK.DemonsRegistrationFilter_SetSmoothUpdateField(
            self, SmoothUpdateField
        )

    def SmoothUpdateFieldOn(self):
        r"""
        SmoothUpdateFieldOn(DemonsRegistrationFilter self)


        Set the value of SmoothUpdateField to true or false respectfully.


        """
        return _SimpleITK.DemonsRegistrationFilter_SmoothUpdateFieldOn(self)

    def SmoothUpdateFieldOff(self):
        r"""
        SmoothUpdateFieldOff(DemonsRegistrationFilter self)


        """
        return _SimpleITK.DemonsRegistrationFilter_SmoothUpdateFieldOff(self)

    def GetSmoothUpdateField(self):
        r"""
        GetSmoothUpdateField(DemonsRegistrationFilter self) -> bool


        Set/Get whether the update field is smoothed (regularized). Smoothing
        the update field yields a solution viscous in nature. If
        SmoothUpdateField is on, then the update field is smoothed with a
        Gaussian whose standard deviations are specified with SetUpdateFieldStandardDeviations()


        """
        return _SimpleITK.DemonsRegistrationFilter_GetSmoothUpdateField(self)

    def SetUpdateFieldStandardDeviations(self, *args):
        r"""
        SetUpdateFieldStandardDeviations(DemonsRegistrationFilter self, VectorDouble UpdateFieldStandardDeviations)
        SetUpdateFieldStandardDeviations(DemonsRegistrationFilter self, double value)


        Set the Gaussian smoothing standard deviations for the update field.
        The values are set with respect to pixel coordinates.


        """
        return _SimpleITK.DemonsRegistrationFilter_SetUpdateFieldStandardDeviations(
            self, *args
        )

    def GetUpdateFieldStandardDeviations(self):
        r"""
        GetUpdateFieldStandardDeviations(DemonsRegistrationFilter self) -> VectorDouble


        Set the Gaussian smoothing standard deviations for the update field.
        The values are set with respect to pixel coordinates.


        """
        return _SimpleITK.DemonsRegistrationFilter_GetUpdateFieldStandardDeviations(
            self
        )

    def SetMaximumKernelWidth(self, MaximumKernelWidth):
        r"""
        SetMaximumKernelWidth(DemonsRegistrationFilter self, unsigned int MaximumKernelWidth)


        Set/Get the desired limits of the Gaussian kernel width.


        """
        return _SimpleITK.DemonsRegistrationFilter_SetMaximumKernelWidth(
            self, MaximumKernelWidth
        )

    def GetMaximumKernelWidth(self):
        r"""
        GetMaximumKernelWidth(DemonsRegistrationFilter self) -> unsigned int


        Set/Get the desired limits of the Gaussian kernel width.


        """
        return _SimpleITK.DemonsRegistrationFilter_GetMaximumKernelWidth(self)

    def SetMaximumError(self, MaximumError):
        r"""
        SetMaximumError(DemonsRegistrationFilter self, double MaximumError)


        Set/Get the desired maximum error of the Guassian kernel approximate.


        """
        return _SimpleITK.DemonsRegistrationFilter_SetMaximumError(
            self, MaximumError
        )

    def GetMaximumError(self):
        r"""
        GetMaximumError(DemonsRegistrationFilter self) -> double


        Set/Get the desired maximum error of the Guassian kernel approximate.


        """
        return _SimpleITK.DemonsRegistrationFilter_GetMaximumError(self)

    def SetIntensityDifferenceThreshold(self, IntensityDifferenceThreshold):
        r"""
        SetIntensityDifferenceThreshold(DemonsRegistrationFilter self, double IntensityDifferenceThreshold)


        Set/Get the threshold below which the absolute difference of intensity
        yields a match. When the intensities match between a moving and fixed
        image pixel, the update vector (for that iteration) will be the zero
        vector. Default is 0.001.


        """
        return _SimpleITK.DemonsRegistrationFilter_SetIntensityDifferenceThreshold(
            self, IntensityDifferenceThreshold
        )

    def GetIntensityDifferenceThreshold(self):
        r"""
        GetIntensityDifferenceThreshold(DemonsRegistrationFilter self) -> double


        """
        return _SimpleITK.DemonsRegistrationFilter_GetIntensityDifferenceThreshold(
            self
        )

    def SetUseImageSpacing(self, UseImageSpacing):
        r"""
        SetUseImageSpacing(DemonsRegistrationFilter self, bool UseImageSpacing)


        """
        return _SimpleITK.DemonsRegistrationFilter_SetUseImageSpacing(
            self, UseImageSpacing
        )

    def UseImageSpacingOn(self):
        r"""
        UseImageSpacingOn(DemonsRegistrationFilter self)


        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.DemonsRegistrationFilter_UseImageSpacingOn(self)

    def UseImageSpacingOff(self):
        r"""
        UseImageSpacingOff(DemonsRegistrationFilter self)


        """
        return _SimpleITK.DemonsRegistrationFilter_UseImageSpacingOff(self)

    def GetUseImageSpacing(self):
        r"""
        GetUseImageSpacing(DemonsRegistrationFilter self) -> bool


        """
        return _SimpleITK.DemonsRegistrationFilter_GetUseImageSpacing(self)

    def GetElapsedIterations(self):
        r"""
        GetElapsedIterations(DemonsRegistrationFilter self) -> uint32_t


        Number of iterations run.


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.DemonsRegistrationFilter_GetElapsedIterations(self)

    def GetRMSChange(self):
        r"""
        GetRMSChange(DemonsRegistrationFilter self) -> double


        The Root Mean Square of the levelset upon termination.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.DemonsRegistrationFilter_GetRMSChange(self)

    def GetMetric(self):
        r"""
        GetMetric(DemonsRegistrationFilter self) -> double


        Get the metric value. The metric value is the mean square difference
        in intensity between the fixed image and transforming moving image
        computed over the overlapping region between the two images. This is
        value is only available for the previous iteration and NOT the current
        iteration.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.DemonsRegistrationFilter_GetMetric(self)

    def StopRegistration(self):
        r"""
        StopRegistration(DemonsRegistrationFilter self)


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.DemonsRegistrationFilter_StopRegistration(self)

    def GetName(self):
        r"""
        GetName(DemonsRegistrationFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.DemonsRegistrationFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(DemonsRegistrationFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.DemonsRegistrationFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(DemonsRegistrationFilter self, Image fixedImage, Image movingImage, Image initialDisplacementField) -> Image
        Execute(DemonsRegistrationFilter self, Image fixedImage, Image movingImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.DemonsRegistrationFilter_Execute(self, *args)


# Register DemonsRegistrationFilter in _SimpleITK:
_SimpleITK.DemonsRegistrationFilter_swigregister(DemonsRegistrationFilter)


class DerivativeImageFilter(ImageFilter):
    r"""


    Computes the directional derivative of an image. The directional
    derivative at each pixel location is computed by convolution with a
    derivative operator of user-specified order.


    SetOrder specifies the order of the derivative.

    SetDirection specifies the direction of the derivative with respect to
    the coordinate axes of the image.


    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     itk::simple::Derivative for the procedural interface

     itk::DerivativeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkDerivativeImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_DerivativeImageFilter

    def __init__(self):
        r"""
        __init__(DerivativeImageFilter self) -> DerivativeImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.DerivativeImageFilter_swiginit(
            self, _SimpleITK.new_DerivativeImageFilter()
        )

    def SetDirection(self, Direction):
        r"""
        SetDirection(DerivativeImageFilter self, unsigned int Direction)


        The output pixel type must be signed. Standard get/set macros for
        filter parameters.


        """
        return _SimpleITK.DerivativeImageFilter_SetDirection(self, Direction)

    def GetDirection(self):
        r"""
        GetDirection(DerivativeImageFilter self) -> unsigned int


        The output pixel type must be signed. Standard get/set macros for
        filter parameters.


        """
        return _SimpleITK.DerivativeImageFilter_GetDirection(self)

    def SetOrder(self, Order):
        r"""
        SetOrder(DerivativeImageFilter self, unsigned int Order)


        The output pixel type must be signed. Standard get/set macros for
        filter parameters.


        """
        return _SimpleITK.DerivativeImageFilter_SetOrder(self, Order)

    def GetOrder(self):
        r"""
        GetOrder(DerivativeImageFilter self) -> unsigned int


        The output pixel type must be signed. Standard get/set macros for
        filter parameters.


        """
        return _SimpleITK.DerivativeImageFilter_GetOrder(self)

    def SetUseImageSpacing(self, UseImageSpacing):
        r"""
        SetUseImageSpacing(DerivativeImageFilter self, bool UseImageSpacing)


        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations. Use On to compute the derivatives in
        physical space; use Off to ignore the image spacing and to compute the
        derivatives in isotropic voxel space. Default is On.


        """
        return _SimpleITK.DerivativeImageFilter_SetUseImageSpacing(
            self, UseImageSpacing
        )

    def UseImageSpacingOn(self):
        r"""
        UseImageSpacingOn(DerivativeImageFilter self)


        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.DerivativeImageFilter_UseImageSpacingOn(self)

    def UseImageSpacingOff(self):
        r"""
        UseImageSpacingOff(DerivativeImageFilter self)


        """
        return _SimpleITK.DerivativeImageFilter_UseImageSpacingOff(self)

    def GetUseImageSpacing(self):
        r"""
        GetUseImageSpacing(DerivativeImageFilter self) -> bool


        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations. Use On to compute the derivatives in
        physical space; use Off to ignore the image spacing and to compute the
        derivatives in isotropic voxel space. Default is On.


        """
        return _SimpleITK.DerivativeImageFilter_GetUseImageSpacing(self)

    def GetName(self):
        r"""
        GetName(DerivativeImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.DerivativeImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(DerivativeImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.DerivativeImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(DerivativeImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.DerivativeImageFilter_Execute(self, image1)


# Register DerivativeImageFilter in _SimpleITK:
_SimpleITK.DerivativeImageFilter_swigregister(DerivativeImageFilter)


def Derivative(image1, direction=0, order=1, useImageSpacing=True):
    r"""Derivative(Image image1, unsigned int direction=0, unsigned int order=1, bool useImageSpacing=True) -> Image"""
    return _SimpleITK.Derivative(image1, direction, order, useImageSpacing)


class DiffeomorphicDemonsRegistrationFilter(ImageFilter):
    r"""


    Deformably register two images using a diffeomorphic demons algorithm.


    This class was contributed by Tom Vercauteren, INRIA & Mauna Kea
    Technologies, based on a variation of the DemonsRegistrationFilter . The basic modification is to use diffeomorphism exponentials.

    See T. Vercauteren, X. Pennec, A. Perchant and N. Ayache, "Non-
    parametric Diffeomorphic Image Registration with the Demons
    Algorithm", Proc. of MICCAI 2007.

    DiffeomorphicDemonsRegistrationFilter implements the demons deformable algorithm that register two images
    by computing the deformation field which will map a moving image onto
    a fixed image.

    A deformation field is represented as a image whose pixel type is some
    vector type with at least N elements, where N is the dimension of the
    fixed image. The vector type must support element access via operator
    []. It is assumed that the vector elements behave like floating point
    scalars.

    This class is templated over the fixed image type, moving image type
    and the deformation field type.

    The input fixed and moving images are set via methods SetFixedImage
    and SetMovingImage respectively. An initial deformation field maybe
    set via SetInitialDisplacementField or SetInput. If no initial field
    is set, a zero field is used as the initial condition.

    The output deformation field can be obtained via methods GetOutput or
    GetDisplacementField.

    This class make use of the finite difference solver hierarchy. Update
    for each iteration is computed in DemonsRegistrationFunction .


    Tom Vercauteren, INRIA & Mauna Kea Technologies

    WARNING:
    This filter assumes that the fixed image type, moving image type and
    deformation field type all have the same number of dimensions.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/ux2obj


    See:
     DemonsRegistrationFilter

     DemonsRegistrationFunction

     itk::DiffeomorphicDemonsRegistrationFilter for the Doxygen on the original ITK class.


    C++ includes: sitkDiffeomorphicDemonsRegistrationFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_DiffeomorphicDemonsRegistrationFilter

    def __init__(self):
        r"""
        __init__(DiffeomorphicDemonsRegistrationFilter self) -> DiffeomorphicDemonsRegistrationFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.DiffeomorphicDemonsRegistrationFilter_swiginit(
            self, _SimpleITK.new_DiffeomorphicDemonsRegistrationFilter()
        )

    def SetStandardDeviations(self, *args):
        r"""
        SetStandardDeviations(DiffeomorphicDemonsRegistrationFilter self, VectorDouble StandardDeviations)
        SetStandardDeviations(DiffeomorphicDemonsRegistrationFilter self, double value)


        Set/Get the Gaussian smoothing standard deviations for the
        displacement field. The values are set with respect to pixel
        coordinates.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetStandardDeviations(
            self, *args
        )

    def GetStandardDeviations(self):
        r"""
        GetStandardDeviations(DiffeomorphicDemonsRegistrationFilter self) -> VectorDouble


        Set/Get the Gaussian smoothing standard deviations for the
        displacement field. The values are set with respect to pixel
        coordinates.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetStandardDeviations(
            self
        )

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(DiffeomorphicDemonsRegistrationFilter self, uint32_t NumberOfIterations)


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(DiffeomorphicDemonsRegistrationFilter self) -> uint32_t


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetNumberOfIterations(
            self
        )

    def SetMaximumRMSError(self, MaximumRMSError):
        r"""
        SetMaximumRMSError(DiffeomorphicDemonsRegistrationFilter self, double MaximumRMSError)


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetMaximumRMSError(
            self, MaximumRMSError
        )

    def GetMaximumRMSError(self):
        r"""
        GetMaximumRMSError(DiffeomorphicDemonsRegistrationFilter self) -> double


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetMaximumRMSError(
            self
        )

    Symmetric = _SimpleITK.DiffeomorphicDemonsRegistrationFilter_Symmetric

    Fixed = _SimpleITK.DiffeomorphicDemonsRegistrationFilter_Fixed

    WarpedMoving = (
        _SimpleITK.DiffeomorphicDemonsRegistrationFilter_WarpedMoving
    )

    MappedMoving = (
        _SimpleITK.DiffeomorphicDemonsRegistrationFilter_MappedMoving
    )

    def SetUseGradientType(self, UseGradientType):
        r"""
        SetUseGradientType(DiffeomorphicDemonsRegistrationFilter self, itk::simple::DiffeomorphicDemonsRegistrationFilter::UseGradientTypeType UseGradientType)


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetUseGradientType(
            self, UseGradientType
        )

    def GetUseGradientType(self):
        r"""
        GetUseGradientType(DiffeomorphicDemonsRegistrationFilter self) -> itk::simple::DiffeomorphicDemonsRegistrationFilter::UseGradientTypeType


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetUseGradientType(
            self
        )

    def SetUseFirstOrderExp(self, UseFirstOrderExp):
        r"""
        SetUseFirstOrderExp(DiffeomorphicDemonsRegistrationFilter self, bool UseFirstOrderExp)


        Use a first-order approximation of the exponential. This amounts to
        using an update rule of the type s <- s o (Id + u) instead of s <- s o
        exp(u)


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetUseFirstOrderExp(
            self, UseFirstOrderExp
        )

    def UseFirstOrderExpOn(self):
        r"""
        UseFirstOrderExpOn(DiffeomorphicDemonsRegistrationFilter self)


        Set the value of UseFirstOrderExp to true or false respectfully.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_UseFirstOrderExpOn(
            self
        )

    def UseFirstOrderExpOff(self):
        r"""
        UseFirstOrderExpOff(DiffeomorphicDemonsRegistrationFilter self)


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_UseFirstOrderExpOff(
            self
        )

    def GetUseFirstOrderExp(self):
        r"""
        GetUseFirstOrderExp(DiffeomorphicDemonsRegistrationFilter self) -> bool


        Use a first-order approximation of the exponential. This amounts to
        using an update rule of the type s <- s o (Id + u) instead of s <- s o
        exp(u)


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetUseFirstOrderExp(
            self
        )

    def SetMaximumUpdateStepLength(self, MaximumUpdateStepLength):
        r"""
        SetMaximumUpdateStepLength(DiffeomorphicDemonsRegistrationFilter self, double MaximumUpdateStepLength)


        Set/Get the maximum length in terms of pixels of the vectors in the
        update buffer.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetMaximumUpdateStepLength(
            self, MaximumUpdateStepLength
        )

    def GetMaximumUpdateStepLength(self):
        r"""
        GetMaximumUpdateStepLength(DiffeomorphicDemonsRegistrationFilter self) -> double


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetMaximumUpdateStepLength(
            self
        )

    def SetSmoothDisplacementField(self, SmoothDisplacementField):
        r"""
        SetSmoothDisplacementField(DiffeomorphicDemonsRegistrationFilter self, bool SmoothDisplacementField)


        Set/Get whether the displacement field is smoothed (regularized).
        Smoothing the displacement yields a solution elastic in nature. If
        SmoothDisplacementField is on, then the displacement field is smoothed
        with a Gaussian whose standard deviations are specified with SetStandardDeviations()


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetSmoothDisplacementField(
            self, SmoothDisplacementField
        )

    def SmoothDisplacementFieldOn(self):
        r"""
        SmoothDisplacementFieldOn(DiffeomorphicDemonsRegistrationFilter self)


        Set the value of SmoothDisplacementField to true or false
        respectfully.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SmoothDisplacementFieldOn(
            self
        )

    def SmoothDisplacementFieldOff(self):
        r"""
        SmoothDisplacementFieldOff(DiffeomorphicDemonsRegistrationFilter self)


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SmoothDisplacementFieldOff(
            self
        )

    def GetSmoothDisplacementField(self):
        r"""
        GetSmoothDisplacementField(DiffeomorphicDemonsRegistrationFilter self) -> bool


        Set/Get whether the displacement field is smoothed (regularized).
        Smoothing the displacement yields a solution elastic in nature. If
        SmoothDisplacementField is on, then the displacement field is smoothed
        with a Gaussian whose standard deviations are specified with SetStandardDeviations()


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetSmoothDisplacementField(
            self
        )

    def SetSmoothUpdateField(self, SmoothUpdateField):
        r"""
        SetSmoothUpdateField(DiffeomorphicDemonsRegistrationFilter self, bool SmoothUpdateField)


        Set/Get whether the update field is smoothed (regularized). Smoothing
        the update field yields a solution viscous in nature. If
        SmoothUpdateField is on, then the update field is smoothed with a
        Gaussian whose standard deviations are specified with SetUpdateFieldStandardDeviations()


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetSmoothUpdateField(
            self, SmoothUpdateField
        )

    def SmoothUpdateFieldOn(self):
        r"""
        SmoothUpdateFieldOn(DiffeomorphicDemonsRegistrationFilter self)


        Set the value of SmoothUpdateField to true or false respectfully.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SmoothUpdateFieldOn(
            self
        )

    def SmoothUpdateFieldOff(self):
        r"""
        SmoothUpdateFieldOff(DiffeomorphicDemonsRegistrationFilter self)


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SmoothUpdateFieldOff(
            self
        )

    def GetSmoothUpdateField(self):
        r"""
        GetSmoothUpdateField(DiffeomorphicDemonsRegistrationFilter self) -> bool


        Set/Get whether the update field is smoothed (regularized). Smoothing
        the update field yields a solution viscous in nature. If
        SmoothUpdateField is on, then the update field is smoothed with a
        Gaussian whose standard deviations are specified with SetUpdateFieldStandardDeviations()


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetSmoothUpdateField(
            self
        )

    def SetUpdateFieldStandardDeviations(self, *args):
        r"""
        SetUpdateFieldStandardDeviations(DiffeomorphicDemonsRegistrationFilter self, VectorDouble UpdateFieldStandardDeviations)
        SetUpdateFieldStandardDeviations(DiffeomorphicDemonsRegistrationFilter self, double value)


        Set the Gaussian smoothing standard deviations for the update field.
        The values are set with respect to pixel coordinates.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetUpdateFieldStandardDeviations(
            self, *args
        )

    def GetUpdateFieldStandardDeviations(self):
        r"""
        GetUpdateFieldStandardDeviations(DiffeomorphicDemonsRegistrationFilter self) -> VectorDouble


        Set the Gaussian smoothing standard deviations for the update field.
        The values are set with respect to pixel coordinates.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetUpdateFieldStandardDeviations(
            self
        )

    def SetMaximumKernelWidth(self, MaximumKernelWidth):
        r"""
        SetMaximumKernelWidth(DiffeomorphicDemonsRegistrationFilter self, unsigned int MaximumKernelWidth)


        Set/Get the desired limits of the Gaussian kernel width.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetMaximumKernelWidth(
            self, MaximumKernelWidth
        )

    def GetMaximumKernelWidth(self):
        r"""
        GetMaximumKernelWidth(DiffeomorphicDemonsRegistrationFilter self) -> unsigned int


        Set/Get the desired limits of the Gaussian kernel width.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetMaximumKernelWidth(
            self
        )

    def SetMaximumError(self, MaximumError):
        r"""
        SetMaximumError(DiffeomorphicDemonsRegistrationFilter self, double MaximumError)


        Set/Get the desired maximum error of the Guassian kernel approximate.


        """
        return (
            _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetMaximumError(
                self, MaximumError
            )
        )

    def GetMaximumError(self):
        r"""
        GetMaximumError(DiffeomorphicDemonsRegistrationFilter self) -> double


        Set/Get the desired maximum error of the Guassian kernel approximate.


        """
        return (
            _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetMaximumError(
                self
            )
        )

    def SetIntensityDifferenceThreshold(self, IntensityDifferenceThreshold):
        r"""
        SetIntensityDifferenceThreshold(DiffeomorphicDemonsRegistrationFilter self, double IntensityDifferenceThreshold)


        Set/Get the threshold below which the absolute difference of intensity
        yields a match. When the intensities match between a moving and fixed
        image pixel, the update vector (for that iteration) will be the zero
        vector. Default is 0.001.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetIntensityDifferenceThreshold(
            self, IntensityDifferenceThreshold
        )

    def GetIntensityDifferenceThreshold(self):
        r"""
        GetIntensityDifferenceThreshold(DiffeomorphicDemonsRegistrationFilter self) -> double


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetIntensityDifferenceThreshold(
            self
        )

    def SetUseImageSpacing(self, UseImageSpacing):
        r"""
        SetUseImageSpacing(DiffeomorphicDemonsRegistrationFilter self, bool UseImageSpacing)


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetUseImageSpacing(
            self, UseImageSpacing
        )

    def UseImageSpacingOn(self):
        r"""
        UseImageSpacingOn(DiffeomorphicDemonsRegistrationFilter self)


        Set the value of UseImageSpacing to true or false respectfully.


        """
        return (
            _SimpleITK.DiffeomorphicDemonsRegistrationFilter_UseImageSpacingOn(
                self
            )
        )

    def UseImageSpacingOff(self):
        r"""
        UseImageSpacingOff(DiffeomorphicDemonsRegistrationFilter self)


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_UseImageSpacingOff(
            self
        )

    def GetUseImageSpacing(self):
        r"""
        GetUseImageSpacing(DiffeomorphicDemonsRegistrationFilter self) -> bool


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetUseImageSpacing(
            self
        )

    def GetElapsedIterations(self):
        r"""
        GetElapsedIterations(DiffeomorphicDemonsRegistrationFilter self) -> uint32_t


        Number of iterations run.


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetElapsedIterations(
            self
        )

    def GetRMSChange(self):
        r"""
        GetRMSChange(DiffeomorphicDemonsRegistrationFilter self) -> double


        Set/Get the root mean squared change of the previous iteration. May
        not be used by all solvers.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetRMSChange(
            self
        )

    def GetMetric(self):
        r"""
        GetMetric(DiffeomorphicDemonsRegistrationFilter self) -> double


        Get the metric value. The metric value is the mean square difference
        in intensity between the fixed image and transforming moving image
        computed over the overlapping region between the two images. This
        value is calculated for the current iteration

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetMetric(self)

    def StopRegistration(self):
        r"""
        StopRegistration(DiffeomorphicDemonsRegistrationFilter self)


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return (
            _SimpleITK.DiffeomorphicDemonsRegistrationFilter_StopRegistration(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(DiffeomorphicDemonsRegistrationFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(DiffeomorphicDemonsRegistrationFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(DiffeomorphicDemonsRegistrationFilter self, Image fixedImage, Image movingImage, Image initialDisplacementField) -> Image
        Execute(DiffeomorphicDemonsRegistrationFilter self, Image fixedImage, Image movingImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_Execute(
            self, *args
        )


# Register DiffeomorphicDemonsRegistrationFilter in _SimpleITK:
_SimpleITK.DiffeomorphicDemonsRegistrationFilter_swigregister(
    DiffeomorphicDemonsRegistrationFilter
)


class DilateObjectMorphologyImageFilter(ImageFilter):
    r"""


    dilation of an object in an image


    Dilate an image using binary morphology. Pixel values matching the
    object value are considered the "foreground" and all other pixels
    are "background". This is useful in processing mask images
    containing only one object.

    If a pixel's value is equal to the object value and the pixel is
    adjacent to a non-object valued pixel, then the kernel is centered on
    the object-value pixel and neighboring pixels covered by the kernel
    are assigned the object value. The structuring element is assumed to
    be composed of binary values (zero or one).


    See:
     ObjectMorphologyImageFilter , ErodeObjectMorphologyImageFilter

     BinaryDilateImageFilter

     itk::simple::DilateObjectMorphology for the procedural interface

     itk::DilateObjectMorphologyImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkDilateObjectMorphologyImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_DilateObjectMorphologyImageFilter

    def __init__(self):
        r"""
        __init__(DilateObjectMorphologyImageFilter self) -> DilateObjectMorphologyImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.DilateObjectMorphologyImageFilter_swiginit(
            self, _SimpleITK.new_DilateObjectMorphologyImageFilter()
        )

    def SetKernelRadius(self, *args):
        r"""
        SetKernelRadius(DilateObjectMorphologyImageFilter self, VectorUInt32 KernelRadius)
        SetKernelRadius(DilateObjectMorphologyImageFilter self, unsigned int value)


        Set the values of the KernelRadius vector all to value


        """
        return _SimpleITK.DilateObjectMorphologyImageFilter_SetKernelRadius(
            self, *args
        )

    def GetKernelRadius(self):
        r"""
        GetKernelRadius(DilateObjectMorphologyImageFilter self) -> VectorUInt32


        Get the radius of the kernel structuring element.


        """
        return _SimpleITK.DilateObjectMorphologyImageFilter_GetKernelRadius(
            self
        )

    def SetKernelType(self, KernelType):
        r"""
        SetKernelType(DilateObjectMorphologyImageFilter self, itk::simple::KernelEnum KernelType)


        Set the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.DilateObjectMorphologyImageFilter_SetKernelType(
            self, KernelType
        )

    def GetKernelType(self):
        r"""
        GetKernelType(DilateObjectMorphologyImageFilter self) -> itk::simple::KernelEnum


        Get the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.DilateObjectMorphologyImageFilter_GetKernelType(self)

    def SetObjectValue(self, ObjectValue):
        r"""
        SetObjectValue(DilateObjectMorphologyImageFilter self, double ObjectValue)


        """
        return _SimpleITK.DilateObjectMorphologyImageFilter_SetObjectValue(
            self, ObjectValue
        )

    def GetObjectValue(self):
        r"""
        GetObjectValue(DilateObjectMorphologyImageFilter self) -> double


        """
        return _SimpleITK.DilateObjectMorphologyImageFilter_GetObjectValue(
            self
        )

    def GetName(self):
        r"""
        GetName(DilateObjectMorphologyImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.DilateObjectMorphologyImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(DilateObjectMorphologyImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.DilateObjectMorphologyImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(DilateObjectMorphologyImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.DilateObjectMorphologyImageFilter_Execute(
            self, image1
        )


# Register DilateObjectMorphologyImageFilter in _SimpleITK:
_SimpleITK.DilateObjectMorphologyImageFilter_swigregister(
    DilateObjectMorphologyImageFilter
)


def DilateObjectMorphology(*args, **kwargs):
    r"""DilateObjectMorphology(Image image1, VectorUInt32 kernelRadius=std::vector< uint32_t >(3, 1), itk::simple::KernelEnum kernelType=sitkBall, double objectValue=1) -> Image"""
    return _SimpleITK.DilateObjectMorphology(*args, **kwargs)


class DiscreteGaussianDerivativeImageFilter(ImageFilter):
    r"""


    Calculates image derivatives using discrete derivative gaussian
    kernels. This filter calculates Gaussian derivative by separable
    convolution of an image and a discrete Gaussian derivative operator
    (kernel).


    The Gaussian operators used here were described by Tony Lindeberg
    (Discrete Scale-Space Theory and the Scale-Space Primal Sketch.
    Dissertation. Royal Institute of Technology, Stockholm, Sweden. May
    1991.)

    The variance or standard deviation (sigma) will be evaluated as pixel
    units if SetUseImageSpacing is off (false) or as physical units if
    SetUseImageSpacing is on (true, default). The variance can be set
    independently in each dimension.

    When the Gaussian kernel is small, this filter tends to run faster
    than itk::RecursiveGaussianImageFilter .


    Ivan Macia, Vicomtech, Spain, https://www.vicomtech.org/en
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/mrg5is


    See:
     GaussianDerivativeOperator

     Image

     Neighborhood

     NeighborhoodOperator

     itk::simple::DiscreteGaussianDerivative for the procedural interface

     itk::DiscreteGaussianDerivativeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkDiscreteGaussianDerivativeImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_DiscreteGaussianDerivativeImageFilter

    def __init__(self):
        r"""
        __init__(DiscreteGaussianDerivativeImageFilter self) -> DiscreteGaussianDerivativeImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.DiscreteGaussianDerivativeImageFilter_swiginit(
            self, _SimpleITK.new_DiscreteGaussianDerivativeImageFilter()
        )

    def SetVariance(self, *args):
        r"""
        SetVariance(DiscreteGaussianDerivativeImageFilter self, VectorDouble Variance)
        SetVariance(DiscreteGaussianDerivativeImageFilter self, double value)


        Convenience Set methods for setting all dimensional parameters to the
        same values.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_SetVariance(
            self, *args
        )

    def GetVariance(self):
        r"""
        GetVariance(DiscreteGaussianDerivativeImageFilter self) -> VectorDouble


        The variance for the discrete Gaussian kernel. Sets the variance
        independently for each dimension, but see also SetVariance(const double v) . The default is 0.0 in each dimension. If UseImageSpacing is true,
        the units are the physical units of your image. If UseImageSpacing is
        false then the units are pixels.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_GetVariance(
            self
        )

    def SetOrder(self, *args):
        r"""
        SetOrder(DiscreteGaussianDerivativeImageFilter self, VectorUInt32 Order)
        SetOrder(DiscreteGaussianDerivativeImageFilter self, unsigned int value)


        Set the values of the Order vector all to value


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_SetOrder(
            self, *args
        )

    def GetOrder(self):
        r"""
        GetOrder(DiscreteGaussianDerivativeImageFilter self) -> VectorUInt32


        Order of derivatives in each dimension. Sets the derivative order
        independently for each dimension, but see also SetOrder(const unsigned int v) . The default is 1 in each dimension.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_GetOrder(self)

    def SetMaximumKernelWidth(self, MaximumKernelWidth):
        r"""
        SetMaximumKernelWidth(DiscreteGaussianDerivativeImageFilter self, unsigned int MaximumKernelWidth)


        Set the kernel to be no wider than MaximumKernelWidth pixels, even if
        MaximumError demands it. The default is 32 pixels.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_SetMaximumKernelWidth(
            self, MaximumKernelWidth
        )

    def GetMaximumKernelWidth(self):
        r"""
        GetMaximumKernelWidth(DiscreteGaussianDerivativeImageFilter self) -> unsigned int


        Set the kernel to be no wider than MaximumKernelWidth pixels, even if
        MaximumError demands it. The default is 32 pixels.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_GetMaximumKernelWidth(
            self
        )

    def SetMaximumError(self, MaximumError):
        r"""
        SetMaximumError(DiscreteGaussianDerivativeImageFilter self, double MaximumError)


        Convenience Set methods for setting all dimensional parameters to the
        same values.


        """
        return (
            _SimpleITK.DiscreteGaussianDerivativeImageFilter_SetMaximumError(
                self, MaximumError
            )
        )

    def GetMaximumError(self):
        r"""
        GetMaximumError(DiscreteGaussianDerivativeImageFilter self) -> double


        The algorithm will size the discrete kernel so that the error
        resulting from truncation of the kernel is no greater than
        MaximumError. The default is 0.01 in each dimension.


        """
        return (
            _SimpleITK.DiscreteGaussianDerivativeImageFilter_GetMaximumError(
                self
            )
        )

    def SetUseImageSpacing(self, UseImageSpacing):
        r"""
        SetUseImageSpacing(DiscreteGaussianDerivativeImageFilter self, bool UseImageSpacing)


        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations. Default is ImageSpacingOn.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_SetUseImageSpacing(
            self, UseImageSpacing
        )

    def UseImageSpacingOn(self):
        r"""
        UseImageSpacingOn(DiscreteGaussianDerivativeImageFilter self)


        Set the value of UseImageSpacing to true or false respectfully.


        """
        return (
            _SimpleITK.DiscreteGaussianDerivativeImageFilter_UseImageSpacingOn(
                self
            )
        )

    def UseImageSpacingOff(self):
        r"""
        UseImageSpacingOff(DiscreteGaussianDerivativeImageFilter self)


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_UseImageSpacingOff(
            self
        )

    def GetUseImageSpacing(self):
        r"""
        GetUseImageSpacing(DiscreteGaussianDerivativeImageFilter self) -> bool


        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations. Default is ImageSpacingOn.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_GetUseImageSpacing(
            self
        )

    def SetNormalizeAcrossScale(self, NormalizeAcrossScale):
        r"""
        SetNormalizeAcrossScale(DiscreteGaussianDerivativeImageFilter self, bool NormalizeAcrossScale)


        Set/Get the flag for calculating scale-space normalized derivatives.
        Normalized derivatives are obtained multiplying by the scale parameter
        t.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_SetNormalizeAcrossScale(
            self, NormalizeAcrossScale
        )

    def NormalizeAcrossScaleOn(self):
        r"""
        NormalizeAcrossScaleOn(DiscreteGaussianDerivativeImageFilter self)


        Set the value of NormalizeAcrossScale to true or false respectfully.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_NormalizeAcrossScaleOn(
            self
        )

    def NormalizeAcrossScaleOff(self):
        r"""
        NormalizeAcrossScaleOff(DiscreteGaussianDerivativeImageFilter self)


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_NormalizeAcrossScaleOff(
            self
        )

    def GetNormalizeAcrossScale(self):
        r"""
        GetNormalizeAcrossScale(DiscreteGaussianDerivativeImageFilter self) -> bool


        Set/Get the flag for calculating scale-space normalized derivatives.
        Normalized derivatives are obtained multiplying by the scale parameter
        t.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_GetNormalizeAcrossScale(
            self
        )

    def GetName(self):
        r"""
        GetName(DiscreteGaussianDerivativeImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(DiscreteGaussianDerivativeImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(DiscreteGaussianDerivativeImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_Execute(
            self, image1
        )


# Register DiscreteGaussianDerivativeImageFilter in _SimpleITK:
_SimpleITK.DiscreteGaussianDerivativeImageFilter_swigregister(
    DiscreteGaussianDerivativeImageFilter
)


def DiscreteGaussianDerivative(*args, **kwargs):
    r"""DiscreteGaussianDerivative(Image image1, VectorDouble variance=std::vector< double >(3, 0.0), VectorUInt32 order=std::vector< unsigned int >(3, 1), unsigned int maximumKernelWidth=32, double maximumError=0.01, bool useImageSpacing=True, bool normalizeAcrossScale=False) -> Image"""
    return _SimpleITK.DiscreteGaussianDerivative(*args, **kwargs)


class DiscreteGaussianImageFilter(ImageFilter):
    r"""


    Blurs an image by separable convolution with discrete gaussian
    kernels. This filter performs Gaussian blurring by separable
    convolution of an image and a discrete Gaussian operator (kernel).


    The Gaussian operator used here was described by Tony Lindeberg
    (Discrete Scale-Space Theory and the Scale-Space Primal Sketch.
    Dissertation. Royal Institute of Technology, Stockholm, Sweden. May
    1991.) The Gaussian kernel used here was designed so that smoothing
    and derivative operations commute after discretization.

    The variance or standard deviation (sigma) will be evaluated as pixel
    units if SetUseImageSpacing is off (false) or as physical units if
    SetUseImageSpacing is on (true, default). The variance can be set
    independently in each dimension.

    When the Gaussian kernel is small, this filter tends to run faster
    than itk::RecursiveGaussianImageFilter .


    See:
     GaussianOperator

     Image

     Neighborhood

     NeighborhoodOperator

     RecursiveGaussianImageFilter

     itk::simple::DiscreteGaussian for the procedural interface

     itk::DiscreteGaussianImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkDiscreteGaussianImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_DiscreteGaussianImageFilter

    def __init__(self):
        r"""
        __init__(DiscreteGaussianImageFilter self) -> DiscreteGaussianImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.DiscreteGaussianImageFilter_swiginit(
            self, _SimpleITK.new_DiscreteGaussianImageFilter()
        )

    def SetVariance(self, *args):
        r"""
        SetVariance(DiscreteGaussianImageFilter self, VectorDouble Variance)
        SetVariance(DiscreteGaussianImageFilter self, double value)


        """
        return _SimpleITK.DiscreteGaussianImageFilter_SetVariance(self, *args)

    def GetVariance(self):
        r"""
        GetVariance(DiscreteGaussianImageFilter self) -> VectorDouble


        The variance for the discrete Gaussian kernel. Sets the variance
        independently for each dimension, but see also SetVariance(const double v) . The default is 0.0 in each dimension. If UseImageSpacing is true,
        the units are the physical units of your image. If UseImageSpacing is
        false then the units are pixels.


        """
        return _SimpleITK.DiscreteGaussianImageFilter_GetVariance(self)

    def SetMaximumKernelWidth(self, MaximumKernelWidth):
        r"""
        SetMaximumKernelWidth(DiscreteGaussianImageFilter self, unsigned int MaximumKernelWidth)


        Set the kernel to be no wider than MaximumKernelWidth pixels, even if
        MaximumError demands it. The default is 32 pixels.


        """
        return _SimpleITK.DiscreteGaussianImageFilter_SetMaximumKernelWidth(
            self, MaximumKernelWidth
        )

    def GetMaximumKernelWidth(self):
        r"""
        GetMaximumKernelWidth(DiscreteGaussianImageFilter self) -> unsigned int


        Set the kernel to be no wider than MaximumKernelWidth pixels, even if
        MaximumError demands it. The default is 32 pixels.


        """
        return _SimpleITK.DiscreteGaussianImageFilter_GetMaximumKernelWidth(
            self
        )

    def SetMaximumError(self, *args):
        r"""
        SetMaximumError(DiscreteGaussianImageFilter self, VectorDouble MaximumError)
        SetMaximumError(DiscreteGaussianImageFilter self, double value)


        """
        return _SimpleITK.DiscreteGaussianImageFilter_SetMaximumError(
            self, *args
        )

    def GetMaximumError(self):
        r"""
        GetMaximumError(DiscreteGaussianImageFilter self) -> VectorDouble


        The algorithm will size the discrete kernel so that the error
        resulting from truncation of the kernel is no greater than
        MaximumError. The default is 0.01 in each dimension.


        """
        return _SimpleITK.DiscreteGaussianImageFilter_GetMaximumError(self)

    def SetUseImageSpacing(self, UseImageSpacing):
        r"""
        SetUseImageSpacing(DiscreteGaussianImageFilter self, bool UseImageSpacing)


        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations. Use On to take the image spacing
        information into account and to specify the Gaussian variance in real
        world units; use Off to ignore the image spacing and to specify the
        Gaussian variance in voxel units. Default is On.


        """
        return _SimpleITK.DiscreteGaussianImageFilter_SetUseImageSpacing(
            self, UseImageSpacing
        )

    def UseImageSpacingOn(self):
        r"""
        UseImageSpacingOn(DiscreteGaussianImageFilter self)


        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.DiscreteGaussianImageFilter_UseImageSpacingOn(self)

    def UseImageSpacingOff(self):
        r"""
        UseImageSpacingOff(DiscreteGaussianImageFilter self)


        """
        return _SimpleITK.DiscreteGaussianImageFilter_UseImageSpacingOff(self)

    def GetUseImageSpacing(self):
        r"""
        GetUseImageSpacing(DiscreteGaussianImageFilter self) -> bool


        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations. Use On to take the image spacing
        information into account and to specify the Gaussian variance in real
        world units; use Off to ignore the image spacing and to specify the
        Gaussian variance in voxel units. Default is On.


        """
        return _SimpleITK.DiscreteGaussianImageFilter_GetUseImageSpacing(self)

    def GetName(self):
        r"""
        GetName(DiscreteGaussianImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.DiscreteGaussianImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(DiscreteGaussianImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.DiscreteGaussianImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(DiscreteGaussianImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.DiscreteGaussianImageFilter_Execute(self, image1)


# Register DiscreteGaussianImageFilter in _SimpleITK:
_SimpleITK.DiscreteGaussianImageFilter_swigregister(
    DiscreteGaussianImageFilter
)


class DisplacementFieldJacobianDeterminantFilter(ImageFilter):
    r"""


    Computes a scalar image from a vector image (e.g., deformation field)
    input, where each output scalar at each pixel is the Jacobian
    determinant of the vector field at that location. This calculation is
    correct in the case where the vector image is a "displacement" from
    the current location. The computation for the jacobian determinant is:
    det[ dT/dx ] = det[ I + du/dx ].


    Overview
    This filter is based on itkVectorGradientMagnitudeImageFilter and
    supports the m_DerivativeWeights weights for partial derivatives.
     Note that the determinant of a zero vector field is also zero,
    whereas the Jacobian determinant of the corresponding identity warp
    transformation is 1.0. In order to compute the effective deformation
    Jacobian determinant 1.0 must be added to the diagonal elements of
    Jacobian prior to taking the derivative. i.e. det([ (1.0+dx/dx) dx/dy
    dx/dz ; dy/dx (1.0+dy/dy) dy/dz; dz/dx dz/dy (1.0+dz/dz) ])

    Template Parameters (Input and Output)
    This filter has one required template parameter which defines the
    input image type. The pixel type of the input image is assumed to be a
    vector (e.g., itk::Vector , itk::RGBPixel , itk::FixedArray ). The scalar type of the vector components must be castable to
    floating point. Instantiating with an image of RGBPixel<unsigned
    short>, for example, is allowed, but the filter will convert it to an
    image of Vector<float,3> for processing.
     The second template parameter, TRealType, can be optionally specified
    to define the scalar numerical type used in calculations. This is the
    component type of the output image, which will be of
    itk::Vector<TRealType, N>, where N is the number of channels in the
    multiple component input image. The default type of TRealType is
    float. For extra precision, you may safely change this parameter to
    double.

    The third template parameter is the output image type. The third
    parameter will be automatically constructed from the first and second
    parameters, so it is not necessary (or advisable) to set this
    parameter explicitly. Given an M-channel input image with
    dimensionality N, and a numerical type specified as TRealType, the
    output image will be of type itk::Image<TRealType, N>.

    Filter Parameters
    The method UseImageSpacingOn will cause derivatives in the image to be
    scaled (inversely) with the pixel size of the input image, effectively
    taking derivatives in world coordinates (versus isotropic image
    space). UseImageSpacingOff turns this functionality off. Default is
    UseImageSpacingOn. The parameter UseImageSpacing can be set directly
    with the method SetUseImageSpacing(bool) .
     Weights can be applied to the derivatives directly using the
    SetDerivativeWeights method. Note that if UseImageSpacing is set to
    TRUE (ON), then these weights will be overridden by weights derived
    from the image spacing when the filter is updated. The argument to
    this method is a C array of TRealValue type.

    Constraints
    We use vnl_det for determinant computation, which only supports square
    matrices. So the vector dimension of the input image values must be
    equal to the image dimensions, which is trivially true for a
    deformation field that maps an n-dimensional space onto itself.
     Currently, dimensions up to and including 4 are supported. This
    limitation comes from the presence of vnl_det() functions for matrices
    of dimension up to 4x4.

    The template parameter TRealType must be floating point (float or
    double) or a user-defined "real" numerical type with arithmetic
    operations defined sufficient to compute derivatives.


    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

    This class was adapted by

    Hans J. Johnson, The University of Iowa from code provided by

    Tom Vercauteren, INRIA & Mauna Kea Technologies

    Torsten Rohlfing, Neuroscience Program, SRI International.

    See:
     itk::simple::DisplacementFieldJacobianDeterminantFilter for the procedural interface

     itk::DisplacementFieldJacobianDeterminantFilter for the Doxygen on the original ITK class.


    C++ includes: sitkDisplacementFieldJacobianDeterminantFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_DisplacementFieldJacobianDeterminantFilter
    )

    def __init__(self):
        r"""
        __init__(DisplacementFieldJacobianDeterminantFilter self) -> DisplacementFieldJacobianDeterminantFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.DisplacementFieldJacobianDeterminantFilter_swiginit(
            self, _SimpleITK.new_DisplacementFieldJacobianDeterminantFilter()
        )

    def SetUseImageSpacing(self, UseImageSpacing):
        r"""
        SetUseImageSpacing(DisplacementFieldJacobianDeterminantFilter self, bool UseImageSpacing)


        Set/Get whether or not the filter will use the spacing of the input
        image (1/spacing) in the calculation of the Jacobian determinant. Use
        On to compute the Jacobian determinant in the space in which the data
        was acquired; use Off to reset the derivative weights, ignore the
        image spacing, and to compute the Jacobian determinant in the image
        space. Default is On.


        """
        return _SimpleITK.DisplacementFieldJacobianDeterminantFilter_SetUseImageSpacing(
            self, UseImageSpacing
        )

    def UseImageSpacingOn(self):
        r"""
        UseImageSpacingOn(DisplacementFieldJacobianDeterminantFilter self)


        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.DisplacementFieldJacobianDeterminantFilter_UseImageSpacingOn(
            self
        )

    def UseImageSpacingOff(self):
        r"""
        UseImageSpacingOff(DisplacementFieldJacobianDeterminantFilter self)


        """
        return _SimpleITK.DisplacementFieldJacobianDeterminantFilter_UseImageSpacingOff(
            self
        )

    def GetUseImageSpacing(self):
        r"""
        GetUseImageSpacing(DisplacementFieldJacobianDeterminantFilter self) -> bool


        Set/Get whether or not the filter will use the spacing of the input
        image (1/spacing) in the calculation of the Jacobian determinant. Use
        On to compute the Jacobian determinant in the space in which the data
        was acquired; use Off to reset the derivative weights, ignore the
        image spacing, and to compute the Jacobian determinant in the image
        space. Default is On.


        """
        return _SimpleITK.DisplacementFieldJacobianDeterminantFilter_GetUseImageSpacing(
            self
        )

    def SetDerivativeWeights(self, DerivativeWeights):
        r"""
        SetDerivativeWeights(DisplacementFieldJacobianDeterminantFilter self, VectorDouble DerivativeWeights)


        Directly Set/Get the array of weights used in the gradient
        calculations. Note that calling UseImageSpacingOn will clobber these
        values.


        """
        return _SimpleITK.DisplacementFieldJacobianDeterminantFilter_SetDerivativeWeights(
            self, DerivativeWeights
        )

    def GetDerivativeWeights(self):
        r"""
        GetDerivativeWeights(DisplacementFieldJacobianDeterminantFilter self) -> VectorDouble


        Directly Set/Get the array of weights used in the gradient
        calculations. Note that calling UseImageSpacingOn will clobber these
        values.


        """
        return _SimpleITK.DisplacementFieldJacobianDeterminantFilter_GetDerivativeWeights(
            self
        )

    def GetName(self):
        r"""
        GetName(DisplacementFieldJacobianDeterminantFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.DisplacementFieldJacobianDeterminantFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(DisplacementFieldJacobianDeterminantFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.DisplacementFieldJacobianDeterminantFilter___str__(
            self
        )

    def Execute(self, image1):
        r"""
        Execute(DisplacementFieldJacobianDeterminantFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.DisplacementFieldJacobianDeterminantFilter_Execute(
            self, image1
        )


# Register DisplacementFieldJacobianDeterminantFilter in _SimpleITK:
_SimpleITK.DisplacementFieldJacobianDeterminantFilter_swigregister(
    DisplacementFieldJacobianDeterminantFilter
)


def DisplacementFieldJacobianDeterminant(*args, **kwargs):
    r"""DisplacementFieldJacobianDeterminant(Image image1, bool useImageSpacing=True, VectorDouble derivativeWeights=std::vector< double >()) -> Image"""
    return _SimpleITK.DisplacementFieldJacobianDeterminant(*args, **kwargs)


class DivideFloorImageFilter(ImageFilter):
    r"""


    Implements pixel-wise generic operation of two images, or of an image
    and a constant.


    This class is parameterized over the types of the two input images and
    the type of the output image. It is also parameterized by the
    operation to be applied. A Functor style is used.

    The constant must be of the same type than the pixel type of the
    corresponding image. It is wrapped in a SimpleDataObjectDecorator so it can be updated through the pipeline. The SetConstant() and
    GetConstant() methods are provided as shortcuts to set or get the
    constant value without manipulating the decorator.


    See:
     BinaryGeneratorImagFilter

     UnaryFunctorImageFilter TernaryFunctorImageFilter

     itk::simple::DivideFloor for the procedural interface

     itk::BinaryFunctorImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkDivideFloorImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_DivideFloorImageFilter

    def __init__(self):
        r"""
        __init__(DivideFloorImageFilter self) -> DivideFloorImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.DivideFloorImageFilter_swiginit(
            self, _SimpleITK.new_DivideFloorImageFilter()
        )

    def GetName(self):
        r"""
        GetName(DivideFloorImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.DivideFloorImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(DivideFloorImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.DivideFloorImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(DivideFloorImageFilter self, Image image1, Image image2) -> Image
        Execute(DivideFloorImageFilter self, Image image1, double constant) -> Image
        Execute(DivideFloorImageFilter self, double constant, Image image2) -> Image


        """
        return _SimpleITK.DivideFloorImageFilter_Execute(self, *args)


# Register DivideFloorImageFilter in _SimpleITK:
_SimpleITK.DivideFloorImageFilter_swigregister(DivideFloorImageFilter)


def DivideFloor(*args):
    r"""
    DivideFloor(Image image1, Image image2) -> Image
    DivideFloor(Image image1, double constant) -> Image
    DivideFloor(double constant, Image image2) -> Image


    """
    return _SimpleITK.DivideFloor(*args)


class DivideImageFilter(ImageFilter):
    r"""


    Pixel-wise division of two images.


    This class is templated over the types of the two input images and the
    type of the output image. When the divisor is zero, the division
    result is set to the maximum number that can be represented by default
    to avoid exception. Numeric conversions (castings) are done by the C++
    defaults.
    See:
     itk::simple::Divide for the procedural interface

     itk::DivideImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkDivideImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_DivideImageFilter

    def __init__(self):
        r"""
        __init__(DivideImageFilter self) -> DivideImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.DivideImageFilter_swiginit(
            self, _SimpleITK.new_DivideImageFilter()
        )

    def GetName(self):
        r"""
        GetName(DivideImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.DivideImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(DivideImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.DivideImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(DivideImageFilter self, Image image1, Image image2) -> Image
        Execute(DivideImageFilter self, Image image1, double constant) -> Image
        Execute(DivideImageFilter self, double constant, Image image2) -> Image


        """
        return _SimpleITK.DivideImageFilter_Execute(self, *args)


# Register DivideImageFilter in _SimpleITK:
_SimpleITK.DivideImageFilter_swigregister(DivideImageFilter)


def Divide(*args):
    r"""
    Divide(Image image1, Image image2) -> Image
    Divide(Image image1, double constant) -> Image
    Divide(double constant, Image image2) -> Image


    """
    return _SimpleITK.Divide(*args)


class DivideRealImageFilter(ImageFilter):
    r"""


    Implements pixel-wise generic operation of two images, or of an image
    and a constant.


    This class is parameterized over the types of the two input images and
    the type of the output image. It is also parameterized by the
    operation to be applied. A Functor style is used.

    The constant must be of the same type than the pixel type of the
    corresponding image. It is wrapped in a SimpleDataObjectDecorator so it can be updated through the pipeline. The SetConstant() and
    GetConstant() methods are provided as shortcuts to set or get the
    constant value without manipulating the decorator.


    See:
     BinaryGeneratorImagFilter

     UnaryFunctorImageFilter TernaryFunctorImageFilter

     itk::simple::DivideReal for the procedural interface

     itk::BinaryFunctorImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkDivideRealImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_DivideRealImageFilter

    def __init__(self):
        r"""
        __init__(DivideRealImageFilter self) -> DivideRealImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.DivideRealImageFilter_swiginit(
            self, _SimpleITK.new_DivideRealImageFilter()
        )

    def GetName(self):
        r"""
        GetName(DivideRealImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.DivideRealImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(DivideRealImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.DivideRealImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(DivideRealImageFilter self, Image image1, Image image2) -> Image
        Execute(DivideRealImageFilter self, Image image1, double constant) -> Image
        Execute(DivideRealImageFilter self, double constant, Image image2) -> Image


        """
        return _SimpleITK.DivideRealImageFilter_Execute(self, *args)


# Register DivideRealImageFilter in _SimpleITK:
_SimpleITK.DivideRealImageFilter_swigregister(DivideRealImageFilter)


def DivideReal(*args):
    r"""
    DivideReal(Image image1, Image image2) -> Image
    DivideReal(Image image1, double constant) -> Image
    DivideReal(double constant, Image image2) -> Image


    """
    return _SimpleITK.DivideReal(*args)


class DoubleThresholdImageFilter(ImageFilter):
    r"""


    Binarize an input image using double thresholding.


    Double threshold addresses the difficulty in selecting a threshold
    that will select the objects of interest without selecting extraneous
    objects. Double threshold considers two threshold ranges: a narrow
    range and a wide range (where the wide range encompasses the narrow
    range). If the wide range was used for a traditional threshold (where
    values inside the range map to the foreground and values outside the
    range map to the background), many extraneous pixels may survive the
    threshold operation. If the narrow range was used for a traditional
    threshold, then too few pixels may survive the threshold.

    Double threshold uses the narrow threshold image as a marker image and
    the wide threshold image as a mask image in the geodesic dilation.
    Essentially, the marker image (narrow threshold) is dilated but
    constrained to lie within the mask image (wide threshold). Thus, only
    the objects of interest (those pixels that survived the narrow
    threshold) are extracted but the those objects appear in the final
    image as they would have if the wide threshold was used.


    See:
     GrayscaleGeodesicDilateImageFilter

     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::DoubleThreshold for the procedural interface

     itk::DoubleThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkDoubleThresholdImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_DoubleThresholdImageFilter

    def __init__(self):
        r"""
        __init__(DoubleThresholdImageFilter self) -> DoubleThresholdImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.DoubleThresholdImageFilter_swiginit(
            self, _SimpleITK.new_DoubleThresholdImageFilter()
        )

    def SetThreshold1(self, Threshold1):
        r"""
        SetThreshold1(DoubleThresholdImageFilter self, double Threshold1)


        Set the thresholds. Four thresholds should be specified. The two lower
        thresholds default to NumericTraits<InputPixelType>::NonpositiveMin() . The two upper thresholds default NumericTraits<InputPixelType>::max . Threshold1 <= Threshold2 <= Threshold3 <= Threshold4.


        """
        return _SimpleITK.DoubleThresholdImageFilter_SetThreshold1(
            self, Threshold1
        )

    def GetThreshold1(self):
        r"""
        GetThreshold1(DoubleThresholdImageFilter self) -> double


        Get the threshold values.


        """
        return _SimpleITK.DoubleThresholdImageFilter_GetThreshold1(self)

    def SetThreshold2(self, Threshold2):
        r"""
        SetThreshold2(DoubleThresholdImageFilter self, double Threshold2)


        Set the thresholds. Four thresholds should be specified. The two lower
        thresholds default to NumericTraits<InputPixelType>::NonpositiveMin() . The two upper thresholds default NumericTraits<InputPixelType>::max . Threshold1 <= Threshold2 <= Threshold3 <= Threshold4.


        """
        return _SimpleITK.DoubleThresholdImageFilter_SetThreshold2(
            self, Threshold2
        )

    def GetThreshold2(self):
        r"""
        GetThreshold2(DoubleThresholdImageFilter self) -> double


        Get the threshold values.


        """
        return _SimpleITK.DoubleThresholdImageFilter_GetThreshold2(self)

    def SetThreshold3(self, Threshold3):
        r"""
        SetThreshold3(DoubleThresholdImageFilter self, double Threshold3)


        Set the thresholds. Four thresholds should be specified. The two lower
        thresholds default to NumericTraits<InputPixelType>::NonpositiveMin() . The two upper thresholds default NumericTraits<InputPixelType>::max . Threshold1 <= Threshold2 <= Threshold3 <= Threshold4.


        """
        return _SimpleITK.DoubleThresholdImageFilter_SetThreshold3(
            self, Threshold3
        )

    def GetThreshold3(self):
        r"""
        GetThreshold3(DoubleThresholdImageFilter self) -> double


        Get the threshold values.


        """
        return _SimpleITK.DoubleThresholdImageFilter_GetThreshold3(self)

    def SetThreshold4(self, Threshold4):
        r"""
        SetThreshold4(DoubleThresholdImageFilter self, double Threshold4)


        Set the thresholds. Four thresholds should be specified. The two lower
        thresholds default to NumericTraits<InputPixelType>::NonpositiveMin() . The two upper thresholds default NumericTraits<InputPixelType>::max . Threshold1 <= Threshold2 <= Threshold3 <= Threshold4.


        """
        return _SimpleITK.DoubleThresholdImageFilter_SetThreshold4(
            self, Threshold4
        )

    def GetThreshold4(self):
        r"""
        GetThreshold4(DoubleThresholdImageFilter self) -> double


        Get the threshold values.


        """
        return _SimpleITK.DoubleThresholdImageFilter_GetThreshold4(self)

    def SetInsideValue(self, InsideValue):
        r"""
        SetInsideValue(DoubleThresholdImageFilter self, uint8_t InsideValue)


        Set the "inside" pixel value. The default value NumericTraits<OutputPixelType>::max()


        """
        return _SimpleITK.DoubleThresholdImageFilter_SetInsideValue(
            self, InsideValue
        )

    def GetInsideValue(self):
        r"""
        GetInsideValue(DoubleThresholdImageFilter self) -> uint8_t


        Get the "inside" pixel value.


        """
        return _SimpleITK.DoubleThresholdImageFilter_GetInsideValue(self)

    def SetOutsideValue(self, OutsideValue):
        r"""
        SetOutsideValue(DoubleThresholdImageFilter self, uint8_t OutsideValue)


        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::ZeroValue() .


        """
        return _SimpleITK.DoubleThresholdImageFilter_SetOutsideValue(
            self, OutsideValue
        )

    def GetOutsideValue(self):
        r"""
        GetOutsideValue(DoubleThresholdImageFilter self) -> uint8_t


        Get the "outside" pixel value.


        """
        return _SimpleITK.DoubleThresholdImageFilter_GetOutsideValue(self)

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(DoubleThresholdImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.DoubleThresholdImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(DoubleThresholdImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.DoubleThresholdImageFilter_FullyConnectedOn(self)

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(DoubleThresholdImageFilter self)


        """
        return _SimpleITK.DoubleThresholdImageFilter_FullyConnectedOff(self)

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(DoubleThresholdImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.DoubleThresholdImageFilter_GetFullyConnected(self)

    def GetName(self):
        r"""
        GetName(DoubleThresholdImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.DoubleThresholdImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(DoubleThresholdImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.DoubleThresholdImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(DoubleThresholdImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.DoubleThresholdImageFilter_Execute(self, image1)


# Register DoubleThresholdImageFilter in _SimpleITK:
_SimpleITK.DoubleThresholdImageFilter_swigregister(DoubleThresholdImageFilter)


def DoubleThreshold(
    image1,
    threshold1=0.0,
    threshold2=1.0,
    threshold3=254.0,
    threshold4=255.0,
    insideValue=1,
    outsideValue=0,
    fullyConnected=False,
):
    r"""DoubleThreshold(Image image1, double threshold1=0.0, double threshold2=1.0, double threshold3=254.0, double threshold4=255.0, uint8_t insideValue=1, uint8_t outsideValue=0, bool fullyConnected=False) -> Image"""
    return _SimpleITK.DoubleThreshold(
        image1,
        threshold1,
        threshold2,
        threshold3,
        threshold4,
        insideValue,
        outsideValue,
        fullyConnected,
    )


class EdgePotentialImageFilter(ImageFilter):
    r"""


    Computes the edge potential of an image from the image gradient.


    Input to this filter should be a CovariantVector image representing the image gradient.

    The filter expect both the input and output images to have the same
    number of dimensions, and the output to be of a scalar image type.
    See:
     itk::simple::EdgePotential for the procedural interface

     itk::EdgePotentialImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkEdgePotentialImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_EdgePotentialImageFilter

    def __init__(self):
        r"""
        __init__(EdgePotentialImageFilter self) -> EdgePotentialImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.EdgePotentialImageFilter_swiginit(
            self, _SimpleITK.new_EdgePotentialImageFilter()
        )

    def GetName(self):
        r"""
        GetName(EdgePotentialImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.EdgePotentialImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(EdgePotentialImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.EdgePotentialImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(EdgePotentialImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.EdgePotentialImageFilter_Execute(self, image1)


# Register EdgePotentialImageFilter in _SimpleITK:
_SimpleITK.EdgePotentialImageFilter_swigregister(EdgePotentialImageFilter)


def EdgePotential(image1):
    r"""EdgePotential(Image image1) -> Image"""
    return _SimpleITK.EdgePotential(image1)


class EqualImageFilter(ImageFilter):
    r"""


    Implements pixel-wise generic operation of two images, or of an image
    and a constant.


    This class is parameterized over the types of the two input images and
    the type of the output image. It is also parameterized by the
    operation to be applied. A Functor style is used.

    The constant must be of the same type than the pixel type of the
    corresponding image. It is wrapped in a SimpleDataObjectDecorator so it can be updated through the pipeline. The SetConstant() and
    GetConstant() methods are provided as shortcuts to set or get the
    constant value without manipulating the decorator.


    See:
     BinaryGeneratorImagFilter

     UnaryFunctorImageFilter TernaryFunctorImageFilter

     itk::simple::Equal for the procedural interface

     itk::BinaryFunctorImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkEqualImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_EqualImageFilter

    def __init__(self):
        r"""
        __init__(EqualImageFilter self) -> EqualImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.EqualImageFilter_swiginit(
            self, _SimpleITK.new_EqualImageFilter()
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(EqualImageFilter self, uint8_t BackgroundValue)


        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.EqualImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(EqualImageFilter self) -> uint8_t


        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.EqualImageFilter_GetBackgroundValue(self)

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(EqualImageFilter self, uint8_t ForegroundValue)


        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.EqualImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(EqualImageFilter self) -> uint8_t


        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.EqualImageFilter_GetForegroundValue(self)

    def GetName(self):
        r"""
        GetName(EqualImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.EqualImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(EqualImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.EqualImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(EqualImageFilter self, Image image1, Image image2) -> Image
        Execute(EqualImageFilter self, Image image1, double constant) -> Image
        Execute(EqualImageFilter self, double constant, Image image2) -> Image
        Execute(EqualImageFilter self, Image image1, double constant, uint8_t backgroundValue, uint8_t foregroundValue) -> Image
        Execute(EqualImageFilter self, double constant, Image image2, uint8_t backgroundValue, uint8_t foregroundValue) -> Image


        """
        return _SimpleITK.EqualImageFilter_Execute(self, *args)


# Register EqualImageFilter in _SimpleITK:
_SimpleITK.EqualImageFilter_swigregister(EqualImageFilter)


def Equal(*args):
    r"""
    Equal(Image image1, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    Equal(Image image1, double constant, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    Equal(double constant, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image


    """
    return _SimpleITK.Equal(*args)


class ErodeObjectMorphologyImageFilter(ImageFilter):
    r"""


    Erosion of an object in an image.


    Erosion of an image using binary morphology. Pixel values matching the
    object value are considered the "object" and all other pixels are
    "background". This is useful in processing mask images containing
    only one object.

    If the pixel covered by the center of the kernel has the pixel value
    ObjectValue and the pixel is adjacent to a non-object valued pixel,
    then the kernel is centered on the object-value pixel and neighboring
    pixels covered by the kernel are assigned the background value. The
    structuring element is assumed to be composed of binary values (zero
    or one).


    See:
     ObjectMorphologyImageFilter , BinaryFunctionErodeImageFilter

     BinaryErodeImageFilter

     itk::simple::ErodeObjectMorphology for the procedural interface

     itk::ErodeObjectMorphologyImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkErodeObjectMorphologyImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ErodeObjectMorphologyImageFilter

    def __init__(self):
        r"""
        __init__(ErodeObjectMorphologyImageFilter self) -> ErodeObjectMorphologyImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ErodeObjectMorphologyImageFilter_swiginit(
            self, _SimpleITK.new_ErodeObjectMorphologyImageFilter()
        )

    def SetKernelRadius(self, *args):
        r"""
        SetKernelRadius(ErodeObjectMorphologyImageFilter self, VectorUInt32 KernelRadius)
        SetKernelRadius(ErodeObjectMorphologyImageFilter self, unsigned int value)


        Set the values of the KernelRadius vector all to value


        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter_SetKernelRadius(
            self, *args
        )

    def GetKernelRadius(self):
        r"""
        GetKernelRadius(ErodeObjectMorphologyImageFilter self) -> VectorUInt32


        Get the radius of the kernel structuring element.


        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter_GetKernelRadius(
            self
        )

    def SetKernelType(self, KernelType):
        r"""
        SetKernelType(ErodeObjectMorphologyImageFilter self, itk::simple::KernelEnum KernelType)


        Set the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter_SetKernelType(
            self, KernelType
        )

    def GetKernelType(self):
        r"""
        GetKernelType(ErodeObjectMorphologyImageFilter self) -> itk::simple::KernelEnum


        Get the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter_GetKernelType(self)

    def SetObjectValue(self, ObjectValue):
        r"""
        SetObjectValue(ErodeObjectMorphologyImageFilter self, double ObjectValue)


        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter_SetObjectValue(
            self, ObjectValue
        )

    def GetObjectValue(self):
        r"""
        GetObjectValue(ErodeObjectMorphologyImageFilter self) -> double


        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter_GetObjectValue(self)

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(ErodeObjectMorphologyImageFilter self, double BackgroundValue)


        Set the value to be assigned to eroded pixels


        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(ErodeObjectMorphologyImageFilter self) -> double


        Get the value to be assigned to eroded pixels


        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter_GetBackgroundValue(
            self
        )

    def GetName(self):
        r"""
        GetName(ErodeObjectMorphologyImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ErodeObjectMorphologyImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ErodeObjectMorphologyImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter_Execute(
            self, image1
        )


# Register ErodeObjectMorphologyImageFilter in _SimpleITK:
_SimpleITK.ErodeObjectMorphologyImageFilter_swigregister(
    ErodeObjectMorphologyImageFilter
)


def ErodeObjectMorphology(*args, **kwargs):
    r"""ErodeObjectMorphology(Image image1, VectorUInt32 kernelRadius=std::vector< uint32_t >(3, 1), itk::simple::KernelEnum kernelType=sitkBall, double objectValue=1, double backgroundValue=0) -> Image"""
    return _SimpleITK.ErodeObjectMorphology(*args, **kwargs)


class ExpImageFilter(ImageFilter):
    r"""


    Computes the exponential function of each pixel.


    The computation is performed using std::exp(x).
    See:
     itk::simple::Exp for the procedural interface

     itk::ExpImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkExpImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ExpImageFilter

    def __init__(self):
        r"""
        __init__(ExpImageFilter self) -> ExpImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ExpImageFilter_swiginit(
            self, _SimpleITK.new_ExpImageFilter()
        )

    def GetName(self):
        r"""
        GetName(ExpImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ExpImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ExpImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ExpImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ExpImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ExpImageFilter_Execute(self, image1)


# Register ExpImageFilter in _SimpleITK:
_SimpleITK.ExpImageFilter_swigregister(ExpImageFilter)


def Exp(image1):
    r"""Exp(Image image1) -> Image"""
    return _SimpleITK.Exp(image1)


class ExpNegativeImageFilter(ImageFilter):
    r"""


    Computes the function exp(-K.x) for each input pixel.


    Every output pixel is equal to std::exp(-K.x ). where x is the
    intensity of the homologous input pixel, and K is a user-provided
    constant.
    See:
     itk::simple::ExpNegative for the procedural interface

     itk::ExpNegativeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkExpNegativeImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ExpNegativeImageFilter

    def __init__(self):
        r"""
        __init__(ExpNegativeImageFilter self) -> ExpNegativeImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ExpNegativeImageFilter_swiginit(
            self, _SimpleITK.new_ExpNegativeImageFilter()
        )

    def GetName(self):
        r"""
        GetName(ExpNegativeImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ExpNegativeImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ExpNegativeImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ExpNegativeImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ExpNegativeImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ExpNegativeImageFilter_Execute(self, image1)


# Register ExpNegativeImageFilter in _SimpleITK:
_SimpleITK.ExpNegativeImageFilter_swigregister(ExpNegativeImageFilter)


def ExpNegative(image1):
    r"""ExpNegative(Image image1) -> Image"""
    return _SimpleITK.ExpNegative(image1)


class ExpandImageFilter(ImageFilter):
    r"""


    Expand the size of an image by an integer factor in each dimension.


    ExpandImageFilter increases the size of an image by an integer factor in each dimension
    using a interpolation method. The output image size in each dimension
    is given by:

    OutputSize[j] = InputSize[j] * ExpandFactors[j]

    The output values are obtained by interpolating the input image. The
    default interpolation type used is the LinearInterpolateImageFunction . The user can specify a particular interpolation function via SetInterpolator() . Note that the input interpolator must derive from base class InterpolateImageFunction .

    This filter will produce an output with different pixel spacing that
    its input image such that:

    OutputSpacing[j] = InputSpacing[j] / ExpandFactors[j]

    The filter is templated over the input image type and the output image
    type.

    This filter is implemented as a multithreaded filter and supports
    streaming.

    This filter assumes that the input and output image has the same
    number of dimensions.


    See:
     InterpolateImageFunction

     LinearInterpolationImageFunction

     itk::simple::Expand for the procedural interface

     itk::ExpandImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkExpandImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ExpandImageFilter

    def __init__(self):
        r"""
        __init__(ExpandImageFilter self) -> ExpandImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ExpandImageFilter_swiginit(
            self, _SimpleITK.new_ExpandImageFilter()
        )

    def SetExpandFactor(self, e):
        r"""
        SetExpandFactor(ExpandImageFilter self, unsigned int e)


        Custom public declarations


        """
        return _SimpleITK.ExpandImageFilter_SetExpandFactor(self, e)

    def SetExpandFactors(self, *args):
        r"""
        SetExpandFactors(ExpandImageFilter self, VectorUInt32 ExpandFactors)
        SetExpandFactors(ExpandImageFilter self, unsigned int value)


        Set the values of the ExpandFactors vector all to value


        """
        return _SimpleITK.ExpandImageFilter_SetExpandFactors(self, *args)

    def GetExpandFactors(self):
        r"""
        GetExpandFactors(ExpandImageFilter self) -> VectorUInt32


        Get the expand factors.


        """
        return _SimpleITK.ExpandImageFilter_GetExpandFactors(self)

    def SetInterpolator(self, Interpolator):
        r"""
        SetInterpolator(ExpandImageFilter self, itk::simple::InterpolatorEnum Interpolator)


        Get/Set the interpolator function.


        """
        return _SimpleITK.ExpandImageFilter_SetInterpolator(self, Interpolator)

    def GetInterpolator(self):
        r"""
        GetInterpolator(ExpandImageFilter self) -> itk::simple::InterpolatorEnum


        Get/Set the interpolator function.


        """
        return _SimpleITK.ExpandImageFilter_GetInterpolator(self)

    def GetName(self):
        r"""
        GetName(ExpandImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ExpandImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ExpandImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ExpandImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ExpandImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ExpandImageFilter_Execute(self, image1)


# Register ExpandImageFilter in _SimpleITK:
_SimpleITK.ExpandImageFilter_swigregister(ExpandImageFilter)


def Expand(*args, **kwargs):
    r"""Expand(Image image1, VectorUInt32 expandFactors=std::vector< unsigned int >(3, 1), itk::simple::InterpolatorEnum interpolator=sitkLinear) -> Image"""
    return _SimpleITK.Expand(*args, **kwargs)


class FFTConvolutionImageFilter(ImageFilter):
    r"""


    Convolve a given image with an arbitrary image kernel using
    multiplication in the Fourier domain.


    This filter produces output equivalent to the output of the ConvolutionImageFilter . However, it takes advantage of the convolution theorem to
    accelerate the convolution computation when the kernel is large.


    WARNING:
    This filter ignores the spacing, origin, and orientation of the kernel
    image and treats them as identical to those in the input image.
     This code was adapted from the Insight Journal contribution:

    "FFT Based Convolution" by Gaetan Lehmann https://doi.org/10.54294/0iky0u


    See:
     ConvolutionImageFilter

     InverseDeconvolutionImageFilter

     IterativeDeconvolutionImageFilter

     itk::simple::FFTConvolution for the procedural interface

     itk::FFTConvolutionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkFFTConvolutionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_FFTConvolutionImageFilter

    def __init__(self):
        r"""
        __init__(FFTConvolutionImageFilter self) -> FFTConvolutionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.FFTConvolutionImageFilter_swiginit(
            self, _SimpleITK.new_FFTConvolutionImageFilter()
        )

    def SetNormalize(self, Normalize):
        r"""
        SetNormalize(FFTConvolutionImageFilter self, bool Normalize)


        Normalize the output image by the sum of the kernel components


        """
        return _SimpleITK.FFTConvolutionImageFilter_SetNormalize(
            self, Normalize
        )

    def NormalizeOn(self):
        r"""
        NormalizeOn(FFTConvolutionImageFilter self)


        Set the value of Normalize to true or false respectfully.


        """
        return _SimpleITK.FFTConvolutionImageFilter_NormalizeOn(self)

    def NormalizeOff(self):
        r"""
        NormalizeOff(FFTConvolutionImageFilter self)


        """
        return _SimpleITK.FFTConvolutionImageFilter_NormalizeOff(self)

    def GetNormalize(self):
        r"""
        GetNormalize(FFTConvolutionImageFilter self) -> bool


        """
        return _SimpleITK.FFTConvolutionImageFilter_GetNormalize(self)

    ZERO_PAD = _SimpleITK.FFTConvolutionImageFilter_ZERO_PAD

    ZERO_FLUX_NEUMANN_PAD = (
        _SimpleITK.FFTConvolutionImageFilter_ZERO_FLUX_NEUMANN_PAD
    )

    PERIODIC_PAD = _SimpleITK.FFTConvolutionImageFilter_PERIODIC_PAD

    def SetBoundaryCondition(self, BoundaryCondition):
        r"""
        SetBoundaryCondition(FFTConvolutionImageFilter self, itk::simple::FFTConvolutionImageFilter::BoundaryConditionType BoundaryCondition)


        """
        return _SimpleITK.FFTConvolutionImageFilter_SetBoundaryCondition(
            self, BoundaryCondition
        )

    def GetBoundaryCondition(self):
        r"""
        GetBoundaryCondition(FFTConvolutionImageFilter self) -> itk::simple::FFTConvolutionImageFilter::BoundaryConditionType


        """
        return _SimpleITK.FFTConvolutionImageFilter_GetBoundaryCondition(self)

    SAME = _SimpleITK.FFTConvolutionImageFilter_SAME

    VALID = _SimpleITK.FFTConvolutionImageFilter_VALID

    def SetOutputRegionMode(self, OutputRegionMode):
        r"""
        SetOutputRegionMode(FFTConvolutionImageFilter self, itk::simple::FFTConvolutionImageFilter::OutputRegionModeType OutputRegionMode)


        """
        return _SimpleITK.FFTConvolutionImageFilter_SetOutputRegionMode(
            self, OutputRegionMode
        )

    def GetOutputRegionMode(self):
        r"""
        GetOutputRegionMode(FFTConvolutionImageFilter self) -> itk::simple::FFTConvolutionImageFilter::OutputRegionModeType


        """
        return _SimpleITK.FFTConvolutionImageFilter_GetOutputRegionMode(self)

    def GetName(self):
        r"""
        GetName(FFTConvolutionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.FFTConvolutionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(FFTConvolutionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.FFTConvolutionImageFilter___str__(self)

    def Execute(self, image, kernelImage):
        r"""
        Execute(FFTConvolutionImageFilter self, Image image, Image kernelImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.FFTConvolutionImageFilter_Execute(
            self, image, kernelImage
        )


# Register FFTConvolutionImageFilter in _SimpleITK:
_SimpleITK.FFTConvolutionImageFilter_swigregister(FFTConvolutionImageFilter)


def FFTConvolution(*args, **kwargs):
    r"""FFTConvolution(Image image, Image kernelImage, bool normalize=False, itk::simple::FFTConvolutionImageFilter::BoundaryConditionType boundaryCondition=ZERO_FLUX_NEUMANN_PAD, itk::simple::FFTConvolutionImageFilter::OutputRegionModeType outputRegionMode=SAME) -> Image"""
    return _SimpleITK.FFTConvolution(*args, **kwargs)


class FFTNormalizedCorrelationImageFilter(ImageFilter):
    r"""


    Calculate normalized cross correlation using FFTs.


    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general MaskedFFTNormalizedCorrelationImageFilter and operates by essentially setting the masks in that algorithm to
    images of ones. As described in detail in the references below, there
    is no computational overhead to utilizing the more general masked
    algorithm because the FFTs of the images of ones are still necessary
    for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain, all
    input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:


    WARNING:
    The pixel type of the output image must be of real type (float or
    double). ConceptChecking is used to enforce the output pixel type. You
    will get a compilation error if the pixel type of the output image is
    not float or double.
     References: 1) D. Padfield. "Masked object registration in the
    Fourier domain." Transactions on Image Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.


    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    See:
     itk::simple::FFTNormalizedCorrelation for the procedural interface

     itk::FFTNormalizedCorrelationImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkFFTNormalizedCorrelationImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_FFTNormalizedCorrelationImageFilter

    def __init__(self):
        r"""
        __init__(FFTNormalizedCorrelationImageFilter self) -> FFTNormalizedCorrelationImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.FFTNormalizedCorrelationImageFilter_swiginit(
            self, _SimpleITK.new_FFTNormalizedCorrelationImageFilter()
        )

    def SetRequiredNumberOfOverlappingPixels(
        self, RequiredNumberOfOverlappingPixels
    ):
        r"""
        SetRequiredNumberOfOverlappingPixels(FFTNormalizedCorrelationImageFilter self, uint64_t RequiredNumberOfOverlappingPixels)


        Set and get the required number of overlapping pixels


        """
        return _SimpleITK.FFTNormalizedCorrelationImageFilter_SetRequiredNumberOfOverlappingPixels(
            self, RequiredNumberOfOverlappingPixels
        )

    def GetRequiredNumberOfOverlappingPixels(self):
        r"""
        GetRequiredNumberOfOverlappingPixels(FFTNormalizedCorrelationImageFilter self) -> uint64_t


        Set and get the required number of overlapping pixels


        """
        return _SimpleITK.FFTNormalizedCorrelationImageFilter_GetRequiredNumberOfOverlappingPixels(
            self
        )

    def SetRequiredFractionOfOverlappingPixels(
        self, RequiredFractionOfOverlappingPixels
    ):
        r"""
        SetRequiredFractionOfOverlappingPixels(FFTNormalizedCorrelationImageFilter self, double RequiredFractionOfOverlappingPixels)


        Set and get the required fraction of overlapping pixels


        """
        return _SimpleITK.FFTNormalizedCorrelationImageFilter_SetRequiredFractionOfOverlappingPixels(
            self, RequiredFractionOfOverlappingPixels
        )

    def GetRequiredFractionOfOverlappingPixels(self):
        r"""
        GetRequiredFractionOfOverlappingPixels(FFTNormalizedCorrelationImageFilter self) -> double


        Set and get the required fraction of overlapping pixels


        """
        return _SimpleITK.FFTNormalizedCorrelationImageFilter_GetRequiredFractionOfOverlappingPixels(
            self
        )

    def GetName(self):
        r"""
        GetName(FFTNormalizedCorrelationImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.FFTNormalizedCorrelationImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(FFTNormalizedCorrelationImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.FFTNormalizedCorrelationImageFilter___str__(self)

    def Execute(self, fixedImage, movingImage):
        r"""
        Execute(FFTNormalizedCorrelationImageFilter self, Image fixedImage, Image movingImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.FFTNormalizedCorrelationImageFilter_Execute(
            self, fixedImage, movingImage
        )


# Register FFTNormalizedCorrelationImageFilter in _SimpleITK:
_SimpleITK.FFTNormalizedCorrelationImageFilter_swigregister(
    FFTNormalizedCorrelationImageFilter
)


def FFTNormalizedCorrelation(
    fixedImage,
    movingImage,
    requiredNumberOfOverlappingPixels=0,
    requiredFractionOfOverlappingPixels=0.0,
):
    r"""FFTNormalizedCorrelation(Image fixedImage, Image movingImage, uint64_t requiredNumberOfOverlappingPixels=0, double requiredFractionOfOverlappingPixels=0.0) -> Image"""
    return _SimpleITK.FFTNormalizedCorrelation(
        fixedImage,
        movingImage,
        requiredNumberOfOverlappingPixels,
        requiredFractionOfOverlappingPixels,
    )


class FFTPadImageFilter(ImageFilter):
    r"""


    Pad an image to make it suitable for an FFT transformation.


    FFT filters usually requires a specific image size. The size is
    decomposed in several prime factors, and the filter only supports
    prime factors up to a maximum value. This filter automatically finds
    the greatest prime factor required by the available implementation and
    pads the input appropriately.

    This code was adapted from the Insight Journal contribution:

    "FFT Based Convolution" by Gaetan Lehmann https://doi.org/10.54294/0iky0u


    Gaetan Lehmann

    See:
     FFTShiftImageFilter

     itk::simple::FFTPad for the procedural interface

     itk::FFTPadImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkFFTPadImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_FFTPadImageFilter

    def __init__(self):
        r"""
        __init__(FFTPadImageFilter self) -> FFTPadImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.FFTPadImageFilter_swiginit(
            self, _SimpleITK.new_FFTPadImageFilter()
        )

    ZERO_PAD = _SimpleITK.FFTPadImageFilter_ZERO_PAD

    ZERO_FLUX_NEUMANN_PAD = _SimpleITK.FFTPadImageFilter_ZERO_FLUX_NEUMANN_PAD

    PERIODIC_PAD = _SimpleITK.FFTPadImageFilter_PERIODIC_PAD

    def SetBoundaryCondition(self, BoundaryCondition):
        r"""
        SetBoundaryCondition(FFTPadImageFilter self, itk::simple::FFTPadImageFilter::BoundaryConditionType BoundaryCondition)


        """
        return _SimpleITK.FFTPadImageFilter_SetBoundaryCondition(
            self, BoundaryCondition
        )

    def GetBoundaryCondition(self):
        r"""
        GetBoundaryCondition(FFTPadImageFilter self) -> itk::simple::FFTPadImageFilter::BoundaryConditionType


        """
        return _SimpleITK.FFTPadImageFilter_GetBoundaryCondition(self)

    def SetSizeGreatestPrimeFactor(self, SizeGreatestPrimeFactor):
        r"""
        SetSizeGreatestPrimeFactor(FFTPadImageFilter self, int SizeGreatestPrimeFactor)


        Set/Get the greatest prime factor allowed on the size of the padded
        image. The filter increase the size of the image to reach a size with
        the greatest prime factor smaller or equal to the specified value. The
        default value is 5 for VNL, which is the greatest prime number for
        which the FFT are precomputed in FFTW, and thus gives very good
        performance. A greatest prime factor of 2 produce a size which is a
        power of 2, and thus is suitable for vnl base fft filters. A greatest
        prime factor of 1 or less - typically 0 - disable the extra padding.


        """
        return _SimpleITK.FFTPadImageFilter_SetSizeGreatestPrimeFactor(
            self, SizeGreatestPrimeFactor
        )

    def GetSizeGreatestPrimeFactor(self):
        r"""
        GetSizeGreatestPrimeFactor(FFTPadImageFilter self) -> int


        Set/Get the greatest prime factor allowed on the size of the padded
        image. The filter increase the size of the image to reach a size with
        the greatest prime factor smaller or equal to the specified value. The
        default value is 5 for VNL, which is the greatest prime number for
        which the FFT are precomputed in FFTW, and thus gives very good
        performance. A greatest prime factor of 2 produce a size which is a
        power of 2, and thus is suitable for vnl base fft filters. A greatest
        prime factor of 1 or less - typically 0 - disable the extra padding.


        """
        return _SimpleITK.FFTPadImageFilter_GetSizeGreatestPrimeFactor(self)

    def GetName(self):
        r"""
        GetName(FFTPadImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.FFTPadImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(FFTPadImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.FFTPadImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(FFTPadImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.FFTPadImageFilter_Execute(self, image1)

    @staticmethod
    def DefaultSizeGreatestPrimeFactor():
        r"""DefaultSizeGreatestPrimeFactor() -> int"""
        return _SimpleITK.FFTPadImageFilter_DefaultSizeGreatestPrimeFactor()


# Register FFTPadImageFilter in _SimpleITK:
_SimpleITK.FFTPadImageFilter_swigregister(FFTPadImageFilter)


def FFTPadImageFilter_DefaultSizeGreatestPrimeFactor():
    r"""FFTPadImageFilter_DefaultSizeGreatestPrimeFactor() -> int"""
    return _SimpleITK.FFTPadImageFilter_DefaultSizeGreatestPrimeFactor()


def FFTPad(*args, **kwargs):
    r"""FFTPad(Image image1, itk::simple::FFTPadImageFilter::BoundaryConditionType boundaryCondition=ZERO_FLUX_NEUMANN_PAD, int sizeGreatestPrimeFactor=itk::simple::FFTPadImageFilter::DefaultSizeGreatestPrimeFactor()) -> Image"""
    return _SimpleITK.FFTPad(*args, **kwargs)


class FFTShiftImageFilter(ImageFilter):
    r"""


    Shift the zero-frequency components of a Fourier transform to the
    center of the image.


    The Fourier transform produces an image where the zero frequency
    components are in the corner of the image, making it difficult to
    understand. This filter shifts the component to the center of the
    image.


    For images with an odd-sized dimension, applying this filter twice
    will not produce the same image as the original one without using
    SetInverse(true) on one (and only one) of the two filters.
    https://doi.org/10.54294/xd0lzg


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ForwardFFTImageFilter , InverseFFTImageFilter

     itk::simple::FFTShift for the procedural interface

     itk::FFTShiftImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkFFTShiftImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_FFTShiftImageFilter

    def __init__(self):
        r"""
        __init__(FFTShiftImageFilter self) -> FFTShiftImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.FFTShiftImageFilter_swiginit(
            self, _SimpleITK.new_FFTShiftImageFilter()
        )

    def SetInverse(self, Inverse):
        r"""
        SetInverse(FFTShiftImageFilter self, bool Inverse)


        Set/Get whether the filter must invert the transform or not. This
        option has no effect if none of the size of the input image is even,
        but is required to restore the original image if at least one of the
        dimensions has an odd size.


        """
        return _SimpleITK.FFTShiftImageFilter_SetInverse(self, Inverse)

    def InverseOn(self):
        r"""
        InverseOn(FFTShiftImageFilter self)


        Set the value of Inverse to true or false respectfully.


        """
        return _SimpleITK.FFTShiftImageFilter_InverseOn(self)

    def InverseOff(self):
        r"""
        InverseOff(FFTShiftImageFilter self)


        """
        return _SimpleITK.FFTShiftImageFilter_InverseOff(self)

    def GetInverse(self):
        r"""
        GetInverse(FFTShiftImageFilter self) -> bool


        Set/Get whether the filter must invert the transform or not. This
        option has no effect if none of the size of the input image is even,
        but is required to restore the original image if at least one of the
        dimensions has an odd size.


        """
        return _SimpleITK.FFTShiftImageFilter_GetInverse(self)

    def GetName(self):
        r"""
        GetName(FFTShiftImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.FFTShiftImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(FFTShiftImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.FFTShiftImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(FFTShiftImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.FFTShiftImageFilter_Execute(self, image1)


# Register FFTShiftImageFilter in _SimpleITK:
_SimpleITK.FFTShiftImageFilter_swigregister(FFTShiftImageFilter)


def FFTShift(image1, inverse=False):
    r"""FFTShift(Image image1, bool inverse=False) -> Image"""
    return _SimpleITK.FFTShift(image1, inverse)


class FastApproximateRankImageFilter(ImageFilter):
    r"""


    A separable rank filter.


    Medians aren't separable, but if you want a large robust smoother to
    be relatively quick then it is worthwhile pretending that they are.

    This code was contributed in the Insight Journal paper: "Efficient
    implementation of kernel filtering" by Beare R., Lehmann G https://doi.org/10.54294/igq8fn


    Richard Beare

    See:
     itk::simple::FastApproximateRank for the procedural interface

     itk::FastApproximateRankImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkFastApproximateRankImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_FastApproximateRankImageFilter

    def __init__(self):
        r"""
        __init__(FastApproximateRankImageFilter self) -> FastApproximateRankImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.FastApproximateRankImageFilter_swiginit(
            self, _SimpleITK.new_FastApproximateRankImageFilter()
        )

    def SetRank(self, Rank):
        r"""
        SetRank(FastApproximateRankImageFilter self, double Rank)


        """
        return _SimpleITK.FastApproximateRankImageFilter_SetRank(self, Rank)

    def GetRank(self):
        r"""
        GetRank(FastApproximateRankImageFilter self) -> double


        """
        return _SimpleITK.FastApproximateRankImageFilter_GetRank(self)

    def SetRadius(self, *args):
        r"""
        SetRadius(FastApproximateRankImageFilter self, VectorUInt32 Radius)
        SetRadius(FastApproximateRankImageFilter self, unsigned int value)


        Set the values of the Radius vector all to value


        """
        return _SimpleITK.FastApproximateRankImageFilter_SetRadius(self, *args)

    def GetRadius(self):
        r"""
        GetRadius(FastApproximateRankImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.FastApproximateRankImageFilter_GetRadius(self)

    def GetName(self):
        r"""
        GetName(FastApproximateRankImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.FastApproximateRankImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(FastApproximateRankImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.FastApproximateRankImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(FastApproximateRankImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.FastApproximateRankImageFilter_Execute(self, image1)


# Register FastApproximateRankImageFilter in _SimpleITK:
_SimpleITK.FastApproximateRankImageFilter_swigregister(
    FastApproximateRankImageFilter
)


def FastApproximateRank(*args, **kwargs):
    r"""FastApproximateRank(Image image1, double rank=0.5, VectorUInt32 radius=std::vector< unsigned int >(3, 1)) -> Image"""
    return _SimpleITK.FastApproximateRank(*args, **kwargs)


class FastMarchingBaseImageFilter(ImageFilter):
    r"""


    Apply the Fast Marching method to solve an Eikonal equation on an
    image.


    The speed function can be specified as a speed image or a speed
    constant. The speed image is set using the method SetInput(). If the
    speed image is nullptr, a constant speed function is used and is
    specified using method the SetSpeedConstant() .

    If the speed function is constant and of value one, fast marching
    results is an approximate distance function from the initial alive
    points.

    There are two ways to specify the output image information
    (LargestPossibleRegion, Spacing, Origin):


    it is copied directly from the input speed image

    it is specified by the user. Default values are used if the user does
    not specify all the information.
     The output information is computed as follows.

    If the speed image is nullptr or if the OverrideOutputInformation is
    set to true, the output information is set from user specified
    parameters. These parameters can be specified using methods


    FastMarchingImageFilterBase::SetOutputRegion() ,

    FastMarchingImageFilterBase::SetOutputSpacing() ,

    FastMarchingImageFilterBase::SetOutputDirection() ,

    FastMarchingImageFilterBase::SetOutputOrigin() .
     Else the output information is copied from the input speed image.

    Implementation of this class is based on Chapter 8 of "Level Set
    Methods and Fast Marching Methods", J.A. Sethian, Cambridge Press,
    Second edition, 1999.

    For an alternative implementation, see itk::FastMarchingImageFilter .

    TTraits

    traits


    See:
     FastMarchingImageFilter

     ImageFastMarchingTraits

     ImageFastMarchingTraits2

     itk::simple::FastMarchingBase for the procedural interface

     itk::FastMarchingImageFilterBase for the Doxygen on the original ITK class.


    C++ includes: sitkFastMarchingBaseImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_FastMarchingBaseImageFilter

    def __init__(self):
        r"""
        __init__(FastMarchingBaseImageFilter self) -> FastMarchingBaseImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.FastMarchingBaseImageFilter_swiginit(
            self, _SimpleITK.new_FastMarchingBaseImageFilter()
        )

    def SetTrialPoints(self, TrialPoints):
        r"""
        SetTrialPoints(FastMarchingBaseImageFilter self, VectorUIntList TrialPoints)


        Set the container of Trial Points representing the initial front.
        Trial points are represented as a VectorContainer of LevelSetNodes.


        """
        return _SimpleITK.FastMarchingBaseImageFilter_SetTrialPoints(
            self, TrialPoints
        )

    def GetTrialPoints(self):
        r"""
        GetTrialPoints(FastMarchingBaseImageFilter self) -> VectorUIntList


        Get the container of Trial Points representing the initial front.


        """
        return _SimpleITK.FastMarchingBaseImageFilter_GetTrialPoints(self)

    def AddTrialPoint(self, point):
        r"""
        AddTrialPoint(FastMarchingBaseImageFilter self, VectorUInt32 point)


        Add TrialPoints point.


        """
        return _SimpleITK.FastMarchingBaseImageFilter_AddTrialPoint(
            self, point
        )

    def ClearTrialPoints(self):
        r"""
        ClearTrialPoints(FastMarchingBaseImageFilter self)


        Remove all TrialPoints points.


        """
        return _SimpleITK.FastMarchingBaseImageFilter_ClearTrialPoints(self)

    def SetNormalizationFactor(self, NormalizationFactor):
        r"""
        SetNormalizationFactor(FastMarchingBaseImageFilter self, double NormalizationFactor)


        Set/Get the Normalization Factor for the Speed Image . The values in the Speed Image is divided by this factor. This allows the use of images with integer
        pixel types to represent the speed.


        """
        return _SimpleITK.FastMarchingBaseImageFilter_SetNormalizationFactor(
            self, NormalizationFactor
        )

    def GetNormalizationFactor(self):
        r"""
        GetNormalizationFactor(FastMarchingBaseImageFilter self) -> double


        Set/Get the Normalization Factor for the Speed Image . The values in the Speed Image is divided by this factor. This allows the use of images with integer
        pixel types to represent the speed.


        """
        return _SimpleITK.FastMarchingBaseImageFilter_GetNormalizationFactor(
            self
        )

    def SetStoppingValue(self, StoppingValue):
        r"""
        SetStoppingValue(FastMarchingBaseImageFilter self, double StoppingValue)


        Set the Fast Marching algorithm Stopping Value. The Fast Marching
        algorithm is terminated when the value of the smallest trial point is
        greater than the stopping value.


        """
        return _SimpleITK.FastMarchingBaseImageFilter_SetStoppingValue(
            self, StoppingValue
        )

    def GetStoppingValue(self):
        r"""
        GetStoppingValue(FastMarchingBaseImageFilter self) -> double


        Get the Fast Marching algorithm Stopping Value.


        """
        return _SimpleITK.FastMarchingBaseImageFilter_GetStoppingValue(self)

    Nothing = _SimpleITK.FastMarchingBaseImageFilter_Nothing

    NoHandles = _SimpleITK.FastMarchingBaseImageFilter_NoHandles

    Strict = _SimpleITK.FastMarchingBaseImageFilter_Strict

    def SetTopologyCheck(self, TopologyCheck):
        r"""
        SetTopologyCheck(FastMarchingBaseImageFilter self, itk::simple::FastMarchingBaseImageFilter::TopologyCheckType TopologyCheck)


        """
        return _SimpleITK.FastMarchingBaseImageFilter_SetTopologyCheck(
            self, TopologyCheck
        )

    def GetTopologyCheck(self):
        r"""
        GetTopologyCheck(FastMarchingBaseImageFilter self) -> itk::simple::FastMarchingBaseImageFilter::TopologyCheckType


        """
        return _SimpleITK.FastMarchingBaseImageFilter_GetTopologyCheck(self)

    def SetInitialTrialValues(self, InitialTrialValues):
        r"""
        SetInitialTrialValues(FastMarchingBaseImageFilter self, VectorDouble InitialTrialValues)


        Set the initial seed values for corresponding trial point.


        """
        return _SimpleITK.FastMarchingBaseImageFilter_SetInitialTrialValues(
            self, InitialTrialValues
        )

    def GetInitialTrialValues(self):
        r"""
        GetInitialTrialValues(FastMarchingBaseImageFilter self) -> VectorDouble


        """
        return _SimpleITK.FastMarchingBaseImageFilter_GetInitialTrialValues(
            self
        )

    def GetName(self):
        r"""
        GetName(FastMarchingBaseImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.FastMarchingBaseImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(FastMarchingBaseImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.FastMarchingBaseImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(FastMarchingBaseImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.FastMarchingBaseImageFilter_Execute(self, image1)


# Register FastMarchingBaseImageFilter in _SimpleITK:
_SimpleITK.FastMarchingBaseImageFilter_swigregister(
    FastMarchingBaseImageFilter
)


def FastMarchingBase(*args, **kwargs):
    r"""FastMarchingBase(Image image1, VectorUIntList trialPoints=std::vector< std::vector< unsigned int > >(), double normalizationFactor=1.0, double stoppingValue=std::numeric_limits< float >::max()/2.0, itk::simple::FastMarchingBaseImageFilter::TopologyCheckType topologyCheck=Nothing, VectorDouble initialTrialValues=std::vector< double >()) -> Image"""
    return _SimpleITK.FastMarchingBase(*args, **kwargs)


class FastMarchingImageFilter(ImageFilter):
    r"""


    Solve an Eikonal equation using Fast Marching.


    Fast marching solves an Eikonal equation where the speed is always
    non-negative and depends on the position only. Starting from an
    initial position on the front, fast marching systematically moves the
    front forward one grid point at a time.

    Updates are performed using an entropy satisfy scheme where only
    "upwind" neighborhoods are used. This implementation of Fast
    Marching uses a std::priority_queue to locate the next proper grid
    position to update.

    Fast Marching sweeps through N grid points in (N log N) steps to
    obtain the arrival time value as the front propagates through the
    grid.

    Implementation of this class is based on Chapter 8 of "Level Set
    Methods and Fast Marching Methods", J.A. Sethian, Cambridge Press,
    Second edition, 1999.

    This class is templated over the level set image type and the speed
    image type. The initial front is specified by two containers: one
    containing the known points and one containing the trial points. Alive
    points are those that are already part of the object, and trial points
    are considered for inclusion. In order for the filter to evolve, at
    least some trial points must be specified. These can for instance be
    specified as the layer of pixels around the alive points.

    The speed function can be specified as a speed image or a speed
    constant. The speed image is set using the method SetInput() . If the
    speed image is nullptr, a constant speed function is used and is
    specified using method the SetSpeedConstant() .

    If the speed function is constant and of value one, fast marching
    results in an approximate distance function from the initial alive
    points. FastMarchingImageFilter is used in the ReinitializeLevelSetImageFilter object to create a signed distance function from the zero level set.

    The algorithm can be terminated early by setting an appropriate
    stopping value. The algorithm terminates when the current arrival time
    being processed is greater than the stopping value.

    There are two ways to specify the output image information (
    LargestPossibleRegion, Spacing, Origin): (a) it is copied directly
    from the input speed image or (b) it is specified by the user. Default
    values are used if the user does not specify all the information.

    The output information is computed as follows. If the speed image is
    nullptr or if the OverrideOutputInformation is set to true, the output
    information is set from user specified parameters. These parameters
    can be specified using methods SetOutputRegion() , SetOutputSpacing()
    , SetOutputDirection() , and SetOutputOrigin() . Else if the speed
    image is not nullptr, the output information is copied from the input
    speed image.

    For an alternative implementation, see itk::FastMarchingImageFilter .

    Possible Improvements: In the current implementation,
    std::priority_queue only allows taking nodes out from the front and
    putting nodes in from the back. To update a value already on the heap,
    a new node is added to the heap. The defunct old node is left on the
    heap. When it is removed from the top, it will be recognized as
    invalid and not used. Future implementations can implement the heap in
    a different way allowing the values to be updated. This will generally
    require some sift-up and sift-down functions and an image of back-
    pointers going from the image to heap in order to locate the node
    which is to be updated.


    See:
     FastMarchingImageFilterBase

     LevelSetTypeDefault

     itk::simple::FastMarching for the procedural interface

     itk::FastMarchingImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkFastMarchingImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_FastMarchingImageFilter

    def __init__(self):
        r"""
        __init__(FastMarchingImageFilter self) -> FastMarchingImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.FastMarchingImageFilter_swiginit(
            self, _SimpleITK.new_FastMarchingImageFilter()
        )

    def SetTrialPoints(self, TrialPoints):
        r"""
        SetTrialPoints(FastMarchingImageFilter self, VectorUIntList TrialPoints)


        Set the container of Trial Points representing the initial front.
        Trial points are represented as a VectorContainer of LevelSetNodes.


        """
        return _SimpleITK.FastMarchingImageFilter_SetTrialPoints(
            self, TrialPoints
        )

    def GetTrialPoints(self):
        r"""
        GetTrialPoints(FastMarchingImageFilter self) -> VectorUIntList


        Get the container of Trial Points representing the initial front.


        """
        return _SimpleITK.FastMarchingImageFilter_GetTrialPoints(self)

    def AddTrialPoint(self, point):
        r"""
        AddTrialPoint(FastMarchingImageFilter self, VectorUInt32 point)


        Add TrialPoints point.


        """
        return _SimpleITK.FastMarchingImageFilter_AddTrialPoint(self, point)

    def ClearTrialPoints(self):
        r"""
        ClearTrialPoints(FastMarchingImageFilter self)


        Remove all TrialPoints points.


        """
        return _SimpleITK.FastMarchingImageFilter_ClearTrialPoints(self)

    def SetNormalizationFactor(self, NormalizationFactor):
        r"""
        SetNormalizationFactor(FastMarchingImageFilter self, double NormalizationFactor)


        Set/Get the Normalization Factor for the Speed Image . The values in the Speed Image is divided by this factor. This allows the use of images with integer
        pixel types to represent the speed.


        """
        return _SimpleITK.FastMarchingImageFilter_SetNormalizationFactor(
            self, NormalizationFactor
        )

    def GetNormalizationFactor(self):
        r"""
        GetNormalizationFactor(FastMarchingImageFilter self) -> double


        Set/Get the Normalization Factor for the Speed Image . The values in the Speed Image is divided by this factor. This allows the use of images with integer
        pixel types to represent the speed.


        """
        return _SimpleITK.FastMarchingImageFilter_GetNormalizationFactor(self)

    def SetStoppingValue(self, StoppingValue):
        r"""
        SetStoppingValue(FastMarchingImageFilter self, double StoppingValue)


        Set the Fast Marching algorithm Stopping Value. The Fast Marching
        algorithm is terminated when the value of the smallest trial point is
        greater than the stopping value.


        """
        return _SimpleITK.FastMarchingImageFilter_SetStoppingValue(
            self, StoppingValue
        )

    def GetStoppingValue(self):
        r"""
        GetStoppingValue(FastMarchingImageFilter self) -> double


        Get the Fast Marching algorithm Stopping Value.


        """
        return _SimpleITK.FastMarchingImageFilter_GetStoppingValue(self)

    def SetInitialTrialValues(self, InitialTrialValues):
        r"""
        SetInitialTrialValues(FastMarchingImageFilter self, VectorDouble InitialTrialValues)


        Set the initial seed values for corresponding trial points.


        """
        return _SimpleITK.FastMarchingImageFilter_SetInitialTrialValues(
            self, InitialTrialValues
        )

    def GetInitialTrialValues(self):
        r"""
        GetInitialTrialValues(FastMarchingImageFilter self) -> VectorDouble


        """
        return _SimpleITK.FastMarchingImageFilter_GetInitialTrialValues(self)

    def GetName(self):
        r"""
        GetName(FastMarchingImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.FastMarchingImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(FastMarchingImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.FastMarchingImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(FastMarchingImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.FastMarchingImageFilter_Execute(self, image1)


# Register FastMarchingImageFilter in _SimpleITK:
_SimpleITK.FastMarchingImageFilter_swigregister(FastMarchingImageFilter)


def FastMarching(*args, **kwargs):
    r"""FastMarching(Image image1, VectorUIntList trialPoints=std::vector< std::vector< unsigned int > >(), double normalizationFactor=1.0, double stoppingValue=std::numeric_limits< double >::max()/2.0, VectorDouble initialTrialValues=std::vector< double >()) -> Image"""
    return _SimpleITK.FastMarching(*args, **kwargs)


class FastMarchingUpwindGradientImageFilter(ImageFilter):
    r"""


    Generates the upwind gradient field of fast marching arrival times.


    This filter adds some extra functionality to its base class. While the
    solution T(x) of the Eikonal equation is being generated by the base
    class with the fast marching method, the filter generates the upwind
    gradient vectors of T(x), storing them in an image.

    Since the Eikonal equation generates the arrival times of a wave
    traveling at a given speed, the generated gradient vectors can be
    interpreted as the slowness (1/velocity) vectors of the front (the
    quantity inside the modulus operator in the Eikonal equation).

    Gradient vectors are computed using upwind finite differences, that
    is, information only propagates from points where the wavefront has
    already passed. This is consistent with how the fast marching method
    works.

    One more extra feature is the possibility to define a set of Target
    points where the propagation stops. This can be used to avoid
    computing the Eikonal solution for the whole domain. The front can be
    stopped either when one Target point is reached or all Target points
    are reached. The propagation can stop after a time TargetOffset has
    passed since the stop condition is met. This way the solution is
    computed a bit downstream the Target points, so that the level sets of
    T(x) corresponding to the Target are smooth.

    For an alternative implementation, see itk::FastMarchingUpwindGradientImageFilterBase .


    Luca Antiga Ph.D. Biomedical Technologies Laboratory, Bioengineering
    Department, Mario Negri Institute, Italy.

    See:
     itk::simple::FastMarchingUpwindGradient for the procedural interface

     itk::FastMarchingUpwindGradientImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkFastMarchingUpwindGradientImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_FastMarchingUpwindGradientImageFilter

    def __init__(self):
        r"""
        __init__(FastMarchingUpwindGradientImageFilter self) -> FastMarchingUpwindGradientImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.FastMarchingUpwindGradientImageFilter_swiginit(
            self, _SimpleITK.new_FastMarchingUpwindGradientImageFilter()
        )

    def SetTrialPoints(self, TrialPoints):
        r"""
        SetTrialPoints(FastMarchingUpwindGradientImageFilter self, VectorUIntList TrialPoints)


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_SetTrialPoints(
            self, TrialPoints
        )

    def GetTrialPoints(self):
        r"""
        GetTrialPoints(FastMarchingUpwindGradientImageFilter self) -> VectorUIntList


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_GetTrialPoints(
            self
        )

    def AddTrialPoint(self, point):
        r"""
        AddTrialPoint(FastMarchingUpwindGradientImageFilter self, VectorUInt32 point)


        Add TrialPoints point.


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_AddTrialPoint(
            self, point
        )

    def ClearTrialPoints(self):
        r"""
        ClearTrialPoints(FastMarchingUpwindGradientImageFilter self)


        Remove all TrialPoints points.


        """
        return (
            _SimpleITK.FastMarchingUpwindGradientImageFilter_ClearTrialPoints(
                self
            )
        )

    def SetNumberOfTargets(self, NumberOfTargets):
        r"""
        SetNumberOfTargets(FastMarchingUpwindGradientImageFilter self, unsigned int NumberOfTargets)


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_SetNumberOfTargets(
            self, NumberOfTargets
        )

    def GetNumberOfTargets(self):
        r"""
        GetNumberOfTargets(FastMarchingUpwindGradientImageFilter self) -> unsigned int


        Get the number of targets.


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_GetNumberOfTargets(
            self
        )

    def SetTargetPoints(self, TargetPoints):
        r"""
        SetTargetPoints(FastMarchingUpwindGradientImageFilter self, VectorUIntList TargetPoints)


        Backwards compatibility for enum values Set the container of Target
        Points. If a target point is reached, the propagation stops. Trial
        points are represented as a VectorContainer of LevelSetNodes.


        """
        return (
            _SimpleITK.FastMarchingUpwindGradientImageFilter_SetTargetPoints(
                self, TargetPoints
            )
        )

    def GetTargetPoints(self):
        r"""
        GetTargetPoints(FastMarchingUpwindGradientImageFilter self) -> VectorUIntList


        Get the container of Target Points.


        """
        return (
            _SimpleITK.FastMarchingUpwindGradientImageFilter_GetTargetPoints(
                self
            )
        )

    def AddTargetPoint(self, point):
        r"""
        AddTargetPoint(FastMarchingUpwindGradientImageFilter self, VectorUInt32 point)


        Add TargetPoints point.


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_AddTargetPoint(
            self, point
        )

    def ClearTargetPoints(self):
        r"""
        ClearTargetPoints(FastMarchingUpwindGradientImageFilter self)


        Remove all TargetPoints points.


        """
        return (
            _SimpleITK.FastMarchingUpwindGradientImageFilter_ClearTargetPoints(
                self
            )
        )

    def SetTargetOffset(self, TargetOffset):
        r"""
        SetTargetOffset(FastMarchingUpwindGradientImageFilter self, double TargetOffset)


        Set how long (in terms of arrival times) after targets are reached the
        front must stop. This is useful to ensure that the level set of target
        arrival time is smooth.


        """
        return (
            _SimpleITK.FastMarchingUpwindGradientImageFilter_SetTargetOffset(
                self, TargetOffset
            )
        )

    def GetTargetOffset(self):
        r"""
        GetTargetOffset(FastMarchingUpwindGradientImageFilter self) -> double


        Get the TargetOffset ivar.


        """
        return (
            _SimpleITK.FastMarchingUpwindGradientImageFilter_GetTargetOffset(
                self
            )
        )

    def SetNormalizationFactor(self, NormalizationFactor):
        r"""
        SetNormalizationFactor(FastMarchingUpwindGradientImageFilter self, double NormalizationFactor)


        Set/Get the Normalization Factor for the Speed Image . The values in the Speed Image is divided by this factor. This allows the use of images with integer
        pixel types to represent the speed.


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_SetNormalizationFactor(
            self, NormalizationFactor
        )

    def GetNormalizationFactor(self):
        r"""
        GetNormalizationFactor(FastMarchingUpwindGradientImageFilter self) -> double


        Set/Get the Normalization Factor for the Speed Image . The values in the Speed Image is divided by this factor. This allows the use of images with integer
        pixel types to represent the speed.


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_GetNormalizationFactor(
            self
        )

    def SetInitialTrialValues(self, InitialTrialValues):
        r"""
        SetInitialTrialValues(FastMarchingUpwindGradientImageFilter self, VectorDouble InitialTrialValues)


        Set the initial seed values for corresponding trial point.


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_SetInitialTrialValues(
            self, InitialTrialValues
        )

    def GetInitialTrialValues(self):
        r"""
        GetInitialTrialValues(FastMarchingUpwindGradientImageFilter self) -> VectorDouble


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_GetInitialTrialValues(
            self
        )

    def GetGradientImage(self):
        r"""
        GetGradientImage(FastMarchingUpwindGradientImageFilter self) -> Image


        Get the gradient image.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return (
            _SimpleITK.FastMarchingUpwindGradientImageFilter_GetGradientImage(
                self
            )
        )

    def GetTargetValue(self):
        r"""
        GetTargetValue(FastMarchingUpwindGradientImageFilter self) -> double


        Get the arrival time corresponding to the last reached target. If
        TargetReachedMode is set to TargetConditionEnum::NoTargets ,
        TargetValue contains the last (aka largest) Eikonal solution value
        generated.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_GetTargetValue(
            self
        )

    def GetName(self):
        r"""
        GetName(FastMarchingUpwindGradientImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(FastMarchingUpwindGradientImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(FastMarchingUpwindGradientImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_Execute(
            self, image1
        )


# Register FastMarchingUpwindGradientImageFilter in _SimpleITK:
_SimpleITK.FastMarchingUpwindGradientImageFilter_swigregister(
    FastMarchingUpwindGradientImageFilter
)


def FastMarchingUpwindGradient(*args, **kwargs):
    r"""FastMarchingUpwindGradient(Image image1, VectorUIntList trialPoints=std::vector< std::vector< unsigned int > >(), unsigned int numberOfTargets=0, VectorUIntList targetPoints=std::vector< std::vector< unsigned int > >(), double targetOffset=1.0, double normalizationFactor=1.0, VectorDouble initialTrialValues=std::vector< double >()) -> Image"""
    return _SimpleITK.FastMarchingUpwindGradient(*args, **kwargs)


class FastSymmetricForcesDemonsRegistrationFilter(ImageFilter):
    r"""


    Deformably register two images using a symmetric forces demons
    algorithm.


    This class was contributed by Tom Vercauteren, INRIA & Mauna Kea
    Technologies based on a variation of the DemonsRegistrationFilter .

    FastSymmetricForcesDemonsRegistrationFilter implements the demons deformable algorithm that register two images
    by computing the deformation field which will map a moving image onto
    a fixed image.

    A deformation field is represented as a image whose pixel type is some
    vector type with at least N elements, where N is the dimension of the
    fixed image. The vector type must support element access via operator
    []. It is assumed that the vector elements behave like floating point
    scalars.

    This class is templated over the fixed image type, moving image type
    and the deformation field type.

    The input fixed and moving images are set via methods SetFixedImage
    and SetMovingImage respectively. An initial deformation field maybe
    set via SetInitialDisplacementField or SetInput. If no initial field
    is set, a zero field is used as the initial condition.

    The output deformation field can be obtained via methods GetOutput or
    GetDisplacementField.

    This class make use of the finite difference solver hierarchy. Update
    for each iteration is computed in DemonsRegistrationFunction .


    Tom Vercauteren, INRIA & Mauna Kea Technologies
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/ux2obj


    WARNING:
    This filter assumes that the fixed image type, moving image type and
    deformation field type all have the same number of dimensions.

    See:
     DemonsRegistrationFilter

     DemonsRegistrationFunction

     itk::FastSymmetricForcesDemonsRegistrationFilter for the Doxygen on the original ITK class.


    C++ includes: sitkFastSymmetricForcesDemonsRegistrationFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_FastSymmetricForcesDemonsRegistrationFilter
    )

    def __init__(self):
        r"""
        __init__(FastSymmetricForcesDemonsRegistrationFilter self) -> FastSymmetricForcesDemonsRegistrationFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_swiginit(
            self, _SimpleITK.new_FastSymmetricForcesDemonsRegistrationFilter()
        )

    def SetStandardDeviations(self, *args):
        r"""
        SetStandardDeviations(FastSymmetricForcesDemonsRegistrationFilter self, VectorDouble StandardDeviations)
        SetStandardDeviations(FastSymmetricForcesDemonsRegistrationFilter self, double value)


        Set/Get the Gaussian smoothing standard deviations for the
        displacement field. The values are set with respect to pixel
        coordinates.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetStandardDeviations(
            self, *args
        )

    def GetStandardDeviations(self):
        r"""
        GetStandardDeviations(FastSymmetricForcesDemonsRegistrationFilter self) -> VectorDouble


        Set/Get the Gaussian smoothing standard deviations for the
        displacement field. The values are set with respect to pixel
        coordinates.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetStandardDeviations(
            self
        )

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(FastSymmetricForcesDemonsRegistrationFilter self, uint32_t NumberOfIterations)


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(FastSymmetricForcesDemonsRegistrationFilter self) -> uint32_t


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetNumberOfIterations(
            self
        )

    def SetMaximumRMSError(self, MaximumRMSError):
        r"""
        SetMaximumRMSError(FastSymmetricForcesDemonsRegistrationFilter self, double MaximumRMSError)


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetMaximumRMSError(
            self, MaximumRMSError
        )

    def GetMaximumRMSError(self):
        r"""
        GetMaximumRMSError(FastSymmetricForcesDemonsRegistrationFilter self) -> double


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetMaximumRMSError(
            self
        )

    Symmetric = (
        _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_Symmetric
    )

    Fixed = _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_Fixed

    WarpedMoving = (
        _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_WarpedMoving
    )

    MappedMoving = (
        _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_MappedMoving
    )

    def SetUseGradientType(self, UseGradientType):
        r"""
        SetUseGradientType(FastSymmetricForcesDemonsRegistrationFilter self, itk::simple::FastSymmetricForcesDemonsRegistrationFilter::UseGradientTypeType UseGradientType)


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetUseGradientType(
            self, UseGradientType
        )

    def GetUseGradientType(self):
        r"""
        GetUseGradientType(FastSymmetricForcesDemonsRegistrationFilter self) -> itk::simple::FastSymmetricForcesDemonsRegistrationFilter::UseGradientTypeType


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetUseGradientType(
            self
        )

    def SetMaximumUpdateStepLength(self, MaximumUpdateStepLength):
        r"""
        SetMaximumUpdateStepLength(FastSymmetricForcesDemonsRegistrationFilter self, double MaximumUpdateStepLength)


        Set/Get the maximum update step length.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetMaximumUpdateStepLength(
            self, MaximumUpdateStepLength
        )

    def GetMaximumUpdateStepLength(self):
        r"""
        GetMaximumUpdateStepLength(FastSymmetricForcesDemonsRegistrationFilter self) -> double


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetMaximumUpdateStepLength(
            self
        )

    def SetSmoothDisplacementField(self, SmoothDisplacementField):
        r"""
        SetSmoothDisplacementField(FastSymmetricForcesDemonsRegistrationFilter self, bool SmoothDisplacementField)


        Set/Get whether the displacement field is smoothed (regularized).
        Smoothing the displacement yields a solution elastic in nature. If
        SmoothDisplacementField is on, then the displacement field is smoothed
        with a Gaussian whose standard deviations are specified with SetStandardDeviations()


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetSmoothDisplacementField(
            self, SmoothDisplacementField
        )

    def SmoothDisplacementFieldOn(self):
        r"""
        SmoothDisplacementFieldOn(FastSymmetricForcesDemonsRegistrationFilter self)


        Set the value of SmoothDisplacementField to true or false
        respectfully.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SmoothDisplacementFieldOn(
            self
        )

    def SmoothDisplacementFieldOff(self):
        r"""
        SmoothDisplacementFieldOff(FastSymmetricForcesDemonsRegistrationFilter self)


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SmoothDisplacementFieldOff(
            self
        )

    def GetSmoothDisplacementField(self):
        r"""
        GetSmoothDisplacementField(FastSymmetricForcesDemonsRegistrationFilter self) -> bool


        Set/Get whether the displacement field is smoothed (regularized).
        Smoothing the displacement yields a solution elastic in nature. If
        SmoothDisplacementField is on, then the displacement field is smoothed
        with a Gaussian whose standard deviations are specified with SetStandardDeviations()


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetSmoothDisplacementField(
            self
        )

    def SetSmoothUpdateField(self, SmoothUpdateField):
        r"""
        SetSmoothUpdateField(FastSymmetricForcesDemonsRegistrationFilter self, bool SmoothUpdateField)


        Set/Get whether the update field is smoothed (regularized). Smoothing
        the update field yields a solution viscous in nature. If
        SmoothUpdateField is on, then the update field is smoothed with a
        Gaussian whose standard deviations are specified with SetUpdateFieldStandardDeviations()


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetSmoothUpdateField(
            self, SmoothUpdateField
        )

    def SmoothUpdateFieldOn(self):
        r"""
        SmoothUpdateFieldOn(FastSymmetricForcesDemonsRegistrationFilter self)


        Set the value of SmoothUpdateField to true or false respectfully.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SmoothUpdateFieldOn(
            self
        )

    def SmoothUpdateFieldOff(self):
        r"""
        SmoothUpdateFieldOff(FastSymmetricForcesDemonsRegistrationFilter self)


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SmoothUpdateFieldOff(
            self
        )

    def GetSmoothUpdateField(self):
        r"""
        GetSmoothUpdateField(FastSymmetricForcesDemonsRegistrationFilter self) -> bool


        Set/Get whether the update field is smoothed (regularized). Smoothing
        the update field yields a solution viscous in nature. If
        SmoothUpdateField is on, then the update field is smoothed with a
        Gaussian whose standard deviations are specified with SetUpdateFieldStandardDeviations()


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetSmoothUpdateField(
            self
        )

    def SetUpdateFieldStandardDeviations(self, *args):
        r"""
        SetUpdateFieldStandardDeviations(FastSymmetricForcesDemonsRegistrationFilter self, VectorDouble UpdateFieldStandardDeviations)
        SetUpdateFieldStandardDeviations(FastSymmetricForcesDemonsRegistrationFilter self, double value)


        Set the Gaussian smoothing standard deviations for the update field.
        The values are set with respect to pixel coordinates.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetUpdateFieldStandardDeviations(
            self, *args
        )

    def GetUpdateFieldStandardDeviations(self):
        r"""
        GetUpdateFieldStandardDeviations(FastSymmetricForcesDemonsRegistrationFilter self) -> VectorDouble


        Set the Gaussian smoothing standard deviations for the update field.
        The values are set with respect to pixel coordinates.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetUpdateFieldStandardDeviations(
            self
        )

    def SetMaximumKernelWidth(self, MaximumKernelWidth):
        r"""
        SetMaximumKernelWidth(FastSymmetricForcesDemonsRegistrationFilter self, unsigned int MaximumKernelWidth)


        Set/Get the desired limits of the Gaussian kernel width.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetMaximumKernelWidth(
            self, MaximumKernelWidth
        )

    def GetMaximumKernelWidth(self):
        r"""
        GetMaximumKernelWidth(FastSymmetricForcesDemonsRegistrationFilter self) -> unsigned int


        Set/Get the desired limits of the Gaussian kernel width.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetMaximumKernelWidth(
            self
        )

    def SetMaximumError(self, MaximumError):
        r"""
        SetMaximumError(FastSymmetricForcesDemonsRegistrationFilter self, double MaximumError)


        Set/Get the desired maximum error of the Guassian kernel approximate.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetMaximumError(
            self, MaximumError
        )

    def GetMaximumError(self):
        r"""
        GetMaximumError(FastSymmetricForcesDemonsRegistrationFilter self) -> double


        Set/Get the desired maximum error of the Guassian kernel approximate.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetMaximumError(
            self
        )

    def SetIntensityDifferenceThreshold(self, IntensityDifferenceThreshold):
        r"""
        SetIntensityDifferenceThreshold(FastSymmetricForcesDemonsRegistrationFilter self, double IntensityDifferenceThreshold)


        Set/Get the threshold below which the absolute difference of intensity
        yields a match. When the intensities match between a moving and fixed
        image pixel, the update vector (for that iteration) will be the zero
        vector. Default is 0.001.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetIntensityDifferenceThreshold(
            self, IntensityDifferenceThreshold
        )

    def GetIntensityDifferenceThreshold(self):
        r"""
        GetIntensityDifferenceThreshold(FastSymmetricForcesDemonsRegistrationFilter self) -> double


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetIntensityDifferenceThreshold(
            self
        )

    def SetUseImageSpacing(self, UseImageSpacing):
        r"""
        SetUseImageSpacing(FastSymmetricForcesDemonsRegistrationFilter self, bool UseImageSpacing)


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetUseImageSpacing(
            self, UseImageSpacing
        )

    def UseImageSpacingOn(self):
        r"""
        UseImageSpacingOn(FastSymmetricForcesDemonsRegistrationFilter self)


        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_UseImageSpacingOn(
            self
        )

    def UseImageSpacingOff(self):
        r"""
        UseImageSpacingOff(FastSymmetricForcesDemonsRegistrationFilter self)


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_UseImageSpacingOff(
            self
        )

    def GetUseImageSpacing(self):
        r"""
        GetUseImageSpacing(FastSymmetricForcesDemonsRegistrationFilter self) -> bool


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetUseImageSpacing(
            self
        )

    def GetElapsedIterations(self):
        r"""
        GetElapsedIterations(FastSymmetricForcesDemonsRegistrationFilter self) -> uint32_t


        Number of iterations run.


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetElapsedIterations(
            self
        )

    def GetRMSChange(self):
        r"""
        GetRMSChange(FastSymmetricForcesDemonsRegistrationFilter self) -> double


        Set/Get the root mean squared change of the previous iteration. May
        not be used by all solvers.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetRMSChange(
            self
        )

    def GetMetric(self):
        r"""
        GetMetric(FastSymmetricForcesDemonsRegistrationFilter self) -> double


        Get the metric value. The metric value is the mean square difference
        in intensity between the fixed image and transforming moving image
        computed over the overlapping region between the two images. This
        value is calculated for the current iteration

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return (
            _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetMetric(
                self
            )
        )

    def StopRegistration(self):
        r"""
        StopRegistration(FastSymmetricForcesDemonsRegistrationFilter self)


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_StopRegistration(
            self
        )

    def GetName(self):
        r"""
        GetName(FastSymmetricForcesDemonsRegistrationFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(FastSymmetricForcesDemonsRegistrationFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter___str__(
            self
        )

    def Execute(self, *args):
        r"""
        Execute(FastSymmetricForcesDemonsRegistrationFilter self, Image fixedImage, Image movingImage, Image initialDisplacementField) -> Image
        Execute(FastSymmetricForcesDemonsRegistrationFilter self, Image fixedImage, Image movingImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_Execute(
            self, *args
        )


# Register FastSymmetricForcesDemonsRegistrationFilter in _SimpleITK:
_SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_swigregister(
    FastSymmetricForcesDemonsRegistrationFilter
)


class FlipImageFilter(ImageFilter):
    r"""


    Flips an image across user specified axes.


    FlipImageFilter flips an image across user specified axes. The flip axes are set via
    method SetFlipAxes( array ) where the input is a
    FixedArray<bool,ImageDimension>. The image is flipped across axes for
    which array[i] is true.

    In terms of grid coordinates the image is flipped within the
    LargestPossibleRegion of the input image. As such, the
    LargestPossibleRegion of the output image is the same as the input.

    In terms of geometric coordinates, the output origin is such that the
    image is flipped with respect to the coordinate axes.
    See:
     itk::simple::Flip for the procedural interface

     itk::FlipImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkFlipImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_FlipImageFilter

    def __init__(self):
        r"""
        __init__(FlipImageFilter self) -> FlipImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.FlipImageFilter_swiginit(
            self, _SimpleITK.new_FlipImageFilter()
        )

    def SetFlipAxes(self, FlipAxes):
        r"""
        SetFlipAxes(FlipImageFilter self, VectorBool FlipAxes)


        Set/Get the axis to be flipped. The image is flipped along axes for
        which array[i] is true. Default is false.


        """
        return _SimpleITK.FlipImageFilter_SetFlipAxes(self, FlipAxes)

    def GetFlipAxes(self):
        r"""
        GetFlipAxes(FlipImageFilter self) -> VectorBool


        Set/Get the axis to be flipped. The image is flipped along axes for
        which array[i] is true. Default is false.


        """
        return _SimpleITK.FlipImageFilter_GetFlipAxes(self)

    def SetFlipAboutOrigin(self, FlipAboutOrigin):
        r"""
        SetFlipAboutOrigin(FlipImageFilter self, bool FlipAboutOrigin)


        Controls how the output origin is computed. If FlipAboutOrigin is
        "On", the flip will occur about the origin of the axis, otherwise,
        the flip will occur about the center of the axis. Default is "On".


        """
        return _SimpleITK.FlipImageFilter_SetFlipAboutOrigin(
            self, FlipAboutOrigin
        )

    def FlipAboutOriginOn(self):
        r"""
        FlipAboutOriginOn(FlipImageFilter self)


        Set the value of FlipAboutOrigin to true or false respectfully.


        """
        return _SimpleITK.FlipImageFilter_FlipAboutOriginOn(self)

    def FlipAboutOriginOff(self):
        r"""
        FlipAboutOriginOff(FlipImageFilter self)


        """
        return _SimpleITK.FlipImageFilter_FlipAboutOriginOff(self)

    def GetFlipAboutOrigin(self):
        r"""
        GetFlipAboutOrigin(FlipImageFilter self) -> bool


        Controls how the output origin is computed. If FlipAboutOrigin is
        "On", the flip will occur about the origin of the axis, otherwise,
        the flip will occur about the center of the axis. Default is "On".


        """
        return _SimpleITK.FlipImageFilter_GetFlipAboutOrigin(self)

    def GetName(self):
        r"""
        GetName(FlipImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.FlipImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(FlipImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.FlipImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(FlipImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.FlipImageFilter_Execute(self, image1)


# Register FlipImageFilter in _SimpleITK:
_SimpleITK.FlipImageFilter_swigregister(FlipImageFilter)


def Flip(*args, **kwargs):
    r"""Flip(Image image1, VectorBool flipAxes=std::vector< bool >(3, false), bool flipAboutOrigin=False) -> Image"""
    return _SimpleITK.Flip(*args, **kwargs)


class ForwardFFTImageFilter(ImageFilter):
    r"""


    Base class for forward Fast Fourier Transform .


    This is a base class for the "forward" or "direct" discrete
    Fourier Transform . This is an abstract base class: the actual implementation is
    provided by the best child class available on the system when the
    object is created via the object factory system.

    This class transforms a real input image into its full complex Fourier
    transform. The Fourier transform of a real input image has Hermitian
    symmetry: $ f(\\mathbf{x}) = f^*(-\\mathbf{x}) $ . That is, when the result of the transform is split in half along
    the x-dimension, the values in the second half of the transform are
    the complex conjugates of values in the first half reflected about the
    center of the image in each dimension.

    This filter works only for real single-component input image types.

    The output generated from a ForwardFFTImageFilter is in the dual space or frequency domain. Refer to FrequencyFFTLayoutImageRegionConstIteratorWithIndex for a description of the layout of frequencies generated after a
    forward FFT. Also see ITKImageFrequency for a set of filters requiring
    input images in the frequency domain.


    See:
     Forward1DFFTImageFilter

     InverseFFTImageFilter

     ComplexToComplexFFTImageFilter

     itk::simple::ForwardFFT for the procedural interface

     itk::ForwardFFTImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkForwardFFTImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ForwardFFTImageFilter

    def __init__(self):
        r"""
        __init__(ForwardFFTImageFilter self) -> ForwardFFTImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ForwardFFTImageFilter_swiginit(
            self, _SimpleITK.new_ForwardFFTImageFilter()
        )

    def GetName(self):
        r"""
        GetName(ForwardFFTImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ForwardFFTImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ForwardFFTImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ForwardFFTImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ForwardFFTImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ForwardFFTImageFilter_Execute(self, image1)


# Register ForwardFFTImageFilter in _SimpleITK:
_SimpleITK.ForwardFFTImageFilter_swigregister(ForwardFFTImageFilter)


def ForwardFFT(image1):
    r"""ForwardFFT(Image image1) -> Image"""
    return _SimpleITK.ForwardFFT(image1)


class GaborImageSource(ImageFilter):
    r"""


    Generate an n-dimensional image of a Gabor filter.


    GaborImageSource generates an image of either the real (i.e. symmetric) or complex
    (i.e. antisymmetric) part of the Gabor filter with the orientation
    directed along the x-axis. The GaborKernelFunction is used to evaluate the contribution along the x-axis whereas a non-
    normalized 1-D Gaussian envelope provides the contribution in each of
    the remaining N dimensions. Orientation can be manipulated via the Transform classes of the toolkit.

    The output image may be of any dimension.

    This implementation was contributed as a paper to the Insight Journal https://doi.org/10.54294/dhogdz
    See:
     itk::simple::GaborSource for the procedural interface

     itk::GaborImageSource for the Doxygen on the original ITK class.


    C++ includes: sitkGaborImageSource.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_GaborImageSource

    def __init__(self):
        r"""
        __init__(GaborImageSource self) -> GaborImageSource


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GaborImageSource_swiginit(
            self, _SimpleITK.new_GaborImageSource()
        )

    def SetOutputPixelType(self, OutputPixelType):
        r"""
        SetOutputPixelType(GaborImageSource self, itk::simple::PixelIDValueEnum OutputPixelType)


        """
        return _SimpleITK.GaborImageSource_SetOutputPixelType(
            self, OutputPixelType
        )

    def GetOutputPixelType(self):
        r"""
        GetOutputPixelType(GaborImageSource self) -> itk::simple::PixelIDValueEnum


        """
        return _SimpleITK.GaborImageSource_GetOutputPixelType(self)

    def SetSize(self, Size):
        r"""
        SetSize(GaborImageSource self, VectorUInt32 Size)


        """
        return _SimpleITK.GaborImageSource_SetSize(self, Size)

    def GetSize(self):
        r"""
        GetSize(GaborImageSource self) -> VectorUInt32


        """
        return _SimpleITK.GaborImageSource_GetSize(self)

    def SetSigma(self, *args):
        r"""
        SetSigma(GaborImageSource self, VectorDouble Sigma)
        SetSigma(GaborImageSource self, double value)


        Set/Get the standard deviation in each direction.


        """
        return _SimpleITK.GaborImageSource_SetSigma(self, *args)

    def GetSigma(self):
        r"""
        GetSigma(GaborImageSource self) -> VectorDouble


        Set/Get the standard deviation in each direction.


        """
        return _SimpleITK.GaborImageSource_GetSigma(self)

    def SetMean(self, *args):
        r"""
        SetMean(GaborImageSource self, VectorDouble Mean)
        SetMean(GaborImageSource self, double value)


        Set/Get the mean in each direction.


        """
        return _SimpleITK.GaborImageSource_SetMean(self, *args)

    def GetMean(self):
        r"""
        GetMean(GaborImageSource self) -> VectorDouble


        Set/Get the mean in each direction.


        """
        return _SimpleITK.GaborImageSource_GetMean(self)

    def SetFrequency(self, Frequency):
        r"""
        SetFrequency(GaborImageSource self, double Frequency)


        Set/Get the modulation frequency of the sine or cosine component.


        """
        return _SimpleITK.GaborImageSource_SetFrequency(self, Frequency)

    def GetFrequency(self):
        r"""
        GetFrequency(GaborImageSource self) -> double


        Set/Get the modulation frequency of the sine or cosine component.


        """
        return _SimpleITK.GaborImageSource_GetFrequency(self)

    def SetOrigin(self, Origin):
        r"""
        SetOrigin(GaborImageSource self, VectorDouble Origin)


        """
        return _SimpleITK.GaborImageSource_SetOrigin(self, Origin)

    def GetOrigin(self):
        r"""
        GetOrigin(GaborImageSource self) -> VectorDouble


        """
        return _SimpleITK.GaborImageSource_GetOrigin(self)

    def SetSpacing(self, Spacing):
        r"""
        SetSpacing(GaborImageSource self, VectorDouble Spacing)


        """
        return _SimpleITK.GaborImageSource_SetSpacing(self, Spacing)

    def GetSpacing(self):
        r"""
        GetSpacing(GaborImageSource self) -> VectorDouble


        """
        return _SimpleITK.GaborImageSource_GetSpacing(self)

    def SetDirection(self, Direction):
        r"""
        SetDirection(GaborImageSource self, VectorDouble Direction)


        """
        return _SimpleITK.GaborImageSource_SetDirection(self, Direction)

    def GetDirection(self):
        r"""
        GetDirection(GaborImageSource self) -> VectorDouble


        """
        return _SimpleITK.GaborImageSource_GetDirection(self)

    def GetName(self):
        r"""
        GetName(GaborImageSource self) -> std::string


        Name of this class


        """
        return _SimpleITK.GaborImageSource_GetName(self)

    def __str__(self):
        r"""
        __str__(GaborImageSource self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.GaborImageSource___str__(self)

    def Execute(self):
        r"""
        Execute(GaborImageSource self) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.GaborImageSource_Execute(self)


# Register GaborImageSource in _SimpleITK:
_SimpleITK.GaborImageSource_swigregister(GaborImageSource)


def GaborSource(*args, **kwargs):
    r"""
    GaborSource(itk::simple::PixelIDValueEnum outputPixelType=sitkFloat32, VectorUInt32 size=std::vector< unsigned int >(3, 64), VectorDouble sigma=std::vector< double >(3, 16.0), VectorDouble mean=std::vector< double >(3, 32.0), double frequency=0.4, VectorDouble origin=std::vector< double >(3, 0.0), VectorDouble spacing=std::vector< double >(3, 1.0), VectorDouble direction=std::vector< double >()) -> Image


    Generate an n-dimensional image of a Gabor filter.


    This function directly calls the execute method of GaborImageSource in order to support a procedural API


    See:
     itk::simple::GaborImageSource for the object oriented interface



    """
    return _SimpleITK.GaborSource(*args, **kwargs)


class GaussianImageSource(ImageFilter):
    r"""


    Generate an n-dimensional image of a Gaussian.


    GaussianImageSource generates an image of a Gaussian. m_Normalized determines whether or
    not the Gaussian is normalized (whether or not the sum over infinite
    space is 1.0) When creating an image, it is preferable to not
    normalize the Gaussian m_Scale scales the output of the Gaussian to
    span a range larger than 0->1, and is typically set to the maximum
    value of the output data type (for instance, 255 for uchars)

    The output image may be of any dimension.
    See:
     itk::simple::GaussianSource for the procedural interface

     itk::GaussianImageSource for the Doxygen on the original ITK class.


    C++ includes: sitkGaussianImageSource.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_GaussianImageSource

    def __init__(self):
        r"""
        __init__(GaussianImageSource self) -> GaussianImageSource


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GaussianImageSource_swiginit(
            self, _SimpleITK.new_GaussianImageSource()
        )

    def SetOutputPixelType(self, OutputPixelType):
        r"""
        SetOutputPixelType(GaussianImageSource self, itk::simple::PixelIDValueEnum OutputPixelType)


        """
        return _SimpleITK.GaussianImageSource_SetOutputPixelType(
            self, OutputPixelType
        )

    def GetOutputPixelType(self):
        r"""
        GetOutputPixelType(GaussianImageSource self) -> itk::simple::PixelIDValueEnum


        """
        return _SimpleITK.GaussianImageSource_GetOutputPixelType(self)

    def SetSize(self, Size):
        r"""
        SetSize(GaussianImageSource self, VectorUInt32 Size)


        """
        return _SimpleITK.GaussianImageSource_SetSize(self, Size)

    def GetSize(self):
        r"""
        GetSize(GaussianImageSource self) -> VectorUInt32


        """
        return _SimpleITK.GaussianImageSource_GetSize(self)

    def SetSigma(self, *args):
        r"""
        SetSigma(GaussianImageSource self, VectorDouble Sigma)
        SetSigma(GaussianImageSource self, double value)


        Set/Get the standard deviation in each direction.


        """
        return _SimpleITK.GaussianImageSource_SetSigma(self, *args)

    def GetSigma(self):
        r"""
        GetSigma(GaussianImageSource self) -> VectorDouble


        Set/Get the standard deviation in each direction.


        """
        return _SimpleITK.GaussianImageSource_GetSigma(self)

    def SetMean(self, *args):
        r"""
        SetMean(GaussianImageSource self, VectorDouble Mean)
        SetMean(GaussianImageSource self, double value)


        Set/Get the mean in each direction.


        """
        return _SimpleITK.GaussianImageSource_SetMean(self, *args)

    def GetMean(self):
        r"""
        GetMean(GaussianImageSource self) -> VectorDouble


        Set/Get the mean in each direction.


        """
        return _SimpleITK.GaussianImageSource_GetMean(self)

    def SetScale(self, Scale):
        r"""
        SetScale(GaussianImageSource self, double Scale)


        Gets and sets for Gaussian parameters Set/Get the scale factor to
        multiply the true value of the Gaussian.


        """
        return _SimpleITK.GaussianImageSource_SetScale(self, Scale)

    def GetScale(self):
        r"""
        GetScale(GaussianImageSource self) -> double


        Gets and sets for Gaussian parameters Set/Get the scale factor to
        multiply the true value of the Gaussian.


        """
        return _SimpleITK.GaussianImageSource_GetScale(self)

    def SetOrigin(self, Origin):
        r"""
        SetOrigin(GaussianImageSource self, VectorDouble Origin)


        """
        return _SimpleITK.GaussianImageSource_SetOrigin(self, Origin)

    def GetOrigin(self):
        r"""
        GetOrigin(GaussianImageSource self) -> VectorDouble


        """
        return _SimpleITK.GaussianImageSource_GetOrigin(self)

    def SetSpacing(self, Spacing):
        r"""
        SetSpacing(GaussianImageSource self, VectorDouble Spacing)


        """
        return _SimpleITK.GaussianImageSource_SetSpacing(self, Spacing)

    def GetSpacing(self):
        r"""
        GetSpacing(GaussianImageSource self) -> VectorDouble


        """
        return _SimpleITK.GaussianImageSource_GetSpacing(self)

    def SetDirection(self, Direction):
        r"""
        SetDirection(GaussianImageSource self, VectorDouble Direction)


        """
        return _SimpleITK.GaussianImageSource_SetDirection(self, Direction)

    def GetDirection(self):
        r"""
        GetDirection(GaussianImageSource self) -> VectorDouble


        """
        return _SimpleITK.GaussianImageSource_GetDirection(self)

    def SetNormalized(self, Normalized):
        r"""
        SetNormalized(GaussianImageSource self, bool Normalized)


        Set/Get whether or not to normalize the Gaussian. Default is false.


        """
        return _SimpleITK.GaussianImageSource_SetNormalized(self, Normalized)

    def NormalizedOn(self):
        r"""
        NormalizedOn(GaussianImageSource self)


        Set the value of Normalized to true or false respectfully.


        """
        return _SimpleITK.GaussianImageSource_NormalizedOn(self)

    def NormalizedOff(self):
        r"""
        NormalizedOff(GaussianImageSource self)


        """
        return _SimpleITK.GaussianImageSource_NormalizedOff(self)

    def GetNormalized(self):
        r"""
        GetNormalized(GaussianImageSource self) -> bool


        Set/Get whether or not to normalize the Gaussian. Default is false.


        """
        return _SimpleITK.GaussianImageSource_GetNormalized(self)

    def GetName(self):
        r"""
        GetName(GaussianImageSource self) -> std::string


        Name of this class


        """
        return _SimpleITK.GaussianImageSource_GetName(self)

    def __str__(self):
        r"""
        __str__(GaussianImageSource self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.GaussianImageSource___str__(self)

    def Execute(self):
        r"""
        Execute(GaussianImageSource self) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.GaussianImageSource_Execute(self)


# Register GaussianImageSource in _SimpleITK:
_SimpleITK.GaussianImageSource_swigregister(GaussianImageSource)


def GaussianSource(*args, **kwargs):
    r"""
    GaussianSource(itk::simple::PixelIDValueEnum outputPixelType=sitkFloat32, VectorUInt32 size=std::vector< unsigned int >(3, 64), VectorDouble sigma=std::vector< double >(3, 16.0), VectorDouble mean=std::vector< double >(3, 32.0), double scale=255, VectorDouble origin=std::vector< double >(3, 0.0), VectorDouble spacing=std::vector< double >(3, 1.0), VectorDouble direction=std::vector< double >(), bool normalized=False) -> Image


    Generate an n-dimensional image of a Gaussian.


    This function directly calls the execute method of GaussianImageSource in order to support a procedural API


    See:
     itk::simple::GaussianImageSource for the object oriented interface



    """
    return _SimpleITK.GaussianSource(*args, **kwargs)


class GeodesicActiveContourLevelSetImageFilter(ImageFilter):
    r"""


    Segments structures in images based on a user supplied edge potential
    map.


    IMPORTANT
    The SegmentationLevelSetImageFilter class and the GeodesicActiveContourLevelSetFunction class contain additional information necessary to gain full
    understanding of how to use this filter.
    OVERVIEW
    This class is a level set method segmentation filter. An initial
    contour is propagated outwards (or inwards) until it ''sticks'' to the
    shape boundaries. This is done by using a level set speed function
    based on a user supplied edge potential map.
    INPUTS
    This filter requires two inputs. The first input is a initial level
    set. The initial level set is a real image which contains the initial
    contour/surface as the zero level set. For example, a signed distance
    function from the initial contour/surface is typically used. Unlike
    the simpler ShapeDetectionLevelSetImageFilter the initial contour does not have to lie wholly within the shape to
    be segmented. The initial contour is allow to overlap the shape
    boundary. The extra advection term in the update equation behaves like
    a doublet and attracts the contour to the boundary. This approach for
    segmentation follows that of Caselles et al (1997).

    The second input is the feature image. For this filter, this is the
    edge potential map. General characteristics of an edge potential map
    is that it has values close to zero in regions near the edges and
    values close to one inside the shape itself. Typically, the edge
    potential map is compute from the image gradient, for example:
    \\[ g(I) = 1 / ( 1 + | (\\nabla * G)(I)| ) \\] \\[ g(I) = \\exp^{-|(\\nabla * G)(I)|} \\]

    where $ I $ is image intensity and $ (\\nabla * G) $ is the derivative of Gaussian operator.


    See SegmentationLevelSetImageFilter and SparseFieldLevelSetImageFilter for more information on Inputs.
    PARAMETERS
    The PropagationScaling parameter can be used to switch from
    propagation outwards (POSITIVE scaling parameter) versus propagating
    inwards (NEGATIVE scaling parameter).
     This implementation allows the user to set the weights between the
    propagation, advection and curvature term using methods SetPropagationScaling() , SetAdvectionScaling() , SetCurvatureScaling() . In general, the larger the CurvatureScaling, the smoother the
    resulting contour. To follow the implementation in Caselles et al
    paper, set the PropagationScaling to $ c $ (the inflation or balloon force) and AdvectionScaling and
    CurvatureScaling both to 1.0.

    OUTPUTS
    The filter outputs a single, scalar, real-valued image. Negative
    values in the output image represent the inside of the segmented
    region and positive values in the image represent the outside of the
    segmented region. The zero crossings of the image correspond to the
    position of the propagating front.

    See SparseFieldLevelSetImageFilter and SegmentationLevelSetImageFilter for more information.
    REFERENCES

    "Geodesic Active Contours", V. Caselles, R. Kimmel and G. Sapiro.
    International Journal on Computer Vision, Vol 22, No. 1, pp 61-97,
    1997

    See:
     SegmentationLevelSetImageFilter

     GeodesicActiveContourLevelSetFunction

     SparseFieldLevelSetImageFilter

     itk::simple::GeodesicActiveContourLevelSet for the procedural interface

     itk::GeodesicActiveContourLevelSetImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGeodesicActiveContourLevelSetImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_GeodesicActiveContourLevelSetImageFilter
    )

    def __init__(self):
        r"""
        __init__(GeodesicActiveContourLevelSetImageFilter self) -> GeodesicActiveContourLevelSetImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GeodesicActiveContourLevelSetImageFilter_swiginit(
            self, _SimpleITK.new_GeodesicActiveContourLevelSetImageFilter()
        )

    def SetMaximumRMSError(self, MaximumRMSError):
        r"""
        SetMaximumRMSError(GeodesicActiveContourLevelSetImageFilter self, double MaximumRMSError)


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_SetMaximumRMSError(
            self, MaximumRMSError
        )

    def GetMaximumRMSError(self):
        r"""
        GetMaximumRMSError(GeodesicActiveContourLevelSetImageFilter self) -> double


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_GetMaximumRMSError(
            self
        )

    def SetPropagationScaling(self, PropagationScaling):
        r"""
        SetPropagationScaling(GeodesicActiveContourLevelSetImageFilter self, double PropagationScaling)


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_SetPropagationScaling(
            self, PropagationScaling
        )

    def GetPropagationScaling(self):
        r"""
        GetPropagationScaling(GeodesicActiveContourLevelSetImageFilter self) -> double


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_GetPropagationScaling(
            self
        )

    def SetCurvatureScaling(self, CurvatureScaling):
        r"""
        SetCurvatureScaling(GeodesicActiveContourLevelSetImageFilter self, double CurvatureScaling)


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_SetCurvatureScaling(
            self, CurvatureScaling
        )

    def GetCurvatureScaling(self):
        r"""
        GetCurvatureScaling(GeodesicActiveContourLevelSetImageFilter self) -> double


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_GetCurvatureScaling(
            self
        )

    def SetAdvectionScaling(self, AdvectionScaling):
        r"""
        SetAdvectionScaling(GeodesicActiveContourLevelSetImageFilter self, double AdvectionScaling)


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_SetAdvectionScaling(
            self, AdvectionScaling
        )

    def GetAdvectionScaling(self):
        r"""
        GetAdvectionScaling(GeodesicActiveContourLevelSetImageFilter self) -> double


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_GetAdvectionScaling(
            self
        )

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(GeodesicActiveContourLevelSetImageFilter self, uint32_t NumberOfIterations)


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(GeodesicActiveContourLevelSetImageFilter self) -> uint32_t


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_GetNumberOfIterations(
            self
        )

    def SetReverseExpansionDirection(self, ReverseExpansionDirection):
        r"""
        SetReverseExpansionDirection(GeodesicActiveContourLevelSetImageFilter self, bool ReverseExpansionDirection)


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_SetReverseExpansionDirection(
            self, ReverseExpansionDirection
        )

    def ReverseExpansionDirectionOn(self):
        r"""
        ReverseExpansionDirectionOn(GeodesicActiveContourLevelSetImageFilter self)


        Set the value of ReverseExpansionDirection to true or false
        respectfully.


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_ReverseExpansionDirectionOn(
            self
        )

    def ReverseExpansionDirectionOff(self):
        r"""
        ReverseExpansionDirectionOff(GeodesicActiveContourLevelSetImageFilter self)


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_ReverseExpansionDirectionOff(
            self
        )

    def GetReverseExpansionDirection(self):
        r"""
        GetReverseExpansionDirection(GeodesicActiveContourLevelSetImageFilter self) -> bool


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_GetReverseExpansionDirection(
            self
        )

    def GetElapsedIterations(self):
        r"""
        GetElapsedIterations(GeodesicActiveContourLevelSetImageFilter self) -> uint32_t


        Number of iterations run.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_GetElapsedIterations(
            self
        )

    def GetRMSChange(self):
        r"""
        GetRMSChange(GeodesicActiveContourLevelSetImageFilter self) -> double


        The Root Mean Square of the levelset upon termination.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return (
            _SimpleITK.GeodesicActiveContourLevelSetImageFilter_GetRMSChange(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(GeodesicActiveContourLevelSetImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(GeodesicActiveContourLevelSetImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter___str__(
            self
        )

    def Execute(self, initialImage, featureImage):
        r"""
        Execute(GeodesicActiveContourLevelSetImageFilter self, Image initialImage, Image featureImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_Execute(
            self, initialImage, featureImage
        )


# Register GeodesicActiveContourLevelSetImageFilter in _SimpleITK:
_SimpleITK.GeodesicActiveContourLevelSetImageFilter_swigregister(
    GeodesicActiveContourLevelSetImageFilter
)


def GeodesicActiveContourLevelSet(
    initialImage,
    featureImage,
    maximumRMSError=0.01,
    propagationScaling=1.0,
    curvatureScaling=1.0,
    advectionScaling=1.0,
    numberOfIterations=1000,
    reverseExpansionDirection=False,
):
    r"""GeodesicActiveContourLevelSet(Image initialImage, Image featureImage, double maximumRMSError=0.01, double propagationScaling=1.0, double curvatureScaling=1.0, double advectionScaling=1.0, uint32_t numberOfIterations=1000, bool reverseExpansionDirection=False) -> Image"""
    return _SimpleITK.GeodesicActiveContourLevelSet(
        initialImage,
        featureImage,
        maximumRMSError,
        propagationScaling,
        curvatureScaling,
        advectionScaling,
        numberOfIterations,
        reverseExpansionDirection,
    )


class GradientAnisotropicDiffusionImageFilter(ImageFilter):
    r"""


    This filter performs anisotropic diffusion on a scalar itk::Image using the classic Perona-Malik, gradient magnitude based equation.


    For detailed information on anisotropic diffusion, see
    itkAnisotropicDiffusionFunction and
    itkGradientNDAnisotropicDiffusionFunction.

    Inputs and Outputs
    The input to this filter should be a scalar itk::Image of any dimensionality. The output image will be a diffused copy of
    the input.
    Parameters
    Please see the description of parameters given in
    itkAnisotropicDiffusionImageFilter.

    See:
     AnisotropicDiffusionImageFilter

     AnisotropicDiffusionFunction

     GradientAnisotropicDiffusionFunction

     itk::simple::GradientAnisotropicDiffusion for the procedural interface

     itk::GradientAnisotropicDiffusionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGradientAnisotropicDiffusionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_GradientAnisotropicDiffusionImageFilter
    )

    def __init__(self):
        r"""
        __init__(GradientAnisotropicDiffusionImageFilter self) -> GradientAnisotropicDiffusionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GradientAnisotropicDiffusionImageFilter_swiginit(
            self, _SimpleITK.new_GradientAnisotropicDiffusionImageFilter()
        )

    def SetTimeStep(self, TimeStep):
        r"""
        SetTimeStep(GradientAnisotropicDiffusionImageFilter self, double TimeStep)


        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_SetTimeStep(
            self, TimeStep
        )

    def GetTimeStep(self):
        r"""
        GetTimeStep(GradientAnisotropicDiffusionImageFilter self) -> double


        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_GetTimeStep(
            self
        )

    def SetConductanceParameter(self, ConductanceParameter):
        r"""
        SetConductanceParameter(GradientAnisotropicDiffusionImageFilter self, double ConductanceParameter)


        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_SetConductanceParameter(
            self, ConductanceParameter
        )

    def GetConductanceParameter(self):
        r"""
        GetConductanceParameter(GradientAnisotropicDiffusionImageFilter self) -> double


        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_GetConductanceParameter(
            self
        )

    def SetConductanceScalingUpdateInterval(
        self, ConductanceScalingUpdateInterval
    ):
        r"""
        SetConductanceScalingUpdateInterval(GradientAnisotropicDiffusionImageFilter self, unsigned int ConductanceScalingUpdateInterval)


        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_SetConductanceScalingUpdateInterval(
            self, ConductanceScalingUpdateInterval
        )

    def GetConductanceScalingUpdateInterval(self):
        r"""
        GetConductanceScalingUpdateInterval(GradientAnisotropicDiffusionImageFilter self) -> unsigned int


        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_GetConductanceScalingUpdateInterval(
            self
        )

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(GradientAnisotropicDiffusionImageFilter self, uint32_t NumberOfIterations)


        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(GradientAnisotropicDiffusionImageFilter self) -> uint32_t


        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_GetNumberOfIterations(
            self
        )

    def GetName(self):
        r"""
        GetName(GradientAnisotropicDiffusionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(GradientAnisotropicDiffusionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(GradientAnisotropicDiffusionImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_Execute(
            self, image1
        )

    def EstimateOptimalTimeStep(self, inImage):
        r"""
        EstimateOptimalTimeStep(GradientAnisotropicDiffusionImageFilter self, Image inImage) -> double


        This method autmatically sets the optimal timestep for an image given
        its spacing.


        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_EstimateOptimalTimeStep(
            self, inImage
        )


# Register GradientAnisotropicDiffusionImageFilter in _SimpleITK:
_SimpleITK.GradientAnisotropicDiffusionImageFilter_swigregister(
    GradientAnisotropicDiffusionImageFilter
)


def GradientAnisotropicDiffusion(
    image1,
    timeStep=0.125,
    conductanceParameter=3,
    conductanceScalingUpdateInterval=1,
    numberOfIterations=5,
):
    r"""GradientAnisotropicDiffusion(Image image1, double timeStep=0.125, double conductanceParameter=3, unsigned int conductanceScalingUpdateInterval=1, uint32_t numberOfIterations=5) -> Image"""
    return _SimpleITK.GradientAnisotropicDiffusion(
        image1,
        timeStep,
        conductanceParameter,
        conductanceScalingUpdateInterval,
        numberOfIterations,
    )


class GradientImageFilter(ImageFilter):
    r"""


    Computes the gradient of an image using directional derivatives.


    Computes the gradient of an image using directional derivatives. The
    directional derivative at each pixel location is computed by
    convolution with a first-order derivative operator.

    The second template parameter defines the value type used in the
    derivative operator (defaults to float). The third template parameter
    defines the value type used for output image (defaults to float). The
    output image is defined as a covariant vector image whose value type
    is specified as this third template parameter.


    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     itk::simple::Gradient for the procedural interface

     itk::GradientImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGradientImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_GradientImageFilter

    def __init__(self):
        r"""
        __init__(GradientImageFilter self) -> GradientImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GradientImageFilter_swiginit(
            self, _SimpleITK.new_GradientImageFilter()
        )

    def SetUseImageSpacing(self, UseImageSpacing):
        r"""
        SetUseImageSpacing(GradientImageFilter self, bool UseImageSpacing)


        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations. Use On to take the image spacing
        information into account and to compute the derivatives in physical
        space; use Off to ignore the image spacing and to compute the
        derivatives in isotropic voxel space. Default is On.


        """
        return _SimpleITK.GradientImageFilter_SetUseImageSpacing(
            self, UseImageSpacing
        )

    def UseImageSpacingOn(self):
        r"""
        UseImageSpacingOn(GradientImageFilter self)


        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.GradientImageFilter_UseImageSpacingOn(self)

    def UseImageSpacingOff(self):
        r"""
        UseImageSpacingOff(GradientImageFilter self)


        """
        return _SimpleITK.GradientImageFilter_UseImageSpacingOff(self)

    def GetUseImageSpacing(self):
        r"""
        GetUseImageSpacing(GradientImageFilter self) -> bool


        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations. Use On to take the image spacing
        information into account and to compute the derivatives in physical
        space; use Off to ignore the image spacing and to compute the
        derivatives in isotropic voxel space. Default is On.


        """
        return _SimpleITK.GradientImageFilter_GetUseImageSpacing(self)

    def SetUseImageDirection(self, UseImageDirection):
        r"""
        SetUseImageDirection(GradientImageFilter self, bool UseImageDirection)


        The UseImageDirection flag determines whether image derivatives are
        computed with respect to the image grid or with respect to the
        physical space. When this flag is ON the derivatives are computed with
        respect to the coordinate system of physical space. The difference is
        whether we take into account the image Direction or not. The flag ON
        will take into account the image direction and will result in an extra
        matrix multiplication compared to the amount of computation performed
        when the flag is OFF. The default value of this flag is On.


        """
        return _SimpleITK.GradientImageFilter_SetUseImageDirection(
            self, UseImageDirection
        )

    def UseImageDirectionOn(self):
        r"""
        UseImageDirectionOn(GradientImageFilter self)


        Set the value of UseImageDirection to true or false respectfully.


        """
        return _SimpleITK.GradientImageFilter_UseImageDirectionOn(self)

    def UseImageDirectionOff(self):
        r"""
        UseImageDirectionOff(GradientImageFilter self)


        """
        return _SimpleITK.GradientImageFilter_UseImageDirectionOff(self)

    def GetUseImageDirection(self):
        r"""
        GetUseImageDirection(GradientImageFilter self) -> bool


        The UseImageDirection flag determines whether image derivatives are
        computed with respect to the image grid or with respect to the
        physical space. When this flag is ON the derivatives are computed with
        respect to the coordinate system of physical space. The difference is
        whether we take into account the image Direction or not. The flag ON
        will take into account the image direction and will result in an extra
        matrix multiplication compared to the amount of computation performed
        when the flag is OFF. The default value of this flag is On.


        """
        return _SimpleITK.GradientImageFilter_GetUseImageDirection(self)

    def GetName(self):
        r"""
        GetName(GradientImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.GradientImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(GradientImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.GradientImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(GradientImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.GradientImageFilter_Execute(self, image1)


# Register GradientImageFilter in _SimpleITK:
_SimpleITK.GradientImageFilter_swigregister(GradientImageFilter)


def Gradient(image1, useImageSpacing=True, useImageDirection=False):
    r"""Gradient(Image image1, bool useImageSpacing=True, bool useImageDirection=False) -> Image"""
    return _SimpleITK.Gradient(image1, useImageSpacing, useImageDirection)


class GradientMagnitudeImageFilter(ImageFilter):
    r"""


    Computes the gradient magnitude of an image region at each pixel.



    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     itk::simple::GradientMagnitude for the procedural interface

     itk::GradientMagnitudeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGradientMagnitudeImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_GradientMagnitudeImageFilter

    def __init__(self):
        r"""
        __init__(GradientMagnitudeImageFilter self) -> GradientMagnitudeImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GradientMagnitudeImageFilter_swiginit(
            self, _SimpleITK.new_GradientMagnitudeImageFilter()
        )

    def SetUseImageSpacing(self, UseImageSpacing):
        r"""
        SetUseImageSpacing(GradientMagnitudeImageFilter self, bool UseImageSpacing)


        Set/Get whether or not the filter will use the spacing of the input
        image in the computation of the derivatives. Use On to compute the
        gradient in physical space; use Off to ignore image spacing and to
        compute the gradient in isotropic voxel space. Default is On.


        """
        return _SimpleITK.GradientMagnitudeImageFilter_SetUseImageSpacing(
            self, UseImageSpacing
        )

    def UseImageSpacingOn(self):
        r"""
        UseImageSpacingOn(GradientMagnitudeImageFilter self)


        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.GradientMagnitudeImageFilter_UseImageSpacingOn(self)

    def UseImageSpacingOff(self):
        r"""
        UseImageSpacingOff(GradientMagnitudeImageFilter self)


        """
        return _SimpleITK.GradientMagnitudeImageFilter_UseImageSpacingOff(self)

    def GetUseImageSpacing(self):
        r"""
        GetUseImageSpacing(GradientMagnitudeImageFilter self) -> bool


        Set/Get whether or not the filter will use the spacing of the input
        image in the computation of the derivatives. Use On to compute the
        gradient in physical space; use Off to ignore image spacing and to
        compute the gradient in isotropic voxel space. Default is On.


        """
        return _SimpleITK.GradientMagnitudeImageFilter_GetUseImageSpacing(self)

    def GetName(self):
        r"""
        GetName(GradientMagnitudeImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.GradientMagnitudeImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(GradientMagnitudeImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.GradientMagnitudeImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(GradientMagnitudeImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.GradientMagnitudeImageFilter_Execute(self, image1)


# Register GradientMagnitudeImageFilter in _SimpleITK:
_SimpleITK.GradientMagnitudeImageFilter_swigregister(
    GradientMagnitudeImageFilter
)


def GradientMagnitude(image1, useImageSpacing=True):
    r"""GradientMagnitude(Image image1, bool useImageSpacing=True) -> Image"""
    return _SimpleITK.GradientMagnitude(image1, useImageSpacing)


class GradientMagnitudeRecursiveGaussianImageFilter(ImageFilter):
    r"""


    Computes the Magnitude of the Gradient of an image by convolution with
    the first derivative of a Gaussian.


    This filter is implemented using the recursive gaussian filters
    See:
     itk::simple::GradientMagnitudeRecursiveGaussian for the procedural interface

     itk::GradientMagnitudeRecursiveGaussianImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGradientMagnitudeRecursiveGaussianImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_GradientMagnitudeRecursiveGaussianImageFilter
    )

    def __init__(self):
        r"""
        __init__(GradientMagnitudeRecursiveGaussianImageFilter self) -> GradientMagnitudeRecursiveGaussianImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter_swiginit(
            self,
            _SimpleITK.new_GradientMagnitudeRecursiveGaussianImageFilter(),
        )

    def SetSigma(self, Sigma):
        r"""
        SetSigma(GradientMagnitudeRecursiveGaussianImageFilter self, double Sigma)


        Set/Get Sigma value. Sigma is measured in the units of image spacing.


        """
        return (
            _SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter_SetSigma(
                self, Sigma
            )
        )

    def GetSigma(self):
        r"""
        GetSigma(GradientMagnitudeRecursiveGaussianImageFilter self) -> double


        Set/Get Sigma value. Sigma is measured in the units of image spacing.


        """
        return (
            _SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter_GetSigma(
                self
            )
        )

    def SetNormalizeAcrossScale(self, NormalizeAcrossScale):
        r"""
        SetNormalizeAcrossScale(GradientMagnitudeRecursiveGaussianImageFilter self, bool NormalizeAcrossScale)


        Set/Get the normalization factor that will be used for the Gaussian.
        See:
         RecursiveGaussianImageFilter::SetNormalizeAcrossScale



        """
        return _SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter_SetNormalizeAcrossScale(
            self, NormalizeAcrossScale
        )

    def NormalizeAcrossScaleOn(self):
        r"""
        NormalizeAcrossScaleOn(GradientMagnitudeRecursiveGaussianImageFilter self)


        Set the value of NormalizeAcrossScale to true or false respectfully.


        """
        return _SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter_NormalizeAcrossScaleOn(
            self
        )

    def NormalizeAcrossScaleOff(self):
        r"""
        NormalizeAcrossScaleOff(GradientMagnitudeRecursiveGaussianImageFilter self)


        """
        return _SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter_NormalizeAcrossScaleOff(
            self
        )

    def GetNormalizeAcrossScale(self):
        r"""
        GetNormalizeAcrossScale(GradientMagnitudeRecursiveGaussianImageFilter self) -> bool


        Set/Get the normalization factor that will be used for the Gaussian.
        See:
         RecursiveGaussianImageFilter::SetNormalizeAcrossScale



        """
        return _SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter_GetNormalizeAcrossScale(
            self
        )

    def GetName(self):
        r"""
        GetName(GradientMagnitudeRecursiveGaussianImageFilter self) -> std::string


        Name of this class


        """
        return (
            _SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter_GetName(
                self
            )
        )

    def __str__(self):
        r"""
        __str__(GradientMagnitudeRecursiveGaussianImageFilter self) -> std::string


        Print ourselves out


        """
        return (
            _SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter___str__(
                self
            )
        )

    def Execute(self, image1):
        r"""
        Execute(GradientMagnitudeRecursiveGaussianImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return (
            _SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter_Execute(
                self, image1
            )
        )


# Register GradientMagnitudeRecursiveGaussianImageFilter in _SimpleITK:
_SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter_swigregister(
    GradientMagnitudeRecursiveGaussianImageFilter
)


def GradientMagnitudeRecursiveGaussian(
    image1, sigma=1.0, normalizeAcrossScale=False
):
    r"""GradientMagnitudeRecursiveGaussian(Image image1, double sigma=1.0, bool normalizeAcrossScale=False) -> Image"""
    return _SimpleITK.GradientMagnitudeRecursiveGaussian(
        image1, sigma, normalizeAcrossScale
    )


class GradientRecursiveGaussianImageFilter(ImageFilter):
    r"""


    Computes the gradient of an image by convolution with the first
    derivative of a Gaussian.


    This filter is implemented using the recursive gaussian filters.

    This filter supports both scalar and vector pixel types within the
    input image, including VectorImage type.
    See:
     itk::simple::GradientRecursiveGaussian for the procedural interface

     itk::GradientRecursiveGaussianImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGradientRecursiveGaussianImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_GradientRecursiveGaussianImageFilter

    def __init__(self):
        r"""
        __init__(GradientRecursiveGaussianImageFilter self) -> GradientRecursiveGaussianImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GradientRecursiveGaussianImageFilter_swiginit(
            self, _SimpleITK.new_GradientRecursiveGaussianImageFilter()
        )

    def SetSigma(self, Sigma):
        r"""
        SetSigma(GradientRecursiveGaussianImageFilter self, double Sigma)


        Set/Get the Sigma value. Sigma is measured in the units of image
        spacing.


        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_SetSigma(
            self, Sigma
        )

    def GetSigma(self):
        r"""
        GetSigma(GradientRecursiveGaussianImageFilter self) -> double


        Get the value of Sigma along the first dimension.


        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_GetSigma(self)

    def SetNormalizeAcrossScale(self, NormalizeAcrossScale):
        r"""
        SetNormalizeAcrossScale(GradientRecursiveGaussianImageFilter self, bool NormalizeAcrossScale)


        Define which normalization factor will be used for the Gaussian
        See:
         RecursiveGaussianImageFilter::SetNormalizeAcrossScale



        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_SetNormalizeAcrossScale(
            self, NormalizeAcrossScale
        )

    def NormalizeAcrossScaleOn(self):
        r"""
        NormalizeAcrossScaleOn(GradientRecursiveGaussianImageFilter self)


        Set the value of NormalizeAcrossScale to true or false respectfully.


        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_NormalizeAcrossScaleOn(
            self
        )

    def NormalizeAcrossScaleOff(self):
        r"""
        NormalizeAcrossScaleOff(GradientRecursiveGaussianImageFilter self)


        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_NormalizeAcrossScaleOff(
            self
        )

    def GetNormalizeAcrossScale(self):
        r"""
        GetNormalizeAcrossScale(GradientRecursiveGaussianImageFilter self) -> bool


        Define which normalization factor will be used for the Gaussian
        See:
         RecursiveGaussianImageFilter::SetNormalizeAcrossScale



        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_GetNormalizeAcrossScale(
            self
        )

    def SetUseImageDirection(self, UseImageDirection):
        r"""
        SetUseImageDirection(GradientRecursiveGaussianImageFilter self, bool UseImageDirection)


        The UseImageDirection flag determines whether the gradients are
        computed with respect to the image grid or with respect to the
        physical space. When this flag is ON the gradients are computed with
        respect to the coordinate system of physical space. The difference is
        whether we take into account the image Direction or not. The flag ON
        will take into account the image direction and will result in an extra
        matrix multiplication compared to the amount of computation performed
        when the flag is OFF. The default value of this flag is On.


        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_SetUseImageDirection(
            self, UseImageDirection
        )

    def UseImageDirectionOn(self):
        r"""
        UseImageDirectionOn(GradientRecursiveGaussianImageFilter self)


        Set the value of UseImageDirection to true or false respectfully.


        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_UseImageDirectionOn(
            self
        )

    def UseImageDirectionOff(self):
        r"""
        UseImageDirectionOff(GradientRecursiveGaussianImageFilter self)


        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_UseImageDirectionOff(
            self
        )

    def GetUseImageDirection(self):
        r"""
        GetUseImageDirection(GradientRecursiveGaussianImageFilter self) -> bool


        The UseImageDirection flag determines whether the gradients are
        computed with respect to the image grid or with respect to the
        physical space. When this flag is ON the gradients are computed with
        respect to the coordinate system of physical space. The difference is
        whether we take into account the image Direction or not. The flag ON
        will take into account the image direction and will result in an extra
        matrix multiplication compared to the amount of computation performed
        when the flag is OFF. The default value of this flag is On.


        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_GetUseImageDirection(
            self
        )

    def GetName(self):
        r"""
        GetName(GradientRecursiveGaussianImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(GradientRecursiveGaussianImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(GradientRecursiveGaussianImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_Execute(
            self, image1
        )


# Register GradientRecursiveGaussianImageFilter in _SimpleITK:
_SimpleITK.GradientRecursiveGaussianImageFilter_swigregister(
    GradientRecursiveGaussianImageFilter
)


def GradientRecursiveGaussian(
    image1, sigma=1.0, normalizeAcrossScale=False, useImageDirection=False
):
    r"""GradientRecursiveGaussian(Image image1, double sigma=1.0, bool normalizeAcrossScale=False, bool useImageDirection=False) -> Image"""
    return _SimpleITK.GradientRecursiveGaussian(
        image1, sigma, normalizeAcrossScale, useImageDirection
    )


class GrayscaleConnectedClosingImageFilter(ImageFilter):
    r"""


    Enhance pixels associated with a dark object (identified by a seed
    pixel) where the dark object is surrounded by a brighter object.


    GrayscaleConnectedClosingImageFilter is useful for enhancing dark objects that are surrounded by bright
    borders. This filter makes it easier to threshold the image and
    extract just the object of interest.

    Geodesic morphology and the connected closing algorithm are described
    in Chapter 6 of Pierre Soille's book "Morphological Image Analysis:
    Principles and Applications", Second Edition, Springer, 2003.


    See:
     GrayscaleGeodesicDilateImageFilter

     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::GrayscaleConnectedClosing for the procedural interface

     itk::GrayscaleConnectedClosingImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGrayscaleConnectedClosingImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_GrayscaleConnectedClosingImageFilter

    def __init__(self):
        r"""
        __init__(GrayscaleConnectedClosingImageFilter self) -> GrayscaleConnectedClosingImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GrayscaleConnectedClosingImageFilter_swiginit(
            self, _SimpleITK.new_GrayscaleConnectedClosingImageFilter()
        )

    def SetSeed(self, Seed):
        r"""
        SetSeed(GrayscaleConnectedClosingImageFilter self, VectorUInt32 Seed)


        Set/Get the seed pixel for the segmentation


        """
        return _SimpleITK.GrayscaleConnectedClosingImageFilter_SetSeed(
            self, Seed
        )

    def GetSeed(self):
        r"""
        GetSeed(GrayscaleConnectedClosingImageFilter self) -> VectorUInt32


        Set/Get the seed pixel for the segmentation


        """
        return _SimpleITK.GrayscaleConnectedClosingImageFilter_GetSeed(self)

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(GrayscaleConnectedClosingImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return (
            _SimpleITK.GrayscaleConnectedClosingImageFilter_SetFullyConnected(
                self, FullyConnected
            )
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(GrayscaleConnectedClosingImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return (
            _SimpleITK.GrayscaleConnectedClosingImageFilter_FullyConnectedOn(
                self
            )
        )

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(GrayscaleConnectedClosingImageFilter self)


        """
        return (
            _SimpleITK.GrayscaleConnectedClosingImageFilter_FullyConnectedOff(
                self
            )
        )

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(GrayscaleConnectedClosingImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return (
            _SimpleITK.GrayscaleConnectedClosingImageFilter_GetFullyConnected(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(GrayscaleConnectedClosingImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.GrayscaleConnectedClosingImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(GrayscaleConnectedClosingImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.GrayscaleConnectedClosingImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(GrayscaleConnectedClosingImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.GrayscaleConnectedClosingImageFilter_Execute(
            self, image1
        )


# Register GrayscaleConnectedClosingImageFilter in _SimpleITK:
_SimpleITK.GrayscaleConnectedClosingImageFilter_swigregister(
    GrayscaleConnectedClosingImageFilter
)


def GrayscaleConnectedClosing(*args, **kwargs):
    r"""GrayscaleConnectedClosing(Image image1, VectorUInt32 seed=std::vector< uint32_t >(3, 0), bool fullyConnected=False) -> Image"""
    return _SimpleITK.GrayscaleConnectedClosing(*args, **kwargs)


class GrayscaleConnectedOpeningImageFilter(ImageFilter):
    r"""


    Enhance pixels associated with a bright object (identified by a seed
    pixel) where the bright object is surrounded by a darker object.


    GrayscaleConnectedOpeningImageFilter is useful for enhancing bright objects that are surrounded by dark
    borders. This filter makes it easier to threshold the image and
    extract just the object of interest.

    Geodesic morphology and the connected opening algorithm is described
    in Chapter 6 of Pierre Soille's book "Morphological Image Analysis:
    Principles and Applications", Second Edition, Springer, 2003.


    See:
     GrayscaleGeodesicDilateImageFilter

     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::GrayscaleConnectedOpening for the procedural interface

     itk::GrayscaleConnectedOpeningImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGrayscaleConnectedOpeningImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_GrayscaleConnectedOpeningImageFilter

    def __init__(self):
        r"""
        __init__(GrayscaleConnectedOpeningImageFilter self) -> GrayscaleConnectedOpeningImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GrayscaleConnectedOpeningImageFilter_swiginit(
            self, _SimpleITK.new_GrayscaleConnectedOpeningImageFilter()
        )

    def SetSeed(self, Seed):
        r"""
        SetSeed(GrayscaleConnectedOpeningImageFilter self, VectorUInt32 Seed)


        Set/Get the seed pixel for the segmentation


        """
        return _SimpleITK.GrayscaleConnectedOpeningImageFilter_SetSeed(
            self, Seed
        )

    def GetSeed(self):
        r"""
        GetSeed(GrayscaleConnectedOpeningImageFilter self) -> VectorUInt32


        Set/Get the seed pixel for the segmentation


        """
        return _SimpleITK.GrayscaleConnectedOpeningImageFilter_GetSeed(self)

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(GrayscaleConnectedOpeningImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return (
            _SimpleITK.GrayscaleConnectedOpeningImageFilter_SetFullyConnected(
                self, FullyConnected
            )
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(GrayscaleConnectedOpeningImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return (
            _SimpleITK.GrayscaleConnectedOpeningImageFilter_FullyConnectedOn(
                self
            )
        )

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(GrayscaleConnectedOpeningImageFilter self)


        """
        return (
            _SimpleITK.GrayscaleConnectedOpeningImageFilter_FullyConnectedOff(
                self
            )
        )

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(GrayscaleConnectedOpeningImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return (
            _SimpleITK.GrayscaleConnectedOpeningImageFilter_GetFullyConnected(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(GrayscaleConnectedOpeningImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.GrayscaleConnectedOpeningImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(GrayscaleConnectedOpeningImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.GrayscaleConnectedOpeningImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(GrayscaleConnectedOpeningImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.GrayscaleConnectedOpeningImageFilter_Execute(
            self, image1
        )


# Register GrayscaleConnectedOpeningImageFilter in _SimpleITK:
_SimpleITK.GrayscaleConnectedOpeningImageFilter_swigregister(
    GrayscaleConnectedOpeningImageFilter
)


def GrayscaleConnectedOpening(*args, **kwargs):
    r"""GrayscaleConnectedOpening(Image image1, VectorUInt32 seed=std::vector< unsigned int >(3, 0), bool fullyConnected=False) -> Image"""
    return _SimpleITK.GrayscaleConnectedOpening(*args, **kwargs)


class GrayscaleDilateImageFilter(ImageFilter):
    r"""


    Grayscale dilation of an image.


    Dilate an image using grayscale morphology. Dilation takes the maximum
    of all the pixels identified by the structuring element.

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel.


    See:
     MorphologyImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::GrayscaleDilate for the procedural interface

     itk::GrayscaleDilateImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGrayscaleDilateImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_GrayscaleDilateImageFilter

    def __init__(self):
        r"""
        __init__(GrayscaleDilateImageFilter self) -> GrayscaleDilateImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GrayscaleDilateImageFilter_swiginit(
            self, _SimpleITK.new_GrayscaleDilateImageFilter()
        )

    def SetKernelRadius(self, *args):
        r"""
        SetKernelRadius(GrayscaleDilateImageFilter self, VectorUInt32 KernelRadius)
        SetKernelRadius(GrayscaleDilateImageFilter self, unsigned int value)


        Set the values of the KernelRadius vector all to value


        """
        return _SimpleITK.GrayscaleDilateImageFilter_SetKernelRadius(
            self, *args
        )

    def GetKernelRadius(self):
        r"""
        GetKernelRadius(GrayscaleDilateImageFilter self) -> VectorUInt32


        Get the radius of the kernel structuring element.


        """
        return _SimpleITK.GrayscaleDilateImageFilter_GetKernelRadius(self)

    def SetKernelType(self, KernelType):
        r"""
        SetKernelType(GrayscaleDilateImageFilter self, itk::simple::KernelEnum KernelType)


        Set the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.GrayscaleDilateImageFilter_SetKernelType(
            self, KernelType
        )

    def GetKernelType(self):
        r"""
        GetKernelType(GrayscaleDilateImageFilter self) -> itk::simple::KernelEnum


        Get the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.GrayscaleDilateImageFilter_GetKernelType(self)

    def GetName(self):
        r"""
        GetName(GrayscaleDilateImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.GrayscaleDilateImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(GrayscaleDilateImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.GrayscaleDilateImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(GrayscaleDilateImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.GrayscaleDilateImageFilter_Execute(self, image1)


# Register GrayscaleDilateImageFilter in _SimpleITK:
_SimpleITK.GrayscaleDilateImageFilter_swigregister(GrayscaleDilateImageFilter)


def GrayscaleDilate(*args, **kwargs):
    r"""GrayscaleDilate(Image image1, VectorUInt32 kernelRadius=std::vector< uint32_t >(3, 1), itk::simple::KernelEnum kernelType=sitkBall) -> Image"""
    return _SimpleITK.GrayscaleDilate(*args, **kwargs)


class GrayscaleErodeImageFilter(ImageFilter):
    r"""


    Grayscale erosion of an image.


    Erode an image using grayscale morphology. Erosion takes the maximum
    of all the pixels identified by the structuring element.

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel.


    See:
     MorphologyImageFilter , GrayscaleFunctionErodeImageFilter , BinaryErodeImageFilter

     itk::simple::GrayscaleErode for the procedural interface

     itk::GrayscaleErodeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGrayscaleErodeImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_GrayscaleErodeImageFilter

    def __init__(self):
        r"""
        __init__(GrayscaleErodeImageFilter self) -> GrayscaleErodeImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GrayscaleErodeImageFilter_swiginit(
            self, _SimpleITK.new_GrayscaleErodeImageFilter()
        )

    def SetKernelRadius(self, *args):
        r"""
        SetKernelRadius(GrayscaleErodeImageFilter self, VectorUInt32 KernelRadius)
        SetKernelRadius(GrayscaleErodeImageFilter self, unsigned int value)


        Set the values of the KernelRadius vector all to value


        """
        return _SimpleITK.GrayscaleErodeImageFilter_SetKernelRadius(
            self, *args
        )

    def GetKernelRadius(self):
        r"""
        GetKernelRadius(GrayscaleErodeImageFilter self) -> VectorUInt32


        Get the radius of the kernel structuring element.


        """
        return _SimpleITK.GrayscaleErodeImageFilter_GetKernelRadius(self)

    def SetKernelType(self, KernelType):
        r"""
        SetKernelType(GrayscaleErodeImageFilter self, itk::simple::KernelEnum KernelType)


        Set the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.GrayscaleErodeImageFilter_SetKernelType(
            self, KernelType
        )

    def GetKernelType(self):
        r"""
        GetKernelType(GrayscaleErodeImageFilter self) -> itk::simple::KernelEnum


        Get the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.GrayscaleErodeImageFilter_GetKernelType(self)

    def GetName(self):
        r"""
        GetName(GrayscaleErodeImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.GrayscaleErodeImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(GrayscaleErodeImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.GrayscaleErodeImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(GrayscaleErodeImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.GrayscaleErodeImageFilter_Execute(self, image1)


# Register GrayscaleErodeImageFilter in _SimpleITK:
_SimpleITK.GrayscaleErodeImageFilter_swigregister(GrayscaleErodeImageFilter)


def GrayscaleErode(*args, **kwargs):
    r"""GrayscaleErode(Image image1, VectorUInt32 kernelRadius=std::vector< uint32_t >(3, 1), itk::simple::KernelEnum kernelType=sitkBall) -> Image"""
    return _SimpleITK.GrayscaleErode(*args, **kwargs)


class GrayscaleFillholeImageFilter(ImageFilter):
    r"""


    Remove local minima not connected to the boundary of the image.


    GrayscaleFillholeImageFilter fills holes in a grayscale image. Holes are local minima in the
    grayscale topography that are not connected to boundaries of the
    image. Gray level values adjacent to a hole are extrapolated across
    the hole.

    This filter is used to smooth over local minima without affecting the
    values of local maxima. If you take the difference between the output
    of this filter and the original image (and perhaps threshold the
    difference above a small value), you'll obtain a map of the local
    minima.

    This filter uses the ReconstructionByErosionImageFilter . It provides its own input as the "mask" input to the geodesic
    erosion. The "marker" image for the geodesic erosion is constructed
    such that boundary pixels match the boundary pixels of the input image
    and the interior pixels are set to the maximum pixel value in the
    input image.

    Geodesic morphology and the Fillhole algorithm is described in Chapter
    6 of Pierre Soille's book "Morphological Image Analysis: Principles
    and Applications", Second Edition, Springer, 2003.


    See:
     ReconstructionByErosionImageFilter

     MorphologyImageFilter , GrayscaleErodeImageFilter , GrayscaleFunctionErodeImageFilter , BinaryErodeImageFilter

     itk::simple::GrayscaleFillhole for the procedural interface

     itk::GrayscaleFillholeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGrayscaleFillholeImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_GrayscaleFillholeImageFilter

    def __init__(self):
        r"""
        __init__(GrayscaleFillholeImageFilter self) -> GrayscaleFillholeImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GrayscaleFillholeImageFilter_swiginit(
            self, _SimpleITK.new_GrayscaleFillholeImageFilter()
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(GrayscaleFillholeImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.GrayscaleFillholeImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(GrayscaleFillholeImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.GrayscaleFillholeImageFilter_FullyConnectedOn(self)

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(GrayscaleFillholeImageFilter self)


        """
        return _SimpleITK.GrayscaleFillholeImageFilter_FullyConnectedOff(self)

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(GrayscaleFillholeImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.GrayscaleFillholeImageFilter_GetFullyConnected(self)

    def GetName(self):
        r"""
        GetName(GrayscaleFillholeImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.GrayscaleFillholeImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(GrayscaleFillholeImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.GrayscaleFillholeImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(GrayscaleFillholeImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.GrayscaleFillholeImageFilter_Execute(self, image1)


# Register GrayscaleFillholeImageFilter in _SimpleITK:
_SimpleITK.GrayscaleFillholeImageFilter_swigregister(
    GrayscaleFillholeImageFilter
)


def GrayscaleFillhole(image1, fullyConnected=False):
    r"""GrayscaleFillhole(Image image1, bool fullyConnected=False) -> Image"""
    return _SimpleITK.GrayscaleFillhole(image1, fullyConnected)


class GrayscaleGeodesicDilateImageFilter(ImageFilter):
    r"""


    Geodesic grayscale dilation of an image.


    Geodesic dilation operates on a "marker" image and a "mask" image.
    The marker image is dilated using an elementary structuring element
    (neighborhood of radius one using only the face connected neighbors).
    The resulting image is then compared with the mask image. The output
    image is the pixelwise minimum of the dilated marker image and the
    mask image.

    Geodesic dilation is run either one iteration or until convergence. In
    the convergence case, the filter is equivalent to "reconstruction by
    dilation". This filter is implemented to handle both scenarios. The
    one iteration case is multi-threaded. The convergence case is
    delegated to another instance of the same filter (but configured to
    run a single iteration).

    The marker image must be less than or equal to the mask image (on a
    pixel by pixel basis).

    Geodesic morphology is described in Chapter 6 of Pierre Soille's book
    "Morphological Image Analysis: Principles and Applications", Second
    Edition, Springer, 2003.

    A noniterative version of this algorithm can be found in the ReconstructionByDilationImageFilter . This noniterative solution is much faster than the implementation
    provided here. All ITK filters that previously used GrayscaleGeodesicDilateImageFilter as part of their implementation have been converted to use the ReconstructionByDilationImageFilter . The GrayscaleGeodesicDilateImageFilter is maintained for backward compatibility.


    See:
     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter , ReconstructionByDilationImageFilter

     itk::simple::GrayscaleGeodesicDilate for the procedural interface

     itk::GrayscaleGeodesicDilateImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGrayscaleGeodesicDilateImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_GrayscaleGeodesicDilateImageFilter

    def __init__(self):
        r"""
        __init__(GrayscaleGeodesicDilateImageFilter self) -> GrayscaleGeodesicDilateImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GrayscaleGeodesicDilateImageFilter_swiginit(
            self, _SimpleITK.new_GrayscaleGeodesicDilateImageFilter()
        )

    def SetRunOneIteration(self, RunOneIteration):
        r"""
        SetRunOneIteration(GrayscaleGeodesicDilateImageFilter self, bool RunOneIteration)


        Set/Get whether the filter should run one iteration or until
        convergence. When run to convergence, this filter is equivalent to
        "reconstruction by dilation". Default is off.


        """
        return (
            _SimpleITK.GrayscaleGeodesicDilateImageFilter_SetRunOneIteration(
                self, RunOneIteration
            )
        )

    def RunOneIterationOn(self):
        r"""
        RunOneIterationOn(GrayscaleGeodesicDilateImageFilter self)


        Set the value of RunOneIteration to true or false respectfully.


        """
        return _SimpleITK.GrayscaleGeodesicDilateImageFilter_RunOneIterationOn(
            self
        )

    def RunOneIterationOff(self):
        r"""
        RunOneIterationOff(GrayscaleGeodesicDilateImageFilter self)


        """
        return (
            _SimpleITK.GrayscaleGeodesicDilateImageFilter_RunOneIterationOff(
                self
            )
        )

    def GetRunOneIteration(self):
        r"""
        GetRunOneIteration(GrayscaleGeodesicDilateImageFilter self) -> bool


        Set/Get whether the filter should run one iteration or until
        convergence. When run to convergence, this filter is equivalent to
        "reconstruction by dilation". Default is off.


        """
        return (
            _SimpleITK.GrayscaleGeodesicDilateImageFilter_GetRunOneIteration(
                self
            )
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(GrayscaleGeodesicDilateImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.GrayscaleGeodesicDilateImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(GrayscaleGeodesicDilateImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.GrayscaleGeodesicDilateImageFilter_FullyConnectedOn(
            self
        )

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(GrayscaleGeodesicDilateImageFilter self)


        """
        return _SimpleITK.GrayscaleGeodesicDilateImageFilter_FullyConnectedOff(
            self
        )

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(GrayscaleGeodesicDilateImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.GrayscaleGeodesicDilateImageFilter_GetFullyConnected(
            self
        )

    def GetName(self):
        r"""
        GetName(GrayscaleGeodesicDilateImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.GrayscaleGeodesicDilateImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(GrayscaleGeodesicDilateImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.GrayscaleGeodesicDilateImageFilter___str__(self)

    def Execute(self, image1, image2):
        r"""
        Execute(GrayscaleGeodesicDilateImageFilter self, Image image1, Image image2) -> Image


        Execute the filter on the input images


        """
        return _SimpleITK.GrayscaleGeodesicDilateImageFilter_Execute(
            self, image1, image2
        )


# Register GrayscaleGeodesicDilateImageFilter in _SimpleITK:
_SimpleITK.GrayscaleGeodesicDilateImageFilter_swigregister(
    GrayscaleGeodesicDilateImageFilter
)


def GrayscaleGeodesicDilate(
    image1, image2, runOneIteration=False, fullyConnected=False
):
    r"""GrayscaleGeodesicDilate(Image image1, Image image2, bool runOneIteration=False, bool fullyConnected=False) -> Image"""
    return _SimpleITK.GrayscaleGeodesicDilate(
        image1, image2, runOneIteration, fullyConnected
    )


class GrayscaleGeodesicErodeImageFilter(ImageFilter):
    r"""


    geodesic gray scale erosion of an image


    Geodesic erosion operates on a "marker" image and a "mask" image.
    The marker image is eroded using an elementary structuring element
    (neighborhood of radius one using only the face connected neighbors).
    The resulting image is then compared with the mask image. The output
    image is the pixelwise maximum of the eroded marker image and the mask
    image.

    Geodesic erosion is run either one iteration or until convergence. In
    the convergence case, the filter is equivalent to "reconstruction by
    erosion". This filter is implemented to handle both scenarios. The
    one iteration case is multi-threaded. The convergence case is
    delegated to another instance of the same filter (but configured to
    run a single iteration).

    The marker image must be greater than or equal to the mask image (on a
    pixel by pixel basis).

    Geodesic morphology is described in Chapter 6 of Pierre Soille's book
    "Morphological Image Analysis: Principles and Applications", Second
    Edition, Springer, 2003.

    A noniterative version of this algorithm can be found in the ReconstructionByErosionImageFilter . This noniterative solution is much faster than the implementation
    provided here. All ITK filters that previously used GrayscaleGeodesicErodeImageFilter as part of their implementation have been converted to use the ReconstructionByErosionImageFilter . The GrayscaleGeodesicErodeImageFilter is maintained for backward compatibility.


    See:
     MorphologyImageFilter , GrayscaleErodeImageFilter , GrayscaleFunctionErodeImageFilter , BinaryErodeImageFilter , ReconstructionByErosionImageFilter

     itk::simple::GrayscaleGeodesicErode for the procedural interface

     itk::GrayscaleGeodesicErodeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGrayscaleGeodesicErodeImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_GrayscaleGeodesicErodeImageFilter

    def __init__(self):
        r"""
        __init__(GrayscaleGeodesicErodeImageFilter self) -> GrayscaleGeodesicErodeImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GrayscaleGeodesicErodeImageFilter_swiginit(
            self, _SimpleITK.new_GrayscaleGeodesicErodeImageFilter()
        )

    def SetRunOneIteration(self, RunOneIteration):
        r"""
        SetRunOneIteration(GrayscaleGeodesicErodeImageFilter self, bool RunOneIteration)


        Set/Get whether the filter should run one iteration or until
        convergence. When run to convergence, this filter is equivalent to
        "reconstruction by erosion". Default is off.


        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter_SetRunOneIteration(
            self, RunOneIteration
        )

    def RunOneIterationOn(self):
        r"""
        RunOneIterationOn(GrayscaleGeodesicErodeImageFilter self)


        Set the value of RunOneIteration to true or false respectfully.


        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter_RunOneIterationOn(
            self
        )

    def RunOneIterationOff(self):
        r"""
        RunOneIterationOff(GrayscaleGeodesicErodeImageFilter self)


        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter_RunOneIterationOff(
            self
        )

    def GetRunOneIteration(self):
        r"""
        GetRunOneIteration(GrayscaleGeodesicErodeImageFilter self) -> bool


        Set/Get whether the filter should run one iteration or until
        convergence. When run to convergence, this filter is equivalent to
        "reconstruction by erosion". Default is off.


        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter_GetRunOneIteration(
            self
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(GrayscaleGeodesicErodeImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(GrayscaleGeodesicErodeImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter_FullyConnectedOn(
            self
        )

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(GrayscaleGeodesicErodeImageFilter self)


        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter_FullyConnectedOff(
            self
        )

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(GrayscaleGeodesicErodeImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter_GetFullyConnected(
            self
        )

    def GetName(self):
        r"""
        GetName(GrayscaleGeodesicErodeImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(GrayscaleGeodesicErodeImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter___str__(self)

    def Execute(self, image1, image2):
        r"""
        Execute(GrayscaleGeodesicErodeImageFilter self, Image image1, Image image2) -> Image


        Execute the filter on the input images


        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter_Execute(
            self, image1, image2
        )


# Register GrayscaleGeodesicErodeImageFilter in _SimpleITK:
_SimpleITK.GrayscaleGeodesicErodeImageFilter_swigregister(
    GrayscaleGeodesicErodeImageFilter
)


def GrayscaleGeodesicErode(
    image1, image2, runOneIteration=False, fullyConnected=False
):
    r"""GrayscaleGeodesicErode(Image image1, Image image2, bool runOneIteration=False, bool fullyConnected=False) -> Image"""
    return _SimpleITK.GrayscaleGeodesicErode(
        image1, image2, runOneIteration, fullyConnected
    )


class GrayscaleGrindPeakImageFilter(ImageFilter):
    r"""


    Remove local maxima not connected to the boundary of the image.


    GrayscaleGrindPeakImageFilter removes peaks in a grayscale image. Peaks are local maxima in the
    grayscale topography that are not connected to boundaries of the
    image. Gray level values adjacent to a peak are extrapolated through
    the peak.

    This filter is used to smooth over local maxima without affecting the
    values of local minima. If you take the difference between the output
    of this filter and the original image (and perhaps threshold the
    difference above a small value), you'll obtain a map of the local
    maxima.

    This filter uses the GrayscaleGeodesicDilateImageFilter . It provides its own input as the "mask" input to the geodesic
    erosion. The "marker" image for the geodesic erosion is constructed
    such that boundary pixels match the boundary pixels of the input image
    and the interior pixels are set to the minimum pixel value in the
    input image.

    This filter is the dual to the GrayscaleFillholeImageFilter which implements the Fillhole algorithm. Since it is a dual, it is
    somewhat superfluous but is provided as a convenience.

    Geodesic morphology and the Fillhole algorithm is described in Chapter
    6 of Pierre Soille's book "Morphological Image Analysis: Principles
    and Applications", Second Edition, Springer, 2003.


    See:
     GrayscaleGeodesicDilateImageFilter

     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::GrayscaleGrindPeak for the procedural interface

     itk::GrayscaleGrindPeakImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGrayscaleGrindPeakImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_GrayscaleGrindPeakImageFilter

    def __init__(self):
        r"""
        __init__(GrayscaleGrindPeakImageFilter self) -> GrayscaleGrindPeakImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GrayscaleGrindPeakImageFilter_swiginit(
            self, _SimpleITK.new_GrayscaleGrindPeakImageFilter()
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(GrayscaleGrindPeakImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.GrayscaleGrindPeakImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(GrayscaleGrindPeakImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.GrayscaleGrindPeakImageFilter_FullyConnectedOn(self)

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(GrayscaleGrindPeakImageFilter self)


        """
        return _SimpleITK.GrayscaleGrindPeakImageFilter_FullyConnectedOff(self)

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(GrayscaleGrindPeakImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.GrayscaleGrindPeakImageFilter_GetFullyConnected(self)

    def GetName(self):
        r"""
        GetName(GrayscaleGrindPeakImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.GrayscaleGrindPeakImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(GrayscaleGrindPeakImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.GrayscaleGrindPeakImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(GrayscaleGrindPeakImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.GrayscaleGrindPeakImageFilter_Execute(self, image1)


# Register GrayscaleGrindPeakImageFilter in _SimpleITK:
_SimpleITK.GrayscaleGrindPeakImageFilter_swigregister(
    GrayscaleGrindPeakImageFilter
)


def GrayscaleGrindPeak(image1, fullyConnected=False):
    r"""GrayscaleGrindPeak(Image image1, bool fullyConnected=False) -> Image"""
    return _SimpleITK.GrayscaleGrindPeak(image1, fullyConnected)


class GrayscaleMorphologicalClosingImageFilter(ImageFilter):
    r"""


    Grayscale closing of an image.


    Close an image using grayscale morphology.

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel.


    See:
     MorphologyImageFilter , GrayscaleFunctionErodeImageFilter , BinaryErodeImageFilter

     itk::simple::GrayscaleMorphologicalClosing for the procedural interface

     itk::GrayscaleMorphologicalClosingImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGrayscaleMorphologicalClosingImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_GrayscaleMorphologicalClosingImageFilter
    )

    def __init__(self):
        r"""
        __init__(GrayscaleMorphologicalClosingImageFilter self) -> GrayscaleMorphologicalClosingImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GrayscaleMorphologicalClosingImageFilter_swiginit(
            self, _SimpleITK.new_GrayscaleMorphologicalClosingImageFilter()
        )

    def SetKernelRadius(self, *args):
        r"""
        SetKernelRadius(GrayscaleMorphologicalClosingImageFilter self, VectorUInt32 KernelRadius)
        SetKernelRadius(GrayscaleMorphologicalClosingImageFilter self, unsigned int value)


        Set the values of the KernelRadius vector all to value


        """
        return _SimpleITK.GrayscaleMorphologicalClosingImageFilter_SetKernelRadius(
            self, *args
        )

    def GetKernelRadius(self):
        r"""
        GetKernelRadius(GrayscaleMorphologicalClosingImageFilter self) -> VectorUInt32


        Get the radius of the kernel structuring element.


        """
        return _SimpleITK.GrayscaleMorphologicalClosingImageFilter_GetKernelRadius(
            self
        )

    def SetKernelType(self, KernelType):
        r"""
        SetKernelType(GrayscaleMorphologicalClosingImageFilter self, itk::simple::KernelEnum KernelType)


        Set the kernel or structuring element used for the morphology.


        """
        return (
            _SimpleITK.GrayscaleMorphologicalClosingImageFilter_SetKernelType(
                self, KernelType
            )
        )

    def GetKernelType(self):
        r"""
        GetKernelType(GrayscaleMorphologicalClosingImageFilter self) -> itk::simple::KernelEnum


        Get the kernel or structuring element used for the morphology.


        """
        return (
            _SimpleITK.GrayscaleMorphologicalClosingImageFilter_GetKernelType(
                self
            )
        )

    def SetSafeBorder(self, SafeBorder):
        r"""
        SetSafeBorder(GrayscaleMorphologicalClosingImageFilter self, bool SafeBorder)


        A safe border is added to input image to avoid borders effects and
        remove it once the closing is done


        """
        return (
            _SimpleITK.GrayscaleMorphologicalClosingImageFilter_SetSafeBorder(
                self, SafeBorder
            )
        )

    def SafeBorderOn(self):
        r"""
        SafeBorderOn(GrayscaleMorphologicalClosingImageFilter self)


        Set the value of SafeBorder to true or false respectfully.


        """
        return (
            _SimpleITK.GrayscaleMorphologicalClosingImageFilter_SafeBorderOn(
                self
            )
        )

    def SafeBorderOff(self):
        r"""
        SafeBorderOff(GrayscaleMorphologicalClosingImageFilter self)


        """
        return (
            _SimpleITK.GrayscaleMorphologicalClosingImageFilter_SafeBorderOff(
                self
            )
        )

    def GetSafeBorder(self):
        r"""
        GetSafeBorder(GrayscaleMorphologicalClosingImageFilter self) -> bool


        A safe border is added to input image to avoid borders effects and
        remove it once the closing is done


        """
        return (
            _SimpleITK.GrayscaleMorphologicalClosingImageFilter_GetSafeBorder(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(GrayscaleMorphologicalClosingImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.GrayscaleMorphologicalClosingImageFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(GrayscaleMorphologicalClosingImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.GrayscaleMorphologicalClosingImageFilter___str__(
            self
        )

    def Execute(self, image1):
        r"""
        Execute(GrayscaleMorphologicalClosingImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.GrayscaleMorphologicalClosingImageFilter_Execute(
            self, image1
        )


# Register GrayscaleMorphologicalClosingImageFilter in _SimpleITK:
_SimpleITK.GrayscaleMorphologicalClosingImageFilter_swigregister(
    GrayscaleMorphologicalClosingImageFilter
)


def GrayscaleMorphologicalClosing(*args, **kwargs):
    r"""GrayscaleMorphologicalClosing(Image image1, VectorUInt32 kernelRadius=std::vector< uint32_t >(3, 1), itk::simple::KernelEnum kernelType=sitkBall, bool safeBorder=True) -> Image"""
    return _SimpleITK.GrayscaleMorphologicalClosing(*args, **kwargs)


class GrayscaleMorphologicalOpeningImageFilter(ImageFilter):
    r"""


    Grayscale opening of an image.


    Open an image using grayscale morphology.

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel.


    See:
     MorphologyImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::GrayscaleMorphologicalOpening for the procedural interface

     itk::GrayscaleMorphologicalOpeningImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGrayscaleMorphologicalOpeningImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_GrayscaleMorphologicalOpeningImageFilter
    )

    def __init__(self):
        r"""
        __init__(GrayscaleMorphologicalOpeningImageFilter self) -> GrayscaleMorphologicalOpeningImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_swiginit(
            self, _SimpleITK.new_GrayscaleMorphologicalOpeningImageFilter()
        )

    def SetKernelRadius(self, *args):
        r"""
        SetKernelRadius(GrayscaleMorphologicalOpeningImageFilter self, VectorUInt32 KernelRadius)
        SetKernelRadius(GrayscaleMorphologicalOpeningImageFilter self, unsigned int value)


        Set the values of the KernelRadius vector all to value


        """
        return _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_SetKernelRadius(
            self, *args
        )

    def GetKernelRadius(self):
        r"""
        GetKernelRadius(GrayscaleMorphologicalOpeningImageFilter self) -> VectorUInt32


        Get the radius of the kernel structuring element.


        """
        return _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_GetKernelRadius(
            self
        )

    def SetKernelType(self, KernelType):
        r"""
        SetKernelType(GrayscaleMorphologicalOpeningImageFilter self, itk::simple::KernelEnum KernelType)


        Set the kernel or structuring element used for the morphology.


        """
        return (
            _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_SetKernelType(
                self, KernelType
            )
        )

    def GetKernelType(self):
        r"""
        GetKernelType(GrayscaleMorphologicalOpeningImageFilter self) -> itk::simple::KernelEnum


        Get the kernel or structuring element used for the morphology.


        """
        return (
            _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_GetKernelType(
                self
            )
        )

    def SetSafeBorder(self, SafeBorder):
        r"""
        SetSafeBorder(GrayscaleMorphologicalOpeningImageFilter self, bool SafeBorder)


        A safe border is added to input image to avoid borders effects and
        remove it once the closing is done


        """
        return (
            _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_SetSafeBorder(
                self, SafeBorder
            )
        )

    def SafeBorderOn(self):
        r"""
        SafeBorderOn(GrayscaleMorphologicalOpeningImageFilter self)


        Set the value of SafeBorder to true or false respectfully.


        """
        return (
            _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_SafeBorderOn(
                self
            )
        )

    def SafeBorderOff(self):
        r"""
        SafeBorderOff(GrayscaleMorphologicalOpeningImageFilter self)


        """
        return (
            _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_SafeBorderOff(
                self
            )
        )

    def GetSafeBorder(self):
        r"""
        GetSafeBorder(GrayscaleMorphologicalOpeningImageFilter self) -> bool


        A safe border is added to input image to avoid borders effects and
        remove it once the closing is done


        """
        return (
            _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_GetSafeBorder(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(GrayscaleMorphologicalOpeningImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(GrayscaleMorphologicalOpeningImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.GrayscaleMorphologicalOpeningImageFilter___str__(
            self
        )

    def Execute(self, image1):
        r"""
        Execute(GrayscaleMorphologicalOpeningImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_Execute(
            self, image1
        )


# Register GrayscaleMorphologicalOpeningImageFilter in _SimpleITK:
_SimpleITK.GrayscaleMorphologicalOpeningImageFilter_swigregister(
    GrayscaleMorphologicalOpeningImageFilter
)


def GrayscaleMorphologicalOpening(*args, **kwargs):
    r"""GrayscaleMorphologicalOpening(Image image1, VectorUInt32 kernelRadius=std::vector< uint32_t >(3, 1), itk::simple::KernelEnum kernelType=sitkBall, bool safeBorder=True) -> Image"""
    return _SimpleITK.GrayscaleMorphologicalOpening(*args, **kwargs)


class GreaterEqualImageFilter(ImageFilter):
    r"""


    Implements pixel-wise generic operation of two images, or of an image
    and a constant.


    This class is parameterized over the types of the two input images and
    the type of the output image. It is also parameterized by the
    operation to be applied. A Functor style is used.

    The constant must be of the same type than the pixel type of the
    corresponding image. It is wrapped in a SimpleDataObjectDecorator so it can be updated through the pipeline. The SetConstant() and
    GetConstant() methods are provided as shortcuts to set or get the
    constant value without manipulating the decorator.


    See:
     BinaryGeneratorImagFilter

     UnaryFunctorImageFilter TernaryFunctorImageFilter

     itk::simple::GreaterEqual for the procedural interface

     itk::BinaryFunctorImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGreaterEqualImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_GreaterEqualImageFilter

    def __init__(self):
        r"""
        __init__(GreaterEqualImageFilter self) -> GreaterEqualImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GreaterEqualImageFilter_swiginit(
            self, _SimpleITK.new_GreaterEqualImageFilter()
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(GreaterEqualImageFilter self, uint8_t BackgroundValue)


        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.GreaterEqualImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(GreaterEqualImageFilter self) -> uint8_t


        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.GreaterEqualImageFilter_GetBackgroundValue(self)

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(GreaterEqualImageFilter self, uint8_t ForegroundValue)


        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.GreaterEqualImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(GreaterEqualImageFilter self) -> uint8_t


        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.GreaterEqualImageFilter_GetForegroundValue(self)

    def GetName(self):
        r"""
        GetName(GreaterEqualImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.GreaterEqualImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(GreaterEqualImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.GreaterEqualImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(GreaterEqualImageFilter self, Image image1, Image image2) -> Image
        Execute(GreaterEqualImageFilter self, Image image1, double constant) -> Image
        Execute(GreaterEqualImageFilter self, double constant, Image image2) -> Image
        Execute(GreaterEqualImageFilter self, Image image1, double constant, uint8_t backgroundValue, uint8_t foregroundValue) -> Image
        Execute(GreaterEqualImageFilter self, double constant, Image image2, uint8_t backgroundValue, uint8_t foregroundValue) -> Image


        """
        return _SimpleITK.GreaterEqualImageFilter_Execute(self, *args)


# Register GreaterEqualImageFilter in _SimpleITK:
_SimpleITK.GreaterEqualImageFilter_swigregister(GreaterEqualImageFilter)


def GreaterEqual(*args):
    r"""
    GreaterEqual(Image image1, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    GreaterEqual(Image image1, double constant, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    GreaterEqual(double constant, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image


    """
    return _SimpleITK.GreaterEqual(*args)


class GreaterImageFilter(ImageFilter):
    r"""


    Implements pixel-wise generic operation of two images, or of an image
    and a constant.


    This class is parameterized over the types of the two input images and
    the type of the output image. It is also parameterized by the
    operation to be applied. A Functor style is used.

    The constant must be of the same type than the pixel type of the
    corresponding image. It is wrapped in a SimpleDataObjectDecorator so it can be updated through the pipeline. The SetConstant() and
    GetConstant() methods are provided as shortcuts to set or get the
    constant value without manipulating the decorator.


    See:
     BinaryGeneratorImagFilter

     UnaryFunctorImageFilter TernaryFunctorImageFilter

     itk::simple::Greater for the procedural interface

     itk::BinaryFunctorImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGreaterImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_GreaterImageFilter

    def __init__(self):
        r"""
        __init__(GreaterImageFilter self) -> GreaterImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GreaterImageFilter_swiginit(
            self, _SimpleITK.new_GreaterImageFilter()
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(GreaterImageFilter self, uint8_t BackgroundValue)


        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.GreaterImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(GreaterImageFilter self) -> uint8_t


        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.GreaterImageFilter_GetBackgroundValue(self)

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(GreaterImageFilter self, uint8_t ForegroundValue)


        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.GreaterImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(GreaterImageFilter self) -> uint8_t


        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.GreaterImageFilter_GetForegroundValue(self)

    def GetName(self):
        r"""
        GetName(GreaterImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.GreaterImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(GreaterImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.GreaterImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(GreaterImageFilter self, Image image1, Image image2) -> Image
        Execute(GreaterImageFilter self, Image image1, double constant) -> Image
        Execute(GreaterImageFilter self, double constant, Image image2) -> Image
        Execute(GreaterImageFilter self, Image image1, double constant, uint8_t backgroundValue, uint8_t foregroundValue) -> Image
        Execute(GreaterImageFilter self, double constant, Image image2, uint8_t backgroundValue, uint8_t foregroundValue) -> Image


        """
        return _SimpleITK.GreaterImageFilter_Execute(self, *args)


# Register GreaterImageFilter in _SimpleITK:
_SimpleITK.GreaterImageFilter_swigregister(GreaterImageFilter)


def Greater(*args):
    r"""
    Greater(Image image1, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    Greater(Image image1, double constant, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    Greater(double constant, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image


    """
    return _SimpleITK.Greater(*args)


class GridImageSource(ImageFilter):
    r"""


    Generate an n-dimensional image of a grid.


    GridImageSource generates an image of a grid. From the abstract... "Certain classes
    of images find disparate use amongst members of the ITK community for
    such purposes as visualization, simulation, testing, etc. Currently
    there exists two derived classes from the ImageSource class used for generating specific images for various applications,
    viz. RandomImageSource and GaussianImageSource. We propose to add to this set with the class GridImageSource which, obviously enough, produces a grid image. Such images are
    useful for visualizing deformation when used in conjunction with the WarpImageFilter, simulating magnetic resonance tagging images, or creating optical
    illusions with which to amaze your friends."

    The output image may be of any dimension.


    Tustison N., Avants B., Gee J. University of Pennsylvania
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/ze1ssz
    See:
     itk::simple::GridSource for the procedural interface

     itk::GridImageSource for the Doxygen on the original ITK class.


    C++ includes: sitkGridImageSource.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_GridImageSource

    def __init__(self):
        r"""
        __init__(GridImageSource self) -> GridImageSource


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.GridImageSource_swiginit(
            self, _SimpleITK.new_GridImageSource()
        )

    def SetOutputPixelType(self, OutputPixelType):
        r"""
        SetOutputPixelType(GridImageSource self, itk::simple::PixelIDValueEnum OutputPixelType)


        """
        return _SimpleITK.GridImageSource_SetOutputPixelType(
            self, OutputPixelType
        )

    def GetOutputPixelType(self):
        r"""
        GetOutputPixelType(GridImageSource self) -> itk::simple::PixelIDValueEnum


        """
        return _SimpleITK.GridImageSource_GetOutputPixelType(self)

    def SetSize(self, Size):
        r"""
        SetSize(GridImageSource self, VectorUInt32 Size)


        """
        return _SimpleITK.GridImageSource_SetSize(self, Size)

    def GetSize(self):
        r"""
        GetSize(GridImageSource self) -> VectorUInt32


        """
        return _SimpleITK.GridImageSource_GetSize(self)

    def SetSigma(self, *args):
        r"""
        SetSigma(GridImageSource self, VectorDouble Sigma)
        SetSigma(GridImageSource self, double value)


        Set/Get the standard deviation of the Gaussians or width of the box
        functions.


        """
        return _SimpleITK.GridImageSource_SetSigma(self, *args)

    def GetSigma(self):
        r"""
        GetSigma(GridImageSource self) -> VectorDouble


        Set/Get the standard deviation of the Gaussians or width of the box
        functions.


        """
        return _SimpleITK.GridImageSource_GetSigma(self)

    def SetGridSpacing(self, GridSpacing):
        r"""
        SetGridSpacing(GridImageSource self, VectorDouble GridSpacing)


        Set/Get the grid spacing of the peaks.


        """
        return _SimpleITK.GridImageSource_SetGridSpacing(self, GridSpacing)

    def GetGridSpacing(self):
        r"""
        GetGridSpacing(GridImageSource self) -> VectorDouble


        Set/Get the grid spacing of the peaks.


        """
        return _SimpleITK.GridImageSource_GetGridSpacing(self)

    def SetGridOffset(self, GridOffset):
        r"""
        SetGridOffset(GridImageSource self, VectorDouble GridOffset)


        Set/Get the grid offset.


        """
        return _SimpleITK.GridImageSource_SetGridOffset(self, GridOffset)

    def GetGridOffset(self):
        r"""
        GetGridOffset(GridImageSource self) -> VectorDouble


        Set/Get the grid offset.


        """
        return _SimpleITK.GridImageSource_GetGridOffset(self)

    def SetScale(self, Scale):
        r"""
        SetScale(GridImageSource self, double Scale)


        Set/Get the scale factor to multiply the true value of the grid.


        """
        return _SimpleITK.GridImageSource_SetScale(self, Scale)

    def GetScale(self):
        r"""
        GetScale(GridImageSource self) -> double


        Set/Get the scale factor to multiply the true value of the grid.


        """
        return _SimpleITK.GridImageSource_GetScale(self)

    def SetOrigin(self, Origin):
        r"""
        SetOrigin(GridImageSource self, VectorDouble Origin)


        """
        return _SimpleITK.GridImageSource_SetOrigin(self, Origin)

    def GetOrigin(self):
        r"""
        GetOrigin(GridImageSource self) -> VectorDouble


        """
        return _SimpleITK.GridImageSource_GetOrigin(self)

    def SetSpacing(self, Spacing):
        r"""
        SetSpacing(GridImageSource self, VectorDouble Spacing)


        """
        return _SimpleITK.GridImageSource_SetSpacing(self, Spacing)

    def GetSpacing(self):
        r"""
        GetSpacing(GridImageSource self) -> VectorDouble


        """
        return _SimpleITK.GridImageSource_GetSpacing(self)

    def SetDirection(self, Direction):
        r"""
        SetDirection(GridImageSource self, VectorDouble Direction)


        """
        return _SimpleITK.GridImageSource_SetDirection(self, Direction)

    def GetDirection(self):
        r"""
        GetDirection(GridImageSource self) -> VectorDouble


        """
        return _SimpleITK.GridImageSource_GetDirection(self)

    def SetWhichDimensions(self, WhichDimensions):
        r"""
        SetWhichDimensions(GridImageSource self, VectorBool WhichDimensions)


        Set/Get the dimensions which are gridded.


        """
        return _SimpleITK.GridImageSource_SetWhichDimensions(
            self, WhichDimensions
        )

    def GetWhichDimensions(self):
        r"""
        GetWhichDimensions(GridImageSource self) -> VectorBool


        Set/Get the dimensions which are gridded.


        """
        return _SimpleITK.GridImageSource_GetWhichDimensions(self)

    def GetName(self):
        r"""
        GetName(GridImageSource self) -> std::string


        Name of this class


        """
        return _SimpleITK.GridImageSource_GetName(self)

    def __str__(self):
        r"""
        __str__(GridImageSource self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.GridImageSource___str__(self)

    def Execute(self):
        r"""
        Execute(GridImageSource self) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.GridImageSource_Execute(self)


# Register GridImageSource in _SimpleITK:
_SimpleITK.GridImageSource_swigregister(GridImageSource)


def GridSource(*args, **kwargs):
    r"""
    GridSource(itk::simple::PixelIDValueEnum outputPixelType=sitkFloat32, VectorUInt32 size=std::vector< unsigned int >(3, 64), VectorDouble sigma=std::vector< double >(3, 0.5), VectorDouble gridSpacing=std::vector< double >(3, 4.0), VectorDouble gridOffset=std::vector< double >(3, 0.0), double scale=255.0, VectorDouble origin=std::vector< double >(3, 0.0), VectorDouble spacing=std::vector< double >(3, 1.0), VectorDouble direction=std::vector< double >(), VectorBool whichDimensions=std::vector< bool >(3, true)) -> Image


    Generate an n-dimensional image of a grid.


    This function directly calls the execute method of GridImageSource in order to support a procedural API


    See:
     itk::simple::GridImageSource for the object oriented interface



    """
    return _SimpleITK.GridSource(*args, **kwargs)


class HConcaveImageFilter(ImageFilter):
    r"""


    Identify local minima whose depth below the baseline is greater than
    h.


    HConcaveImageFilter extract local minima that are more than h intensity units below the
    (local) background. This has the effect of extracting objects that are
    darker than the background by at least h intensity units.

    This filter uses the HMinimaImageFilter .

    Geodesic morphology and the H-Convex algorithm is described in Chapter
    6 of Pierre Soille's book "Morphological Image Analysis: Principles
    and Applications", Second Edition, Springer, 2003.


    See:
     GrayscaleGeodesicDilateImageFilter , HMaximaImageFilter ,

     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::HConcave for the procedural interface

     itk::HConcaveImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkHConcaveImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_HConcaveImageFilter

    def __init__(self):
        r"""
        __init__(HConcaveImageFilter self) -> HConcaveImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.HConcaveImageFilter_swiginit(
            self, _SimpleITK.new_HConcaveImageFilter()
        )

    def SetHeight(self, Height):
        r"""
        SetHeight(HConcaveImageFilter self, double Height)


        Set/Get the height that a local maximum must be above the local
        background (local contrast) in order to survive the processing. Local
        maxima below this value are replaced with an estimate of the local
        background.


        """
        return _SimpleITK.HConcaveImageFilter_SetHeight(self, Height)

    def GetHeight(self):
        r"""
        GetHeight(HConcaveImageFilter self) -> double


        Set/Get the height that a local maximum must be above the local
        background (local contrast) in order to survive the processing. Local
        maxima below this value are replaced with an estimate of the local
        background.


        """
        return _SimpleITK.HConcaveImageFilter_GetHeight(self)

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(HConcaveImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.HConcaveImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(HConcaveImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.HConcaveImageFilter_FullyConnectedOn(self)

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(HConcaveImageFilter self)


        """
        return _SimpleITK.HConcaveImageFilter_FullyConnectedOff(self)

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(HConcaveImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.HConcaveImageFilter_GetFullyConnected(self)

    def GetName(self):
        r"""
        GetName(HConcaveImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.HConcaveImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(HConcaveImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.HConcaveImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(HConcaveImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.HConcaveImageFilter_Execute(self, image1)


# Register HConcaveImageFilter in _SimpleITK:
_SimpleITK.HConcaveImageFilter_swigregister(HConcaveImageFilter)


def HConcave(image1, height=2.0, fullyConnected=False):
    r"""HConcave(Image image1, double height=2.0, bool fullyConnected=False) -> Image"""
    return _SimpleITK.HConcave(image1, height, fullyConnected)


class HConvexImageFilter(ImageFilter):
    r"""


    Identify local maxima whose height above the baseline is greater than
    h.


    HConvexImageFilter extract local maxima that are more than h intensity units above the
    (local) background. This has the effect of extracting objects that are
    brighter than background by at least h intensity units.

    This filter uses the HMaximaImageFilter .

    Geodesic morphology and the H-Convex algorithm is described in Chapter
    6 of Pierre Soille's book "Morphological Image Analysis: Principles
    and Applications", Second Edition, Springer, 2003.


    See:
     GrayscaleGeodesicDilateImageFilter , HMinimaImageFilter

     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::HConvex for the procedural interface

     itk::HConvexImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkHConvexImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_HConvexImageFilter

    def __init__(self):
        r"""
        __init__(HConvexImageFilter self) -> HConvexImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.HConvexImageFilter_swiginit(
            self, _SimpleITK.new_HConvexImageFilter()
        )

    def SetHeight(self, Height):
        r"""
        SetHeight(HConvexImageFilter self, double Height)


        Set/Get the height that a local maximum must be above the local
        background (local contrast) in order to survive the processing. Local
        maxima below this value are replaced with an estimate of the local
        background.


        """
        return _SimpleITK.HConvexImageFilter_SetHeight(self, Height)

    def GetHeight(self):
        r"""
        GetHeight(HConvexImageFilter self) -> double


        Set/Get the height that a local maximum must be above the local
        background (local contrast) in order to survive the processing. Local
        maxima below this value are replaced with an estimate of the local
        background.


        """
        return _SimpleITK.HConvexImageFilter_GetHeight(self)

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(HConvexImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.HConvexImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(HConvexImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.HConvexImageFilter_FullyConnectedOn(self)

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(HConvexImageFilter self)


        """
        return _SimpleITK.HConvexImageFilter_FullyConnectedOff(self)

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(HConvexImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.HConvexImageFilter_GetFullyConnected(self)

    def GetName(self):
        r"""
        GetName(HConvexImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.HConvexImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(HConvexImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.HConvexImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(HConvexImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.HConvexImageFilter_Execute(self, image1)


# Register HConvexImageFilter in _SimpleITK:
_SimpleITK.HConvexImageFilter_swigregister(HConvexImageFilter)


def HConvex(image1, height=2.0, fullyConnected=False):
    r"""HConvex(Image image1, double height=2.0, bool fullyConnected=False) -> Image"""
    return _SimpleITK.HConvex(image1, height, fullyConnected)


class HMaximaImageFilter(ImageFilter):
    r"""


    Suppress local maxima whose height above the baseline is less than h.


    HMaximaImageFilter suppresses local maxima that are less than h intensity units above
    the (local) background. This has the effect of smoothing over the
    "high" parts of the noise in the image without smoothing over large
    changes in intensity (region boundaries). See the HMinimaImageFilter to suppress the local minima whose depth is less than h intensity
    units below the (local) background.

    If the output of HMaximaImageFilter is subtracted from the original image, the significant "peaks" in
    the image can be identified. This is what the HConvexImageFilter provides.

    This filter uses the ReconstructionByDilationImageFilter . It provides its own input as the "mask" input to the geodesic
    dilation. The "marker" image for the geodesic dilation is the input
    image minus the height parameter h.

    Geodesic morphology and the H-Maxima algorithm is described in Chapter
    6 of Pierre Soille's book "Morphological Image Analysis: Principles
    and Applications", Second Edition, Springer, 2003.

    The height parameter is set using SetHeight.


    See:
     ReconstructionByDilationImageFilter , HMinimaImageFilter , HConvexImageFilter

     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::HMaxima for the procedural interface

     itk::HMaximaImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkHMaximaImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_HMaximaImageFilter

    def __init__(self):
        r"""
        __init__(HMaximaImageFilter self) -> HMaximaImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.HMaximaImageFilter_swiginit(
            self, _SimpleITK.new_HMaximaImageFilter()
        )

    def SetHeight(self, Height):
        r"""
        SetHeight(HMaximaImageFilter self, double Height)


        Set/Get the height that a local maximum must be above the local
        background (local contrast) in order to survive the processing. Local
        maxima below this value are replaced with an estimate of the local
        background.


        """
        return _SimpleITK.HMaximaImageFilter_SetHeight(self, Height)

    def GetHeight(self):
        r"""
        GetHeight(HMaximaImageFilter self) -> double


        Set/Get the height that a local maximum must be above the local
        background (local contrast) in order to survive the processing. Local
        maxima below this value are replaced with an estimate of the local
        background.


        """
        return _SimpleITK.HMaximaImageFilter_GetHeight(self)

    def GetName(self):
        r"""
        GetName(HMaximaImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.HMaximaImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(HMaximaImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.HMaximaImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(HMaximaImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.HMaximaImageFilter_Execute(self, image1)


# Register HMaximaImageFilter in _SimpleITK:
_SimpleITK.HMaximaImageFilter_swigregister(HMaximaImageFilter)


def HMaxima(image1, height=2.0):
    r"""HMaxima(Image image1, double height=2.0) -> Image"""
    return _SimpleITK.HMaxima(image1, height)


class HMinimaImageFilter(ImageFilter):
    r"""


    Suppress local minima whose depth below the baseline is less than h.


    HMinimaImageFilter suppresses local minima that are less than h intensity units below
    the (local) background. This has the effect of smoothing over the
    "low" parts of the noise in the image without smoothing over large
    changes in intensity (region boundaries). See the HMaximaImageFilter to suppress the local maxima whose height is less than h intensity
    units above the (local) background.

    If original image is subtracted from the output of HMinimaImageFilter , the significant "valleys" in the image can be identified. This is
    what the HConcaveImageFilter provides.

    This filter uses the GrayscaleGeodesicErodeImageFilter . It provides its own input as the "mask" input to the geodesic
    dilation. The "marker" image for the geodesic dilation is the input
    image plus the height parameter h.

    Geodesic morphology and the H-Minima algorithm is described in Chapter
    6 of Pierre Soille's book "Morphological Image Analysis: Principles
    and Applications", Second Edition, Springer, 2003.


    See:
     GrayscaleGeodesicDilateImageFilter , HMinimaImageFilter , HConvexImageFilter

     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::HMinima for the procedural interface

     itk::HMinimaImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkHMinimaImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_HMinimaImageFilter

    def __init__(self):
        r"""
        __init__(HMinimaImageFilter self) -> HMinimaImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.HMinimaImageFilter_swiginit(
            self, _SimpleITK.new_HMinimaImageFilter()
        )

    def SetHeight(self, Height):
        r"""
        SetHeight(HMinimaImageFilter self, double Height)


        Set/Get the height that a local maximum must be above the local
        background (local contrast) in order to survive the processing. Local
        maxima below this value are replaced with an estimate of the local
        background.


        """
        return _SimpleITK.HMinimaImageFilter_SetHeight(self, Height)

    def GetHeight(self):
        r"""
        GetHeight(HMinimaImageFilter self) -> double


        Set/Get the height that a local maximum must be above the local
        background (local contrast) in order to survive the processing. Local
        maxima below this value are replaced with an estimate of the local
        background.


        """
        return _SimpleITK.HMinimaImageFilter_GetHeight(self)

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(HMinimaImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.HMinimaImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(HMinimaImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.HMinimaImageFilter_FullyConnectedOn(self)

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(HMinimaImageFilter self)


        """
        return _SimpleITK.HMinimaImageFilter_FullyConnectedOff(self)

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(HMinimaImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.HMinimaImageFilter_GetFullyConnected(self)

    def GetName(self):
        r"""
        GetName(HMinimaImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.HMinimaImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(HMinimaImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.HMinimaImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(HMinimaImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.HMinimaImageFilter_Execute(self, image1)


# Register HMinimaImageFilter in _SimpleITK:
_SimpleITK.HMinimaImageFilter_swigregister(HMinimaImageFilter)


def HMinima(image1, height=2.0, fullyConnected=False):
    r"""HMinima(Image image1, double height=2.0, bool fullyConnected=False) -> Image"""
    return _SimpleITK.HMinima(image1, height, fullyConnected)


class HalfHermitianToRealInverseFFTImageFilter(ImageFilter):
    r"""


    Base class for specialized complex-to-real inverse Fast Fourier Transform .


    This is a base class for the "inverse" or "reverse" Discrete
    Fourier Transform . This is an abstract base class: the actual implementation is
    provided by the best child class available on the system when the
    object is created via the object factory system.

    The input to this filter is assumed to have the same format as the
    output of the RealToHalfHermitianForwardFFTImageFilter . That is, the input is assumed to consist of roughly half the full
    complex image resulting from a real-to-complex discrete Fourier
    transform. This half is expected to be the first half of the image in
    the X-dimension. Because this filter assumes that the input stores
    only about half of the non-redundant complex pixels, the output is
    larger in the X-dimension than it is in the input. To determine the
    actual size of the output image, this filter needs additional
    information in the form of a flag indicating whether the output image
    has an odd size in the X-dimension. Use SetActualXDimensionIsOdd() to set this flag.


    See:
     ForwardFFTImageFilter , HalfHermitianToRealInverseFFTImageFilter

     itk::simple::HalfHermitianToRealInverseFFT for the procedural interface

     itk::HalfHermitianToRealInverseFFTImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkHalfHermitianToRealInverseFFTImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_HalfHermitianToRealInverseFFTImageFilter
    )

    def __init__(self):
        r"""
        __init__(HalfHermitianToRealInverseFFTImageFilter self) -> HalfHermitianToRealInverseFFTImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.HalfHermitianToRealInverseFFTImageFilter_swiginit(
            self, _SimpleITK.new_HalfHermitianToRealInverseFFTImageFilter()
        )

    def SetActualXDimensionIsOdd(self, ActualXDimensionIsOdd):
        r"""
        SetActualXDimensionIsOdd(HalfHermitianToRealInverseFFTImageFilter self, bool ActualXDimensionIsOdd)


        Was the original truncated dimension size odd?


        """
        return _SimpleITK.HalfHermitianToRealInverseFFTImageFilter_SetActualXDimensionIsOdd(
            self, ActualXDimensionIsOdd
        )

    def ActualXDimensionIsOddOn(self):
        r"""
        ActualXDimensionIsOddOn(HalfHermitianToRealInverseFFTImageFilter self)


        Set the value of ActualXDimensionIsOdd to true or false respectfully.


        """
        return _SimpleITK.HalfHermitianToRealInverseFFTImageFilter_ActualXDimensionIsOddOn(
            self
        )

    def ActualXDimensionIsOddOff(self):
        r"""
        ActualXDimensionIsOddOff(HalfHermitianToRealInverseFFTImageFilter self)


        """
        return _SimpleITK.HalfHermitianToRealInverseFFTImageFilter_ActualXDimensionIsOddOff(
            self
        )

    def GetActualXDimensionIsOdd(self):
        r"""
        GetActualXDimensionIsOdd(HalfHermitianToRealInverseFFTImageFilter self) -> bool


        Was the original truncated dimension size odd?


        """
        return _SimpleITK.HalfHermitianToRealInverseFFTImageFilter_GetActualXDimensionIsOdd(
            self
        )

    def GetName(self):
        r"""
        GetName(HalfHermitianToRealInverseFFTImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.HalfHermitianToRealInverseFFTImageFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(HalfHermitianToRealInverseFFTImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.HalfHermitianToRealInverseFFTImageFilter___str__(
            self
        )

    def Execute(self, image1):
        r"""
        Execute(HalfHermitianToRealInverseFFTImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.HalfHermitianToRealInverseFFTImageFilter_Execute(
            self, image1
        )


# Register HalfHermitianToRealInverseFFTImageFilter in _SimpleITK:
_SimpleITK.HalfHermitianToRealInverseFFTImageFilter_swigregister(
    HalfHermitianToRealInverseFFTImageFilter
)


def HalfHermitianToRealInverseFFT(image1, actualXDimensionIsOdd=False):
    r"""HalfHermitianToRealInverseFFT(Image image1, bool actualXDimensionIsOdd=False) -> Image"""
    return _SimpleITK.HalfHermitianToRealInverseFFT(
        image1, actualXDimensionIsOdd
    )


class HausdorffDistanceImageFilter(ImageFilter):
    r"""


    Computes the Hausdorff distance between the set of non-zero pixels of
    two images.


    HausdorffDistanceImageFilter computes the distance between the set non-zero pixels of two images
    using the following formula: \\[ H(A,B) = \\max(h(A,B),h(B,A)) \\] where \\[ h(A,B) = \\max_{a \\in A} \\min_{b \\in B} \\| a -
    b\\| \\] is the directed Hausdorff distance and $A$ and $B$ are respectively the set of non-zero pixels in the first and second
    input images.

    In particular, this filter uses the DirectedHausdorffImageFilter
    inside to compute the two directed distances and then select the
    largest of the two.

    The Hausdorff distance measures the degree of mismatch between two
    sets and behaves like a metric over the set of all closed bounded sets
    - with properties of identity, symmetry and triangle inequality.

    This filter requires the largest possible region of the first image
    and the same corresponding region in the second image. It behaves as
    filter with two inputs and one output. Thus it can be inserted in a
    pipeline with other filters. The filter passes the first input through
    unmodified.

    This filter is templated over the two input image types. It assume
    both images have the same number of dimensions.


    See:
     DirectedHausdorffDistanceImageFilter

     itk::HausdorffDistanceImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkHausdorffDistanceImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_HausdorffDistanceImageFilter

    def __init__(self):
        r"""
        __init__(HausdorffDistanceImageFilter self) -> HausdorffDistanceImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.HausdorffDistanceImageFilter_swiginit(
            self, _SimpleITK.new_HausdorffDistanceImageFilter()
        )

    def GetHausdorffDistance(self):
        r"""
        GetHausdorffDistance(HausdorffDistanceImageFilter self) -> double


        Return the computed Hausdorff distance.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.HausdorffDistanceImageFilter_GetHausdorffDistance(
            self
        )

    def GetAverageHausdorffDistance(self):
        r"""
        GetAverageHausdorffDistance(HausdorffDistanceImageFilter self) -> double


        Return the computed Hausdorff distance.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.HausdorffDistanceImageFilter_GetAverageHausdorffDistance(
            self
        )

    def GetName(self):
        r"""
        GetName(HausdorffDistanceImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.HausdorffDistanceImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(HausdorffDistanceImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.HausdorffDistanceImageFilter___str__(self)

    def Execute(self, image1, image2):
        r"""
        Execute(HausdorffDistanceImageFilter self, Image image1, Image image2)


        Execute the filter on the input images


        """
        return _SimpleITK.HausdorffDistanceImageFilter_Execute(
            self, image1, image2
        )


# Register HausdorffDistanceImageFilter in _SimpleITK:
_SimpleITK.HausdorffDistanceImageFilter_swigregister(
    HausdorffDistanceImageFilter
)


class HistogramMatchingImageFilter(ImageFilter):
    r"""


    Normalize the grayscale values for a source image by matching the
    shape of the source image histogram to a reference histogram.


    HistogramMatchingImageFilter normalizes the grayscale values of a source image based on the
    grayscale values of either a reference image or a reference histogram.
    This filter uses a histogram matching technique where the histograms
    of the are matched only at a specified number of quantile values.

    This filter was originally designed to normalize MR images of the same
    MR protocol and same body part. The algorithm works best if background
    pixels are excluded from both the source and reference histograms. A
    simple background exclusion method is to exclude all pixels whose
    grayscale values are smaller than the mean grayscale value. ThresholdAtMeanIntensityOn() switches on this simple background exclusion method. With ThresholdAtMeanIntensityOn() , The reference histogram returned from this filter will expand the
    first and last bin bounds to include the minimum and maximum intensity
    values of the entire reference image, but only intensity values
    greater than the mean will be used to populate the histogram.

    The source image can be set via either SetInput() or SetSourceImage().
    The reference object used is selected with can be set via
    SetReferenceImage() or SetReferenceHistogram().

    SetNumberOfHistogramLevels() sets the number of bins used when creating histograms of the source
    and reference images. SetNumberOfMatchPoints() governs the number of quantile values to be matched.

    This filter assumes that both the source and reference are of the same
    type and that the input and output image type have the same number of
    dimension and have scalar pixel types.

    REFERENCE
    Laszlo G. Nyul, Jayaram K. Udupa, and Xuan Zhang, "New Variants of a
    Method of MRI Scale Standardization", IEEE Transactions on Medical
    Imaging, 19(2):143-150, 2000.

    See:
     itk::simple::HistogramMatching for the procedural interface

     itk::HistogramMatchingImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkHistogramMatchingImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_HistogramMatchingImageFilter

    def __init__(self):
        r"""
        __init__(HistogramMatchingImageFilter self) -> HistogramMatchingImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.HistogramMatchingImageFilter_swiginit(
            self, _SimpleITK.new_HistogramMatchingImageFilter()
        )

    def SetNumberOfHistogramLevels(self, NumberOfHistogramLevels):
        r"""
        SetNumberOfHistogramLevels(HistogramMatchingImageFilter self, uint32_t NumberOfHistogramLevels)


        Set/Get the number of histogram levels used.


        """
        return (
            _SimpleITK.HistogramMatchingImageFilter_SetNumberOfHistogramLevels(
                self, NumberOfHistogramLevels
            )
        )

    def GetNumberOfHistogramLevels(self):
        r"""
        GetNumberOfHistogramLevels(HistogramMatchingImageFilter self) -> uint32_t


        Set/Get the number of histogram levels used.


        """
        return (
            _SimpleITK.HistogramMatchingImageFilter_GetNumberOfHistogramLevels(
                self
            )
        )

    def SetNumberOfMatchPoints(self, NumberOfMatchPoints):
        r"""
        SetNumberOfMatchPoints(HistogramMatchingImageFilter self, uint32_t NumberOfMatchPoints)


        Set/Get the number of match points used.


        """
        return _SimpleITK.HistogramMatchingImageFilter_SetNumberOfMatchPoints(
            self, NumberOfMatchPoints
        )

    def GetNumberOfMatchPoints(self):
        r"""
        GetNumberOfMatchPoints(HistogramMatchingImageFilter self) -> uint32_t


        Set/Get the number of match points used.


        """
        return _SimpleITK.HistogramMatchingImageFilter_GetNumberOfMatchPoints(
            self
        )

    def SetThresholdAtMeanIntensity(self, ThresholdAtMeanIntensity):
        r"""
        SetThresholdAtMeanIntensity(HistogramMatchingImageFilter self, bool ThresholdAtMeanIntensity)


        Set/Get the threshold at mean intensity flag. If true, only source
        (reference) pixels which are greater than the mean source (reference)
        intensity is used in the histogram matching. If false, all pixels are
        used.


        """
        return _SimpleITK.HistogramMatchingImageFilter_SetThresholdAtMeanIntensity(
            self, ThresholdAtMeanIntensity
        )

    def ThresholdAtMeanIntensityOn(self):
        r"""
        ThresholdAtMeanIntensityOn(HistogramMatchingImageFilter self)


        Set the value of ThresholdAtMeanIntensity to true or false
        respectfully.


        """
        return (
            _SimpleITK.HistogramMatchingImageFilter_ThresholdAtMeanIntensityOn(
                self
            )
        )

    def ThresholdAtMeanIntensityOff(self):
        r"""
        ThresholdAtMeanIntensityOff(HistogramMatchingImageFilter self)


        """
        return _SimpleITK.HistogramMatchingImageFilter_ThresholdAtMeanIntensityOff(
            self
        )

    def GetThresholdAtMeanIntensity(self):
        r"""
        GetThresholdAtMeanIntensity(HistogramMatchingImageFilter self) -> bool


        Set/Get the threshold at mean intensity flag. If true, only source
        (reference) pixels which are greater than the mean source (reference)
        intensity is used in the histogram matching. If false, all pixels are
        used.


        """
        return _SimpleITK.HistogramMatchingImageFilter_GetThresholdAtMeanIntensity(
            self
        )

    def GetName(self):
        r"""
        GetName(HistogramMatchingImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.HistogramMatchingImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(HistogramMatchingImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.HistogramMatchingImageFilter___str__(self)

    def Execute(self, image, referenceImage):
        r"""
        Execute(HistogramMatchingImageFilter self, Image image, Image referenceImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.HistogramMatchingImageFilter_Execute(
            self, image, referenceImage
        )


# Register HistogramMatchingImageFilter in _SimpleITK:
_SimpleITK.HistogramMatchingImageFilter_swigregister(
    HistogramMatchingImageFilter
)


def HistogramMatching(
    image,
    referenceImage,
    numberOfHistogramLevels=256,
    numberOfMatchPoints=1,
    thresholdAtMeanIntensity=True,
):
    r"""HistogramMatching(Image image, Image referenceImage, uint32_t numberOfHistogramLevels=256, uint32_t numberOfMatchPoints=1, bool thresholdAtMeanIntensity=True) -> Image"""
    return _SimpleITK.HistogramMatching(
        image,
        referenceImage,
        numberOfHistogramLevels,
        numberOfMatchPoints,
        thresholdAtMeanIntensity,
    )


class HuangThresholdImageFilter(ImageFilter):
    r"""


    Threshold an image using the Huang Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the HuangThresholdCalculator and applies that threshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/efycla


    See:
     HistogramThresholdImageFilter

     itk::simple::HuangThreshold for the procedural interface

     itk::HuangThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkHuangThresholdImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_HuangThresholdImageFilter

    def __init__(self):
        r"""
        __init__(HuangThresholdImageFilter self) -> HuangThresholdImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.HuangThresholdImageFilter_swiginit(
            self, _SimpleITK.new_HuangThresholdImageFilter()
        )

    def SetInsideValue(self, InsideValue):
        r"""
        SetInsideValue(HuangThresholdImageFilter self, uint8_t InsideValue)


        Set the "inside" pixel value. The default value NumericTraits<OutputPixelType>::max()


        """
        return _SimpleITK.HuangThresholdImageFilter_SetInsideValue(
            self, InsideValue
        )

    def GetInsideValue(self):
        r"""
        GetInsideValue(HuangThresholdImageFilter self) -> uint8_t


        Get the "inside" pixel value.


        """
        return _SimpleITK.HuangThresholdImageFilter_GetInsideValue(self)

    def SetOutsideValue(self, OutsideValue):
        r"""
        SetOutsideValue(HuangThresholdImageFilter self, uint8_t OutsideValue)


        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.HuangThresholdImageFilter_SetOutsideValue(
            self, OutsideValue
        )

    def GetOutsideValue(self):
        r"""
        GetOutsideValue(HuangThresholdImageFilter self) -> uint8_t


        Get the "outside" pixel value.


        """
        return _SimpleITK.HuangThresholdImageFilter_GetOutsideValue(self)

    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        r"""
        SetNumberOfHistogramBins(HuangThresholdImageFilter self, uint32_t NumberOfHistogramBins)


        Set/Get the number of histogram bins. Defaults is 128.


        """
        return _SimpleITK.HuangThresholdImageFilter_SetNumberOfHistogramBins(
            self, NumberOfHistogramBins
        )

    def GetNumberOfHistogramBins(self):
        r"""
        GetNumberOfHistogramBins(HuangThresholdImageFilter self) -> uint32_t


        """
        return _SimpleITK.HuangThresholdImageFilter_GetNumberOfHistogramBins(
            self
        )

    def SetMaskOutput(self, MaskOutput):
        r"""
        SetMaskOutput(HuangThresholdImageFilter self, bool MaskOutput)


        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.HuangThresholdImageFilter_SetMaskOutput(
            self, MaskOutput
        )

    def MaskOutputOn(self):
        r"""
        MaskOutputOn(HuangThresholdImageFilter self)


        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.HuangThresholdImageFilter_MaskOutputOn(self)

    def MaskOutputOff(self):
        r"""
        MaskOutputOff(HuangThresholdImageFilter self)


        """
        return _SimpleITK.HuangThresholdImageFilter_MaskOutputOff(self)

    def GetMaskOutput(self):
        r"""
        GetMaskOutput(HuangThresholdImageFilter self) -> bool


        """
        return _SimpleITK.HuangThresholdImageFilter_GetMaskOutput(self)

    def SetMaskValue(self, MaskValue):
        r"""
        SetMaskValue(HuangThresholdImageFilter self, uint8_t MaskValue)


        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.HuangThresholdImageFilter_SetMaskValue(
            self, MaskValue
        )

    def GetMaskValue(self):
        r"""
        GetMaskValue(HuangThresholdImageFilter self) -> uint8_t


        """
        return _SimpleITK.HuangThresholdImageFilter_GetMaskValue(self)

    def GetThreshold(self):
        r"""
        GetThreshold(HuangThresholdImageFilter self) -> double


        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.HuangThresholdImageFilter_GetThreshold(self)

    def GetName(self):
        r"""
        GetName(HuangThresholdImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.HuangThresholdImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(HuangThresholdImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.HuangThresholdImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(HuangThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(HuangThresholdImageFilter self, Image image) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.HuangThresholdImageFilter_Execute(self, *args)


# Register HuangThresholdImageFilter in _SimpleITK:
_SimpleITK.HuangThresholdImageFilter_swigregister(HuangThresholdImageFilter)


def HuangThreshold(*args):
    r"""
    HuangThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=128, bool maskOutput=True, uint8_t maskValue=255) -> Image
    HuangThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=128, bool maskOutput=True, uint8_t maskValue=255) -> Image
    """
    return _SimpleITK.HuangThreshold(*args)


class IntensityWindowingImageFilter(ImageFilter):
    r"""


    Applies a linear transformation to the intensity levels of the input Image that are inside a user-defined interval. Values below this interval
    are mapped to a constant. Values over the interval are mapped to
    another constant.


    IntensityWindowingImageFilter applies pixel-wise a linear transformation to the intensity values of
    input image pixels. The linear transformation is defined by the user
    in terms of the minimum and maximum values that the output image
    should have and the lower and upper limits of the intensity window of
    the input image. This operation is very common in visualization, and
    can also be applied as a convenient preprocessing operation for image
    segmentation.

    All computations are performed in the precision of the input pixel's
    RealType. Before assigning the computed value to the output pixel.


    See:
     RescaleIntensityImageFilter

     itk::simple::IntensityWindowing for the procedural interface

     itk::IntensityWindowingImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkIntensityWindowingImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_IntensityWindowingImageFilter

    def __init__(self):
        r"""
        __init__(IntensityWindowingImageFilter self) -> IntensityWindowingImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.IntensityWindowingImageFilter_swiginit(
            self, _SimpleITK.new_IntensityWindowingImageFilter()
        )

    def SetWindowMinimum(self, WindowMinimum):
        r"""
        SetWindowMinimum(IntensityWindowingImageFilter self, double WindowMinimum)


        Set/Get the values of the maximum and minimum intensities of the input
        intensity window.


        """
        return _SimpleITK.IntensityWindowingImageFilter_SetWindowMinimum(
            self, WindowMinimum
        )

    def GetWindowMinimum(self):
        r"""
        GetWindowMinimum(IntensityWindowingImageFilter self) -> double


        Set/Get the values of the maximum and minimum intensities of the input
        intensity window.


        """
        return _SimpleITK.IntensityWindowingImageFilter_GetWindowMinimum(self)

    def SetWindowMaximum(self, WindowMaximum):
        r"""
        SetWindowMaximum(IntensityWindowingImageFilter self, double WindowMaximum)


        Set/Get the values of the maximum and minimum intensities of the input
        intensity window.


        """
        return _SimpleITK.IntensityWindowingImageFilter_SetWindowMaximum(
            self, WindowMaximum
        )

    def GetWindowMaximum(self):
        r"""
        GetWindowMaximum(IntensityWindowingImageFilter self) -> double


        Set/Get the values of the maximum and minimum intensities of the input
        intensity window.


        """
        return _SimpleITK.IntensityWindowingImageFilter_GetWindowMaximum(self)

    def SetOutputMinimum(self, OutputMinimum):
        r"""
        SetOutputMinimum(IntensityWindowingImageFilter self, double OutputMinimum)


        Set/Get the values of the maximum and minimum intensities of the
        output image.


        """
        return _SimpleITK.IntensityWindowingImageFilter_SetOutputMinimum(
            self, OutputMinimum
        )

    def GetOutputMinimum(self):
        r"""
        GetOutputMinimum(IntensityWindowingImageFilter self) -> double


        Set/Get the values of the maximum and minimum intensities of the
        output image.


        """
        return _SimpleITK.IntensityWindowingImageFilter_GetOutputMinimum(self)

    def SetOutputMaximum(self, OutputMaximum):
        r"""
        SetOutputMaximum(IntensityWindowingImageFilter self, double OutputMaximum)


        Set/Get the values of the maximum and minimum intensities of the
        output image.


        """
        return _SimpleITK.IntensityWindowingImageFilter_SetOutputMaximum(
            self, OutputMaximum
        )

    def GetOutputMaximum(self):
        r"""
        GetOutputMaximum(IntensityWindowingImageFilter self) -> double


        Set/Get the values of the maximum and minimum intensities of the
        output image.


        """
        return _SimpleITK.IntensityWindowingImageFilter_GetOutputMaximum(self)

    def GetName(self):
        r"""
        GetName(IntensityWindowingImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.IntensityWindowingImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(IntensityWindowingImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.IntensityWindowingImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(IntensityWindowingImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.IntensityWindowingImageFilter_Execute(self, image1)


# Register IntensityWindowingImageFilter in _SimpleITK:
_SimpleITK.IntensityWindowingImageFilter_swigregister(
    IntensityWindowingImageFilter
)


def IntensityWindowing(
    image1,
    windowMinimum=0.0,
    windowMaximum=255.0,
    outputMinimum=0.0,
    outputMaximum=255.0,
):
    r"""IntensityWindowing(Image image1, double windowMinimum=0.0, double windowMaximum=255.0, double outputMinimum=0.0, double outputMaximum=255.0) -> Image"""
    return _SimpleITK.IntensityWindowing(
        image1, windowMinimum, windowMaximum, outputMinimum, outputMaximum
    )


class IntermodesThresholdImageFilter(ImageFilter):
    r"""


    Threshold an image using the Intermodes Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the IntermodesThresholdCalculator and applies that threshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/efycla


    See:
     HistogramThresholdImageFilter

     itk::simple::IntermodesThreshold for the procedural interface

     itk::IntermodesThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkIntermodesThresholdImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_IntermodesThresholdImageFilter

    def __init__(self):
        r"""
        __init__(IntermodesThresholdImageFilter self) -> IntermodesThresholdImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.IntermodesThresholdImageFilter_swiginit(
            self, _SimpleITK.new_IntermodesThresholdImageFilter()
        )

    def SetInsideValue(self, InsideValue):
        r"""
        SetInsideValue(IntermodesThresholdImageFilter self, uint8_t InsideValue)


        Set the "inside" pixel value.


        """
        return _SimpleITK.IntermodesThresholdImageFilter_SetInsideValue(
            self, InsideValue
        )

    def GetInsideValue(self):
        r"""
        GetInsideValue(IntermodesThresholdImageFilter self) -> uint8_t


        Get the "inside" pixel value.


        """
        return _SimpleITK.IntermodesThresholdImageFilter_GetInsideValue(self)

    def SetOutsideValue(self, OutsideValue):
        r"""
        SetOutsideValue(IntermodesThresholdImageFilter self, uint8_t OutsideValue)


        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.IntermodesThresholdImageFilter_SetOutsideValue(
            self, OutsideValue
        )

    def GetOutsideValue(self):
        r"""
        GetOutsideValue(IntermodesThresholdImageFilter self) -> uint8_t


        Get the "outside" pixel value.


        """
        return _SimpleITK.IntermodesThresholdImageFilter_GetOutsideValue(self)

    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        r"""
        SetNumberOfHistogramBins(IntermodesThresholdImageFilter self, uint32_t NumberOfHistogramBins)


        Set/Get the number of histogram bins.


        """
        return (
            _SimpleITK.IntermodesThresholdImageFilter_SetNumberOfHistogramBins(
                self, NumberOfHistogramBins
            )
        )

    def GetNumberOfHistogramBins(self):
        r"""
        GetNumberOfHistogramBins(IntermodesThresholdImageFilter self) -> uint32_t


        """
        return (
            _SimpleITK.IntermodesThresholdImageFilter_GetNumberOfHistogramBins(
                self
            )
        )

    def SetMaskOutput(self, MaskOutput):
        r"""
        SetMaskOutput(IntermodesThresholdImageFilter self, bool MaskOutput)


        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.IntermodesThresholdImageFilter_SetMaskOutput(
            self, MaskOutput
        )

    def MaskOutputOn(self):
        r"""
        MaskOutputOn(IntermodesThresholdImageFilter self)


        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.IntermodesThresholdImageFilter_MaskOutputOn(self)

    def MaskOutputOff(self):
        r"""
        MaskOutputOff(IntermodesThresholdImageFilter self)


        """
        return _SimpleITK.IntermodesThresholdImageFilter_MaskOutputOff(self)

    def GetMaskOutput(self):
        r"""
        GetMaskOutput(IntermodesThresholdImageFilter self) -> bool


        """
        return _SimpleITK.IntermodesThresholdImageFilter_GetMaskOutput(self)

    def SetMaskValue(self, MaskValue):
        r"""
        SetMaskValue(IntermodesThresholdImageFilter self, uint8_t MaskValue)


        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.IntermodesThresholdImageFilter_SetMaskValue(
            self, MaskValue
        )

    def GetMaskValue(self):
        r"""
        GetMaskValue(IntermodesThresholdImageFilter self) -> uint8_t


        """
        return _SimpleITK.IntermodesThresholdImageFilter_GetMaskValue(self)

    def GetThreshold(self):
        r"""
        GetThreshold(IntermodesThresholdImageFilter self) -> double


        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.IntermodesThresholdImageFilter_GetThreshold(self)

    def GetName(self):
        r"""
        GetName(IntermodesThresholdImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.IntermodesThresholdImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(IntermodesThresholdImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.IntermodesThresholdImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(IntermodesThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(IntermodesThresholdImageFilter self, Image image) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.IntermodesThresholdImageFilter_Execute(self, *args)


# Register IntermodesThresholdImageFilter in _SimpleITK:
_SimpleITK.IntermodesThresholdImageFilter_swigregister(
    IntermodesThresholdImageFilter
)


def IntermodesThreshold(*args):
    r"""
    IntermodesThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    IntermodesThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    """
    return _SimpleITK.IntermodesThreshold(*args)


class InverseDeconvolutionImageFilter(ImageFilter):
    r"""


    The direct linear inverse deconvolution filter.


    The inverse filter is the most straightforward deconvolution method.
    Considering that convolution of two images in the spatial domain is
    equivalent to multiplying the Fourier transform of the two images, the
    inverse filter consists of inverting the multiplication. In other
    words, this filter computes the following: \\[ hat{F}(\\omega) = \\begin{cases} G(\\omega) / H(\\omega)
    & \\text{if \\f$|H(\\omega)| \\geq \\epsilon\\f$} \\\\
    0 & \\text{otherwise} \\end{cases} \\] where $\\hat{F}(\\omega)$ is the Fourier transform of the estimate produced by this filter, $G(\\omega)$ is the Fourier transform of the input blurred image, $H(\\omega)$ is the Fourier transform of the blurring kernel, and $\\epsilon$ is a constant real non-negative threshold (called
    KernelZeroMagnitudeThreshold in this filter) that determines when the
    magnitude of a complex number is considered zero.


    Gaetan Lehmann, Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France

    Cory Quammen, The University of North Carolina at Chapel Hill

    See:
     itk::simple::InverseDeconvolution for the procedural interface

     itk::InverseDeconvolutionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkInverseDeconvolutionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_InverseDeconvolutionImageFilter

    def __init__(self):
        r"""
        __init__(InverseDeconvolutionImageFilter self) -> InverseDeconvolutionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.InverseDeconvolutionImageFilter_swiginit(
            self, _SimpleITK.new_InverseDeconvolutionImageFilter()
        )

    def SetKernelZeroMagnitudeThreshold(self, KernelZeroMagnitudeThreshold):
        r"""
        SetKernelZeroMagnitudeThreshold(InverseDeconvolutionImageFilter self, double KernelZeroMagnitudeThreshold)


        Set/get the threshold value used to determine whether a frequency of
        the Fourier transform of the blurring kernel is considered to be zero.
        Default value is 1.0e-4.


        """
        return _SimpleITK.InverseDeconvolutionImageFilter_SetKernelZeroMagnitudeThreshold(
            self, KernelZeroMagnitudeThreshold
        )

    def GetKernelZeroMagnitudeThreshold(self):
        r"""
        GetKernelZeroMagnitudeThreshold(InverseDeconvolutionImageFilter self) -> double


        Set/get the threshold value used to determine whether a frequency of
        the Fourier transform of the blurring kernel is considered to be zero.
        Default value is 1.0e-4.


        """
        return _SimpleITK.InverseDeconvolutionImageFilter_GetKernelZeroMagnitudeThreshold(
            self
        )

    def SetNormalize(self, Normalize):
        r"""
        SetNormalize(InverseDeconvolutionImageFilter self, bool Normalize)


        Normalize the output image by the sum of the kernel components


        """
        return _SimpleITK.InverseDeconvolutionImageFilter_SetNormalize(
            self, Normalize
        )

    def NormalizeOn(self):
        r"""
        NormalizeOn(InverseDeconvolutionImageFilter self)


        Set the value of Normalize to true or false respectfully.


        """
        return _SimpleITK.InverseDeconvolutionImageFilter_NormalizeOn(self)

    def NormalizeOff(self):
        r"""
        NormalizeOff(InverseDeconvolutionImageFilter self)


        """
        return _SimpleITK.InverseDeconvolutionImageFilter_NormalizeOff(self)

    def GetNormalize(self):
        r"""
        GetNormalize(InverseDeconvolutionImageFilter self) -> bool


        """
        return _SimpleITK.InverseDeconvolutionImageFilter_GetNormalize(self)

    ZERO_PAD = _SimpleITK.InverseDeconvolutionImageFilter_ZERO_PAD

    ZERO_FLUX_NEUMANN_PAD = (
        _SimpleITK.InverseDeconvolutionImageFilter_ZERO_FLUX_NEUMANN_PAD
    )

    PERIODIC_PAD = _SimpleITK.InverseDeconvolutionImageFilter_PERIODIC_PAD

    def SetBoundaryCondition(self, BoundaryCondition):
        r"""
        SetBoundaryCondition(InverseDeconvolutionImageFilter self, itk::simple::InverseDeconvolutionImageFilter::BoundaryConditionType BoundaryCondition)


        """
        return _SimpleITK.InverseDeconvolutionImageFilter_SetBoundaryCondition(
            self, BoundaryCondition
        )

    def GetBoundaryCondition(self):
        r"""
        GetBoundaryCondition(InverseDeconvolutionImageFilter self) -> itk::simple::InverseDeconvolutionImageFilter::BoundaryConditionType


        """
        return _SimpleITK.InverseDeconvolutionImageFilter_GetBoundaryCondition(
            self
        )

    SAME = _SimpleITK.InverseDeconvolutionImageFilter_SAME

    VALID = _SimpleITK.InverseDeconvolutionImageFilter_VALID

    def SetOutputRegionMode(self, OutputRegionMode):
        r"""
        SetOutputRegionMode(InverseDeconvolutionImageFilter self, itk::simple::InverseDeconvolutionImageFilter::OutputRegionModeType OutputRegionMode)


        """
        return _SimpleITK.InverseDeconvolutionImageFilter_SetOutputRegionMode(
            self, OutputRegionMode
        )

    def GetOutputRegionMode(self):
        r"""
        GetOutputRegionMode(InverseDeconvolutionImageFilter self) -> itk::simple::InverseDeconvolutionImageFilter::OutputRegionModeType


        """
        return _SimpleITK.InverseDeconvolutionImageFilter_GetOutputRegionMode(
            self
        )

    def GetName(self):
        r"""
        GetName(InverseDeconvolutionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.InverseDeconvolutionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(InverseDeconvolutionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.InverseDeconvolutionImageFilter___str__(self)

    def Execute(self, image1, image2):
        r"""
        Execute(InverseDeconvolutionImageFilter self, Image image1, Image image2) -> Image


        Execute the filter on the input images


        """
        return _SimpleITK.InverseDeconvolutionImageFilter_Execute(
            self, image1, image2
        )


# Register InverseDeconvolutionImageFilter in _SimpleITK:
_SimpleITK.InverseDeconvolutionImageFilter_swigregister(
    InverseDeconvolutionImageFilter
)


def InverseDeconvolution(*args, **kwargs):
    r"""InverseDeconvolution(Image image1, Image image2, double kernelZeroMagnitudeThreshold=1.0e-4, bool normalize=False, itk::simple::InverseDeconvolutionImageFilter::BoundaryConditionType boundaryCondition=ZERO_FLUX_NEUMANN_PAD, itk::simple::InverseDeconvolutionImageFilter::OutputRegionModeType outputRegionMode=SAME) -> Image"""
    return _SimpleITK.InverseDeconvolution(*args, **kwargs)


class InverseDisplacementFieldImageFilter(ImageFilter):
    r"""


    Computes the inverse of a displacement field.


    InverseDisplacementFieldImageFilter takes a displacement field as input and computes the displacement
    field that is its inverse. If the input displacement field was mapping
    coordinates from a space A into a space B, the output of this filter
    will map coordinates from the space B into the space A.

    Given that both the input and output displacement field are
    represented as discrete images with pixel type vector, the inverse
    will be only an estimation and will probably not correspond to a
    perfect inverse. The precision of the inverse can be improved at the
    price of increasing the computation time and memory consumption in
    this filter.

    The method used for computing the inverse displacement field is to
    subsample the input field using a regular grid and create Kerned-Base
    Spline in which the reference landmarks are the coordinates of the
    deformed point and the target landmarks are the negative of the
    displacement vectors. The kernel-base spline is then used for
    regularly sampling the output space and recover vector values for
    every single pixel.

    The subsampling factor used for the regular grid of the input field
    will determine the number of landmarks in the KernelBased spline and
    therefore it will have a dramatic effect on both the precision of
    output displacement field and the computational time required for the
    filter to complete the estimation. A large subsampling factor will
    result in few landmarks in the KernelBased spline, therefore on fast
    computation and low precision. A small subsampling factor will result
    in a large number of landmarks in the KernelBased spline, therefore a
    large memory consumption, long computation time and high precision for
    the inverse estimation.

    This filter expects both the input and output images to be of pixel
    type Vector .
    See:
     itk::simple::InverseDisplacementField for the procedural interface

     itk::InverseDisplacementFieldImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkInverseDisplacementFieldImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_InverseDisplacementFieldImageFilter

    def __init__(self):
        r"""
        __init__(InverseDisplacementFieldImageFilter self) -> InverseDisplacementFieldImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.InverseDisplacementFieldImageFilter_swiginit(
            self, _SimpleITK.new_InverseDisplacementFieldImageFilter()
        )

    def SetSize(self, Size):
        r"""
        SetSize(InverseDisplacementFieldImageFilter self, VectorUInt32 Size)


        Set the size of the output image.


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_SetSize(
            self, Size
        )

    def GetSize(self):
        r"""
        GetSize(InverseDisplacementFieldImageFilter self) -> VectorUInt32


        Get the size of the output image.


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_GetSize(self)

    def SetOutputOrigin(self, OutputOrigin):
        r"""
        SetOutputOrigin(InverseDisplacementFieldImageFilter self, VectorDouble OutputOrigin)


        Set the output image origin.


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_SetOutputOrigin(
            self, OutputOrigin
        )

    def GetOutputOrigin(self):
        r"""
        GetOutputOrigin(InverseDisplacementFieldImageFilter self) -> VectorDouble


        Get the output image origin.


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_GetOutputOrigin(
            self
        )

    def SetOutputSpacing(self, OutputSpacing):
        r"""
        SetOutputSpacing(InverseDisplacementFieldImageFilter self, VectorDouble OutputSpacing)


        Set the output image spacing.


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_SetOutputSpacing(
            self, OutputSpacing
        )

    def GetOutputSpacing(self):
        r"""
        GetOutputSpacing(InverseDisplacementFieldImageFilter self) -> VectorDouble


        Get the output image spacing.


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_GetOutputSpacing(
            self
        )

    def SetSubsamplingFactor(self, SubsamplingFactor):
        r"""
        SetSubsamplingFactor(InverseDisplacementFieldImageFilter self, unsigned int SubsamplingFactor)


        Set/Get the factor used for subsampling the input displacement field.
        A large value in this factor will produce a fast computation of the
        inverse field but with low precision. A small value of this factor
        will produce a precise computation of the inverse field at the price
        of large memory consumption and long computational time.


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_SetSubsamplingFactor(
            self, SubsamplingFactor
        )

    def GetSubsamplingFactor(self):
        r"""
        GetSubsamplingFactor(InverseDisplacementFieldImageFilter self) -> unsigned int


        Set/Get the factor used for subsampling the input displacement field.
        A large value in this factor will produce a fast computation of the
        inverse field but with low precision. A small value of this factor
        will produce a precise computation of the inverse field at the price
        of large memory consumption and long computational time.


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_GetSubsamplingFactor(
            self
        )

    def GetName(self):
        r"""
        GetName(InverseDisplacementFieldImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(InverseDisplacementFieldImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(InverseDisplacementFieldImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_Execute(
            self, image1
        )

    def SetReferenceImage(self, refImage):
        r"""
        SetReferenceImage(InverseDisplacementFieldImageFilter self, Image refImage)


        This methods sets the output size, origin, and direction to that of
        the provided image


        """
        return (
            _SimpleITK.InverseDisplacementFieldImageFilter_SetReferenceImage(
                self, refImage
            )
        )


# Register InverseDisplacementFieldImageFilter in _SimpleITK:
_SimpleITK.InverseDisplacementFieldImageFilter_swigregister(
    InverseDisplacementFieldImageFilter
)


def InverseDisplacementField(*args, **kwargs):
    r"""InverseDisplacementField(Image image1, VectorUInt32 size=std::vector< uint32_t >(3, 0), VectorDouble outputOrigin=std::vector< double >(3, 0.0), VectorDouble outputSpacing=std::vector< double >(3, 1.0), unsigned int subsamplingFactor=16) -> Image"""
    return _SimpleITK.InverseDisplacementField(*args, **kwargs)


class InverseFFTImageFilter(ImageFilter):
    r"""


    Base class for inverse Fast Fourier Transform .


    This is a base class for the "inverse" or "reverse" Discrete
    Fourier Transform . This is an abstract base class: the actual implementation is
    provided by the best child available on the system when the object is
    created via the object factory system.

    This class transforms a full complex image with Hermitian symmetry
    into its real spatial domain representation. If the input does not
    have Hermitian symmetry, the imaginary component is discarded.


    See:
     ForwardFFTImageFilter , InverseFFTImageFilter

     itk::simple::InverseFFT for the procedural interface

     itk::InverseFFTImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkInverseFFTImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_InverseFFTImageFilter

    def __init__(self):
        r"""
        __init__(InverseFFTImageFilter self) -> InverseFFTImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.InverseFFTImageFilter_swiginit(
            self, _SimpleITK.new_InverseFFTImageFilter()
        )

    def GetName(self):
        r"""
        GetName(InverseFFTImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.InverseFFTImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(InverseFFTImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.InverseFFTImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(InverseFFTImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.InverseFFTImageFilter_Execute(self, image1)


# Register InverseFFTImageFilter in _SimpleITK:
_SimpleITK.InverseFFTImageFilter_swigregister(InverseFFTImageFilter)


def InverseFFT(image1):
    r"""InverseFFT(Image image1) -> Image"""
    return _SimpleITK.InverseFFT(image1)


class InvertDisplacementFieldImageFilter(ImageFilter):
    r"""


    Iteratively estimate the inverse field of a displacement field.



    Nick Tustison

    Brian Avants

    See:
     itk::simple::InvertDisplacementField for the procedural interface

     itk::InvertDisplacementFieldImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkInvertDisplacementFieldImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_InvertDisplacementFieldImageFilter

    def __init__(self):
        r"""
        __init__(InvertDisplacementFieldImageFilter self) -> InvertDisplacementFieldImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.InvertDisplacementFieldImageFilter_swiginit(
            self, _SimpleITK.new_InvertDisplacementFieldImageFilter()
        )

    def SetMaximumNumberOfIterations(self, MaximumNumberOfIterations):
        r"""
        SetMaximumNumberOfIterations(InvertDisplacementFieldImageFilter self, uint32_t MaximumNumberOfIterations)


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_SetMaximumNumberOfIterations(
            self, MaximumNumberOfIterations
        )

    def GetMaximumNumberOfIterations(self):
        r"""
        GetMaximumNumberOfIterations(InvertDisplacementFieldImageFilter self) -> uint32_t


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_GetMaximumNumberOfIterations(
            self
        )

    def SetMaxErrorToleranceThreshold(self, MaxErrorToleranceThreshold):
        r"""
        SetMaxErrorToleranceThreshold(InvertDisplacementFieldImageFilter self, double MaxErrorToleranceThreshold)


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_SetMaxErrorToleranceThreshold(
            self, MaxErrorToleranceThreshold
        )

    def GetMaxErrorToleranceThreshold(self):
        r"""
        GetMaxErrorToleranceThreshold(InvertDisplacementFieldImageFilter self) -> double


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_GetMaxErrorToleranceThreshold(
            self
        )

    def SetMeanErrorToleranceThreshold(self, MeanErrorToleranceThreshold):
        r"""
        SetMeanErrorToleranceThreshold(InvertDisplacementFieldImageFilter self, double MeanErrorToleranceThreshold)


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_SetMeanErrorToleranceThreshold(
            self, MeanErrorToleranceThreshold
        )

    def GetMeanErrorToleranceThreshold(self):
        r"""
        GetMeanErrorToleranceThreshold(InvertDisplacementFieldImageFilter self) -> double


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_GetMeanErrorToleranceThreshold(
            self
        )

    def SetEnforceBoundaryCondition(self, EnforceBoundaryCondition):
        r"""
        SetEnforceBoundaryCondition(InvertDisplacementFieldImageFilter self, bool EnforceBoundaryCondition)


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_SetEnforceBoundaryCondition(
            self, EnforceBoundaryCondition
        )

    def EnforceBoundaryConditionOn(self):
        r"""
        EnforceBoundaryConditionOn(InvertDisplacementFieldImageFilter self)


        Set the value of EnforceBoundaryCondition to true or false
        respectfully.


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_EnforceBoundaryConditionOn(
            self
        )

    def EnforceBoundaryConditionOff(self):
        r"""
        EnforceBoundaryConditionOff(InvertDisplacementFieldImageFilter self)


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_EnforceBoundaryConditionOff(
            self
        )

    def GetEnforceBoundaryCondition(self):
        r"""
        GetEnforceBoundaryCondition(InvertDisplacementFieldImageFilter self) -> bool


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_GetEnforceBoundaryCondition(
            self
        )

    def GetMaxErrorNorm(self):
        r"""
        GetMaxErrorNorm(InvertDisplacementFieldImageFilter self) -> double


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_GetMaxErrorNorm(
            self
        )

    def GetMeanErrorNorm(self):
        r"""
        GetMeanErrorNorm(InvertDisplacementFieldImageFilter self) -> double


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_GetMeanErrorNorm(
            self
        )

    def GetName(self):
        r"""
        GetName(InvertDisplacementFieldImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(InvertDisplacementFieldImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(InvertDisplacementFieldImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_Execute(
            self, image1
        )


# Register InvertDisplacementFieldImageFilter in _SimpleITK:
_SimpleITK.InvertDisplacementFieldImageFilter_swigregister(
    InvertDisplacementFieldImageFilter
)


def InvertDisplacementField(
    image1,
    maximumNumberOfIterations=10,
    maxErrorToleranceThreshold=0.1,
    meanErrorToleranceThreshold=0.001,
    enforceBoundaryCondition=True,
):
    r"""InvertDisplacementField(Image image1, uint32_t maximumNumberOfIterations=10, double maxErrorToleranceThreshold=0.1, double meanErrorToleranceThreshold=0.001, bool enforceBoundaryCondition=True) -> Image"""
    return _SimpleITK.InvertDisplacementField(
        image1,
        maximumNumberOfIterations,
        maxErrorToleranceThreshold,
        meanErrorToleranceThreshold,
        enforceBoundaryCondition,
    )


class InvertIntensityImageFilter(ImageFilter):
    r"""


    Invert the intensity of an image.


    InvertIntensityImageFilter inverts intensity of pixels by subtracting pixel value to a maximum
    value. The maximum value can be set with SetMaximum and defaults the
    maximum of input pixel type. This filter can be used to invert, for
    example, a binary image, a distance map, etc.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     IntensityWindowingImageFilter ShiftScaleImageFilter

     itk::simple::InvertIntensity for the procedural interface

     itk::InvertIntensityImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkInvertIntensityImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_InvertIntensityImageFilter

    def __init__(self):
        r"""
        __init__(InvertIntensityImageFilter self) -> InvertIntensityImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.InvertIntensityImageFilter_swiginit(
            self, _SimpleITK.new_InvertIntensityImageFilter()
        )

    def SetMaximum(self, Maximum):
        r"""
        SetMaximum(InvertIntensityImageFilter self, double Maximum)


        Set/Get the maximum intensity value for the inversion.


        """
        return _SimpleITK.InvertIntensityImageFilter_SetMaximum(self, Maximum)

    def GetMaximum(self):
        r"""
        GetMaximum(InvertIntensityImageFilter self) -> double


        Set/Get the maximum intensity value for the inversion.


        """
        return _SimpleITK.InvertIntensityImageFilter_GetMaximum(self)

    def GetName(self):
        r"""
        GetName(InvertIntensityImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.InvertIntensityImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(InvertIntensityImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.InvertIntensityImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(InvertIntensityImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.InvertIntensityImageFilter_Execute(self, image1)


# Register InvertIntensityImageFilter in _SimpleITK:
_SimpleITK.InvertIntensityImageFilter_swigregister(InvertIntensityImageFilter)


def InvertIntensity(image1, maximum=255):
    r"""InvertIntensity(Image image1, double maximum=255) -> Image"""
    return _SimpleITK.InvertIntensity(image1, maximum)


class IsoContourDistanceImageFilter(ImageFilter):
    r"""


    Compute an approximate distance from an interpolated isocontour to the
    close grid points.


    For standard level set algorithms, it is useful to periodically
    reinitialize the evolving image to prevent numerical accuracy problems
    in computing derivatives. This reinitialization is done by computing a
    signed distance map to the current level set. This class provides the
    first step in this reinitialization by computing an estimate of the
    distance from the interpolated isocontour to the pixels (or voxels)
    that are close to it, i.e. for which the isocontour crosses a segment
    between them and one of their direct neighbors. This class supports
    narrowbanding. If the input narrowband is provided, the algorithm will
    only locate the level set within the input narrowband.

    Implementation of this class is based on Fast and Accurate
    Redistancing for Level Set Methods Krissian K. and Westin C.F.,
    EUROCAST NeuroImaging Workshop Las Palmas Spain, Ninth International
    Conference on Computer Aided Systems Theory , pages 48-51, Feb 2003.
    See:
     itk::simple::IsoContourDistance for the procedural interface

     itk::IsoContourDistanceImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkIsoContourDistanceImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_IsoContourDistanceImageFilter

    def __init__(self):
        r"""
        __init__(IsoContourDistanceImageFilter self) -> IsoContourDistanceImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.IsoContourDistanceImageFilter_swiginit(
            self, _SimpleITK.new_IsoContourDistanceImageFilter()
        )

    def SetLevelSetValue(self, LevelSetValue):
        r"""
        SetLevelSetValue(IsoContourDistanceImageFilter self, double LevelSetValue)


        Set/Get the value of the level set to be located. The default value is
        0.


        """
        return _SimpleITK.IsoContourDistanceImageFilter_SetLevelSetValue(
            self, LevelSetValue
        )

    def GetLevelSetValue(self):
        r"""
        GetLevelSetValue(IsoContourDistanceImageFilter self) -> double


        Set/Get the value of the level set to be located. The default value is
        0.


        """
        return _SimpleITK.IsoContourDistanceImageFilter_GetLevelSetValue(self)

    def SetFarValue(self, FarValue):
        r"""
        SetFarValue(IsoContourDistanceImageFilter self, double FarValue)


        Set/Get the value of the level set to be located. The default value is
        0.


        """
        return _SimpleITK.IsoContourDistanceImageFilter_SetFarValue(
            self, FarValue
        )

    def GetFarValue(self):
        r"""
        GetFarValue(IsoContourDistanceImageFilter self) -> double


        Set/Get the value of the level set to be located. The default value is
        0.


        """
        return _SimpleITK.IsoContourDistanceImageFilter_GetFarValue(self)

    def GetName(self):
        r"""
        GetName(IsoContourDistanceImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.IsoContourDistanceImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(IsoContourDistanceImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.IsoContourDistanceImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(IsoContourDistanceImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.IsoContourDistanceImageFilter_Execute(self, image1)


# Register IsoContourDistanceImageFilter in _SimpleITK:
_SimpleITK.IsoContourDistanceImageFilter_swigregister(
    IsoContourDistanceImageFilter
)


def IsoContourDistance(image1, levelSetValue=0.0, farValue=10):
    r"""IsoContourDistance(Image image1, double levelSetValue=0.0, double farValue=10) -> Image"""
    return _SimpleITK.IsoContourDistance(image1, levelSetValue, farValue)


class IsoDataThresholdImageFilter(ImageFilter):
    r"""


    Threshold an image using the IsoData Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the IsoDataThresholdCalculator and applies that threshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/efycla


    See:
     HistogramThresholdImageFilter

     itk::simple::IsoDataThreshold for the procedural interface

     itk::IsoDataThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkIsoDataThresholdImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_IsoDataThresholdImageFilter

    def __init__(self):
        r"""
        __init__(IsoDataThresholdImageFilter self) -> IsoDataThresholdImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.IsoDataThresholdImageFilter_swiginit(
            self, _SimpleITK.new_IsoDataThresholdImageFilter()
        )

    def SetInsideValue(self, InsideValue):
        r"""
        SetInsideValue(IsoDataThresholdImageFilter self, uint8_t InsideValue)


        Set the "inside" pixel value.


        """
        return _SimpleITK.IsoDataThresholdImageFilter_SetInsideValue(
            self, InsideValue
        )

    def GetInsideValue(self):
        r"""
        GetInsideValue(IsoDataThresholdImageFilter self) -> uint8_t


        Get the "inside" pixel value.


        """
        return _SimpleITK.IsoDataThresholdImageFilter_GetInsideValue(self)

    def SetOutsideValue(self, OutsideValue):
        r"""
        SetOutsideValue(IsoDataThresholdImageFilter self, uint8_t OutsideValue)


        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.IsoDataThresholdImageFilter_SetOutsideValue(
            self, OutsideValue
        )

    def GetOutsideValue(self):
        r"""
        GetOutsideValue(IsoDataThresholdImageFilter self) -> uint8_t


        Get the "outside" pixel value.


        """
        return _SimpleITK.IsoDataThresholdImageFilter_GetOutsideValue(self)

    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        r"""
        SetNumberOfHistogramBins(IsoDataThresholdImageFilter self, uint32_t NumberOfHistogramBins)


        Set/Get the number of histogram bins.


        """
        return _SimpleITK.IsoDataThresholdImageFilter_SetNumberOfHistogramBins(
            self, NumberOfHistogramBins
        )

    def GetNumberOfHistogramBins(self):
        r"""
        GetNumberOfHistogramBins(IsoDataThresholdImageFilter self) -> uint32_t


        """
        return _SimpleITK.IsoDataThresholdImageFilter_GetNumberOfHistogramBins(
            self
        )

    def SetMaskOutput(self, MaskOutput):
        r"""
        SetMaskOutput(IsoDataThresholdImageFilter self, bool MaskOutput)


        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.IsoDataThresholdImageFilter_SetMaskOutput(
            self, MaskOutput
        )

    def MaskOutputOn(self):
        r"""
        MaskOutputOn(IsoDataThresholdImageFilter self)


        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.IsoDataThresholdImageFilter_MaskOutputOn(self)

    def MaskOutputOff(self):
        r"""
        MaskOutputOff(IsoDataThresholdImageFilter self)


        """
        return _SimpleITK.IsoDataThresholdImageFilter_MaskOutputOff(self)

    def GetMaskOutput(self):
        r"""
        GetMaskOutput(IsoDataThresholdImageFilter self) -> bool


        """
        return _SimpleITK.IsoDataThresholdImageFilter_GetMaskOutput(self)

    def SetMaskValue(self, MaskValue):
        r"""
        SetMaskValue(IsoDataThresholdImageFilter self, uint8_t MaskValue)


        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.IsoDataThresholdImageFilter_SetMaskValue(
            self, MaskValue
        )

    def GetMaskValue(self):
        r"""
        GetMaskValue(IsoDataThresholdImageFilter self) -> uint8_t


        """
        return _SimpleITK.IsoDataThresholdImageFilter_GetMaskValue(self)

    def GetThreshold(self):
        r"""
        GetThreshold(IsoDataThresholdImageFilter self) -> double


        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.IsoDataThresholdImageFilter_GetThreshold(self)

    def GetName(self):
        r"""
        GetName(IsoDataThresholdImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.IsoDataThresholdImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(IsoDataThresholdImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.IsoDataThresholdImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(IsoDataThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(IsoDataThresholdImageFilter self, Image image) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.IsoDataThresholdImageFilter_Execute(self, *args)


# Register IsoDataThresholdImageFilter in _SimpleITK:
_SimpleITK.IsoDataThresholdImageFilter_swigregister(
    IsoDataThresholdImageFilter
)


def IsoDataThreshold(*args):
    r"""
    IsoDataThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    IsoDataThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    """
    return _SimpleITK.IsoDataThreshold(*args)


class IsolatedConnectedImageFilter(ImageFilter):
    r"""


    Label pixels that are connected to one set of seeds but not another.


    IsolatedConnectedImageFilter finds the optimal threshold to separate two regions. It has two
    modes, one to separate dark regions surrounded by bright regions by
    automatically finding a minimum isolating upper threshold, and another
    to separate bright regions surrounded by dark regions by automatically
    finding a maximum lower isolating threshold. The mode can be chosen by
    setting FindUpperThresholdOn() /Off(). In both cases, the isolating threshold is retrieved with GetIsolatedValue() .

    The algorithm labels pixels with ReplaceValue that are connected to
    Seeds1 AND NOT connected to Seeds2. When finding the threshold to
    separate two dark regions surrounded by bright regions, given a fixed
    lower threshold, the filter adjusts the upper threshold until the two
    sets of seeds are not connected. The algorithm uses a binary search to
    adjust the upper threshold, starting at Upper. The reverse is true for
    finding the threshold to separate two bright regions. Lower defaults
    to the smallest possible value for the InputImagePixelType, and Upper
    defaults to the largest possible value for the InputImagePixelType.

    The user can also supply the Lower and Upper values to restrict the
    search. However, if the range is too restrictive, it could happen that
    no isolating threshold can be found between the user specified Lower
    and Upper values. Therefore, unless the user is sure of the bounds to
    set, it is recommended that the user set these values to the lowest
    and highest intensity values in the image, respectively.

    The user can specify more than one seed for both regions to separate.
    The algorithm will try find the threshold that ensures that all of the
    first seeds are contained in the resulting segmentation and all of the
    second seeds are not contained in the segmentation.

    It is possible that the algorithm may not be able to find the
    isolating threshold because no such threshold exists. The user can
    check for this by querying the GetThresholdingFailed() flag.
    See:
     itk::simple::IsolatedConnected for the procedural interface

     itk::IsolatedConnectedImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkIsolatedConnectedImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_IsolatedConnectedImageFilter

    def __init__(self):
        r"""
        __init__(IsolatedConnectedImageFilter self) -> IsolatedConnectedImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.IsolatedConnectedImageFilter_swiginit(
            self, _SimpleITK.new_IsolatedConnectedImageFilter()
        )

    def SetSeed1(self, Seed1):
        r"""
        SetSeed1(IsolatedConnectedImageFilter self, VectorUInt32 Seed1)


             Set a single seed point 1.

        This seed will be isolated from Seed2 (if possible). All pixels
        connected to this seed will be replaced with ReplaceValue.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_SetSeed1(self, Seed1)

    def GetSeed1(self):
        r"""
        GetSeed1(IsolatedConnectedImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.IsolatedConnectedImageFilter_GetSeed1(self)

    def SetSeed2(self, Seed2):
        r"""
        SetSeed2(IsolatedConnectedImageFilter self, VectorUInt32 Seed2)


             Set a single seed point 2.

        This seed will be isolated from Seed1 (if possible).


        """
        return _SimpleITK.IsolatedConnectedImageFilter_SetSeed2(self, Seed2)

    def GetSeed2(self):
        r"""
        GetSeed2(IsolatedConnectedImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.IsolatedConnectedImageFilter_GetSeed2(self)

    def SetLower(self, Lower):
        r"""
        SetLower(IsolatedConnectedImageFilter self, double Lower)


        Set/Get the limit on the lower threshold value. The default is the
        NonpositiveMin() for the InputPixelType.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_SetLower(self, Lower)

    def GetLower(self):
        r"""
        GetLower(IsolatedConnectedImageFilter self) -> double


        Set/Get the limit on the lower threshold value. The default is the
        NonpositiveMin() for the InputPixelType.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_GetLower(self)

    def SetUpper(self, Upper):
        r"""
        SetUpper(IsolatedConnectedImageFilter self, double Upper)


        Set/Get the limit on the upper threshold value. The default is the
        max() for the InputPixelType.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_SetUpper(self, Upper)

    def GetUpper(self):
        r"""
        GetUpper(IsolatedConnectedImageFilter self) -> double


        Set/Get the limit on the upper threshold value. The default is the
        max() for the InputPixelType.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_GetUpper(self)

    def SetReplaceValue(self, ReplaceValue):
        r"""
        SetReplaceValue(IsolatedConnectedImageFilter self, uint8_t ReplaceValue)


        Set/Get value to replace thresholded pixels. Pixels that lie within
        the thresholds will be replaced with this value. The default is 1.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_SetReplaceValue(
            self, ReplaceValue
        )

    def GetReplaceValue(self):
        r"""
        GetReplaceValue(IsolatedConnectedImageFilter self) -> uint8_t


        Set/Get value to replace thresholded pixels. Pixels that lie within
        the thresholds will be replaced with this value. The default is 1.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_GetReplaceValue(self)

    def SetIsolatedValueTolerance(self, IsolatedValueTolerance):
        r"""
        SetIsolatedValueTolerance(IsolatedConnectedImageFilter self, double IsolatedValueTolerance)


        Set/Get the precision required for the intensity threshold value. The
        default is 1.


        """
        return (
            _SimpleITK.IsolatedConnectedImageFilter_SetIsolatedValueTolerance(
                self, IsolatedValueTolerance
            )
        )

    def GetIsolatedValueTolerance(self):
        r"""
        GetIsolatedValueTolerance(IsolatedConnectedImageFilter self) -> double


        Set/Get the precision required for the intensity threshold value. The
        default is 1.


        """
        return (
            _SimpleITK.IsolatedConnectedImageFilter_GetIsolatedValueTolerance(
                self
            )
        )

    def SetFindUpperThreshold(self, FindUpperThreshold):
        r"""
        SetFindUpperThreshold(IsolatedConnectedImageFilter self, bool FindUpperThreshold)


        Set/Get whether to find an upper threshold (separating two dark
        regions) or a lower threshold (separating two bright regions).


        """
        return _SimpleITK.IsolatedConnectedImageFilter_SetFindUpperThreshold(
            self, FindUpperThreshold
        )

    def FindUpperThresholdOn(self):
        r"""
        FindUpperThresholdOn(IsolatedConnectedImageFilter self)


        Set the value of FindUpperThreshold to true or false respectfully.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_FindUpperThresholdOn(
            self
        )

    def FindUpperThresholdOff(self):
        r"""
        FindUpperThresholdOff(IsolatedConnectedImageFilter self)


        """
        return _SimpleITK.IsolatedConnectedImageFilter_FindUpperThresholdOff(
            self
        )

    def GetFindUpperThreshold(self):
        r"""
        GetFindUpperThreshold(IsolatedConnectedImageFilter self) -> bool


        Set/Get whether to find an upper threshold (separating two dark
        regions) or a lower threshold (separating two bright regions).


        """
        return _SimpleITK.IsolatedConnectedImageFilter_GetFindUpperThreshold(
            self
        )

    def GetThresholdingFailed(self):
        r"""
        GetThresholdingFailed(IsolatedConnectedImageFilter self) -> bool


        Get the flag that tells whether the algorithm failed to find a
        threshold.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_GetThresholdingFailed(
            self
        )

    def GetIsolatedValue(self):
        r"""
        GetIsolatedValue(IsolatedConnectedImageFilter self) -> double


        Get value that isolates the two seeds.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_GetIsolatedValue(self)

    def GetName(self):
        r"""
        GetName(IsolatedConnectedImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.IsolatedConnectedImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(IsolatedConnectedImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.IsolatedConnectedImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(IsolatedConnectedImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.IsolatedConnectedImageFilter_Execute(self, image1)


# Register IsolatedConnectedImageFilter in _SimpleITK:
_SimpleITK.IsolatedConnectedImageFilter_swigregister(
    IsolatedConnectedImageFilter
)


def IsolatedConnected(*args, **kwargs):
    r"""IsolatedConnected(Image image1, VectorUInt32 seed1=std::vector< unsigned int >(3, 0), VectorUInt32 seed2=std::vector< unsigned int >(3, 0), double lower=0, double upper=1, uint8_t replaceValue=1, double isolatedValueTolerance=1.0, bool findUpperThreshold=True) -> Image"""
    return _SimpleITK.IsolatedConnected(*args, **kwargs)


class IsolatedWatershedImageFilter(ImageFilter):
    r"""


    Isolate watershed basins using two seeds.


    IsolatedWatershedImageFilter labels pixels with ReplaceValue1 that are in the same watershed basin
    as Seed1 AND NOT the same as Seed2. The filter adjusts the waterlevel
    until the two seeds are not in different basins. The user supplies a
    Watershed threshold. The algorithm uses a binary search to adjust the
    upper waterlevel, starting at UpperValueLimit. UpperValueLimit
    defaults to the 1.0.
    See:
     itk::simple::IsolatedWatershed for the procedural interface

     itk::IsolatedWatershedImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkIsolatedWatershedImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_IsolatedWatershedImageFilter

    def __init__(self):
        r"""
        __init__(IsolatedWatershedImageFilter self) -> IsolatedWatershedImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.IsolatedWatershedImageFilter_swiginit(
            self, _SimpleITK.new_IsolatedWatershedImageFilter()
        )

    def SetSeed1(self, Seed1):
        r"""
        SetSeed1(IsolatedWatershedImageFilter self, VectorUInt32 Seed1)


        Set seed point 1. This seed will be isolated from Seed2 (if possible).
        All pixels connected to this seed will be replaced with ReplaceValue1.


        """
        return _SimpleITK.IsolatedWatershedImageFilter_SetSeed1(self, Seed1)

    def GetSeed1(self):
        r"""
        GetSeed1(IsolatedWatershedImageFilter self) -> VectorUInt32


        Set seed point 1. This seed will be isolated from Seed2 (if possible).
        All pixels connected to this seed will be replaced with ReplaceValue1.


        """
        return _SimpleITK.IsolatedWatershedImageFilter_GetSeed1(self)

    def SetSeed2(self, Seed2):
        r"""
        SetSeed2(IsolatedWatershedImageFilter self, VectorUInt32 Seed2)


        Set seed point 2. This seed will be isolated from Seed1 (if possible).
        All pixels connected to this seed will be replaced with ReplaceValue2.


        """
        return _SimpleITK.IsolatedWatershedImageFilter_SetSeed2(self, Seed2)

    def GetSeed2(self):
        r"""
        GetSeed2(IsolatedWatershedImageFilter self) -> VectorUInt32


        Set seed point 2. This seed will be isolated from Seed1 (if possible).
        All pixels connected to this seed will be replaced with ReplaceValue2.


        """
        return _SimpleITK.IsolatedWatershedImageFilter_GetSeed2(self)

    def SetThreshold(self, Threshold):
        r"""
        SetThreshold(IsolatedWatershedImageFilter self, double Threshold)


        Set/Get the Watershed threshold. The default is 0.


        """
        return _SimpleITK.IsolatedWatershedImageFilter_SetThreshold(
            self, Threshold
        )

    def GetThreshold(self):
        r"""
        GetThreshold(IsolatedWatershedImageFilter self) -> double


        Set/Get the Watershed threshold. The default is 0.


        """
        return _SimpleITK.IsolatedWatershedImageFilter_GetThreshold(self)

    def SetUpperValueLimit(self, UpperValueLimit):
        r"""
        SetUpperValueLimit(IsolatedWatershedImageFilter self, double UpperValueLimit)


        Set/Get the limit on the upper waterlevel value. The default is 1.0.


        """
        return _SimpleITK.IsolatedWatershedImageFilter_SetUpperValueLimit(
            self, UpperValueLimit
        )

    def GetUpperValueLimit(self):
        r"""
        GetUpperValueLimit(IsolatedWatershedImageFilter self) -> double


        Set/Get the limit on the upper waterlevel value. The default is 1.0.


        """
        return _SimpleITK.IsolatedWatershedImageFilter_GetUpperValueLimit(self)

    def SetIsolatedValueTolerance(self, IsolatedValueTolerance):
        r"""
        SetIsolatedValueTolerance(IsolatedWatershedImageFilter self, double IsolatedValueTolerance)


        Set/Get the precision required for the intensity threshold value. The
        default is .001.


        """
        return (
            _SimpleITK.IsolatedWatershedImageFilter_SetIsolatedValueTolerance(
                self, IsolatedValueTolerance
            )
        )

    def GetIsolatedValueTolerance(self):
        r"""
        GetIsolatedValueTolerance(IsolatedWatershedImageFilter self) -> double


        Set/Get the precision required for the intensity threshold value. The
        default is .001.


        """
        return (
            _SimpleITK.IsolatedWatershedImageFilter_GetIsolatedValueTolerance(
                self
            )
        )

    def SetReplaceValue1(self, ReplaceValue1):
        r"""
        SetReplaceValue1(IsolatedWatershedImageFilter self, uint8_t ReplaceValue1)


        Set/Get value to replace Seed1(Seed2) pixels, pixels that are within
        the basin that contains Seed1(Seed2) this value. The default is 1(0).


        """
        return _SimpleITK.IsolatedWatershedImageFilter_SetReplaceValue1(
            self, ReplaceValue1
        )

    def GetReplaceValue1(self):
        r"""
        GetReplaceValue1(IsolatedWatershedImageFilter self) -> uint8_t


        Set/Get value to replace Seed1(Seed2) pixels, pixels that are within
        the basin that contains Seed1(Seed2) this value. The default is 1(0).


        """
        return _SimpleITK.IsolatedWatershedImageFilter_GetReplaceValue1(self)

    def SetReplaceValue2(self, ReplaceValue2):
        r"""
        SetReplaceValue2(IsolatedWatershedImageFilter self, uint8_t ReplaceValue2)


        Set/Get value to replace Seed1(Seed2) pixels, pixels that are within
        the basin that contains Seed1(Seed2) this value. The default is 1(0).


        """
        return _SimpleITK.IsolatedWatershedImageFilter_SetReplaceValue2(
            self, ReplaceValue2
        )

    def GetReplaceValue2(self):
        r"""
        GetReplaceValue2(IsolatedWatershedImageFilter self) -> uint8_t


        Set/Get value to replace Seed1(Seed2) pixels, pixels that are within
        the basin that contains Seed1(Seed2) this value. The default is 1(0).


        """
        return _SimpleITK.IsolatedWatershedImageFilter_GetReplaceValue2(self)

    def GetName(self):
        r"""
        GetName(IsolatedWatershedImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.IsolatedWatershedImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(IsolatedWatershedImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.IsolatedWatershedImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(IsolatedWatershedImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.IsolatedWatershedImageFilter_Execute(self, image1)


# Register IsolatedWatershedImageFilter in _SimpleITK:
_SimpleITK.IsolatedWatershedImageFilter_swigregister(
    IsolatedWatershedImageFilter
)


def IsolatedWatershed(*args, **kwargs):
    r"""IsolatedWatershed(Image image1, VectorUInt32 seed1=std::vector< uint32_t >(3, 0), VectorUInt32 seed2=std::vector< uint32_t >(3, 0), double threshold=0.0, double upperValueLimit=1.0, double isolatedValueTolerance=0.001, uint8_t replaceValue1=1, uint8_t replaceValue2=2) -> Image"""
    return _SimpleITK.IsolatedWatershed(*args, **kwargs)


class IterativeInverseDisplacementFieldImageFilter(ImageFilter):
    r"""


    Computes the inverse of a displacement field.


    IterativeInverseDisplacementFieldImageFilter takes a displacement field as input and computes the displacement
    field that is its inverse. If the input displacement field was mapping
    coordinates from a space A into a space B, the output of this filter
    will map coordinates from the space B into the space A.

    The algorithm implemented in this filter uses an iterative method for
    progressively refining the values of the inverse field. Starting from
    the direct field, at every pixel the direct mapping of this point is
    found, and a the negative of the current displacement is stored in the
    inverse field at the nearest pixel. Then, subsequent iterations verify
    if any of the neighbor pixels provide a better return to the current
    pixel, in which case its value is taken for updating the vector in the
    inverse field.

    This method was discussed in the users-list during February 2004.


    Corinne Mattmann

    See:
     itk::simple::IterativeInverseDisplacementField for the procedural interface

     itk::IterativeInverseDisplacementFieldImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkIterativeInverseDisplacementFieldImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_IterativeInverseDisplacementFieldImageFilter
    )

    def __init__(self):
        r"""
        __init__(IterativeInverseDisplacementFieldImageFilter self) -> IterativeInverseDisplacementFieldImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.IterativeInverseDisplacementFieldImageFilter_swiginit(
            self, _SimpleITK.new_IterativeInverseDisplacementFieldImageFilter()
        )

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(IterativeInverseDisplacementFieldImageFilter self, uint32_t NumberOfIterations)


        """
        return _SimpleITK.IterativeInverseDisplacementFieldImageFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(IterativeInverseDisplacementFieldImageFilter self) -> uint32_t


        """
        return _SimpleITK.IterativeInverseDisplacementFieldImageFilter_GetNumberOfIterations(
            self
        )

    def SetStopValue(self, StopValue):
        r"""
        SetStopValue(IterativeInverseDisplacementFieldImageFilter self, double StopValue)


        """
        return _SimpleITK.IterativeInverseDisplacementFieldImageFilter_SetStopValue(
            self, StopValue
        )

    def GetStopValue(self):
        r"""
        GetStopValue(IterativeInverseDisplacementFieldImageFilter self) -> double


        """
        return _SimpleITK.IterativeInverseDisplacementFieldImageFilter_GetStopValue(
            self
        )

    def GetName(self):
        r"""
        GetName(IterativeInverseDisplacementFieldImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.IterativeInverseDisplacementFieldImageFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(IterativeInverseDisplacementFieldImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.IterativeInverseDisplacementFieldImageFilter___str__(
            self
        )

    def Execute(self, image1):
        r"""
        Execute(IterativeInverseDisplacementFieldImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.IterativeInverseDisplacementFieldImageFilter_Execute(
            self, image1
        )


# Register IterativeInverseDisplacementFieldImageFilter in _SimpleITK:
_SimpleITK.IterativeInverseDisplacementFieldImageFilter_swigregister(
    IterativeInverseDisplacementFieldImageFilter
)


def IterativeInverseDisplacementField(
    image1, numberOfIterations=5, stopValue=0.0
):
    r"""IterativeInverseDisplacementField(Image image1, uint32_t numberOfIterations=5, double stopValue=0.0) -> Image"""
    return _SimpleITK.IterativeInverseDisplacementField(
        image1, numberOfIterations, stopValue
    )


class JoinSeriesImageFilter(ImageFilter):
    r"""


    Join N-D images into an (N+1)-D image.


    This filter is templated over the input image type and the output
    image type. The pixel type of them must be the same and the input
    dimension must be less than the output dimension. When the input
    images are N-dimensional, they are joined in order and the size of the
    N+1'th dimension of the output is same as the number of the inputs.
    The spacing and the origin (where the first input is placed) for the
    N+1'th dimension is specified in this filter. The output image
    information for the first N dimensions are taken from the first input.
    Note that all the inputs should have the same information.


    Hideaki Hiraki
     Contributed in the users list https://public.kitware.com/pipermail/insight-
    users/2004-February/006542.html


    See:
     itk::simple::JoinSeries for the procedural interface


    C++ includes: sitkJoinSeriesImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_JoinSeriesImageFilter

    def __init__(self):
        r"""
        __init__(JoinSeriesImageFilter self) -> JoinSeriesImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.JoinSeriesImageFilter_swiginit(
            self, _SimpleITK.new_JoinSeriesImageFilter()
        )

    def SetOrigin(self, Origin):
        r"""
        SetOrigin(JoinSeriesImageFilter self, double Origin)


        Set/Get origin of the new dimension


        """
        return _SimpleITK.JoinSeriesImageFilter_SetOrigin(self, Origin)

    def GetOrigin(self):
        r"""
        GetOrigin(JoinSeriesImageFilter self) -> double


        Set/Get origin of the new dimension


        """
        return _SimpleITK.JoinSeriesImageFilter_GetOrigin(self)

    def SetSpacing(self, Spacing):
        r"""
        SetSpacing(JoinSeriesImageFilter self, double Spacing)


        Set/Get spacing of the new dimension


        """
        return _SimpleITK.JoinSeriesImageFilter_SetSpacing(self, Spacing)

    def GetSpacing(self):
        r"""
        GetSpacing(JoinSeriesImageFilter self) -> double


        Set/Get spacing of the new dimension


        """
        return _SimpleITK.JoinSeriesImageFilter_GetSpacing(self)

    def GetName(self):
        r"""
        GetName(JoinSeriesImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.JoinSeriesImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(JoinSeriesImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.JoinSeriesImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(JoinSeriesImageFilter self, VectorOfImage images) -> Image
        Execute(JoinSeriesImageFilter self, Image image1) -> Image
        Execute(JoinSeriesImageFilter self, Image image1, Image image2) -> Image
        Execute(JoinSeriesImageFilter self, Image image1, Image image2, Image image3) -> Image
        Execute(JoinSeriesImageFilter self, Image image1, Image image2, Image image3, Image image4) -> Image
        Execute(JoinSeriesImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5) -> Image


        Execute the filter on the input images


        """
        return _SimpleITK.JoinSeriesImageFilter_Execute(self, *args)


# Register JoinSeriesImageFilter in _SimpleITK:
_SimpleITK.JoinSeriesImageFilter_swigregister(JoinSeriesImageFilter)


def JoinSeries(*args):
    r"""
    JoinSeries(VectorOfImage images, double origin=0.0, double spacing=1.0) -> Image
    JoinSeries(Image image1, double origin=0.0, double spacing=1.0) -> Image
    JoinSeries(Image image1, Image image2, double origin=0.0, double spacing=1.0) -> Image
    JoinSeries(Image image1, Image image2, Image image3, double origin=0.0, double spacing=1.0) -> Image
    JoinSeries(Image image1, Image image2, Image image3, Image image4, double origin=0.0, double spacing=1.0) -> Image
    JoinSeries(Image image1, Image image2, Image image3, Image image4, Image image5, double origin=0.0, double spacing=1.0) -> Image
    """
    return _SimpleITK.JoinSeries(*args)


class KittlerIllingworthThresholdImageFilter(ImageFilter):
    r"""


    Threshold an image using the KittlerIllingworth Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the KittlerIllingworthThresholdCalculator and applies that threshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/efycla


    See:
     HistogramThresholdImageFilter

     itk::simple::KittlerIllingworthThreshold for the procedural interface

     itk::KittlerIllingworthThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkKittlerIllingworthThresholdImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_KittlerIllingworthThresholdImageFilter

    def __init__(self):
        r"""
        __init__(KittlerIllingworthThresholdImageFilter self) -> KittlerIllingworthThresholdImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.KittlerIllingworthThresholdImageFilter_swiginit(
            self, _SimpleITK.new_KittlerIllingworthThresholdImageFilter()
        )

    def SetInsideValue(self, InsideValue):
        r"""
        SetInsideValue(KittlerIllingworthThresholdImageFilter self, uint8_t InsideValue)


        Set the "inside" pixel value.


        """
        return (
            _SimpleITK.KittlerIllingworthThresholdImageFilter_SetInsideValue(
                self, InsideValue
            )
        )

    def GetInsideValue(self):
        r"""
        GetInsideValue(KittlerIllingworthThresholdImageFilter self) -> uint8_t


        Get the "inside" pixel value.


        """
        return (
            _SimpleITK.KittlerIllingworthThresholdImageFilter_GetInsideValue(
                self
            )
        )

    def SetOutsideValue(self, OutsideValue):
        r"""
        SetOutsideValue(KittlerIllingworthThresholdImageFilter self, uint8_t OutsideValue)


        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return (
            _SimpleITK.KittlerIllingworthThresholdImageFilter_SetOutsideValue(
                self, OutsideValue
            )
        )

    def GetOutsideValue(self):
        r"""
        GetOutsideValue(KittlerIllingworthThresholdImageFilter self) -> uint8_t


        Get the "outside" pixel value.


        """
        return (
            _SimpleITK.KittlerIllingworthThresholdImageFilter_GetOutsideValue(
                self
            )
        )

    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        r"""
        SetNumberOfHistogramBins(KittlerIllingworthThresholdImageFilter self, uint32_t NumberOfHistogramBins)


        Set/Get the number of histogram bins.


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_SetNumberOfHistogramBins(
            self, NumberOfHistogramBins
        )

    def GetNumberOfHistogramBins(self):
        r"""
        GetNumberOfHistogramBins(KittlerIllingworthThresholdImageFilter self) -> uint32_t


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_GetNumberOfHistogramBins(
            self
        )

    def SetMaskOutput(self, MaskOutput):
        r"""
        SetMaskOutput(KittlerIllingworthThresholdImageFilter self, bool MaskOutput)


        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_SetMaskOutput(
            self, MaskOutput
        )

    def MaskOutputOn(self):
        r"""
        MaskOutputOn(KittlerIllingworthThresholdImageFilter self)


        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_MaskOutputOn(
            self
        )

    def MaskOutputOff(self):
        r"""
        MaskOutputOff(KittlerIllingworthThresholdImageFilter self)


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_MaskOutputOff(
            self
        )

    def GetMaskOutput(self):
        r"""
        GetMaskOutput(KittlerIllingworthThresholdImageFilter self) -> bool


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_GetMaskOutput(
            self
        )

    def SetMaskValue(self, MaskValue):
        r"""
        SetMaskValue(KittlerIllingworthThresholdImageFilter self, uint8_t MaskValue)


        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_SetMaskValue(
            self, MaskValue
        )

    def GetMaskValue(self):
        r"""
        GetMaskValue(KittlerIllingworthThresholdImageFilter self) -> uint8_t


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_GetMaskValue(
            self
        )

    def GetThreshold(self):
        r"""
        GetThreshold(KittlerIllingworthThresholdImageFilter self) -> double


        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_GetThreshold(
            self
        )

    def GetName(self):
        r"""
        GetName(KittlerIllingworthThresholdImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(KittlerIllingworthThresholdImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(KittlerIllingworthThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(KittlerIllingworthThresholdImageFilter self, Image image) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_Execute(
            self, *args
        )


# Register KittlerIllingworthThresholdImageFilter in _SimpleITK:
_SimpleITK.KittlerIllingworthThresholdImageFilter_swigregister(
    KittlerIllingworthThresholdImageFilter
)


def KittlerIllingworthThreshold(*args):
    r"""
    KittlerIllingworthThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    KittlerIllingworthThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    """
    return _SimpleITK.KittlerIllingworthThreshold(*args)


class LabelContourImageFilter(ImageFilter):
    r"""


    Labels the pixels on the border of the objects in a labeled image.


    LabelContourImageFilter takes a labeled image as input, where the pixels in the objects are
    the pixels with a value different of the BackgroundValue. Only the
    pixels on the contours of the objects are kept. The pixels not on the
    border are changed to BackgroundValue. The labels of the object are
    the same in the input and in the output image.

    The connectivity can be changed to minimum or maximum connectivity
    with SetFullyConnected() . Full connectivity produces thicker contours.

    https://doi.org/10.54294/c7d3gv


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     BinaryContourImageFilter

     itk::simple::LabelContour for the procedural interface

     itk::LabelContourImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelContourImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LabelContourImageFilter

    def __init__(self):
        r"""
        __init__(LabelContourImageFilter self) -> LabelContourImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LabelContourImageFilter_swiginit(
            self, _SimpleITK.new_LabelContourImageFilter()
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(LabelContourImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff.
        For objects that are 1 pixel wide, use FullyConnectedOn.



        """
        return _SimpleITK.LabelContourImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(LabelContourImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.LabelContourImageFilter_FullyConnectedOn(self)

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(LabelContourImageFilter self)


        """
        return _SimpleITK.LabelContourImageFilter_FullyConnectedOff(self)

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(LabelContourImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff.
        For objects that are 1 pixel wide, use FullyConnectedOn.



        """
        return _SimpleITK.LabelContourImageFilter_GetFullyConnected(self)

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(LabelContourImageFilter self, double BackgroundValue)


        Set/Get the background value used to identify the objects and mark the
        pixels not on the border of the objects.


        """
        return _SimpleITK.LabelContourImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(LabelContourImageFilter self) -> double


        Set/Get the background value used to identify the objects and mark the
        pixels not on the border of the objects.


        """
        return _SimpleITK.LabelContourImageFilter_GetBackgroundValue(self)

    def GetName(self):
        r"""
        GetName(LabelContourImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LabelContourImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LabelContourImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LabelContourImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(LabelContourImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.LabelContourImageFilter_Execute(self, image1)


# Register LabelContourImageFilter in _SimpleITK:
_SimpleITK.LabelContourImageFilter_swigregister(LabelContourImageFilter)


def LabelContour(image1, fullyConnected=False, backgroundValue=0):
    r"""LabelContour(Image image1, bool fullyConnected=False, double backgroundValue=0) -> Image"""
    return _SimpleITK.LabelContour(image1, fullyConnected, backgroundValue)


class LabelImageToLabelMapFilter(ImageFilter):
    r"""


    convert a labeled image to a label collection image


    LabelImageToLabelMapFilter converts a label image to a label collection image. The labels are
    the same in the input and the output image.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4


    See:
     BinaryImageToLabelMapFilter , LabelMapToLabelImageFilter

     itk::simple::LabelImageToLabelMapFilter for the procedural interface

     itk::LabelImageToLabelMapFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelImageToLabelMapFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LabelImageToLabelMapFilter

    def __init__(self):
        r"""
        __init__(LabelImageToLabelMapFilter self) -> LabelImageToLabelMapFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LabelImageToLabelMapFilter_swiginit(
            self, _SimpleITK.new_LabelImageToLabelMapFilter()
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(LabelImageToLabelMapFilter self, double BackgroundValue)


        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.LabelImageToLabelMapFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(LabelImageToLabelMapFilter self) -> double


        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.LabelImageToLabelMapFilter_GetBackgroundValue(self)

    def GetName(self):
        r"""
        GetName(LabelImageToLabelMapFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LabelImageToLabelMapFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LabelImageToLabelMapFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LabelImageToLabelMapFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(LabelImageToLabelMapFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.LabelImageToLabelMapFilter_Execute(self, image1)


# Register LabelImageToLabelMapFilter in _SimpleITK:
_SimpleITK.LabelImageToLabelMapFilter_swigregister(LabelImageToLabelMapFilter)


def LabelImageToLabelMap(image1, backgroundValue=0):
    r"""LabelImageToLabelMap(Image image1, double backgroundValue=0) -> Image"""
    return _SimpleITK.LabelImageToLabelMap(image1, backgroundValue)


class LabelIntensityStatisticsImageFilter(ImageFilter):
    r"""


    a convenient class to convert a label image to a label map and valuate
    the statistics attributes at once



    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4


    See:
     StatisticsLabelObject , LabelStatisticsOpeningImageFilter , LabelStatisticsOpeningImageFilter

     itk::LabelImageToStatisticsLabelMapFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelIntensityStatisticsImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LabelIntensityStatisticsImageFilter

    def __init__(self):
        r"""
        __init__(LabelIntensityStatisticsImageFilter self) -> LabelIntensityStatisticsImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LabelIntensityStatisticsImageFilter_swiginit(
            self, _SimpleITK.new_LabelIntensityStatisticsImageFilter()
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(LabelIntensityStatisticsImageFilter self, double BackgroundValue)


        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return (
            _SimpleITK.LabelIntensityStatisticsImageFilter_SetBackgroundValue(
                self, BackgroundValue
            )
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(LabelIntensityStatisticsImageFilter self) -> double


        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return (
            _SimpleITK.LabelIntensityStatisticsImageFilter_GetBackgroundValue(
                self
            )
        )

    def SetComputeFeretDiameter(self, ComputeFeretDiameter):
        r"""
        SetComputeFeretDiameter(LabelIntensityStatisticsImageFilter self, bool ComputeFeretDiameter)


        Set/Get whether the maximum Feret diameter should be computed or not.
        The default value is false, because of the high computation time
        required.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_SetComputeFeretDiameter(
            self, ComputeFeretDiameter
        )

    def ComputeFeretDiameterOn(self):
        r"""
        ComputeFeretDiameterOn(LabelIntensityStatisticsImageFilter self)


        Set the value of ComputeFeretDiameter to true or false respectfully.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_ComputeFeretDiameterOn(
            self
        )

    def ComputeFeretDiameterOff(self):
        r"""
        ComputeFeretDiameterOff(LabelIntensityStatisticsImageFilter self)


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_ComputeFeretDiameterOff(
            self
        )

    def GetComputeFeretDiameter(self):
        r"""
        GetComputeFeretDiameter(LabelIntensityStatisticsImageFilter self) -> bool


        Set/Get whether the maximum Feret diameter should be computed or not.
        The default value is false, because of the high computation time
        required.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetComputeFeretDiameter(
            self
        )

    def SetComputePerimeter(self, ComputePerimeter):
        r"""
        SetComputePerimeter(LabelIntensityStatisticsImageFilter self, bool ComputePerimeter)


        Set/Get whether the perimeter should be computed or not. The default
        value is false, because of the high computation time required.


        """
        return (
            _SimpleITK.LabelIntensityStatisticsImageFilter_SetComputePerimeter(
                self, ComputePerimeter
            )
        )

    def ComputePerimeterOn(self):
        r"""
        ComputePerimeterOn(LabelIntensityStatisticsImageFilter self)


        Set the value of ComputePerimeter to true or false respectfully.


        """
        return (
            _SimpleITK.LabelIntensityStatisticsImageFilter_ComputePerimeterOn(
                self
            )
        )

    def ComputePerimeterOff(self):
        r"""
        ComputePerimeterOff(LabelIntensityStatisticsImageFilter self)


        """
        return (
            _SimpleITK.LabelIntensityStatisticsImageFilter_ComputePerimeterOff(
                self
            )
        )

    def GetComputePerimeter(self):
        r"""
        GetComputePerimeter(LabelIntensityStatisticsImageFilter self) -> bool


        Set/Get whether the perimeter should be computed or not. The default
        value is false, because of the high computation time required.


        """
        return (
            _SimpleITK.LabelIntensityStatisticsImageFilter_GetComputePerimeter(
                self
            )
        )

    def SetNumberOfBins(self, NumberOfBins):
        r"""
        SetNumberOfBins(LabelIntensityStatisticsImageFilter self, uint32_t NumberOfBins)


        Set/Get the number of bins in the histogram. Note that the histogram
        is used to compute the median value, and that this option may have an
        effect on the value of the median.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_SetNumberOfBins(
            self, NumberOfBins
        )

    def GetNumberOfBins(self):
        r"""
        GetNumberOfBins(LabelIntensityStatisticsImageFilter self) -> uint32_t


        Set/Get the number of bins in the histogram. Note that the histogram
        is used to compute the median value, and that this option may have an
        effect on the value of the median.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetNumberOfBins(
            self
        )

    def GetBoundingBox(self, label):
        r"""
        GetBoundingBox(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorUInt32


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetBoundingBox(
            self, label
        )

    def GetRegion(self, label):
        r"""
        GetRegion(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorUInt32


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetRegion(
            self, label
        )

    def GetCentroid(self, label):
        r"""
        GetCentroid(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorDouble


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetCentroid(
            self, label
        )

    def GetElongation(self, label):
        r"""
        GetElongation(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetElongation(
            self, label
        )

    def GetEquivalentEllipsoidDiameter(self, label):
        r"""
        GetEquivalentEllipsoidDiameter(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorDouble


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetEquivalentEllipsoidDiameter(
            self, label
        )

    def GetEquivalentSphericalPerimeter(self, label):
        r"""
        GetEquivalentSphericalPerimeter(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetEquivalentSphericalPerimeter(
            self, label
        )

    def GetEquivalentSphericalRadius(self, label):
        r"""
        GetEquivalentSphericalRadius(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetEquivalentSphericalRadius(
            self, label
        )

    def GetFeretDiameter(self, label):
        r"""
        GetFeretDiameter(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetFeretDiameter(
            self, label
        )

    def GetFlatness(self, label):
        r"""
        GetFlatness(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetFlatness(
            self, label
        )

    def GetLabels(self):
        r"""
        GetLabels(LabelIntensityStatisticsImageFilter self) -> VectorInt64


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetLabels(self)

    def GetNumberOfPixels(self, label):
        r"""
        GetNumberOfPixels(LabelIntensityStatisticsImageFilter self, int64_t label) -> uint64_t


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return (
            _SimpleITK.LabelIntensityStatisticsImageFilter_GetNumberOfPixels(
                self, label
            )
        )

    def GetNumberOfPixelsOnBorder(self, label):
        r"""
        GetNumberOfPixelsOnBorder(LabelIntensityStatisticsImageFilter self, int64_t label) -> uint64_t


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetNumberOfPixelsOnBorder(
            self, label
        )

    def GetPerimeter(self, label):
        r"""
        GetPerimeter(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetPerimeter(
            self, label
        )

    def GetPerimeterOnBorder(self, label):
        r"""
        GetPerimeterOnBorder(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetPerimeterOnBorder(
            self, label
        )

    def GetPerimeterOnBorderRatio(self, label):
        r"""
        GetPerimeterOnBorderRatio(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetPerimeterOnBorderRatio(
            self, label
        )

    def GetPhysicalSize(self, label):
        r"""
        GetPhysicalSize(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetPhysicalSize(
            self, label
        )

    def GetPrincipalAxes(self, label):
        r"""
        GetPrincipalAxes(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorDouble


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetPrincipalAxes(
            self, label
        )

    def GetPrincipalMoments(self, label):
        r"""
        GetPrincipalMoments(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorDouble


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return (
            _SimpleITK.LabelIntensityStatisticsImageFilter_GetPrincipalMoments(
                self, label
            )
        )

    def GetRoundness(self, label):
        r"""
        GetRoundness(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetRoundness(
            self, label
        )

    def GetCenterOfGravity(self, label):
        r"""
        GetCenterOfGravity(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorDouble


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return (
            _SimpleITK.LabelIntensityStatisticsImageFilter_GetCenterOfGravity(
                self, label
            )
        )

    def GetKurtosis(self, label):
        r"""
        GetKurtosis(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetKurtosis(
            self, label
        )

    def GetMaximum(self, label):
        r"""
        GetMaximum(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetMaximum(
            self, label
        )

    def GetMaximumIndex(self, label):
        r"""
        GetMaximumIndex(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorUInt32


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetMaximumIndex(
            self, label
        )

    def GetMean(self, label):
        r"""
        GetMean(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetMean(
            self, label
        )

    def GetMedian(self, label):
        r"""
        GetMedian(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetMedian(
            self, label
        )

    def GetMinimum(self, label):
        r"""
        GetMinimum(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetMinimum(
            self, label
        )

    def GetMinimumIndex(self, label):
        r"""
        GetMinimumIndex(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorUInt32


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetMinimumIndex(
            self, label
        )

    def GetSkewness(self, label):
        r"""
        GetSkewness(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetSkewness(
            self, label
        )

    def GetStandardDeviation(self, label):
        r"""
        GetStandardDeviation(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetStandardDeviation(
            self, label
        )

    def GetSum(self, label):
        r"""
        GetSum(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetSum(
            self, label
        )

    def GetVariance(self, label):
        r"""
        GetVariance(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetVariance(
            self, label
        )

    def GetWeightedElongation(self, label):
        r"""
        GetWeightedElongation(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetWeightedElongation(
            self, label
        )

    def GetWeightedFlatness(self, label):
        r"""
        GetWeightedFlatness(LabelIntensityStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return (
            _SimpleITK.LabelIntensityStatisticsImageFilter_GetWeightedFlatness(
                self, label
            )
        )

    def GetWeightedPrincipalAxes(self, label):
        r"""
        GetWeightedPrincipalAxes(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorDouble


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetWeightedPrincipalAxes(
            self, label
        )

    def GetWeightedPrincipalMoments(self, label):
        r"""
        GetWeightedPrincipalMoments(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorDouble


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetWeightedPrincipalMoments(
            self, label
        )

    def GetName(self):
        r"""
        GetName(LabelIntensityStatisticsImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LabelIntensityStatisticsImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter___str__(self)

    def Execute(self, image, featureImage):
        r"""
        Execute(LabelIntensityStatisticsImageFilter self, Image image, Image featureImage)


        Execute the filter on the input image


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_Execute(
            self, image, featureImage
        )

    def HasLabel(self, label):
        r"""
        HasLabel(LabelIntensityStatisticsImageFilter self, int64_t label) -> bool


        Does the specified label exist? Can only be called after a call a call
        to Update().


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_HasLabel(
            self, label
        )

    def GetNumberOfLabels(self):
        r"""
        GetNumberOfLabels(LabelIntensityStatisticsImageFilter self) -> uint64_t


        Return the number of labels after execution.


        """
        return (
            _SimpleITK.LabelIntensityStatisticsImageFilter_GetNumberOfLabels(
                self
            )
        )


# Register LabelIntensityStatisticsImageFilter in _SimpleITK:
_SimpleITK.LabelIntensityStatisticsImageFilter_swigregister(
    LabelIntensityStatisticsImageFilter
)


class LabelMapContourOverlayImageFilter(ImageFilter):
    r"""


    Apply a colormap to the contours (outlines) of each object in a label
    map and superimpose it on top of the feature image.


    The feature image is typically the image from which the labeling was
    produced. Use the SetInput function to set the LabelMap , and the SetFeatureImage function to set the feature image.

    Apply a colormap to a label map and put it on top of the input image.
    The set of colors is a good selection of distinct colors. The opacity
    of the label map can be defined by the user. A background label
    produce a gray pixel with the same intensity than the input one.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4


    See:
     LabelMapOverlayImageFilter , LabelOverlayImageFilter , LabelOverlayFunctor

     LabelMapToBinaryImageFilter , LabelMapToLabelImageFilter ,

     itk::simple::LabelMapContourOverlay for the procedural interface

     itk::LabelMapContourOverlayImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelMapContourOverlayImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LabelMapContourOverlayImageFilter

    def __init__(self):
        r"""
        __init__(LabelMapContourOverlayImageFilter self) -> LabelMapContourOverlayImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LabelMapContourOverlayImageFilter_swiginit(
            self, _SimpleITK.new_LabelMapContourOverlayImageFilter()
        )

    def SetOpacity(self, Opacity):
        r"""
        SetOpacity(LabelMapContourOverlayImageFilter self, double Opacity)


        Set/Get the opacity of the colored label image. The value must be
        between 0 and 1


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_SetOpacity(
            self, Opacity
        )

    def GetOpacity(self):
        r"""
        GetOpacity(LabelMapContourOverlayImageFilter self) -> double


        Set/Get the opacity of the colored label image. The value must be
        between 0 and 1


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_GetOpacity(self)

    def SetDilationRadius(self, *args):
        r"""
        SetDilationRadius(LabelMapContourOverlayImageFilter self, VectorUInt32 DilationRadius)
        SetDilationRadius(LabelMapContourOverlayImageFilter self, unsigned int value)


        Set the values of the DilationRadius vector all to value


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_SetDilationRadius(
            self, *args
        )

    def GetDilationRadius(self):
        r"""
        GetDilationRadius(LabelMapContourOverlayImageFilter self) -> VectorUInt32


        Set/Get the object dilation radius - 0 by default.


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_GetDilationRadius(
            self
        )

    def SetContourThickness(self, ContourThickness):
        r"""
        SetContourThickness(LabelMapContourOverlayImageFilter self, VectorUInt32 ContourThickness)


        Set/Get the contour thickness - 1 by default.


        """
        return (
            _SimpleITK.LabelMapContourOverlayImageFilter_SetContourThickness(
                self, ContourThickness
            )
        )

    def GetContourThickness(self):
        r"""
        GetContourThickness(LabelMapContourOverlayImageFilter self) -> VectorUInt32


        Set/Get the contour thickness - 1 by default.


        """
        return (
            _SimpleITK.LabelMapContourOverlayImageFilter_GetContourThickness(
                self
            )
        )

    def SetSliceDimension(self, SliceDimension):
        r"""
        SetSliceDimension(LabelMapContourOverlayImageFilter self, unsigned int SliceDimension)


        Set/Get the slice dimension - defaults to image dimension - 1.


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_SetSliceDimension(
            self, SliceDimension
        )

    def GetSliceDimension(self):
        r"""
        GetSliceDimension(LabelMapContourOverlayImageFilter self) -> unsigned int


        Set/Get the slice dimension - defaults to image dimension - 1.


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_GetSliceDimension(
            self
        )

    PLAIN = _SimpleITK.LabelMapContourOverlayImageFilter_PLAIN

    CONTOUR = _SimpleITK.LabelMapContourOverlayImageFilter_CONTOUR

    SLICE_CONTOUR = _SimpleITK.LabelMapContourOverlayImageFilter_SLICE_CONTOUR

    def SetContourType(self, ContourType):
        r"""
        SetContourType(LabelMapContourOverlayImageFilter self, itk::simple::LabelMapContourOverlayImageFilter::ContourTypeType ContourType)


        Set/Get the overlay type - CONTOUR is used by default.


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_SetContourType(
            self, ContourType
        )

    def GetContourType(self):
        r"""
        GetContourType(LabelMapContourOverlayImageFilter self) -> itk::simple::LabelMapContourOverlayImageFilter::ContourTypeType


        Set/Get the overlay type - CONTOUR is used by default.


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_GetContourType(
            self
        )

    HIGH_LABEL_ON_TOP = (
        _SimpleITK.LabelMapContourOverlayImageFilter_HIGH_LABEL_ON_TOP
    )

    LOW_LABEL_ON_TOP = (
        _SimpleITK.LabelMapContourOverlayImageFilter_LOW_LABEL_ON_TOP
    )

    def SetPriority(self, Priority):
        r"""
        SetPriority(LabelMapContourOverlayImageFilter self, itk::simple::LabelMapContourOverlayImageFilter::PriorityType Priority)


        Set/Get the object priority - HIGH_LABEL_ON_TOP by default.


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_SetPriority(
            self, Priority
        )

    def GetPriority(self):
        r"""
        GetPriority(LabelMapContourOverlayImageFilter self) -> itk::simple::LabelMapContourOverlayImageFilter::PriorityType


        Set/Get the object priority - HIGH_LABEL_ON_TOP by default.


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_GetPriority(self)

    def SetColormap(self, Colormap):
        r"""
        SetColormap(LabelMapContourOverlayImageFilter self, VectorUInt8 Colormap)


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_SetColormap(
            self, Colormap
        )

    def GetColormap(self):
        r"""
        GetColormap(LabelMapContourOverlayImageFilter self) -> VectorUInt8


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_GetColormap(self)

    def GetName(self):
        r"""
        GetName(LabelMapContourOverlayImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LabelMapContourOverlayImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter___str__(self)

    def Execute(self, labelMapImage, featureImage):
        r"""
        Execute(LabelMapContourOverlayImageFilter self, Image labelMapImage, Image featureImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_Execute(
            self, labelMapImage, featureImage
        )


# Register LabelMapContourOverlayImageFilter in _SimpleITK:
_SimpleITK.LabelMapContourOverlayImageFilter_swigregister(
    LabelMapContourOverlayImageFilter
)


def LabelMapContourOverlay(*args, **kwargs):
    r"""LabelMapContourOverlay(Image labelMapImage, Image featureImage, double opacity=0.5, VectorUInt32 dilationRadius=std::vector< unsigned int >(3, 1), VectorUInt32 contourThickness=std::vector< unsigned int >(3, 1), unsigned int sliceDimension=0, itk::simple::LabelMapContourOverlayImageFilter::ContourTypeType contourType=CONTOUR, itk::simple::LabelMapContourOverlayImageFilter::PriorityType priority=HIGH_LABEL_ON_TOP, VectorUInt8 colormap=std::vector< uint8_t >()) -> Image"""
    return _SimpleITK.LabelMapContourOverlay(*args, **kwargs)


class LabelMapMaskImageFilter(ImageFilter):
    r"""


    Mask and image with a LabelMap .


    LabelMapMaskImageFilter mask the content of an input image according to the content of the
    input LabelMap . The masked pixel of the input image are set to the BackgroundValue. LabelMapMaskImageFilter can keep the input image for one label only, with Negated = false
    (the default) or it can mask the input image for a single label, when
    Negated equals true. In Both cases, the label is set with SetLabel() .


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4


    See:
     LabelMapToBinaryImageFilter , LabelMapToLabelImageFilter

     itk::simple::LabelMapMask for the procedural interface

     itk::LabelMapMaskImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelMapMaskImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LabelMapMaskImageFilter

    def __init__(self):
        r"""
        __init__(LabelMapMaskImageFilter self) -> LabelMapMaskImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LabelMapMaskImageFilter_swiginit(
            self, _SimpleITK.new_LabelMapMaskImageFilter()
        )

    def SetLabel(self, Label):
        r"""
        SetLabel(LabelMapMaskImageFilter self, uint64_t Label)


        The label to mask or to not mask, depending on the value of the
        Negated ivar.


        """
        return _SimpleITK.LabelMapMaskImageFilter_SetLabel(self, Label)

    def GetLabel(self):
        r"""
        GetLabel(LabelMapMaskImageFilter self) -> uint64_t


        The label to mask or to not mask, depending on the value of the
        Negated ivar.


        """
        return _SimpleITK.LabelMapMaskImageFilter_GetLabel(self)

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(LabelMapMaskImageFilter self, double BackgroundValue)


        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::ZeroValue() .


        """
        return _SimpleITK.LabelMapMaskImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(LabelMapMaskImageFilter self) -> double


        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::ZeroValue() .


        """
        return _SimpleITK.LabelMapMaskImageFilter_GetBackgroundValue(self)

    def SetNegated(self, Negated):
        r"""
        SetNegated(LabelMapMaskImageFilter self, bool Negated)


        Set/Get whether the Label should be masked or not.


        """
        return _SimpleITK.LabelMapMaskImageFilter_SetNegated(self, Negated)

    def NegatedOn(self):
        r"""
        NegatedOn(LabelMapMaskImageFilter self)


        Set the value of Negated to true or false respectfully.


        """
        return _SimpleITK.LabelMapMaskImageFilter_NegatedOn(self)

    def NegatedOff(self):
        r"""
        NegatedOff(LabelMapMaskImageFilter self)


        """
        return _SimpleITK.LabelMapMaskImageFilter_NegatedOff(self)

    def GetNegated(self):
        r"""
        GetNegated(LabelMapMaskImageFilter self) -> bool


        Set/Get whether the Label should be masked or not.


        """
        return _SimpleITK.LabelMapMaskImageFilter_GetNegated(self)

    def SetCrop(self, Crop):
        r"""
        SetCrop(LabelMapMaskImageFilter self, bool Crop)


        Set/Get whether the image size should be adjusted to the masked image
        or not.


        """
        return _SimpleITK.LabelMapMaskImageFilter_SetCrop(self, Crop)

    def CropOn(self):
        r"""
        CropOn(LabelMapMaskImageFilter self)


        Set the value of Crop to true or false respectfully.


        """
        return _SimpleITK.LabelMapMaskImageFilter_CropOn(self)

    def CropOff(self):
        r"""
        CropOff(LabelMapMaskImageFilter self)


        """
        return _SimpleITK.LabelMapMaskImageFilter_CropOff(self)

    def GetCrop(self):
        r"""
        GetCrop(LabelMapMaskImageFilter self) -> bool


        Set/Get whether the image size should be adjusted to the masked image
        or not.


        """
        return _SimpleITK.LabelMapMaskImageFilter_GetCrop(self)

    def SetCropBorder(self, *args):
        r"""
        SetCropBorder(LabelMapMaskImageFilter self, VectorUInt32 CropBorder)
        SetCropBorder(LabelMapMaskImageFilter self, unsigned int value)


        Set the values of the CropBorder vector all to value


        """
        return _SimpleITK.LabelMapMaskImageFilter_SetCropBorder(self, *args)

    def GetCropBorder(self):
        r"""
        GetCropBorder(LabelMapMaskImageFilter self) -> VectorUInt32


        Set/Get the border added to the mask before the crop. The default is 0
        on all the axes.


        """
        return _SimpleITK.LabelMapMaskImageFilter_GetCropBorder(self)

    def GetName(self):
        r"""
        GetName(LabelMapMaskImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LabelMapMaskImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LabelMapMaskImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LabelMapMaskImageFilter___str__(self)

    def Execute(self, labelMapImage, featureImage):
        r"""
        Execute(LabelMapMaskImageFilter self, Image labelMapImage, Image featureImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.LabelMapMaskImageFilter_Execute(
            self, labelMapImage, featureImage
        )


# Register LabelMapMaskImageFilter in _SimpleITK:
_SimpleITK.LabelMapMaskImageFilter_swigregister(LabelMapMaskImageFilter)


def LabelMapMask(*args, **kwargs):
    r"""LabelMapMask(Image labelMapImage, Image featureImage, uint64_t label=1, double backgroundValue=0, bool negated=False, bool crop=False, VectorUInt32 cropBorder=std::vector< unsigned int >(3, 0)) -> Image"""
    return _SimpleITK.LabelMapMask(*args, **kwargs)


class LabelMapOverlayImageFilter(ImageFilter):
    r"""


    Apply a colormap to a label map and superimpose it on an image.


    Apply a colormap to a label map and put it on top of the feature
    image. The feature image is typically the image from which the
    labeling was produced. Use the SetInput function to set the LabelMap , and the SetFeatureImage function to set the feature image.

    The set of colors is a good selection of distinct colors. The opacity
    of the label map can be defined by the user. A background label
    produce a gray pixel with the same intensity than the input one.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4


    See:
     LabelOverlayImageFilter , LabelOverlayFunctor

     LabelMapToRGBImageFilter , LabelMapToBinaryImageFilter , LabelMapToLabelImageFilter

     itk::simple::LabelMapOverlay for the procedural interface

     itk::LabelMapOverlayImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelMapOverlayImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LabelMapOverlayImageFilter

    def __init__(self):
        r"""
        __init__(LabelMapOverlayImageFilter self) -> LabelMapOverlayImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LabelMapOverlayImageFilter_swiginit(
            self, _SimpleITK.new_LabelMapOverlayImageFilter()
        )

    def SetOpacity(self, Opacity):
        r"""
        SetOpacity(LabelMapOverlayImageFilter self, double Opacity)


        Set/Get the opacity of the colored label image. The value must be
        between 0 and 1


        """
        return _SimpleITK.LabelMapOverlayImageFilter_SetOpacity(self, Opacity)

    def GetOpacity(self):
        r"""
        GetOpacity(LabelMapOverlayImageFilter self) -> double


        Set/Get the opacity of the colored label image. The value must be
        between 0 and 1


        """
        return _SimpleITK.LabelMapOverlayImageFilter_GetOpacity(self)

    def SetColormap(self, Colormap):
        r"""
        SetColormap(LabelMapOverlayImageFilter self, VectorUInt8 Colormap)


        """
        return _SimpleITK.LabelMapOverlayImageFilter_SetColormap(
            self, Colormap
        )

    def GetColormap(self):
        r"""
        GetColormap(LabelMapOverlayImageFilter self) -> VectorUInt8


        """
        return _SimpleITK.LabelMapOverlayImageFilter_GetColormap(self)

    def GetName(self):
        r"""
        GetName(LabelMapOverlayImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LabelMapOverlayImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LabelMapOverlayImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LabelMapOverlayImageFilter___str__(self)

    def Execute(self, labelMapImage, featureImage):
        r"""
        Execute(LabelMapOverlayImageFilter self, Image labelMapImage, Image featureImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.LabelMapOverlayImageFilter_Execute(
            self, labelMapImage, featureImage
        )


# Register LabelMapOverlayImageFilter in _SimpleITK:
_SimpleITK.LabelMapOverlayImageFilter_swigregister(LabelMapOverlayImageFilter)


def LabelMapOverlay(*args, **kwargs):
    r"""LabelMapOverlay(Image labelMapImage, Image featureImage, double opacity=0.5, VectorUInt8 colormap=std::vector< unsigned char >()) -> Image"""
    return _SimpleITK.LabelMapOverlay(*args, **kwargs)


class LabelMapToBinaryImageFilter(ImageFilter):
    r"""


    Convert a LabelMap to a binary image.


    LabelMapToBinaryImageFilter to a binary image. All the objects in the image are used as
    foreground. The background values of the original binary image can be
    restored by passing this image to the filter with the
    SetBackgroundImage() method.

    This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     LabelMapToLabelImageFilter , LabelMapMaskImageFilter

     itk::simple::LabelMapToBinary for the procedural interface

     itk::LabelMapToBinaryImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelMapToBinaryImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LabelMapToBinaryImageFilter

    def __init__(self):
        r"""
        __init__(LabelMapToBinaryImageFilter self) -> LabelMapToBinaryImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LabelMapToBinaryImageFilter_swiginit(
            self, _SimpleITK.new_LabelMapToBinaryImageFilter()
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(LabelMapToBinaryImageFilter self, double BackgroundValue)


        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.LabelMapToBinaryImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(LabelMapToBinaryImageFilter self) -> double


        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.LabelMapToBinaryImageFilter_GetBackgroundValue(self)

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(LabelMapToBinaryImageFilter self, double ForegroundValue)


        Set/Get the value used as "foreground" in the output image. Defaults
        to NumericTraits<PixelType>::max() .


        """
        return _SimpleITK.LabelMapToBinaryImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(LabelMapToBinaryImageFilter self) -> double


        Set/Get the value used as "foreground" in the output image. Defaults
        to NumericTraits<PixelType>::max() .


        """
        return _SimpleITK.LabelMapToBinaryImageFilter_GetForegroundValue(self)

    def GetName(self):
        r"""
        GetName(LabelMapToBinaryImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LabelMapToBinaryImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LabelMapToBinaryImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LabelMapToBinaryImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(LabelMapToBinaryImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.LabelMapToBinaryImageFilter_Execute(self, image1)


# Register LabelMapToBinaryImageFilter in _SimpleITK:
_SimpleITK.LabelMapToBinaryImageFilter_swigregister(
    LabelMapToBinaryImageFilter
)


def LabelMapToBinary(image1, backgroundValue=0, foregroundValue=1.0):
    r"""LabelMapToBinary(Image image1, double backgroundValue=0, double foregroundValue=1.0) -> Image"""
    return _SimpleITK.LabelMapToBinary(
        image1, backgroundValue, foregroundValue
    )


class LabelMapToLabelImageFilter(ImageFilter):
    r"""


    Converts a LabelMap to a labeled image.


    LabelMapToBinaryImageFilter to a label image.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4


    See:
     LabelMapToBinaryImageFilter , LabelMapMaskImageFilter

     itk::simple::LabelMapToLabel for the procedural interface

     itk::LabelMapToLabelImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelMapToLabelImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LabelMapToLabelImageFilter

    def __init__(self):
        r"""
        __init__(LabelMapToLabelImageFilter self) -> LabelMapToLabelImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LabelMapToLabelImageFilter_swiginit(
            self, _SimpleITK.new_LabelMapToLabelImageFilter()
        )

    def GetName(self):
        r"""
        GetName(LabelMapToLabelImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LabelMapToLabelImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LabelMapToLabelImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LabelMapToLabelImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(LabelMapToLabelImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.LabelMapToLabelImageFilter_Execute(self, image1)


# Register LabelMapToLabelImageFilter in _SimpleITK:
_SimpleITK.LabelMapToLabelImageFilter_swigregister(LabelMapToLabelImageFilter)


def LabelMapToLabel(image1):
    r"""LabelMapToLabel(Image image1) -> Image"""
    return _SimpleITK.LabelMapToLabel(image1)


class LabelMapToRGBImageFilter(ImageFilter):
    r"""


    Convert a LabelMap to a colored image.



    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4


    See:
     LabelToRGBImageFilter , LabelToRGBFunctor

     LabelMapOverlayImageFilter , LabelMapToBinaryImageFilter , LabelMapMaskImageFilter

     itk::simple::LabelMapToRGB for the procedural interface

     itk::LabelMapToRGBImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelMapToRGBImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LabelMapToRGBImageFilter

    def __init__(self):
        r"""
        __init__(LabelMapToRGBImageFilter self) -> LabelMapToRGBImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LabelMapToRGBImageFilter_swiginit(
            self, _SimpleITK.new_LabelMapToRGBImageFilter()
        )

    def SetColormap(self, Colormap):
        r"""
        SetColormap(LabelMapToRGBImageFilter self, VectorUInt8 Colormap)


        """
        return _SimpleITK.LabelMapToRGBImageFilter_SetColormap(self, Colormap)

    def GetColormap(self):
        r"""
        GetColormap(LabelMapToRGBImageFilter self) -> VectorUInt8


        """
        return _SimpleITK.LabelMapToRGBImageFilter_GetColormap(self)

    def GetName(self):
        r"""
        GetName(LabelMapToRGBImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LabelMapToRGBImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LabelMapToRGBImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LabelMapToRGBImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(LabelMapToRGBImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.LabelMapToRGBImageFilter_Execute(self, image1)


# Register LabelMapToRGBImageFilter in _SimpleITK:
_SimpleITK.LabelMapToRGBImageFilter_swigregister(LabelMapToRGBImageFilter)


def LabelMapToRGB(*args, **kwargs):
    r"""LabelMapToRGB(Image image1, VectorUInt8 colormap=std::vector< uint8_t >()) -> Image"""
    return _SimpleITK.LabelMapToRGB(*args, **kwargs)


class LabelOverlapMeasuresImageFilter(ImageFilter):
    r"""


    Computes overlap measures between the set same set of labels of pixels
    of two images. Background is assumed to be 0.


    This code was contributed in the Insight Journal paper: "Introducing
    Dice, Jaccard, and Other Label Overlap Measures To ITK" by Nicholas
    J. Tustison, James C. Gee https://doi.org/10.54294/1vixgg


    Nicholas J. Tustison

    See:
     LabelOverlapMeasuresImageFilter

     itk::LabelOverlapMeasuresImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelOverlapMeasuresImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LabelOverlapMeasuresImageFilter

    def __init__(self):
        r"""
        __init__(LabelOverlapMeasuresImageFilter self) -> LabelOverlapMeasuresImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LabelOverlapMeasuresImageFilter_swiginit(
            self, _SimpleITK.new_LabelOverlapMeasuresImageFilter()
        )

    def GetFalseNegativeError(self, *args):
        r"""
        GetFalseNegativeError(LabelOverlapMeasuresImageFilter self) -> double
        GetFalseNegativeError(LabelOverlapMeasuresImageFilter self, int64_t label) -> double


        Get the false negative error for the specified individual label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return (
            _SimpleITK.LabelOverlapMeasuresImageFilter_GetFalseNegativeError(
                self, *args
            )
        )

    def GetFalsePositiveError(self, *args):
        r"""
        GetFalsePositiveError(LabelOverlapMeasuresImageFilter self) -> double
        GetFalsePositiveError(LabelOverlapMeasuresImageFilter self, int64_t label) -> double


        Get the false positive error for the specified individual label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return (
            _SimpleITK.LabelOverlapMeasuresImageFilter_GetFalsePositiveError(
                self, *args
            )
        )

    def GetMeanOverlap(self, *args):
        r"""
        GetMeanOverlap(LabelOverlapMeasuresImageFilter self) -> double
        GetMeanOverlap(LabelOverlapMeasuresImageFilter self, int64_t label) -> double


        Get the mean overlap (Dice coefficient) for the specified individual
        label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelOverlapMeasuresImageFilter_GetMeanOverlap(
            self, *args
        )

    def GetUnionOverlap(self, *args):
        r"""
        GetUnionOverlap(LabelOverlapMeasuresImageFilter self) -> double
        GetUnionOverlap(LabelOverlapMeasuresImageFilter self, int64_t label) -> double


        Get the union overlap (Jaccard coefficient) for the specified
        individual label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelOverlapMeasuresImageFilter_GetUnionOverlap(
            self, *args
        )

    def GetVolumeSimilarity(self, *args):
        r"""
        GetVolumeSimilarity(LabelOverlapMeasuresImageFilter self) -> double
        GetVolumeSimilarity(LabelOverlapMeasuresImageFilter self, int64_t label) -> double


        Get the volume similarity for the specified individual label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelOverlapMeasuresImageFilter_GetVolumeSimilarity(
            self, *args
        )

    def GetJaccardCoefficient(self, *args):
        r"""
        GetJaccardCoefficient(LabelOverlapMeasuresImageFilter self) -> double
        GetJaccardCoefficient(LabelOverlapMeasuresImageFilter self, int64_t label) -> double


        Get the union overlap (Jaccard coefficient) for the specified
        individual label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return (
            _SimpleITK.LabelOverlapMeasuresImageFilter_GetJaccardCoefficient(
                self, *args
            )
        )

    def GetDiceCoefficient(self, *args):
        r"""
        GetDiceCoefficient(LabelOverlapMeasuresImageFilter self) -> double
        GetDiceCoefficient(LabelOverlapMeasuresImageFilter self, int64_t label) -> double


        Get the mean overlap (Dice coefficient) for the specified individual
        label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelOverlapMeasuresImageFilter_GetDiceCoefficient(
            self, *args
        )

    def GetFalseDiscoveryRate(self, *args):
        r"""
        GetFalseDiscoveryRate(LabelOverlapMeasuresImageFilter self) -> double
        GetFalseDiscoveryRate(LabelOverlapMeasuresImageFilter self, int64_t label) -> double


        Get the false discovery rate for the specified individual label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return (
            _SimpleITK.LabelOverlapMeasuresImageFilter_GetFalseDiscoveryRate(
                self, *args
            )
        )

    def GetName(self):
        r"""
        GetName(LabelOverlapMeasuresImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LabelOverlapMeasuresImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LabelOverlapMeasuresImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LabelOverlapMeasuresImageFilter___str__(self)

    def Execute(self, sourceImage, targetImage):
        r"""
        Execute(LabelOverlapMeasuresImageFilter self, Image sourceImage, Image targetImage)


        Execute the filter on the input image


        """
        return _SimpleITK.LabelOverlapMeasuresImageFilter_Execute(
            self, sourceImage, targetImage
        )


# Register LabelOverlapMeasuresImageFilter in _SimpleITK:
_SimpleITK.LabelOverlapMeasuresImageFilter_swigregister(
    LabelOverlapMeasuresImageFilter
)


class LabelOverlayImageFilter(ImageFilter):
    r"""


    Apply a colormap to a label image and put it on top of the input
    image.


    Apply a colormap to a label image and put it on top of the input
    image. The set of colors is a good selection of distinct colors. The
    opacity of the label image can be defined by the user. The user can
    also choose if the want to use a background and which label value is
    the background. A background label produce a gray pixel with the same
    intensity than the input one.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This class was contributed to the Insight Journal https://doi.org/10.54294/xr1bvx


    See:
     LabelToRGBImageFilter

     LabelMapOverlayImageFilter , LabelOverlayFunctor

     itk::simple::LabelOverlay for the procedural interface

     itk::LabelOverlayImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelOverlayImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LabelOverlayImageFilter

    def __init__(self):
        r"""
        __init__(LabelOverlayImageFilter self) -> LabelOverlayImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LabelOverlayImageFilter_swiginit(
            self, _SimpleITK.new_LabelOverlayImageFilter()
        )

    def SetOpacity(self, Opacity):
        r"""
        SetOpacity(LabelOverlayImageFilter self, double Opacity)


        Set/Get the opacity of the colored label image. The value must be
        between 0 and 1.


        """
        return _SimpleITK.LabelOverlayImageFilter_SetOpacity(self, Opacity)

    def GetOpacity(self):
        r"""
        GetOpacity(LabelOverlayImageFilter self) -> double


        Set/Get the opacity of the colored label image. The value must be
        between 0 and 1.


        """
        return _SimpleITK.LabelOverlayImageFilter_GetOpacity(self)

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(LabelOverlayImageFilter self, double BackgroundValue)


        Set/Get the background value.


        """
        return _SimpleITK.LabelOverlayImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(LabelOverlayImageFilter self) -> double


        Set/Get the background value.


        """
        return _SimpleITK.LabelOverlayImageFilter_GetBackgroundValue(self)

    def SetColormap(self, Colormap):
        r"""
        SetColormap(LabelOverlayImageFilter self, VectorUInt8 Colormap)


        """
        return _SimpleITK.LabelOverlayImageFilter_SetColormap(self, Colormap)

    def GetColormap(self):
        r"""
        GetColormap(LabelOverlayImageFilter self) -> VectorUInt8


        """
        return _SimpleITK.LabelOverlayImageFilter_GetColormap(self)

    def GetName(self):
        r"""
        GetName(LabelOverlayImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LabelOverlayImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LabelOverlayImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LabelOverlayImageFilter___str__(self)

    def Execute(self, image, labelImage):
        r"""
        Execute(LabelOverlayImageFilter self, Image image, Image labelImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.LabelOverlayImageFilter_Execute(
            self, image, labelImage
        )


# Register LabelOverlayImageFilter in _SimpleITK:
_SimpleITK.LabelOverlayImageFilter_swigregister(LabelOverlayImageFilter)


def LabelOverlay(*args, **kwargs):
    r"""LabelOverlay(Image image, Image labelImage, double opacity=0.5, double backgroundValue=0.0, VectorUInt8 colormap=std::vector< uint8_t >()) -> Image"""
    return _SimpleITK.LabelOverlay(*args, **kwargs)


class LabelShapeStatisticsImageFilter(ImageFilter):
    r"""


    Converts a label image to a label map and valuates the shape
    attributes.


    A convenient class that converts a label image to a label map and
    valuates the shape attribute at once.

    This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ShapeLabelObject , LabelShapeOpeningImageFilter , LabelStatisticsOpeningImageFilter

     itk::LabelImageToShapeLabelMapFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelShapeStatisticsImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LabelShapeStatisticsImageFilter

    def __init__(self):
        r"""
        __init__(LabelShapeStatisticsImageFilter self) -> LabelShapeStatisticsImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LabelShapeStatisticsImageFilter_swiginit(
            self, _SimpleITK.new_LabelShapeStatisticsImageFilter()
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(LabelShapeStatisticsImageFilter self, double BackgroundValue)


        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(LabelShapeStatisticsImageFilter self) -> double


        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetBackgroundValue(
            self
        )

    def SetComputeFeretDiameter(self, ComputeFeretDiameter):
        r"""
        SetComputeFeretDiameter(LabelShapeStatisticsImageFilter self, bool ComputeFeretDiameter)


        Set/Get whether the maximum Feret diameter should be computed or not.
        Default value is false, because of the high computation time required.


        """
        return (
            _SimpleITK.LabelShapeStatisticsImageFilter_SetComputeFeretDiameter(
                self, ComputeFeretDiameter
            )
        )

    def ComputeFeretDiameterOn(self):
        r"""
        ComputeFeretDiameterOn(LabelShapeStatisticsImageFilter self)


        Set the value of ComputeFeretDiameter to true or false respectfully.


        """
        return (
            _SimpleITK.LabelShapeStatisticsImageFilter_ComputeFeretDiameterOn(
                self
            )
        )

    def ComputeFeretDiameterOff(self):
        r"""
        ComputeFeretDiameterOff(LabelShapeStatisticsImageFilter self)


        """
        return (
            _SimpleITK.LabelShapeStatisticsImageFilter_ComputeFeretDiameterOff(
                self
            )
        )

    def GetComputeFeretDiameter(self):
        r"""
        GetComputeFeretDiameter(LabelShapeStatisticsImageFilter self) -> bool


        Set/Get whether the maximum Feret diameter should be computed or not.
        Default value is false, because of the high computation time required.


        """
        return (
            _SimpleITK.LabelShapeStatisticsImageFilter_GetComputeFeretDiameter(
                self
            )
        )

    def SetComputePerimeter(self, ComputePerimeter):
        r"""
        SetComputePerimeter(LabelShapeStatisticsImageFilter self, bool ComputePerimeter)


        Set/Get whether the perimeter should be computed or not. Default value
        is false, because of the high computation time required.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_SetComputePerimeter(
            self, ComputePerimeter
        )

    def ComputePerimeterOn(self):
        r"""
        ComputePerimeterOn(LabelShapeStatisticsImageFilter self)


        Set the value of ComputePerimeter to true or false respectfully.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_ComputePerimeterOn(
            self
        )

    def ComputePerimeterOff(self):
        r"""
        ComputePerimeterOff(LabelShapeStatisticsImageFilter self)


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_ComputePerimeterOff(
            self
        )

    def GetComputePerimeter(self):
        r"""
        GetComputePerimeter(LabelShapeStatisticsImageFilter self) -> bool


        Set/Get whether the perimeter should be computed or not. Default value
        is false, because of the high computation time required.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetComputePerimeter(
            self
        )

    def SetComputeOrientedBoundingBox(self, ComputeOrientedBoundingBox):
        r"""
        SetComputeOrientedBoundingBox(LabelShapeStatisticsImageFilter self, bool ComputeOrientedBoundingBox)


        Set/Get whether the oriented bounding box should be computed or not.
        Default value is false because of potential memory consumption issues
        with sparse labels.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_SetComputeOrientedBoundingBox(
            self, ComputeOrientedBoundingBox
        )

    def ComputeOrientedBoundingBoxOn(self):
        r"""
        ComputeOrientedBoundingBoxOn(LabelShapeStatisticsImageFilter self)


        Set the value of ComputeOrientedBoundingBox to true or false
        respectfully.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_ComputeOrientedBoundingBoxOn(
            self
        )

    def ComputeOrientedBoundingBoxOff(self):
        r"""
        ComputeOrientedBoundingBoxOff(LabelShapeStatisticsImageFilter self)


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_ComputeOrientedBoundingBoxOff(
            self
        )

    def GetComputeOrientedBoundingBox(self):
        r"""
        GetComputeOrientedBoundingBox(LabelShapeStatisticsImageFilter self) -> bool


        Set/Get whether the oriented bounding box should be computed or not.
        Default value is false because of potential memory consumption issues
        with sparse labels.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetComputeOrientedBoundingBox(
            self
        )

    def GetBoundingBox(self, label):
        r"""
        GetBoundingBox(LabelShapeStatisticsImageFilter self, int64_t label) -> VectorUInt32


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetBoundingBox(
            self, label
        )

    def GetRegion(self, label):
        r"""
        GetRegion(LabelShapeStatisticsImageFilter self, int64_t label) -> VectorUInt32


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetRegion(
            self, label
        )

    def GetCentroid(self, label):
        r"""
        GetCentroid(LabelShapeStatisticsImageFilter self, int64_t label) -> VectorDouble


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetCentroid(
            self, label
        )

    def GetElongation(self, label):
        r"""
        GetElongation(LabelShapeStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetElongation(
            self, label
        )

    def GetEquivalentEllipsoidDiameter(self, label):
        r"""
        GetEquivalentEllipsoidDiameter(LabelShapeStatisticsImageFilter self, int64_t label) -> VectorDouble


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetEquivalentEllipsoidDiameter(
            self, label
        )

    def GetEquivalentSphericalPerimeter(self, label):
        r"""
        GetEquivalentSphericalPerimeter(LabelShapeStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetEquivalentSphericalPerimeter(
            self, label
        )

    def GetEquivalentSphericalRadius(self, label):
        r"""
        GetEquivalentSphericalRadius(LabelShapeStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetEquivalentSphericalRadius(
            self, label
        )

    def GetFeretDiameter(self, label):
        r"""
        GetFeretDiameter(LabelShapeStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetFeretDiameter(
            self, label
        )

    def GetFlatness(self, label):
        r"""
        GetFlatness(LabelShapeStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetFlatness(
            self, label
        )

    def GetLabels(self):
        r"""
        GetLabels(LabelShapeStatisticsImageFilter self) -> VectorInt64


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetLabels(self)

    def GetNumberOfPixels(self, label):
        r"""
        GetNumberOfPixels(LabelShapeStatisticsImageFilter self, int64_t label) -> uint64_t


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetNumberOfPixels(
            self, label
        )

    def GetNumberOfPixelsOnBorder(self, label):
        r"""
        GetNumberOfPixelsOnBorder(LabelShapeStatisticsImageFilter self, int64_t label) -> uint64_t


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetNumberOfPixelsOnBorder(
            self, label
        )

    def GetPerimeter(self, label):
        r"""
        GetPerimeter(LabelShapeStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetPerimeter(
            self, label
        )

    def GetPerimeterOnBorder(self, label):
        r"""
        GetPerimeterOnBorder(LabelShapeStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetPerimeterOnBorder(
            self, label
        )

    def GetPerimeterOnBorderRatio(self, label):
        r"""
        GetPerimeterOnBorderRatio(LabelShapeStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetPerimeterOnBorderRatio(
            self, label
        )

    def GetPhysicalSize(self, label):
        r"""
        GetPhysicalSize(LabelShapeStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetPhysicalSize(
            self, label
        )

    def GetPrincipalAxes(self, label):
        r"""
        GetPrincipalAxes(LabelShapeStatisticsImageFilter self, int64_t label) -> VectorDouble


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetPrincipalAxes(
            self, label
        )

    def GetPrincipalMoments(self, label):
        r"""
        GetPrincipalMoments(LabelShapeStatisticsImageFilter self, int64_t label) -> VectorDouble


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetPrincipalMoments(
            self, label
        )

    def GetRoundness(self, label):
        r"""
        GetRoundness(LabelShapeStatisticsImageFilter self, int64_t label) -> double


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetRoundness(
            self, label
        )

    def GetOrientedBoundingBoxSize(self, label):
        r"""
        GetOrientedBoundingBoxSize(LabelShapeStatisticsImageFilter self, int64_t label) -> VectorDouble


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetOrientedBoundingBoxSize(
            self, label
        )

    def GetOrientedBoundingBoxOrigin(self, label):
        r"""
        GetOrientedBoundingBoxOrigin(LabelShapeStatisticsImageFilter self, int64_t label) -> VectorDouble


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetOrientedBoundingBoxOrigin(
            self, label
        )

    def GetOrientedBoundingBoxDirection(self, label):
        r"""
        GetOrientedBoundingBoxDirection(LabelShapeStatisticsImageFilter self, int64_t label) -> VectorDouble


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetOrientedBoundingBoxDirection(
            self, label
        )

    def GetOrientedBoundingBoxVertices(self, label):
        r"""
        GetOrientedBoundingBoxVertices(LabelShapeStatisticsImageFilter self, int64_t label) -> VectorDouble


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetOrientedBoundingBoxVertices(
            self, label
        )

    def GetIndexes(self, label):
        r"""
        GetIndexes(LabelShapeStatisticsImageFilter self, int64_t label) -> VectorUInt32


        Get an array of indexes for pixels with the label value.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetIndexes(
            self, label
        )

    def GetRLEIndexes(self, label):
        r"""
        GetRLEIndexes(LabelShapeStatisticsImageFilter self, int64_t label) -> VectorUInt32


        Get an array of run-length encoding (RLE) indexes for pixels with the
        label value. The array is the index of a starting line, followed by
        the length repeated. The length of the array is divisible by the
        image's dimension + 1. For example for a 2D image the array [ 2, 3, 2]
        would encode the two indexes [2,3] and [3,3].

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetRLEIndexes(
            self, label
        )

    def GetName(self):
        r"""
        GetName(LabelShapeStatisticsImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LabelShapeStatisticsImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(LabelShapeStatisticsImageFilter self, Image image1)


        Execute the filter on the input image


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_Execute(self, image1)

    def HasLabel(self, label):
        r"""
        HasLabel(LabelShapeStatisticsImageFilter self, int64_t label) -> bool


        Does the specified label exist? Can only be called after a call a call
        to Update().


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_HasLabel(self, label)

    def GetNumberOfLabels(self):
        r"""
        GetNumberOfLabels(LabelShapeStatisticsImageFilter self) -> uint64_t


        Return the number of labels after execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetNumberOfLabels(
            self
        )


# Register LabelShapeStatisticsImageFilter in _SimpleITK:
_SimpleITK.LabelShapeStatisticsImageFilter_swigregister(
    LabelShapeStatisticsImageFilter
)


class LabelStatisticsImageFilter(ImageFilter):
    r"""


    Given an intensity image and a label map, compute min, max, variance
    and mean of the pixels associated with each label or segment.


    LabelStatisticsImageFilter computes the minimum, maximum, sum, mean, median, variance and sigma
    of regions of an intensity image, where the regions are defined via a
    label map (a second input). The label image should be integral type.
    The filter needs all of its input image. It behaves as a filter with
    an input and output. Thus it can be inserted in a pipeline with other
    filters and the statistics will only be recomputed if a downstream
    filter changes.

    Optionally, the filter also computes intensity histograms on each
    object. If histograms are enabled, a median intensity value can also
    be computed, although its accuracy is limited to the bin width of the
    histogram. If histograms are not enabled, the median returns zero.

    This filter is automatically multi-threaded and can stream its input
    when NumberOfStreamDivisions is set to more than
    Statistics are independently computed for each streamed and threaded region then
    merged.

    See:
     itk::LabelStatisticsImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelStatisticsImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LabelStatisticsImageFilter

    def __init__(self):
        r"""
        __init__(LabelStatisticsImageFilter self) -> LabelStatisticsImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LabelStatisticsImageFilter_swiginit(
            self, _SimpleITK.new_LabelStatisticsImageFilter()
        )

    def SetUseHistograms(self, UseHistograms):
        r"""
        SetUseHistograms(LabelStatisticsImageFilter self, bool UseHistograms)


        """
        return _SimpleITK.LabelStatisticsImageFilter_SetUseHistograms(
            self, UseHistograms
        )

    def UseHistogramsOn(self):
        r"""
        UseHistogramsOn(LabelStatisticsImageFilter self)


        Set the value of UseHistograms to true or false respectfully.


        """
        return _SimpleITK.LabelStatisticsImageFilter_UseHistogramsOn(self)

    def UseHistogramsOff(self):
        r"""
        UseHistogramsOff(LabelStatisticsImageFilter self)


        """
        return _SimpleITK.LabelStatisticsImageFilter_UseHistogramsOff(self)

    def GetUseHistograms(self):
        r"""
        GetUseHistograms(LabelStatisticsImageFilter self) -> bool


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetUseHistograms(self)

    def GetMinimum(self, label):
        r"""
        GetMinimum(LabelStatisticsImageFilter self, int64_t label) -> double


        Return the computed Minimum for a label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetMinimum(self, label)

    def GetMaximum(self, label):
        r"""
        GetMaximum(LabelStatisticsImageFilter self, int64_t label) -> double


        Return the computed Maximum for a label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetMaximum(self, label)

    def GetMean(self, label):
        r"""
        GetMean(LabelStatisticsImageFilter self, int64_t label) -> double


        Return the computed Mean for a label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetMean(self, label)

    def GetMedian(self, label):
        r"""
        GetMedian(LabelStatisticsImageFilter self, int64_t label) -> double


        Return the computed Median for a label. Requires histograms to be
        enabled!

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetMedian(self, label)

    def GetSigma(self, label):
        r"""
        GetSigma(LabelStatisticsImageFilter self, int64_t label) -> double


        Return the computed Standard Deviation for a label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetSigma(self, label)

    def GetVariance(self, label):
        r"""
        GetVariance(LabelStatisticsImageFilter self, int64_t label) -> double


        Return the computed Variance for a label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetVariance(self, label)

    def GetSum(self, label):
        r"""
        GetSum(LabelStatisticsImageFilter self, int64_t label) -> double


        Return the compute Sum for a label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetSum(self, label)

    def GetCount(self, label):
        r"""
        GetCount(LabelStatisticsImageFilter self, int64_t label) -> uint64_t


        Return the number of pixels for a label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetCount(self, label)

    def GetBoundingBox(self, label):
        r"""
        GetBoundingBox(LabelStatisticsImageFilter self, int64_t label) -> VectorInt32


        Return the computed bounding box for a label. A vector of minIndex,
        maxIndex pairs for each axis. The intervals include the endpoints.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetBoundingBox(
            self, label
        )

    def GetRegion(self, label):
        r"""
        GetRegion(LabelStatisticsImageFilter self, int64_t label) -> VectorUInt32


        Return the computed region.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetRegion(self, label)

    def GetLabels(self):
        r"""
        GetLabels(LabelStatisticsImageFilter self) -> VectorInt64


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetLabels(self)

    def GetName(self):
        r"""
        GetName(LabelStatisticsImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LabelStatisticsImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LabelStatisticsImageFilter___str__(self)

    def Execute(self, image, labelImage):
        r"""
        Execute(LabelStatisticsImageFilter self, Image image, Image labelImage)


        Execute the filter on the input image


        """
        return _SimpleITK.LabelStatisticsImageFilter_Execute(
            self, image, labelImage
        )

    def HasLabel(self, label):
        r"""
        HasLabel(LabelStatisticsImageFilter self, int64_t label) -> bool


        Does the specified label exist? Can only be called after a call a call
        to Update().


        """
        return _SimpleITK.LabelStatisticsImageFilter_HasLabel(self, label)

    def GetNumberOfLabels(self):
        r"""
        GetNumberOfLabels(LabelStatisticsImageFilter self) -> uint64_t


        Return the number of labels after execution .


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetNumberOfLabels(self)


# Register LabelStatisticsImageFilter in _SimpleITK:
_SimpleITK.LabelStatisticsImageFilter_swigregister(LabelStatisticsImageFilter)


class LabelToRGBImageFilter(ImageFilter):
    r"""


    Apply a colormap to a label image.


    Apply a colormap to a label image. The set of colors is a good
    selection of distinct colors. The user can choose to use a background
    value. In that case, a gray pixel with the same intensity than the
    background label is produced.

    This code was contributed in the Insight Journal paper: "The
    watershed transform in ITK - discussion and new developments" by
    Beare R., Lehmann G. https://doi.org/10.54294/lf8u75


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    See:
     LabelOverlayImageFilter

     LabelMapToRGBImageFilter , LabelToRGBFunctor, ScalarToRGBPixelFunctor

     itk::simple::LabelToRGB for the procedural interface

     itk::LabelToRGBImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelToRGBImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LabelToRGBImageFilter

    def __init__(self):
        r"""
        __init__(LabelToRGBImageFilter self) -> LabelToRGBImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LabelToRGBImageFilter_swiginit(
            self, _SimpleITK.new_LabelToRGBImageFilter()
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(LabelToRGBImageFilter self, double BackgroundValue)


        Set/Get the background value


        """
        return _SimpleITK.LabelToRGBImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(LabelToRGBImageFilter self) -> double


        Set/Get the background value


        """
        return _SimpleITK.LabelToRGBImageFilter_GetBackgroundValue(self)

    def SetColormap(self, Colormap):
        r"""
        SetColormap(LabelToRGBImageFilter self, VectorUInt8 Colormap)


        """
        return _SimpleITK.LabelToRGBImageFilter_SetColormap(self, Colormap)

    def GetColormap(self):
        r"""
        GetColormap(LabelToRGBImageFilter self) -> VectorUInt8


        """
        return _SimpleITK.LabelToRGBImageFilter_GetColormap(self)

    def GetName(self):
        r"""
        GetName(LabelToRGBImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LabelToRGBImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LabelToRGBImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LabelToRGBImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(LabelToRGBImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.LabelToRGBImageFilter_Execute(self, image1)


# Register LabelToRGBImageFilter in _SimpleITK:
_SimpleITK.LabelToRGBImageFilter_swigregister(LabelToRGBImageFilter)


def LabelToRGB(*args, **kwargs):
    r"""LabelToRGB(Image image1, double backgroundValue=0.0, VectorUInt8 colormap=std::vector< uint8_t >()) -> Image"""
    return _SimpleITK.LabelToRGB(*args, **kwargs)


class LabelUniqueLabelMapFilter(ImageFilter):
    r"""


    Make sure that the objects are not overlapping.


    AttributeUniqueLabelMapFilter search the overlapping zones in the overlapping objects and keeps
    only a single object on all the pixels of the image. The object to
    keep is selected according to their label.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4


    See:
     AttributeLabelObject

     itk::simple::LabelUniqueLabelMapFilter for the procedural interface

     itk::LabelUniqueLabelMapFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelUniqueLabelMapFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LabelUniqueLabelMapFilter

    def __init__(self):
        r"""
        __init__(LabelUniqueLabelMapFilter self) -> LabelUniqueLabelMapFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LabelUniqueLabelMapFilter_swiginit(
            self, _SimpleITK.new_LabelUniqueLabelMapFilter()
        )

    def SetReverseOrdering(self, ReverseOrdering):
        r"""
        SetReverseOrdering(LabelUniqueLabelMapFilter self, bool ReverseOrdering)


        """
        return _SimpleITK.LabelUniqueLabelMapFilter_SetReverseOrdering(
            self, ReverseOrdering
        )

    def ReverseOrderingOn(self):
        r"""
        ReverseOrderingOn(LabelUniqueLabelMapFilter self)


        Set the value of ReverseOrdering to true or false respectfully.


        """
        return _SimpleITK.LabelUniqueLabelMapFilter_ReverseOrderingOn(self)

    def ReverseOrderingOff(self):
        r"""
        ReverseOrderingOff(LabelUniqueLabelMapFilter self)


        """
        return _SimpleITK.LabelUniqueLabelMapFilter_ReverseOrderingOff(self)

    def GetReverseOrdering(self):
        r"""
        GetReverseOrdering(LabelUniqueLabelMapFilter self) -> bool


        """
        return _SimpleITK.LabelUniqueLabelMapFilter_GetReverseOrdering(self)

    def GetName(self):
        r"""
        GetName(LabelUniqueLabelMapFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LabelUniqueLabelMapFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LabelUniqueLabelMapFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LabelUniqueLabelMapFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(LabelUniqueLabelMapFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.LabelUniqueLabelMapFilter_Execute(self, image1)


# Register LabelUniqueLabelMapFilter in _SimpleITK:
_SimpleITK.LabelUniqueLabelMapFilter_swigregister(LabelUniqueLabelMapFilter)


def LabelUniqueLabelMap(image1, reverseOrdering=False):
    r"""LabelUniqueLabelMap(Image image1, bool reverseOrdering=False) -> Image"""
    return _SimpleITK.LabelUniqueLabelMap(image1, reverseOrdering)


class LabelVotingImageFilter(ImageFilter):
    r"""


    This filter performs pixelwise voting among an arbitrary number of
    input images, where each of them represents a segmentation of the same
    scene (i.e., image).


    Label voting is a simple method of classifier combination applied to image
    segmentation. Typically, the accuracy of the combined segmentation
    exceeds the accuracy of any of the input segmentations. Voting is
    therefore commonly used as a way of boosting segmentation performance.

    The use of label voting for combination of multiple segmentations is
    described in

    T. Rohlfing and C. R. Maurer, Jr., "Multi-classifier framework for
    atlas-based image segmentation," Pattern Recognition Letters, 2005.

    INPUTS
    All input volumes to this filter must be segmentations of an image,
    that is, they must have discrete pixel values where each value
    represents a different segmented object.
     Input volumes must all contain the same size RequestedRegions. Not all input images must contain all possible labels, but all label
    values must have the same meaning in all images.

    OUTPUTS
    The voting filter produces a single output volume. Each output pixel
    contains the label that occurred most often among the labels assigned
    to this pixel in all the input volumes, that is, the label that
    received the maximum number of "votes" from the input pixels.. If
    the maximum number of votes is not unique, i.e., if more than one
    label have a maximum number of votes, an "undecided" label is
    assigned to that output pixel.
     By default, the label used for undecided pixels is the maximum label
    value used in the input images plus one. Since it is possible for an
    image with 8 bit pixel values to use all 256 possible label values, it
    is permissible to combine 8 bit (i.e., byte) images into a 16 bit
    (i.e., short) output image.

    PARAMETERS
    The label used for "undecided" labels can be set using
    SetLabelForUndecidedPixels. This functionality can be unset by calling
    UnsetLabelForUndecidedPixels.

    Torsten Rohlfing, SRI International, Neuroscience Program

    See:
     itk::simple::LabelVoting for the procedural interface


    C++ includes: sitkLabelVotingImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LabelVotingImageFilter

    def __init__(self):
        r"""
        __init__(LabelVotingImageFilter self) -> LabelVotingImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LabelVotingImageFilter_swiginit(
            self, _SimpleITK.new_LabelVotingImageFilter()
        )

    def SetLabelForUndecidedPixels(self, LabelForUndecidedPixels):
        r"""
        SetLabelForUndecidedPixels(LabelVotingImageFilter self, uint64_t LabelForUndecidedPixels)


        Set label value for undecided pixels.


        """
        return _SimpleITK.LabelVotingImageFilter_SetLabelForUndecidedPixels(
            self, LabelForUndecidedPixels
        )

    def GetLabelForUndecidedPixels(self):
        r"""
        GetLabelForUndecidedPixels(LabelVotingImageFilter self) -> uint64_t


        Get label value used for undecided pixels. After updating the filter,
        this function returns the actual label value used for undecided pixels
        in the current output. Note that this value is overwritten when
        SetLabelForUndecidedPixels is called and the new value only becomes
        effective upon the next filter update.


        """
        return _SimpleITK.LabelVotingImageFilter_GetLabelForUndecidedPixels(
            self
        )

    def GetName(self):
        r"""
        GetName(LabelVotingImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LabelVotingImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LabelVotingImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LabelVotingImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(LabelVotingImageFilter self, VectorOfImage images) -> Image
        Execute(LabelVotingImageFilter self, Image image1) -> Image
        Execute(LabelVotingImageFilter self, Image image1, Image image2) -> Image
        Execute(LabelVotingImageFilter self, Image image1, Image image2, Image image3) -> Image
        Execute(LabelVotingImageFilter self, Image image1, Image image2, Image image3, Image image4) -> Image
        Execute(LabelVotingImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5) -> Image


        Execute the filter on the input images


        """
        return _SimpleITK.LabelVotingImageFilter_Execute(self, *args)


# Register LabelVotingImageFilter in _SimpleITK:
_SimpleITK.LabelVotingImageFilter_swigregister(LabelVotingImageFilter)


def LabelVoting(*args):
    r"""
    LabelVoting(VectorOfImage images, uint64_t labelForUndecidedPixels=std::numeric_limits< uint64_t >::max()) -> Image
    LabelVoting(Image image1, uint64_t labelForUndecidedPixels=std::numeric_limits< uint64_t >::max()) -> Image
    LabelVoting(Image image1, Image image2, uint64_t labelForUndecidedPixels=std::numeric_limits< uint64_t >::max()) -> Image
    LabelVoting(Image image1, Image image2, Image image3, uint64_t labelForUndecidedPixels=std::numeric_limits< uint64_t >::max()) -> Image
    LabelVoting(Image image1, Image image2, Image image3, Image image4, uint64_t labelForUndecidedPixels=std::numeric_limits< uint64_t >::max()) -> Image
    LabelVoting(Image image1, Image image2, Image image3, Image image4, Image image5, uint64_t labelForUndecidedPixels=std::numeric_limits< uint64_t >::max()) -> Image
    """
    return _SimpleITK.LabelVoting(*args)


class LandweberDeconvolutionImageFilter(ImageFilter):
    r"""


    Deconvolve an image using the Landweber deconvolution algorithm.


    This filter implements the Landweber deconvolution algorithm as
    defined in Bertero M and Boccacci P, "Introduction to Inverse
    Problems in Imaging", 1998. The algorithm assumes that the input
    image has been formed by a linear shift-invariant system with a known
    kernel.

    The Landweber algorithm converges to a solution that minimizes the sum
    of squared errors $||f \\otimes h - g||$ where $f$ is the estimate of the unblurred image, $\\otimes$ is the convolution operator, $h$ is the blurring kernel, and $g$ is the blurred input image. As such, it is best suited for images
    that have zero-mean Gaussian white noise.

    This is the base implementation of the Landweber algorithm. It may
    produce results with negative values. For a version of this algorithm
    that enforces a positivity constraint on each intermediate solution,
    see ProjectedLandweberDeconvolutionImageFilter .

    This code was adapted from the Insight Journal contribution:

    "Deconvolution: infrastructure and reference algorithms" by Gaetan
    Lehmann https://doi.org/10.54294/tvgfv1


    Gaetan Lehmann, Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France

    Cory Quammen, The University of North Carolina at Chapel Hill

    See:
     IterativeDeconvolutionImageFilter

     RichardsonLucyDeconvolutionImageFilter

     ProjectedLandweberDeconvolutionImageFilter

     itk::simple::LandweberDeconvolution for the procedural interface

     itk::LandweberDeconvolutionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLandweberDeconvolutionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LandweberDeconvolutionImageFilter

    def __init__(self):
        r"""
        __init__(LandweberDeconvolutionImageFilter self) -> LandweberDeconvolutionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LandweberDeconvolutionImageFilter_swiginit(
            self, _SimpleITK.new_LandweberDeconvolutionImageFilter()
        )

    def SetAlpha(self, Alpha):
        r"""
        SetAlpha(LandweberDeconvolutionImageFilter self, double Alpha)


        Set/get relaxation factor.


        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_SetAlpha(
            self, Alpha
        )

    def GetAlpha(self):
        r"""
        GetAlpha(LandweberDeconvolutionImageFilter self) -> double


        Set/get relaxation factor.


        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_GetAlpha(self)

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(LandweberDeconvolutionImageFilter self, int NumberOfIterations)


        Set the number of iterations.


        """
        return (
            _SimpleITK.LandweberDeconvolutionImageFilter_SetNumberOfIterations(
                self, NumberOfIterations
            )
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(LandweberDeconvolutionImageFilter self) -> int


        Get the number of iterations.


        """
        return (
            _SimpleITK.LandweberDeconvolutionImageFilter_GetNumberOfIterations(
                self
            )
        )

    def SetNormalize(self, Normalize):
        r"""
        SetNormalize(LandweberDeconvolutionImageFilter self, bool Normalize)


        Normalize the output image by the sum of the kernel components


        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_SetNormalize(
            self, Normalize
        )

    def NormalizeOn(self):
        r"""
        NormalizeOn(LandweberDeconvolutionImageFilter self)


        Set the value of Normalize to true or false respectfully.


        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_NormalizeOn(self)

    def NormalizeOff(self):
        r"""
        NormalizeOff(LandweberDeconvolutionImageFilter self)


        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_NormalizeOff(self)

    def GetNormalize(self):
        r"""
        GetNormalize(LandweberDeconvolutionImageFilter self) -> bool


        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_GetNormalize(self)

    ZERO_PAD = _SimpleITK.LandweberDeconvolutionImageFilter_ZERO_PAD

    ZERO_FLUX_NEUMANN_PAD = (
        _SimpleITK.LandweberDeconvolutionImageFilter_ZERO_FLUX_NEUMANN_PAD
    )

    PERIODIC_PAD = _SimpleITK.LandweberDeconvolutionImageFilter_PERIODIC_PAD

    def SetBoundaryCondition(self, BoundaryCondition):
        r"""
        SetBoundaryCondition(LandweberDeconvolutionImageFilter self, itk::simple::LandweberDeconvolutionImageFilter::BoundaryConditionType BoundaryCondition)


        """
        return (
            _SimpleITK.LandweberDeconvolutionImageFilter_SetBoundaryCondition(
                self, BoundaryCondition
            )
        )

    def GetBoundaryCondition(self):
        r"""
        GetBoundaryCondition(LandweberDeconvolutionImageFilter self) -> itk::simple::LandweberDeconvolutionImageFilter::BoundaryConditionType


        """
        return (
            _SimpleITK.LandweberDeconvolutionImageFilter_GetBoundaryCondition(
                self
            )
        )

    SAME = _SimpleITK.LandweberDeconvolutionImageFilter_SAME

    VALID = _SimpleITK.LandweberDeconvolutionImageFilter_VALID

    def SetOutputRegionMode(self, OutputRegionMode):
        r"""
        SetOutputRegionMode(LandweberDeconvolutionImageFilter self, itk::simple::LandweberDeconvolutionImageFilter::OutputRegionModeType OutputRegionMode)


        """
        return (
            _SimpleITK.LandweberDeconvolutionImageFilter_SetOutputRegionMode(
                self, OutputRegionMode
            )
        )

    def GetOutputRegionMode(self):
        r"""
        GetOutputRegionMode(LandweberDeconvolutionImageFilter self) -> itk::simple::LandweberDeconvolutionImageFilter::OutputRegionModeType


        """
        return (
            _SimpleITK.LandweberDeconvolutionImageFilter_GetOutputRegionMode(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(LandweberDeconvolutionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LandweberDeconvolutionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LandweberDeconvolutionImageFilter___str__(self)

    def Execute(self, image1, image2):
        r"""
        Execute(LandweberDeconvolutionImageFilter self, Image image1, Image image2) -> Image


        Execute the filter on the input images


        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_Execute(
            self, image1, image2
        )


# Register LandweberDeconvolutionImageFilter in _SimpleITK:
_SimpleITK.LandweberDeconvolutionImageFilter_swigregister(
    LandweberDeconvolutionImageFilter
)


def LandweberDeconvolution(*args, **kwargs):
    r"""LandweberDeconvolution(Image image1, Image image2, double alpha=0.1, int numberOfIterations=1, bool normalize=False, itk::simple::LandweberDeconvolutionImageFilter::BoundaryConditionType boundaryCondition=ZERO_FLUX_NEUMANN_PAD, itk::simple::LandweberDeconvolutionImageFilter::OutputRegionModeType outputRegionMode=SAME) -> Image"""
    return _SimpleITK.LandweberDeconvolution(*args, **kwargs)


class LaplacianImageFilter(ImageFilter):
    r"""


    This filter computes the Laplacian of a scalar-valued image.


    The Laplacian is an isotropic measure of the 2nd spatial derivative of
    an image. The Laplacian of an image highlights regions of rapid
    intensity change and is therefore often used for edge detection.
    Often, the Laplacian is applied to an image that has first been
    smoothed with a Gaussian filter in order to reduce its sensitivity to
    noise.


    The Laplacian at each pixel location is computed by convolution with
    the itk::LaplacianOperator .
    Inputs and Outputs
    The input to this filter is a scalar-valued itk::Image of arbitrary dimension. The output is a scalar-valued itk::Image .

    WARNING:
    The pixel type of the input and output images must be of real type
    (float or double). ConceptChecking is used here to enforce the input
    pixel type. You will get a compilation error if the pixel type of the
    input and output images is not float or double.

    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     LaplacianOperator

     itk::simple::Laplacian for the procedural interface

     itk::LaplacianImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLaplacianImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LaplacianImageFilter

    def __init__(self):
        r"""
        __init__(LaplacianImageFilter self) -> LaplacianImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LaplacianImageFilter_swiginit(
            self, _SimpleITK.new_LaplacianImageFilter()
        )

    def SetUseImageSpacing(self, UseImageSpacing):
        r"""
        SetUseImageSpacing(LaplacianImageFilter self, bool UseImageSpacing)


        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations


        """
        return _SimpleITK.LaplacianImageFilter_SetUseImageSpacing(
            self, UseImageSpacing
        )

    def UseImageSpacingOn(self):
        r"""
        UseImageSpacingOn(LaplacianImageFilter self)


        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.LaplacianImageFilter_UseImageSpacingOn(self)

    def UseImageSpacingOff(self):
        r"""
        UseImageSpacingOff(LaplacianImageFilter self)


        """
        return _SimpleITK.LaplacianImageFilter_UseImageSpacingOff(self)

    def GetUseImageSpacing(self):
        r"""
        GetUseImageSpacing(LaplacianImageFilter self) -> bool


        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations


        """
        return _SimpleITK.LaplacianImageFilter_GetUseImageSpacing(self)

    def GetName(self):
        r"""
        GetName(LaplacianImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LaplacianImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LaplacianImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LaplacianImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(LaplacianImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.LaplacianImageFilter_Execute(self, image1)


# Register LaplacianImageFilter in _SimpleITK:
_SimpleITK.LaplacianImageFilter_swigregister(LaplacianImageFilter)


def Laplacian(image1, useImageSpacing=True):
    r"""Laplacian(Image image1, bool useImageSpacing=True) -> Image"""
    return _SimpleITK.Laplacian(image1, useImageSpacing)


class LaplacianRecursiveGaussianImageFilter(ImageFilter):
    r"""


    Computes the Laplacian of Gaussian (LoG) of an image.


    Computes the Laplacian of Gaussian (LoG) of an image by convolution
    with the second derivative of a Gaussian. This filter is implemented
    using the recursive gaussian filters.
    See:
     itk::simple::LaplacianRecursiveGaussian for the procedural interface

     itk::LaplacianRecursiveGaussianImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLaplacianRecursiveGaussianImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LaplacianRecursiveGaussianImageFilter

    def __init__(self):
        r"""
        __init__(LaplacianRecursiveGaussianImageFilter self) -> LaplacianRecursiveGaussianImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LaplacianRecursiveGaussianImageFilter_swiginit(
            self, _SimpleITK.new_LaplacianRecursiveGaussianImageFilter()
        )

    def SetSigma(self, Sigma):
        r"""
        SetSigma(LaplacianRecursiveGaussianImageFilter self, double Sigma)


        Set/Get Sigma value. Sigma is measured in the units of image spacing.


        """
        return _SimpleITK.LaplacianRecursiveGaussianImageFilter_SetSigma(
            self, Sigma
        )

    def GetSigma(self):
        r"""
        GetSigma(LaplacianRecursiveGaussianImageFilter self) -> double


        Set/Get Sigma value. Sigma is measured in the units of image spacing.


        """
        return _SimpleITK.LaplacianRecursiveGaussianImageFilter_GetSigma(self)

    def SetNormalizeAcrossScale(self, NormalizeAcrossScale):
        r"""
        SetNormalizeAcrossScale(LaplacianRecursiveGaussianImageFilter self, bool NormalizeAcrossScale)


        Define which normalization factor will be used for the Gaussian
        See:
         RecursiveGaussianImageFilter::SetNormalizeAcrossScale



        """
        return _SimpleITK.LaplacianRecursiveGaussianImageFilter_SetNormalizeAcrossScale(
            self, NormalizeAcrossScale
        )

    def NormalizeAcrossScaleOn(self):
        r"""
        NormalizeAcrossScaleOn(LaplacianRecursiveGaussianImageFilter self)


        Set the value of NormalizeAcrossScale to true or false respectfully.


        """
        return _SimpleITK.LaplacianRecursiveGaussianImageFilter_NormalizeAcrossScaleOn(
            self
        )

    def NormalizeAcrossScaleOff(self):
        r"""
        NormalizeAcrossScaleOff(LaplacianRecursiveGaussianImageFilter self)


        """
        return _SimpleITK.LaplacianRecursiveGaussianImageFilter_NormalizeAcrossScaleOff(
            self
        )

    def GetNormalizeAcrossScale(self):
        r"""
        GetNormalizeAcrossScale(LaplacianRecursiveGaussianImageFilter self) -> bool


        Define which normalization factor will be used for the Gaussian
        See:
         RecursiveGaussianImageFilter::SetNormalizeAcrossScale



        """
        return _SimpleITK.LaplacianRecursiveGaussianImageFilter_GetNormalizeAcrossScale(
            self
        )

    def GetName(self):
        r"""
        GetName(LaplacianRecursiveGaussianImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LaplacianRecursiveGaussianImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LaplacianRecursiveGaussianImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LaplacianRecursiveGaussianImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(LaplacianRecursiveGaussianImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.LaplacianRecursiveGaussianImageFilter_Execute(
            self, image1
        )


# Register LaplacianRecursiveGaussianImageFilter in _SimpleITK:
_SimpleITK.LaplacianRecursiveGaussianImageFilter_swigregister(
    LaplacianRecursiveGaussianImageFilter
)


def LaplacianRecursiveGaussian(image1, sigma=1.0, normalizeAcrossScale=False):
    r"""LaplacianRecursiveGaussian(Image image1, double sigma=1.0, bool normalizeAcrossScale=False) -> Image"""
    return _SimpleITK.LaplacianRecursiveGaussian(
        image1, sigma, normalizeAcrossScale
    )


class LaplacianSegmentationLevelSetImageFilter(ImageFilter):
    r"""


    Segments structures in images based on a second derivative image
    features.


    IMPORTANT
    The SegmentationLevelSetImageFilter class and the LaplacianSegmentationLevelSetFunction class contain additional information necessary to the full
    understanding of how to use this filter.
    OVERVIEW
    This class is a level set method segmentation filter. It constructs a
    speed function which is zero at image edges as detected by a Laplacian
    filter. The evolving level set front will therefore tend to lock onto
    zero crossings in the image. The level set front moves fastest near
    edges.

    The Laplacian segmentation filter is intended primarily as a tool for
    refining existing segmentations. The initial isosurface (as given in
    the seed input image) should ideally be very close to the segmentation
    boundary of interest. The idea is that a rough segmentation can be
    refined by allowing the isosurface to deform slightly to achieve a
    better fit to the edge features of an image. One example of such an
    application is to refine the output of a hand segmented image.

    Because values in the Laplacian feature image will tend to be low
    except near edge features, this filter is not effective for segmenting
    large image regions from small seed surfaces.
    INPUTS
    This filter requires two inputs. The first input is a seed image. This
    seed image must contain an isosurface that you want to use as the seed
    for your segmentation. It can be a binary, graylevel, or floating
    point image. The only requirement is that it contain a closed
    isosurface that you will identify as the seed by setting the
    IsosurfaceValue parameter of the filter. For a binary image you will
    want to set your isosurface value halfway between your on and off
    values (i.e. for 0's and 1's, use an isosurface value of 0.5).

    The second input is the feature image. This is the image from which
    the speed function will be calculated. For most applications, this is
    the image that you want to segment. The desired isosurface in your
    seed image should lie within the region of your feature image that you
    are trying to segment.
     Note that this filter does no preprocessing of the feature image
    before thresholding. Because second derivative calculations are highly
    sensitive to noise, isotropic or anisotropic smoothing of the feature
    image can dramatically improve the results.


    See SegmentationLevelSetImageFilter for more information on Inputs.
    OUTPUTS
    The filter outputs a single, scalar, real-valued image. Positive
    *values in the output image are inside the segmented region and
    negative *values in the image are outside of the inside region. The
    zero crossings of *the image correspond to the position of the level
    set front.

    See SparseFieldLevelSetImageFilter and SegmentationLevelSetImageFilter for more information.
    PARAMETERS
    This filter has no parameters other than those described in SegmentationLevelSetImageFilter .

    See:
     SegmentationLevelSetImageFilter

     LaplacianSegmentationLevelSetFunction ,

     SparseFieldLevelSetImageFilter

     itk::simple::LaplacianSegmentationLevelSet for the procedural interface

     itk::LaplacianSegmentationLevelSetImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLaplacianSegmentationLevelSetImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_LaplacianSegmentationLevelSetImageFilter
    )

    def __init__(self):
        r"""
        __init__(LaplacianSegmentationLevelSetImageFilter self) -> LaplacianSegmentationLevelSetImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LaplacianSegmentationLevelSetImageFilter_swiginit(
            self, _SimpleITK.new_LaplacianSegmentationLevelSetImageFilter()
        )

    def SetMaximumRMSError(self, MaximumRMSError):
        r"""
        SetMaximumRMSError(LaplacianSegmentationLevelSetImageFilter self, double MaximumRMSError)


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_SetMaximumRMSError(
            self, MaximumRMSError
        )

    def GetMaximumRMSError(self):
        r"""
        GetMaximumRMSError(LaplacianSegmentationLevelSetImageFilter self) -> double


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_GetMaximumRMSError(
            self
        )

    def SetPropagationScaling(self, PropagationScaling):
        r"""
        SetPropagationScaling(LaplacianSegmentationLevelSetImageFilter self, double PropagationScaling)


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_SetPropagationScaling(
            self, PropagationScaling
        )

    def GetPropagationScaling(self):
        r"""
        GetPropagationScaling(LaplacianSegmentationLevelSetImageFilter self) -> double


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_GetPropagationScaling(
            self
        )

    def SetCurvatureScaling(self, CurvatureScaling):
        r"""
        SetCurvatureScaling(LaplacianSegmentationLevelSetImageFilter self, double CurvatureScaling)


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_SetCurvatureScaling(
            self, CurvatureScaling
        )

    def GetCurvatureScaling(self):
        r"""
        GetCurvatureScaling(LaplacianSegmentationLevelSetImageFilter self) -> double


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_GetCurvatureScaling(
            self
        )

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(LaplacianSegmentationLevelSetImageFilter self, uint32_t NumberOfIterations)


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(LaplacianSegmentationLevelSetImageFilter self) -> uint32_t


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_GetNumberOfIterations(
            self
        )

    def SetReverseExpansionDirection(self, ReverseExpansionDirection):
        r"""
        SetReverseExpansionDirection(LaplacianSegmentationLevelSetImageFilter self, bool ReverseExpansionDirection)


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_SetReverseExpansionDirection(
            self, ReverseExpansionDirection
        )

    def ReverseExpansionDirectionOn(self):
        r"""
        ReverseExpansionDirectionOn(LaplacianSegmentationLevelSetImageFilter self)


        Set the value of ReverseExpansionDirection to true or false
        respectfully.


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_ReverseExpansionDirectionOn(
            self
        )

    def ReverseExpansionDirectionOff(self):
        r"""
        ReverseExpansionDirectionOff(LaplacianSegmentationLevelSetImageFilter self)


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_ReverseExpansionDirectionOff(
            self
        )

    def GetReverseExpansionDirection(self):
        r"""
        GetReverseExpansionDirection(LaplacianSegmentationLevelSetImageFilter self) -> bool


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_GetReverseExpansionDirection(
            self
        )

    def GetElapsedIterations(self):
        r"""
        GetElapsedIterations(LaplacianSegmentationLevelSetImageFilter self) -> uint32_t


        Number of iterations run.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_GetElapsedIterations(
            self
        )

    def GetRMSChange(self):
        r"""
        GetRMSChange(LaplacianSegmentationLevelSetImageFilter self) -> double


        The Root Mean Square of the levelset upon termination.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return (
            _SimpleITK.LaplacianSegmentationLevelSetImageFilter_GetRMSChange(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(LaplacianSegmentationLevelSetImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(LaplacianSegmentationLevelSetImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter___str__(
            self
        )

    def Execute(self, initialImage, featureImage):
        r"""
        Execute(LaplacianSegmentationLevelSetImageFilter self, Image initialImage, Image featureImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_Execute(
            self, initialImage, featureImage
        )


# Register LaplacianSegmentationLevelSetImageFilter in _SimpleITK:
_SimpleITK.LaplacianSegmentationLevelSetImageFilter_swigregister(
    LaplacianSegmentationLevelSetImageFilter
)


def LaplacianSegmentationLevelSet(
    initialImage,
    featureImage,
    maximumRMSError=0.02,
    propagationScaling=1.0,
    curvatureScaling=1.0,
    numberOfIterations=1000,
    reverseExpansionDirection=False,
):
    r"""LaplacianSegmentationLevelSet(Image initialImage, Image featureImage, double maximumRMSError=0.02, double propagationScaling=1.0, double curvatureScaling=1.0, uint32_t numberOfIterations=1000, bool reverseExpansionDirection=False) -> Image"""
    return _SimpleITK.LaplacianSegmentationLevelSet(
        initialImage,
        featureImage,
        maximumRMSError,
        propagationScaling,
        curvatureScaling,
        numberOfIterations,
        reverseExpansionDirection,
    )


class LaplacianSharpeningImageFilter(ImageFilter):
    r"""


    This filter sharpens an image using a Laplacian. LaplacianSharpening
    highlights regions of rapid intensity change and therefore highlights
    or enhances the edges. The result is an image that appears more in
    focus.


    The LaplacianSharpening at each pixel location is computed by
    convolution with the itk::LaplacianOperator .
    Inputs and Outputs
    The input to this filter is a scalar-valued itk::Image of arbitrary dimension. The output is a scalar-valued itk::Image .

    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     LaplacianOperator

     itk::simple::LaplacianSharpening for the procedural interface

     itk::LaplacianSharpeningImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLaplacianSharpeningImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LaplacianSharpeningImageFilter

    def __init__(self):
        r"""
        __init__(LaplacianSharpeningImageFilter self) -> LaplacianSharpeningImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LaplacianSharpeningImageFilter_swiginit(
            self, _SimpleITK.new_LaplacianSharpeningImageFilter()
        )

    def SetUseImageSpacing(self, UseImageSpacing):
        r"""
        SetUseImageSpacing(LaplacianSharpeningImageFilter self, bool UseImageSpacing)


        Set/Get whether or not the filter will use the spacing information of
        the input image in its calculations. Use this option if derivatives
        are required in physical space.


        """
        return _SimpleITK.LaplacianSharpeningImageFilter_SetUseImageSpacing(
            self, UseImageSpacing
        )

    def UseImageSpacingOn(self):
        r"""
        UseImageSpacingOn(LaplacianSharpeningImageFilter self)


        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.LaplacianSharpeningImageFilter_UseImageSpacingOn(
            self
        )

    def UseImageSpacingOff(self):
        r"""
        UseImageSpacingOff(LaplacianSharpeningImageFilter self)


        """
        return _SimpleITK.LaplacianSharpeningImageFilter_UseImageSpacingOff(
            self
        )

    def GetUseImageSpacing(self):
        r"""
        GetUseImageSpacing(LaplacianSharpeningImageFilter self) -> bool


        Set/Get whether or not the filter will use the spacing information of
        the input image in its calculations. Use this option if derivatives
        are required in physical space.


        """
        return _SimpleITK.LaplacianSharpeningImageFilter_GetUseImageSpacing(
            self
        )

    def GetName(self):
        r"""
        GetName(LaplacianSharpeningImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LaplacianSharpeningImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LaplacianSharpeningImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LaplacianSharpeningImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(LaplacianSharpeningImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.LaplacianSharpeningImageFilter_Execute(self, image1)


# Register LaplacianSharpeningImageFilter in _SimpleITK:
_SimpleITK.LaplacianSharpeningImageFilter_swigregister(
    LaplacianSharpeningImageFilter
)


def LaplacianSharpening(image1, useImageSpacing=True):
    r"""LaplacianSharpening(Image image1, bool useImageSpacing=True) -> Image"""
    return _SimpleITK.LaplacianSharpening(image1, useImageSpacing)


class LessEqualImageFilter(ImageFilter):
    r"""


    Implements pixel-wise generic operation of two images, or of an image
    and a constant.


    This class is parameterized over the types of the two input images and
    the type of the output image. It is also parameterized by the
    operation to be applied. A Functor style is used.

    The constant must be of the same type than the pixel type of the
    corresponding image. It is wrapped in a SimpleDataObjectDecorator so it can be updated through the pipeline. The SetConstant() and
    GetConstant() methods are provided as shortcuts to set or get the
    constant value without manipulating the decorator.


    See:
     BinaryGeneratorImagFilter

     UnaryFunctorImageFilter TernaryFunctorImageFilter

     itk::simple::LessEqual for the procedural interface

     itk::BinaryFunctorImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLessEqualImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LessEqualImageFilter

    def __init__(self):
        r"""
        __init__(LessEqualImageFilter self) -> LessEqualImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LessEqualImageFilter_swiginit(
            self, _SimpleITK.new_LessEqualImageFilter()
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(LessEqualImageFilter self, uint8_t BackgroundValue)


        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.LessEqualImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(LessEqualImageFilter self) -> uint8_t


        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.LessEqualImageFilter_GetBackgroundValue(self)

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(LessEqualImageFilter self, uint8_t ForegroundValue)


        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.LessEqualImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(LessEqualImageFilter self) -> uint8_t


        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.LessEqualImageFilter_GetForegroundValue(self)

    def GetName(self):
        r"""
        GetName(LessEqualImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LessEqualImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LessEqualImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LessEqualImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(LessEqualImageFilter self, Image image1, Image image2) -> Image
        Execute(LessEqualImageFilter self, Image image1, double constant) -> Image
        Execute(LessEqualImageFilter self, double constant, Image image2) -> Image
        Execute(LessEqualImageFilter self, Image image1, double constant, uint8_t backgroundValue, uint8_t foregroundValue) -> Image
        Execute(LessEqualImageFilter self, double constant, Image image2, uint8_t backgroundValue, uint8_t foregroundValue) -> Image


        """
        return _SimpleITK.LessEqualImageFilter_Execute(self, *args)


# Register LessEqualImageFilter in _SimpleITK:
_SimpleITK.LessEqualImageFilter_swigregister(LessEqualImageFilter)


def LessEqual(*args):
    r"""
    LessEqual(Image image1, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    LessEqual(Image image1, double constant, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    LessEqual(double constant, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image


    """
    return _SimpleITK.LessEqual(*args)


class LessImageFilter(ImageFilter):
    r"""


    Implements pixel-wise generic operation of two images, or of an image
    and a constant.


    This class is parameterized over the types of the two input images and
    the type of the output image. It is also parameterized by the
    operation to be applied. A Functor style is used.

    The constant must be of the same type than the pixel type of the
    corresponding image. It is wrapped in a SimpleDataObjectDecorator so it can be updated through the pipeline. The SetConstant() and
    GetConstant() methods are provided as shortcuts to set or get the
    constant value without manipulating the decorator.


    See:
     BinaryGeneratorImagFilter

     UnaryFunctorImageFilter TernaryFunctorImageFilter

     itk::simple::Less for the procedural interface

     itk::BinaryFunctorImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLessImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LessImageFilter

    def __init__(self):
        r"""
        __init__(LessImageFilter self) -> LessImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LessImageFilter_swiginit(
            self, _SimpleITK.new_LessImageFilter()
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(LessImageFilter self, uint8_t BackgroundValue)


        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.LessImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(LessImageFilter self) -> uint8_t


        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.LessImageFilter_GetBackgroundValue(self)

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(LessImageFilter self, uint8_t ForegroundValue)


        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.LessImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(LessImageFilter self) -> uint8_t


        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.LessImageFilter_GetForegroundValue(self)

    def GetName(self):
        r"""
        GetName(LessImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LessImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LessImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LessImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(LessImageFilter self, Image image1, Image image2) -> Image
        Execute(LessImageFilter self, Image image1, double constant) -> Image
        Execute(LessImageFilter self, double constant, Image image2) -> Image
        Execute(LessImageFilter self, Image image1, double constant, uint8_t backgroundValue, uint8_t foregroundValue) -> Image
        Execute(LessImageFilter self, double constant, Image image2, uint8_t backgroundValue, uint8_t foregroundValue) -> Image


        """
        return _SimpleITK.LessImageFilter_Execute(self, *args)


# Register LessImageFilter in _SimpleITK:
_SimpleITK.LessImageFilter_swigregister(LessImageFilter)


def Less(*args):
    r"""
    Less(Image image1, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    Less(Image image1, double constant, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    Less(double constant, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image


    """
    return _SimpleITK.Less(*args)


class LevelSetMotionRegistrationFilter(ImageFilter):
    r"""


    Deformably register two images using level set motion.


    LevelSetMotionFilter implements a deformable registration algorithm
    that aligns a fixed and a moving image under level set motion. The
    equations of motion are similar to those of the DemonsRegistrationFilter . The main differences are: (1) Gradients of the moving image are
    calculated on a smoothed image while intensity difference are measured
    on the original images (2) Magnitude of the motion vector is a
    function of the differences in intensity between the fixed and moving
    pixel. An adaptive timestep is calculated based on the maximum motion
    vector over the entire field to ensure stability. The timestep also
    implicitly converts the motion vector measured in units of intensity
    to a vector measured in physical units. Demons, on the other hand,
    defines its motion vectors as function of both the intensity
    differences and gradient magnitude at each respective pixel. Consider
    two separate pixels with the same intensity differences between the
    corresponding fixed and moving pixel pairs. In demons, the motion
    vector of the pixel over a low gradient region will be larger than the
    motion vector of the pixel over a large gradient region. This leads to
    an unstable vector field. In the levelset approach, the motion vectors
    will be proportional to the gradients, scaled by the maximum gradient
    over the entire field. The pixel with at the lower gradient position
    will more less than the pixel at the higher gradient position. (3)
    Gradients are calculated using minmod finite difference instead of
    using central differences.

    A deformation field is represented as a image whose pixel type is some
    vector type with at least N elements, where N is the dimension of the
    fixed image. The vector type must support element access via operator
    []. It is assumed that the vector elements behave like floating point
    scalars.

    This class is templated over the fixed image type, moving image type
    and the deformation field type.

    The input fixed and moving images are set via methods SetFixedImage
    and SetMovingImage respectively. An initial deformation field maybe
    set via SetInitialDisplacementField or SetInput. If no initial field
    is set, a zero field is used as the initial condition.

    The algorithm has one parameters: the number of iteration to be
    performed.

    The output deformation field can be obtained via methods GetOutput or
    GetDisplacementField.

    This class make use of the finite difference solver hierarchy. Update
    for each iteration is computed in LevelSetMotionFunction.


    WARNING:
    This filter assumes that the fixed image type, moving image type and
    deformation field type all have the same number of dimensions.
     Ref: B.C. Vemuri, J. Ye, Y. Chen, C.M. Leonard. " Image registration via level-set motion: applications to atlas-based
    segmentation". Medical Image Analysis. Vol. 7. pp. 1-20. 2003.


    See:
     LevelSetMotionRegistrationFunction

     DemonsRegistrationFilter

     itk::LevelSetMotionRegistrationFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLevelSetMotionRegistrationFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LevelSetMotionRegistrationFilter

    def __init__(self):
        r"""
        __init__(LevelSetMotionRegistrationFilter self) -> LevelSetMotionRegistrationFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LevelSetMotionRegistrationFilter_swiginit(
            self, _SimpleITK.new_LevelSetMotionRegistrationFilter()
        )

    def SetGradientSmoothingStandardDeviations(
        self, GradientSmoothingStandardDeviations
    ):
        r"""
        SetGradientSmoothingStandardDeviations(LevelSetMotionRegistrationFilter self, double GradientSmoothingStandardDeviations)


        Set/Get the standard deviation used for smoothing the moving image
        prior to calculating gradients. The standard deviation is measured in
        physical units (for instance mm). Note that this smoothing value is
        not to be confused with the PDEDeformableRegistrationFilter::SetStandardDeviations() method. The method in PDEDeformableRegistrationFilter is for setting the smoothing parameters for regularizing the
        deformation field between iterations. Those smoothing parameters are
        set in pixel units not physical units. Deformation field smoothing is
        not done by default in LevelSetMotionRegistration. This smoothing
        parameter is to condition the gradient calculation and parameter is
        specified in physical units.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetGradientSmoothingStandardDeviations(
            self, GradientSmoothingStandardDeviations
        )

    def GetGradientSmoothingStandardDeviations(self):
        r"""
        GetGradientSmoothingStandardDeviations(LevelSetMotionRegistrationFilter self) -> double


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetGradientSmoothingStandardDeviations(
            self
        )

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(LevelSetMotionRegistrationFilter self, uint32_t NumberOfIterations)


        """
        return (
            _SimpleITK.LevelSetMotionRegistrationFilter_SetNumberOfIterations(
                self, NumberOfIterations
            )
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(LevelSetMotionRegistrationFilter self) -> uint32_t


        """
        return (
            _SimpleITK.LevelSetMotionRegistrationFilter_GetNumberOfIterations(
                self
            )
        )

    def SetMaximumRMSError(self, MaximumRMSError):
        r"""
        SetMaximumRMSError(LevelSetMotionRegistrationFilter self, double MaximumRMSError)


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetMaximumRMSError(
            self, MaximumRMSError
        )

    def GetMaximumRMSError(self):
        r"""
        GetMaximumRMSError(LevelSetMotionRegistrationFilter self) -> double


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetMaximumRMSError(
            self
        )

    def SetStandardDeviations(self, *args):
        r"""
        SetStandardDeviations(LevelSetMotionRegistrationFilter self, VectorDouble StandardDeviations)
        SetStandardDeviations(LevelSetMotionRegistrationFilter self, double value)


        Set/Get the Gaussian smoothing standard deviations for the
        displacement field. The values are set with respect to pixel
        coordinates.


        """
        return (
            _SimpleITK.LevelSetMotionRegistrationFilter_SetStandardDeviations(
                self, *args
            )
        )

    def GetStandardDeviations(self):
        r"""
        GetStandardDeviations(LevelSetMotionRegistrationFilter self) -> VectorDouble


        Set/Get the Gaussian smoothing standard deviations for the
        displacement field. The values are set with respect to pixel
        coordinates.


        """
        return (
            _SimpleITK.LevelSetMotionRegistrationFilter_GetStandardDeviations(
                self
            )
        )

    def SetSmoothDisplacementField(self, SmoothDisplacementField):
        r"""
        SetSmoothDisplacementField(LevelSetMotionRegistrationFilter self, bool SmoothDisplacementField)


        Set/Get whether the displacement field is smoothed (regularized).
        Smoothing the displacement yields a solution elastic in nature. If
        SmoothDisplacementField is on, then the displacement field is smoothed
        with a Gaussian whose standard deviations are specified with SetStandardDeviations()


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetSmoothDisplacementField(
            self, SmoothDisplacementField
        )

    def SmoothDisplacementFieldOn(self):
        r"""
        SmoothDisplacementFieldOn(LevelSetMotionRegistrationFilter self)


        Set the value of SmoothDisplacementField to true or false
        respectfully.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SmoothDisplacementFieldOn(
            self
        )

    def SmoothDisplacementFieldOff(self):
        r"""
        SmoothDisplacementFieldOff(LevelSetMotionRegistrationFilter self)


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SmoothDisplacementFieldOff(
            self
        )

    def GetSmoothDisplacementField(self):
        r"""
        GetSmoothDisplacementField(LevelSetMotionRegistrationFilter self) -> bool


        Set/Get whether the displacement field is smoothed (regularized).
        Smoothing the displacement yields a solution elastic in nature. If
        SmoothDisplacementField is on, then the displacement field is smoothed
        with a Gaussian whose standard deviations are specified with SetStandardDeviations()


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetSmoothDisplacementField(
            self
        )

    def SetUpdateFieldStandardDeviations(self, *args):
        r"""
        SetUpdateFieldStandardDeviations(LevelSetMotionRegistrationFilter self, VectorDouble UpdateFieldStandardDeviations)
        SetUpdateFieldStandardDeviations(LevelSetMotionRegistrationFilter self, double value)


        Set the Gaussian smoothing standard deviations for the update field.
        The values are set with respect to pixel coordinates.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetUpdateFieldStandardDeviations(
            self, *args
        )

    def GetUpdateFieldStandardDeviations(self):
        r"""
        GetUpdateFieldStandardDeviations(LevelSetMotionRegistrationFilter self) -> VectorDouble


        Set the Gaussian smoothing standard deviations for the update field.
        The values are set with respect to pixel coordinates.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetUpdateFieldStandardDeviations(
            self
        )

    def SetSmoothUpdateField(self, SmoothUpdateField):
        r"""
        SetSmoothUpdateField(LevelSetMotionRegistrationFilter self, bool SmoothUpdateField)


        Set/Get whether the update field is smoothed (regularized). Smoothing
        the update field yields a solution viscous in nature. If
        SmoothUpdateField is on, then the update field is smoothed with a
        Gaussian whose standard deviations are specified with SetUpdateFieldStandardDeviations()


        """
        return (
            _SimpleITK.LevelSetMotionRegistrationFilter_SetSmoothUpdateField(
                self, SmoothUpdateField
            )
        )

    def SmoothUpdateFieldOn(self):
        r"""
        SmoothUpdateFieldOn(LevelSetMotionRegistrationFilter self)


        Set the value of SmoothUpdateField to true or false respectfully.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SmoothUpdateFieldOn(
            self
        )

    def SmoothUpdateFieldOff(self):
        r"""
        SmoothUpdateFieldOff(LevelSetMotionRegistrationFilter self)


        """
        return (
            _SimpleITK.LevelSetMotionRegistrationFilter_SmoothUpdateFieldOff(
                self
            )
        )

    def GetSmoothUpdateField(self):
        r"""
        GetSmoothUpdateField(LevelSetMotionRegistrationFilter self) -> bool


        Set/Get whether the update field is smoothed (regularized). Smoothing
        the update field yields a solution viscous in nature. If
        SmoothUpdateField is on, then the update field is smoothed with a
        Gaussian whose standard deviations are specified with SetUpdateFieldStandardDeviations()


        """
        return (
            _SimpleITK.LevelSetMotionRegistrationFilter_GetSmoothUpdateField(
                self
            )
        )

    def SetMaximumKernelWidth(self, MaximumKernelWidth):
        r"""
        SetMaximumKernelWidth(LevelSetMotionRegistrationFilter self, unsigned int MaximumKernelWidth)


        Set/Get the desired limits of the Gaussian kernel width.


        """
        return (
            _SimpleITK.LevelSetMotionRegistrationFilter_SetMaximumKernelWidth(
                self, MaximumKernelWidth
            )
        )

    def GetMaximumKernelWidth(self):
        r"""
        GetMaximumKernelWidth(LevelSetMotionRegistrationFilter self) -> unsigned int


        Set/Get the desired limits of the Gaussian kernel width.


        """
        return (
            _SimpleITK.LevelSetMotionRegistrationFilter_GetMaximumKernelWidth(
                self
            )
        )

    def SetMaximumError(self, MaximumError):
        r"""
        SetMaximumError(LevelSetMotionRegistrationFilter self, double MaximumError)


        Set/Get the desired maximum error of the Guassian kernel approximate.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetMaximumError(
            self, MaximumError
        )

    def GetMaximumError(self):
        r"""
        GetMaximumError(LevelSetMotionRegistrationFilter self) -> double


        Set/Get the desired maximum error of the Guassian kernel approximate.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetMaximumError(
            self
        )

    def SetAlpha(self, Alpha):
        r"""
        SetAlpha(LevelSetMotionRegistrationFilter self, double Alpha)


        Set/Get the parameter alpha. Alpha is added to the calculated gradient
        magnitude prior to normalizing the gradient to protect against
        numerical instability as the gradient magnitude approaches zero. This
        should be set as a small fraction of the intensity dynamic range, for
        instance 0.04%. Default is the absolute (not percentage) value of 0.1.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetAlpha(
            self, Alpha
        )

    def GetAlpha(self):
        r"""
        GetAlpha(LevelSetMotionRegistrationFilter self) -> double


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetAlpha(self)

    def SetIntensityDifferenceThreshold(self, IntensityDifferenceThreshold):
        r"""
        SetIntensityDifferenceThreshold(LevelSetMotionRegistrationFilter self, double IntensityDifferenceThreshold)


        Set/Get the threshold below which the absolute difference of intensity
        yields a match. When the intensities match between a moving and fixed
        image pixel, the update vector (for that iteration) will be the zero
        vector. Default is 0.001.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetIntensityDifferenceThreshold(
            self, IntensityDifferenceThreshold
        )

    def GetIntensityDifferenceThreshold(self):
        r"""
        GetIntensityDifferenceThreshold(LevelSetMotionRegistrationFilter self) -> double


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetIntensityDifferenceThreshold(
            self
        )

    def SetGradientMagnitudeThreshold(self, GradientMagnitudeThreshold):
        r"""
        SetGradientMagnitudeThreshold(LevelSetMotionRegistrationFilter self, double GradientMagnitudeThreshold)


        Set/Get the threshold below which the gradient magnitude is considered
        the zero vector. Default is 1e-9.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetGradientMagnitudeThreshold(
            self, GradientMagnitudeThreshold
        )

    def GetGradientMagnitudeThreshold(self):
        r"""
        GetGradientMagnitudeThreshold(LevelSetMotionRegistrationFilter self) -> double


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetGradientMagnitudeThreshold(
            self
        )

    def SetUseImageSpacing(self, UseImageSpacing):
        r"""
        SetUseImageSpacing(LevelSetMotionRegistrationFilter self, bool UseImageSpacing)


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetUseImageSpacing(
            self, UseImageSpacing
        )

    def UseImageSpacingOn(self):
        r"""
        UseImageSpacingOn(LevelSetMotionRegistrationFilter self)


        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_UseImageSpacingOn(
            self
        )

    def UseImageSpacingOff(self):
        r"""
        UseImageSpacingOff(LevelSetMotionRegistrationFilter self)


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_UseImageSpacingOff(
            self
        )

    def GetUseImageSpacing(self):
        r"""
        GetUseImageSpacing(LevelSetMotionRegistrationFilter self) -> bool


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetUseImageSpacing(
            self
        )

    def GetElapsedIterations(self):
        r"""
        GetElapsedIterations(LevelSetMotionRegistrationFilter self) -> uint32_t


        Number of iterations run.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return (
            _SimpleITK.LevelSetMotionRegistrationFilter_GetElapsedIterations(
                self
            )
        )

    def GetRMSChange(self):
        r"""
        GetRMSChange(LevelSetMotionRegistrationFilter self) -> double


        The Root Mean Square of the levelset upon termination.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetRMSChange(self)

    def GetMetric(self):
        r"""
        GetMetric(LevelSetMotionRegistrationFilter self) -> double


        Get the metric value. The metric value is the mean square difference
        in intensity between the fixed image and transforming moving image
        computed over the overlapping region between the two images. This is
        value is only available for the previous iteration and NOT the current
        iteration.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetMetric(self)

    def GetName(self):
        r"""
        GetName(LevelSetMotionRegistrationFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LevelSetMotionRegistrationFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(LevelSetMotionRegistrationFilter self, Image fixedImage, Image movingImage, Image initialDisplacementField) -> Image
        Execute(LevelSetMotionRegistrationFilter self, Image fixedImage, Image movingImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_Execute(self, *args)


# Register LevelSetMotionRegistrationFilter in _SimpleITK:
_SimpleITK.LevelSetMotionRegistrationFilter_swigregister(
    LevelSetMotionRegistrationFilter
)


class LiThresholdImageFilter(ImageFilter):
    r"""


    Threshold an image using the Li Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the LiThresholdCalculator and applies that threshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/efycla


    See:
     HistogramThresholdImageFilter

     itk::simple::LiThreshold for the procedural interface

     itk::LiThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLiThresholdImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LiThresholdImageFilter

    def __init__(self):
        r"""
        __init__(LiThresholdImageFilter self) -> LiThresholdImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LiThresholdImageFilter_swiginit(
            self, _SimpleITK.new_LiThresholdImageFilter()
        )

    def SetInsideValue(self, InsideValue):
        r"""
        SetInsideValue(LiThresholdImageFilter self, uint8_t InsideValue)


        Set the "inside" pixel value.


        """
        return _SimpleITK.LiThresholdImageFilter_SetInsideValue(
            self, InsideValue
        )

    def GetInsideValue(self):
        r"""
        GetInsideValue(LiThresholdImageFilter self) -> uint8_t


        Get the "inside" pixel value.


        """
        return _SimpleITK.LiThresholdImageFilter_GetInsideValue(self)

    def SetOutsideValue(self, OutsideValue):
        r"""
        SetOutsideValue(LiThresholdImageFilter self, uint8_t OutsideValue)


        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.LiThresholdImageFilter_SetOutsideValue(
            self, OutsideValue
        )

    def GetOutsideValue(self):
        r"""
        GetOutsideValue(LiThresholdImageFilter self) -> uint8_t


        Get the "outside" pixel value.


        """
        return _SimpleITK.LiThresholdImageFilter_GetOutsideValue(self)

    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        r"""
        SetNumberOfHistogramBins(LiThresholdImageFilter self, uint32_t NumberOfHistogramBins)


        Set/Get the number of histogram bins.


        """
        return _SimpleITK.LiThresholdImageFilter_SetNumberOfHistogramBins(
            self, NumberOfHistogramBins
        )

    def GetNumberOfHistogramBins(self):
        r"""
        GetNumberOfHistogramBins(LiThresholdImageFilter self) -> uint32_t


        """
        return _SimpleITK.LiThresholdImageFilter_GetNumberOfHistogramBins(self)

    def SetMaskOutput(self, MaskOutput):
        r"""
        SetMaskOutput(LiThresholdImageFilter self, bool MaskOutput)


        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.LiThresholdImageFilter_SetMaskOutput(
            self, MaskOutput
        )

    def MaskOutputOn(self):
        r"""
        MaskOutputOn(LiThresholdImageFilter self)


        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.LiThresholdImageFilter_MaskOutputOn(self)

    def MaskOutputOff(self):
        r"""
        MaskOutputOff(LiThresholdImageFilter self)


        """
        return _SimpleITK.LiThresholdImageFilter_MaskOutputOff(self)

    def GetMaskOutput(self):
        r"""
        GetMaskOutput(LiThresholdImageFilter self) -> bool


        """
        return _SimpleITK.LiThresholdImageFilter_GetMaskOutput(self)

    def SetMaskValue(self, MaskValue):
        r"""
        SetMaskValue(LiThresholdImageFilter self, uint8_t MaskValue)


        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.LiThresholdImageFilter_SetMaskValue(self, MaskValue)

    def GetMaskValue(self):
        r"""
        GetMaskValue(LiThresholdImageFilter self) -> uint8_t


        """
        return _SimpleITK.LiThresholdImageFilter_GetMaskValue(self)

    def GetThreshold(self):
        r"""
        GetThreshold(LiThresholdImageFilter self) -> double


        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LiThresholdImageFilter_GetThreshold(self)

    def GetName(self):
        r"""
        GetName(LiThresholdImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LiThresholdImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LiThresholdImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LiThresholdImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(LiThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(LiThresholdImageFilter self, Image image) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.LiThresholdImageFilter_Execute(self, *args)


# Register LiThresholdImageFilter in _SimpleITK:
_SimpleITK.LiThresholdImageFilter_swigregister(LiThresholdImageFilter)


def LiThreshold(*args):
    r"""
    LiThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    LiThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    """
    return _SimpleITK.LiThreshold(*args)


class Log10ImageFilter(ImageFilter):
    r"""


    Computes the log10 of each pixel.


    The computation is performed using std::log10(x).
    See:
     itk::simple::Log10 for the procedural interface

     itk::Log10ImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLog10ImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_Log10ImageFilter

    def __init__(self):
        r"""
        __init__(Log10ImageFilter self) -> Log10ImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.Log10ImageFilter_swiginit(
            self, _SimpleITK.new_Log10ImageFilter()
        )

    def GetName(self):
        r"""
        GetName(Log10ImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.Log10ImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(Log10ImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.Log10ImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(Log10ImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.Log10ImageFilter_Execute(self, image1)


# Register Log10ImageFilter in _SimpleITK:
_SimpleITK.Log10ImageFilter_swigregister(Log10ImageFilter)


def Log10(image1):
    r"""Log10(Image image1) -> Image"""
    return _SimpleITK.Log10(image1)


class LogImageFilter(ImageFilter):
    r"""


    Computes the log() of each pixel.



    See:
     itk::simple::Log for the procedural interface

     itk::LogImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLogImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_LogImageFilter

    def __init__(self):
        r"""
        __init__(LogImageFilter self) -> LogImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.LogImageFilter_swiginit(
            self, _SimpleITK.new_LogImageFilter()
        )

    def GetName(self):
        r"""
        GetName(LogImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.LogImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(LogImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.LogImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(LogImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.LogImageFilter_Execute(self, image1)


# Register LogImageFilter in _SimpleITK:
_SimpleITK.LogImageFilter_swigregister(LogImageFilter)


def Log(image1):
    r"""Log(Image image1) -> Image"""
    return _SimpleITK.Log(image1)


class MagnitudeAndPhaseToComplexImageFilter(ImageFilter):
    r"""


    Implements pixel-wise conversion of magnitude and phase data into
    complex voxels.


    This filter is parameterized over the types of the two input images
    and the type of the output image.

    The filter expect all images to have the same dimension (e.g. all 2D,
    or all 3D, or all ND)
    See:
     itk::simple::MagnitudeAndPhaseToComplex for the procedural interface

     itk::MagnitudeAndPhaseToComplexImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMagnitudeAndPhaseToComplexImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MagnitudeAndPhaseToComplexImageFilter

    def __init__(self):
        r"""
        __init__(MagnitudeAndPhaseToComplexImageFilter self) -> MagnitudeAndPhaseToComplexImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MagnitudeAndPhaseToComplexImageFilter_swiginit(
            self, _SimpleITK.new_MagnitudeAndPhaseToComplexImageFilter()
        )

    def GetName(self):
        r"""
        GetName(MagnitudeAndPhaseToComplexImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MagnitudeAndPhaseToComplexImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MagnitudeAndPhaseToComplexImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MagnitudeAndPhaseToComplexImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(MagnitudeAndPhaseToComplexImageFilter self, Image image1, Image image2) -> Image
        Execute(MagnitudeAndPhaseToComplexImageFilter self, Image image1, double constant) -> Image
        Execute(MagnitudeAndPhaseToComplexImageFilter self, double constant, Image image2) -> Image


        """
        return _SimpleITK.MagnitudeAndPhaseToComplexImageFilter_Execute(
            self, *args
        )


# Register MagnitudeAndPhaseToComplexImageFilter in _SimpleITK:
_SimpleITK.MagnitudeAndPhaseToComplexImageFilter_swigregister(
    MagnitudeAndPhaseToComplexImageFilter
)


def MagnitudeAndPhaseToComplex(*args):
    r"""
    MagnitudeAndPhaseToComplex(Image image1, Image image2) -> Image
    MagnitudeAndPhaseToComplex(Image image1, double constant) -> Image
    MagnitudeAndPhaseToComplex(double constant, Image image2) -> Image


    """
    return _SimpleITK.MagnitudeAndPhaseToComplex(*args)


class MaskImageFilter(ImageFilter):
    r"""


    Mask an image with a mask.


    This class is templated over the types of the input image type, the
    mask image type and the type of the output image. Numeric conversions
    (castings) are done by the C++ defaults.

    The pixel type of the input 2 image must have a valid definition of
    the operator != with zero. This condition is required because
    internally this filter will perform the operation


    The pixel from the input 1 is cast to the pixel type of the output
    image.

    Note that the input and the mask images must be of the same size.


    WARNING:
    Any pixel value other than masking value (0 by default) will not be
    masked out.

    See:
     MaskNegatedImageFilter

     itk::simple::Mask for the procedural interface

     itk::MaskImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMaskImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MaskImageFilter

    def __init__(self):
        r"""
        __init__(MaskImageFilter self) -> MaskImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MaskImageFilter_swiginit(
            self, _SimpleITK.new_MaskImageFilter()
        )

    def SetOutsideValue(self, OutsideValue):
        r"""
        SetOutsideValue(MaskImageFilter self, double OutsideValue)


        Method to explicitly set the outside value of the mask. Defaults to 0


        """
        return _SimpleITK.MaskImageFilter_SetOutsideValue(self, OutsideValue)

    def GetOutsideValue(self):
        r"""
        GetOutsideValue(MaskImageFilter self) -> double


        """
        return _SimpleITK.MaskImageFilter_GetOutsideValue(self)

    def SetMaskingValue(self, MaskingValue):
        r"""
        SetMaskingValue(MaskImageFilter self, double MaskingValue)


        Method to explicitly set the masking value of the mask. Defaults to 0


        """
        return _SimpleITK.MaskImageFilter_SetMaskingValue(self, MaskingValue)

    def GetMaskingValue(self):
        r"""
        GetMaskingValue(MaskImageFilter self) -> double


        Method to get the masking value of the mask.


        """
        return _SimpleITK.MaskImageFilter_GetMaskingValue(self)

    def GetName(self):
        r"""
        GetName(MaskImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MaskImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MaskImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MaskImageFilter___str__(self)

    def Execute(self, image, maskImage):
        r"""
        Execute(MaskImageFilter self, Image image, Image maskImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.MaskImageFilter_Execute(self, image, maskImage)


# Register MaskImageFilter in _SimpleITK:
_SimpleITK.MaskImageFilter_swigregister(MaskImageFilter)


def Mask(image, maskImage, outsideValue=0, maskingValue=0):
    r"""Mask(Image image, Image maskImage, double outsideValue=0, double maskingValue=0) -> Image"""
    return _SimpleITK.Mask(image, maskImage, outsideValue, maskingValue)


class MaskNegatedImageFilter(ImageFilter):
    r"""


    Mask an image with the negation (or logical compliment) of a mask.


    This class is templated over the types of the input image type, the
    mask image type and the type of the output image. Numeric conversions
    (castings) are done by the C++ defaults.

    The pixel type of the input 2 image must have a valid definition of
    the operator!=. This condition is required because internally this
    filter will perform the operation


    The pixel from the input 1 is cast to the pixel type of the output
    image.

    Note that the input and the mask images must be of the same size.


    WARNING:
    Only pixel value with mask_value ( defaults to 0 ) will be preserved.

    See:
     MaskImageFilter

     itk::simple::MaskNegated for the procedural interface

     itk::MaskNegatedImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMaskNegatedImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MaskNegatedImageFilter

    def __init__(self):
        r"""
        __init__(MaskNegatedImageFilter self) -> MaskNegatedImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MaskNegatedImageFilter_swiginit(
            self, _SimpleITK.new_MaskNegatedImageFilter()
        )

    def SetOutsideValue(self, OutsideValue):
        r"""
        SetOutsideValue(MaskNegatedImageFilter self, double OutsideValue)


        Method to explicitly set the outside value of the mask. Defaults to 0


        """
        return _SimpleITK.MaskNegatedImageFilter_SetOutsideValue(
            self, OutsideValue
        )

    def GetOutsideValue(self):
        r"""
        GetOutsideValue(MaskNegatedImageFilter self) -> double


        """
        return _SimpleITK.MaskNegatedImageFilter_GetOutsideValue(self)

    def SetMaskingValue(self, MaskingValue):
        r"""
        SetMaskingValue(MaskNegatedImageFilter self, double MaskingValue)


        Method to explicitly set the masking value of the mask. Defaults to 0


        """
        return _SimpleITK.MaskNegatedImageFilter_SetMaskingValue(
            self, MaskingValue
        )

    def GetMaskingValue(self):
        r"""
        GetMaskingValue(MaskNegatedImageFilter self) -> double


        Method to get the masking value of the mask.


        """
        return _SimpleITK.MaskNegatedImageFilter_GetMaskingValue(self)

    def GetName(self):
        r"""
        GetName(MaskNegatedImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MaskNegatedImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MaskNegatedImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MaskNegatedImageFilter___str__(self)

    def Execute(self, image, maskImage):
        r"""
        Execute(MaskNegatedImageFilter self, Image image, Image maskImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.MaskNegatedImageFilter_Execute(
            self, image, maskImage
        )


# Register MaskNegatedImageFilter in _SimpleITK:
_SimpleITK.MaskNegatedImageFilter_swigregister(MaskNegatedImageFilter)


def MaskNegated(image, maskImage, outsideValue=0, maskingValue=0):
    r"""MaskNegated(Image image, Image maskImage, double outsideValue=0, double maskingValue=0) -> Image"""
    return _SimpleITK.MaskNegated(image, maskImage, outsideValue, maskingValue)


class MaskedAssignImageFilter(ImageFilter):
    r"""


    Mask an image with a mask.


    This class is templated over the types of the input image type, the
    mask image type and the type of the output image. Numeric conversions
    (castings) are done by the C++ defaults.

    The pixel type of the input 2 image must have a valid definition of
    the operator != with zero. This condition is required because
    internally this filter will perform the operation


    The pixel from the input 1 is cast to the pixel type of the output
    image.

    Note that the input and the mask images must be of the same size.


    WARNING:
    Any pixel value other than masking value (0 by default) will not be
    masked out.

    See:
     MaskNegatedImageFilter

     itk::simple::MaskedAssign for the procedural interface

     itk::MaskedAssignImageFilter for the Doxygen on the original ITK
    class.


    C++ includes: sitkMaskedAssignImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MaskedAssignImageFilter

    def __init__(self):
        r"""
        __init__(MaskedAssignImageFilter self) -> MaskedAssignImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MaskedAssignImageFilter_swiginit(
            self, _SimpleITK.new_MaskedAssignImageFilter()
        )

    def SetAssignConstant(self, AssignConstant):
        r"""
        SetAssignConstant(MaskedAssignImageFilter self, double AssignConstant)


        Method to explicitly set the outside value of the mask when
        AssignImage is undefined. Defaults to 0


        """
        return _SimpleITK.MaskedAssignImageFilter_SetAssignConstant(
            self, AssignConstant
        )

    def GetAssignConstant(self):
        r"""
        GetAssignConstant(MaskedAssignImageFilter self) -> double


        """
        return _SimpleITK.MaskedAssignImageFilter_GetAssignConstant(self)

    def GetName(self):
        r"""
        GetName(MaskedAssignImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MaskedAssignImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MaskedAssignImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MaskedAssignImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(MaskedAssignImageFilter self, Image image, Image maskImage, Image assignImage) -> Image
        Execute(MaskedAssignImageFilter self, Image image, Image maskImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.MaskedAssignImageFilter_Execute(self, *args)


# Register MaskedAssignImageFilter in _SimpleITK:
_SimpleITK.MaskedAssignImageFilter_swigregister(MaskedAssignImageFilter)


def MaskedAssign(*args):
    r"""
    MaskedAssign(Image image, Image maskImage, Image assignImage, double assignConstant=0) -> Image
    MaskedAssign(Image image, Image maskImage, double assignConstant=0) -> Image
    """
    return _SimpleITK.MaskedAssign(*args)


class MaskedFFTNormalizedCorrelationImageFilter(ImageFilter):
    r"""


    Calculate masked normalized cross correlation using FFTs.


    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. For example, if
    only a mask for the fixed image is needed, the movingMask can either
    not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. For example, when the masks have strange shapes, it is
    difficult to predict how the correlation of the masks will interact
    and what the maximum overlap will be. It is also useful when the mask
    shapes or sizes change because it is relative to the internally
    computed maximum of the overlap. Larger values zero-out pixels on a
    larger border around the correlation image. Thus, larger values remove
    less stable computations but also limit the capture range. Experiments
    have shown that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain, all
    input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:


    WARNING:
    The pixel type of the output image must be of real type (float or
    double). ConceptChecking is used to enforce the output pixel type. You
    will get a compilation error if the pixel type of the output image is
    not float or double.
     References: 1) D. Padfield. "Masked object registration in the
    Fourier domain." Transactions on Image Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.


    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    See:
     itk::simple::MaskedFFTNormalizedCorrelation for the procedural interface

     itk::MaskedFFTNormalizedCorrelationImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMaskedFFTNormalizedCorrelationImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_MaskedFFTNormalizedCorrelationImageFilter
    )

    def __init__(self):
        r"""
        __init__(MaskedFFTNormalizedCorrelationImageFilter self) -> MaskedFFTNormalizedCorrelationImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MaskedFFTNormalizedCorrelationImageFilter_swiginit(
            self, _SimpleITK.new_MaskedFFTNormalizedCorrelationImageFilter()
        )

    def SetRequiredNumberOfOverlappingPixels(
        self, RequiredNumberOfOverlappingPixels
    ):
        r"""
        SetRequiredNumberOfOverlappingPixels(MaskedFFTNormalizedCorrelationImageFilter self, uint64_t RequiredNumberOfOverlappingPixels)


        Set and get the required number of overlapping pixels


        """
        return _SimpleITK.MaskedFFTNormalizedCorrelationImageFilter_SetRequiredNumberOfOverlappingPixels(
            self, RequiredNumberOfOverlappingPixels
        )

    def GetRequiredNumberOfOverlappingPixels(self):
        r"""
        GetRequiredNumberOfOverlappingPixels(MaskedFFTNormalizedCorrelationImageFilter self) -> uint64_t


        Set and get the required number of overlapping pixels


        """
        return _SimpleITK.MaskedFFTNormalizedCorrelationImageFilter_GetRequiredNumberOfOverlappingPixels(
            self
        )

    def SetRequiredFractionOfOverlappingPixels(
        self, RequiredFractionOfOverlappingPixels
    ):
        r"""
        SetRequiredFractionOfOverlappingPixels(MaskedFFTNormalizedCorrelationImageFilter self, float RequiredFractionOfOverlappingPixels)


        Set and get the required fraction of overlapping pixels


        """
        return _SimpleITK.MaskedFFTNormalizedCorrelationImageFilter_SetRequiredFractionOfOverlappingPixels(
            self, RequiredFractionOfOverlappingPixels
        )

    def GetRequiredFractionOfOverlappingPixels(self):
        r"""
        GetRequiredFractionOfOverlappingPixels(MaskedFFTNormalizedCorrelationImageFilter self) -> float


        Set and get the required fraction of overlapping pixels


        """
        return _SimpleITK.MaskedFFTNormalizedCorrelationImageFilter_GetRequiredFractionOfOverlappingPixels(
            self
        )

    def GetName(self):
        r"""
        GetName(MaskedFFTNormalizedCorrelationImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MaskedFFTNormalizedCorrelationImageFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(MaskedFFTNormalizedCorrelationImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MaskedFFTNormalizedCorrelationImageFilter___str__(
            self
        )

    def Execute(
        self, fixedImage, movingImage, fixedImageMask, movingImageMask
    ):
        r"""
        Execute(MaskedFFTNormalizedCorrelationImageFilter self, Image fixedImage, Image movingImage, Image fixedImageMask, Image movingImageMask) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.MaskedFFTNormalizedCorrelationImageFilter_Execute(
            self, fixedImage, movingImage, fixedImageMask, movingImageMask
        )


# Register MaskedFFTNormalizedCorrelationImageFilter in _SimpleITK:
_SimpleITK.MaskedFFTNormalizedCorrelationImageFilter_swigregister(
    MaskedFFTNormalizedCorrelationImageFilter
)


def MaskedFFTNormalizedCorrelation(
    fixedImage,
    movingImage,
    fixedImageMask,
    movingImageMask,
    requiredNumberOfOverlappingPixels=0,
    requiredFractionOfOverlappingPixels=0.0,
):
    r"""MaskedFFTNormalizedCorrelation(Image fixedImage, Image movingImage, Image fixedImageMask, Image movingImageMask, uint64_t requiredNumberOfOverlappingPixels=0, float requiredFractionOfOverlappingPixels=0.0) -> Image"""
    return _SimpleITK.MaskedFFTNormalizedCorrelation(
        fixedImage,
        movingImage,
        fixedImageMask,
        movingImageMask,
        requiredNumberOfOverlappingPixels,
        requiredFractionOfOverlappingPixels,
    )


class MaximumEntropyThresholdImageFilter(ImageFilter):
    r"""


    Threshold an image using the MaximumEntropy Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the MaximumEntropyThresholdCalculator and applies that threshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/efycla


    See:
     HistogramThresholdImageFilter

     itk::simple::MaximumEntropyThreshold for the procedural interface

     itk::MaximumEntropyThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMaximumEntropyThresholdImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MaximumEntropyThresholdImageFilter

    def __init__(self):
        r"""
        __init__(MaximumEntropyThresholdImageFilter self) -> MaximumEntropyThresholdImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MaximumEntropyThresholdImageFilter_swiginit(
            self, _SimpleITK.new_MaximumEntropyThresholdImageFilter()
        )

    def SetInsideValue(self, InsideValue):
        r"""
        SetInsideValue(MaximumEntropyThresholdImageFilter self, uint8_t InsideValue)


        Set the "inside" pixel value.


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_SetInsideValue(
            self, InsideValue
        )

    def GetInsideValue(self):
        r"""
        GetInsideValue(MaximumEntropyThresholdImageFilter self) -> uint8_t


        Get the "inside" pixel value.


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_GetInsideValue(
            self
        )

    def SetOutsideValue(self, OutsideValue):
        r"""
        SetOutsideValue(MaximumEntropyThresholdImageFilter self, uint8_t OutsideValue)


        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_SetOutsideValue(
            self, OutsideValue
        )

    def GetOutsideValue(self):
        r"""
        GetOutsideValue(MaximumEntropyThresholdImageFilter self) -> uint8_t


        Get the "outside" pixel value.


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_GetOutsideValue(
            self
        )

    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        r"""
        SetNumberOfHistogramBins(MaximumEntropyThresholdImageFilter self, uint32_t NumberOfHistogramBins)


        Set/Get the number of histogram bins.


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_SetNumberOfHistogramBins(
            self, NumberOfHistogramBins
        )

    def GetNumberOfHistogramBins(self):
        r"""
        GetNumberOfHistogramBins(MaximumEntropyThresholdImageFilter self) -> uint32_t


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_GetNumberOfHistogramBins(
            self
        )

    def SetMaskOutput(self, MaskOutput):
        r"""
        SetMaskOutput(MaximumEntropyThresholdImageFilter self, bool MaskOutput)


        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_SetMaskOutput(
            self, MaskOutput
        )

    def MaskOutputOn(self):
        r"""
        MaskOutputOn(MaximumEntropyThresholdImageFilter self)


        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_MaskOutputOn(self)

    def MaskOutputOff(self):
        r"""
        MaskOutputOff(MaximumEntropyThresholdImageFilter self)


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_MaskOutputOff(
            self
        )

    def GetMaskOutput(self):
        r"""
        GetMaskOutput(MaximumEntropyThresholdImageFilter self) -> bool


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_GetMaskOutput(
            self
        )

    def SetMaskValue(self, MaskValue):
        r"""
        SetMaskValue(MaximumEntropyThresholdImageFilter self, uint8_t MaskValue)


        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_SetMaskValue(
            self, MaskValue
        )

    def GetMaskValue(self):
        r"""
        GetMaskValue(MaximumEntropyThresholdImageFilter self) -> uint8_t


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_GetMaskValue(self)

    def GetThreshold(self):
        r"""
        GetThreshold(MaximumEntropyThresholdImageFilter self) -> double


        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_GetThreshold(self)

    def GetName(self):
        r"""
        GetName(MaximumEntropyThresholdImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MaximumEntropyThresholdImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(MaximumEntropyThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(MaximumEntropyThresholdImageFilter self, Image image) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_Execute(
            self, *args
        )


# Register MaximumEntropyThresholdImageFilter in _SimpleITK:
_SimpleITK.MaximumEntropyThresholdImageFilter_swigregister(
    MaximumEntropyThresholdImageFilter
)


def MaximumEntropyThreshold(*args):
    r"""
    MaximumEntropyThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    MaximumEntropyThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    """
    return _SimpleITK.MaximumEntropyThreshold(*args)


class MaximumImageFilter(ImageFilter):
    r"""


    Implements a pixel-wise operator Max(a,b) between two images.


    The pixel values of the output image are the maximum between the
    corresponding pixels of the two input images.

    This class is templated over the types of the two input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.
    See:
     itk::simple::Maximum for the procedural interface

     itk::MaximumImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMaximumImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MaximumImageFilter

    def __init__(self):
        r"""
        __init__(MaximumImageFilter self) -> MaximumImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MaximumImageFilter_swiginit(
            self, _SimpleITK.new_MaximumImageFilter()
        )

    def GetName(self):
        r"""
        GetName(MaximumImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MaximumImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MaximumImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MaximumImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(MaximumImageFilter self, Image image1, Image image2) -> Image
        Execute(MaximumImageFilter self, Image image1, double constant) -> Image
        Execute(MaximumImageFilter self, double constant, Image image2) -> Image


        """
        return _SimpleITK.MaximumImageFilter_Execute(self, *args)


# Register MaximumImageFilter in _SimpleITK:
_SimpleITK.MaximumImageFilter_swigregister(MaximumImageFilter)


def Maximum(*args):
    r"""
    Maximum(Image image1, Image image2) -> Image
    Maximum(Image image1, double constant) -> Image
    Maximum(double constant, Image image2) -> Image


    """
    return _SimpleITK.Maximum(*args)


class MaximumProjectionImageFilter(ImageFilter):
    r"""


    Maximum projection.


    This class was contributed to the insight journal by Gaetan Lehmann.
    The original paper can be found at https://doi.org/10.54294/0pjyho


    Gaetan Lehmann. Biologie du Developpement et de la reproduction, inra
    de jouy-en-josas, France.

    See:
     ProjectionImageFilter

     MedianProjectionImageFilter

     MeanProjectionImageFilter

     MinimumProjectionImageFilter

     StandardDeviationProjectionImageFilter

     SumProjectionImageFilter

     BinaryProjectionImageFilter

     itk::simple::MaximumProjection for the procedural interface

     itk::MaximumProjectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMaximumProjectionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MaximumProjectionImageFilter

    def __init__(self):
        r"""
        __init__(MaximumProjectionImageFilter self) -> MaximumProjectionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MaximumProjectionImageFilter_swiginit(
            self, _SimpleITK.new_MaximumProjectionImageFilter()
        )

    def SetProjectionDimension(self, ProjectionDimension):
        r"""
        SetProjectionDimension(MaximumProjectionImageFilter self, unsigned int ProjectionDimension)


        """
        return _SimpleITK.MaximumProjectionImageFilter_SetProjectionDimension(
            self, ProjectionDimension
        )

    def GetProjectionDimension(self):
        r"""
        GetProjectionDimension(MaximumProjectionImageFilter self) -> unsigned int


        """
        return _SimpleITK.MaximumProjectionImageFilter_GetProjectionDimension(
            self
        )

    def GetName(self):
        r"""
        GetName(MaximumProjectionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MaximumProjectionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MaximumProjectionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MaximumProjectionImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(MaximumProjectionImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.MaximumProjectionImageFilter_Execute(self, image1)


# Register MaximumProjectionImageFilter in _SimpleITK:
_SimpleITK.MaximumProjectionImageFilter_swigregister(
    MaximumProjectionImageFilter
)


def MaximumProjection(image1, projectionDimension=0):
    r"""MaximumProjection(Image image1, unsigned int projectionDimension=0) -> Image"""
    return _SimpleITK.MaximumProjection(image1, projectionDimension)


class MeanImageFilter(ImageFilter):
    r"""


    Applies an averaging filter to an image.


    Computes an image where a given pixel is the mean value of the the
    pixels in a neighborhood about the corresponding input pixel.

    A mean filter is one of the family of linear filters.


    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     itk::simple::Mean for the procedural interface

     itk::MeanImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMeanImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MeanImageFilter

    def __init__(self):
        r"""
        __init__(MeanImageFilter self) -> MeanImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MeanImageFilter_swiginit(
            self, _SimpleITK.new_MeanImageFilter()
        )

    def SetRadius(self, *args):
        r"""
        SetRadius(MeanImageFilter self, VectorUInt32 Radius)
        SetRadius(MeanImageFilter self, unsigned int value)


        Set the values of the Radius vector all to value


        """
        return _SimpleITK.MeanImageFilter_SetRadius(self, *args)

    def GetRadius(self):
        r"""
        GetRadius(MeanImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.MeanImageFilter_GetRadius(self)

    def GetName(self):
        r"""
        GetName(MeanImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MeanImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MeanImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MeanImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(MeanImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.MeanImageFilter_Execute(self, image1)


# Register MeanImageFilter in _SimpleITK:
_SimpleITK.MeanImageFilter_swigregister(MeanImageFilter)


def Mean(*args, **kwargs):
    r"""Mean(Image image1, VectorUInt32 radius=std::vector< unsigned int >(3, 1)) -> Image"""
    return _SimpleITK.Mean(*args, **kwargs)


class MeanProjectionImageFilter(ImageFilter):
    r"""


    Mean projection.


    This class was contributed to the Insight Journal by Gaetan Lehmann.
    The original paper can be found at https://doi.org/10.54294/0pjyho


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ProjectionImageFilter

     MedianProjectionImageFilter

     MinimumProjectionImageFilter

     StandardDeviationProjectionImageFilter

     SumProjectionImageFilter

     BinaryProjectionImageFilter

     MaximumProjectionImageFilter

     itk::simple::MeanProjection for the procedural interface

     itk::MeanProjectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMeanProjectionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MeanProjectionImageFilter

    def __init__(self):
        r"""
        __init__(MeanProjectionImageFilter self) -> MeanProjectionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MeanProjectionImageFilter_swiginit(
            self, _SimpleITK.new_MeanProjectionImageFilter()
        )

    def SetProjectionDimension(self, ProjectionDimension):
        r"""
        SetProjectionDimension(MeanProjectionImageFilter self, unsigned int ProjectionDimension)


        """
        return _SimpleITK.MeanProjectionImageFilter_SetProjectionDimension(
            self, ProjectionDimension
        )

    def GetProjectionDimension(self):
        r"""
        GetProjectionDimension(MeanProjectionImageFilter self) -> unsigned int


        """
        return _SimpleITK.MeanProjectionImageFilter_GetProjectionDimension(
            self
        )

    def GetName(self):
        r"""
        GetName(MeanProjectionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MeanProjectionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MeanProjectionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MeanProjectionImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(MeanProjectionImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.MeanProjectionImageFilter_Execute(self, image1)


# Register MeanProjectionImageFilter in _SimpleITK:
_SimpleITK.MeanProjectionImageFilter_swigregister(MeanProjectionImageFilter)


def MeanProjection(image1, projectionDimension=0):
    r"""MeanProjection(Image image1, unsigned int projectionDimension=0) -> Image"""
    return _SimpleITK.MeanProjection(image1, projectionDimension)


class MedianImageFilter(ImageFilter):
    r"""


    Applies a median filter to an image.


    Computes an image where a given pixel is the median value of the the
    pixels in a neighborhood about the corresponding input pixel.

    A median filter is one of the family of nonlinear filters. It is used
    to smooth an image without being biased by outliers or shot noise.

    This filter requires that the input pixel type provides an operator<() (LessThan Comparable).


    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     itk::simple::Median for the procedural interface

     itk::MedianImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMedianImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MedianImageFilter

    def __init__(self):
        r"""
        __init__(MedianImageFilter self) -> MedianImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MedianImageFilter_swiginit(
            self, _SimpleITK.new_MedianImageFilter()
        )

    def SetRadius(self, *args):
        r"""
        SetRadius(MedianImageFilter self, VectorUInt32 Radius)
        SetRadius(MedianImageFilter self, unsigned int value)


        Set the values of the Radius vector all to value


        """
        return _SimpleITK.MedianImageFilter_SetRadius(self, *args)

    def GetRadius(self):
        r"""
        GetRadius(MedianImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.MedianImageFilter_GetRadius(self)

    def GetName(self):
        r"""
        GetName(MedianImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MedianImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MedianImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MedianImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(MedianImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.MedianImageFilter_Execute(self, image1)


# Register MedianImageFilter in _SimpleITK:
_SimpleITK.MedianImageFilter_swigregister(MedianImageFilter)


def Median(*args, **kwargs):
    r"""Median(Image image1, VectorUInt32 radius=std::vector< unsigned int >(3, 1)) -> Image"""
    return _SimpleITK.Median(*args, **kwargs)


class MedianProjectionImageFilter(ImageFilter):
    r"""


    Median projection.


    This class was contributed to the Insight Journal by Gaetan Lehmann.
    The original paper can be found at https://doi.org/10.54294/0pjyho


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ProjectionImageFilter

     StandardDeviationProjectionImageFilter

     SumProjectionImageFilter

     BinaryProjectionImageFilter

     MaximumProjectionImageFilter

     MinimumProjectionImageFilter

     MeanProjectionImageFilter

     itk::simple::MedianProjection for the procedural interface

     itk::MedianProjectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMedianProjectionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MedianProjectionImageFilter

    def __init__(self):
        r"""
        __init__(MedianProjectionImageFilter self) -> MedianProjectionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MedianProjectionImageFilter_swiginit(
            self, _SimpleITK.new_MedianProjectionImageFilter()
        )

    def SetProjectionDimension(self, ProjectionDimension):
        r"""
        SetProjectionDimension(MedianProjectionImageFilter self, unsigned int ProjectionDimension)


        """
        return _SimpleITK.MedianProjectionImageFilter_SetProjectionDimension(
            self, ProjectionDimension
        )

    def GetProjectionDimension(self):
        r"""
        GetProjectionDimension(MedianProjectionImageFilter self) -> unsigned int


        """
        return _SimpleITK.MedianProjectionImageFilter_GetProjectionDimension(
            self
        )

    def GetName(self):
        r"""
        GetName(MedianProjectionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MedianProjectionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MedianProjectionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MedianProjectionImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(MedianProjectionImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.MedianProjectionImageFilter_Execute(self, image1)


# Register MedianProjectionImageFilter in _SimpleITK:
_SimpleITK.MedianProjectionImageFilter_swigregister(
    MedianProjectionImageFilter
)


def MedianProjection(image1, projectionDimension=0):
    r"""MedianProjection(Image image1, unsigned int projectionDimension=0) -> Image"""
    return _SimpleITK.MedianProjection(image1, projectionDimension)


class MergeLabelMapFilter(ImageFilter):
    r"""


    Merges several Label Maps.


    This filter takes one or more input Label Map and merges them.

    SetMethod() can be used to change how the filter manage the labels from the
    different label maps. KEEP (0): MergeLabelMapFilter do its best to keep the label unchanged, but if a label is already
    used in a previous label map, a new label is assigned. AGGREGATE (1):
    If the same label is found several times in the label maps, the label
    objects with the same label are merged. PACK (2): MergeLabelMapFilter relabel all the label objects by order of processing. No conflict can
    occur. STRICT (3): MergeLabelMapFilter keeps the labels unchanged and raises an exception if the same label
    is found in several images.

    This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ShapeLabelObject , RelabelComponentImageFilter

     itk::simple::MergeLabelMapFilter for the procedural interface


    C++ includes: sitkMergeLabelMapFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MergeLabelMapFilter

    def __init__(self):
        r"""
        __init__(MergeLabelMapFilter self) -> MergeLabelMapFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MergeLabelMapFilter_swiginit(
            self, _SimpleITK.new_MergeLabelMapFilter()
        )

    Keep = _SimpleITK.MergeLabelMapFilter_Keep

    Aggregate = _SimpleITK.MergeLabelMapFilter_Aggregate

    Pack = _SimpleITK.MergeLabelMapFilter_Pack

    Strict = _SimpleITK.MergeLabelMapFilter_Strict

    def SetMethod(self, Method):
        r"""
        SetMethod(MergeLabelMapFilter self, itk::simple::MergeLabelMapFilter::MethodType Method)


        Set/Get the method used to merge the label maps


        """
        return _SimpleITK.MergeLabelMapFilter_SetMethod(self, Method)

    def GetMethod(self):
        r"""
        GetMethod(MergeLabelMapFilter self) -> itk::simple::MergeLabelMapFilter::MethodType


        Set/Get the method used to merge the label maps


        """
        return _SimpleITK.MergeLabelMapFilter_GetMethod(self)

    def GetName(self):
        r"""
        GetName(MergeLabelMapFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MergeLabelMapFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MergeLabelMapFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MergeLabelMapFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(MergeLabelMapFilter self, VectorOfImage images) -> Image
        Execute(MergeLabelMapFilter self, Image image1) -> Image
        Execute(MergeLabelMapFilter self, Image image1, Image image2) -> Image
        Execute(MergeLabelMapFilter self, Image image1, Image image2, Image image3) -> Image
        Execute(MergeLabelMapFilter self, Image image1, Image image2, Image image3, Image image4) -> Image
        Execute(MergeLabelMapFilter self, Image image1, Image image2, Image image3, Image image4, Image image5) -> Image


        Execute the filter on the input images


        """
        return _SimpleITK.MergeLabelMapFilter_Execute(self, *args)


# Register MergeLabelMapFilter in _SimpleITK:
_SimpleITK.MergeLabelMapFilter_swigregister(MergeLabelMapFilter)


def MergeLabelMap(*args):
    r"""
    MergeLabelMap(VectorOfImage images, itk::simple::MergeLabelMapFilter::MethodType method=Keep) -> Image
    MergeLabelMap(Image image1, itk::simple::MergeLabelMapFilter::MethodType method=Keep) -> Image
    MergeLabelMap(Image image1, Image image2, itk::simple::MergeLabelMapFilter::MethodType method=Keep) -> Image
    MergeLabelMap(Image image1, Image image2, Image image3, itk::simple::MergeLabelMapFilter::MethodType method=Keep) -> Image
    MergeLabelMap(Image image1, Image image2, Image image3, Image image4, itk::simple::MergeLabelMapFilter::MethodType method=Keep) -> Image
    MergeLabelMap(Image image1, Image image2, Image image3, Image image4, Image image5, itk::simple::MergeLabelMapFilter::MethodType method=Keep) -> Image
    """
    return _SimpleITK.MergeLabelMap(*args)


class MinMaxCurvatureFlowImageFilter(ImageFilter):
    r"""


    Denoise an image using min/max curvature flow.


    MinMaxCurvatureFlowImageFilter implements a curvature driven image denoising algorithm. Iso-
    brightness contours in the grayscale input image are viewed as a level
    set. The level set is then evolved using a curvature-based speed
    function:

    \\[ I_t = F_{\\mbox{minmax}} |\\nabla I| \\]

    where $ F_{\\mbox{minmax}} = \\max(\\kappa,0) $ if $ \\mbox{Avg}_{\\mbox{stencil}}(x) $ is less than or equal to $ T_{threshold} $ and $ \\min(\\kappa,0) $ , otherwise. $ \\kappa $ is the mean curvature of the iso-brightness contour at point $ x $ .

    In min/max curvature flow, movement is turned on or off depending on
    the scale of the noise one wants to remove. Switching depends on the
    average image value of a region of radius $ R $ around each point. The choice of $ R $ , the stencil radius, governs the scale of the noise to be removed.

    The threshold value $ T_{threshold} $ is the average intensity obtained in the direction perpendicular to
    the gradient at point $ x $ at the extrema of the local neighborhood.

    This filter make use of the multi-threaded finite difference solver
    hierarchy. Updates are computed using a MinMaxCurvatureFlowFunction object. A zero flux Neumann boundary condition is used when computing
    derivatives near the data boundary.


    WARNING:
    This filter assumes that the input and output types have the same
    dimensions. This filter also requires that the output image pixels are
    of a real type. This filter works for any dimensional images, however
    for dimensions greater than 3D, an expensive brute-force search is
    used to compute the local threshold.
     Reference: "Level Set Methods and Fast Marching Methods", J.A.
    Sethian, Cambridge Press, Chapter 16, Second edition, 1999.


    See:
     MinMaxCurvatureFlowFunction

     CurvatureFlowImageFilter

     BinaryMinMaxCurvatureFlowImageFilter

     itk::simple::MinMaxCurvatureFlow for the procedural interface

     itk::MinMaxCurvatureFlowImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMinMaxCurvatureFlowImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MinMaxCurvatureFlowImageFilter

    def __init__(self):
        r"""
        __init__(MinMaxCurvatureFlowImageFilter self) -> MinMaxCurvatureFlowImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MinMaxCurvatureFlowImageFilter_swiginit(
            self, _SimpleITK.new_MinMaxCurvatureFlowImageFilter()
        )

    def SetTimeStep(self, TimeStep):
        r"""
        SetTimeStep(MinMaxCurvatureFlowImageFilter self, double TimeStep)


        """
        return _SimpleITK.MinMaxCurvatureFlowImageFilter_SetTimeStep(
            self, TimeStep
        )

    def GetTimeStep(self):
        r"""
        GetTimeStep(MinMaxCurvatureFlowImageFilter self) -> double


        """
        return _SimpleITK.MinMaxCurvatureFlowImageFilter_GetTimeStep(self)

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(MinMaxCurvatureFlowImageFilter self, uint32_t NumberOfIterations)


        """
        return _SimpleITK.MinMaxCurvatureFlowImageFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(MinMaxCurvatureFlowImageFilter self) -> uint32_t


        """
        return _SimpleITK.MinMaxCurvatureFlowImageFilter_GetNumberOfIterations(
            self
        )

    def SetStencilRadius(self, StencilRadius):
        r"""
        SetStencilRadius(MinMaxCurvatureFlowImageFilter self, int StencilRadius)


        Set/Get the stencil radius.


        """
        return _SimpleITK.MinMaxCurvatureFlowImageFilter_SetStencilRadius(
            self, StencilRadius
        )

    def GetStencilRadius(self):
        r"""
        GetStencilRadius(MinMaxCurvatureFlowImageFilter self) -> int


        Set/Get the stencil radius.


        """
        return _SimpleITK.MinMaxCurvatureFlowImageFilter_GetStencilRadius(self)

    def GetName(self):
        r"""
        GetName(MinMaxCurvatureFlowImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MinMaxCurvatureFlowImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MinMaxCurvatureFlowImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MinMaxCurvatureFlowImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(MinMaxCurvatureFlowImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.MinMaxCurvatureFlowImageFilter_Execute(self, image1)


# Register MinMaxCurvatureFlowImageFilter in _SimpleITK:
_SimpleITK.MinMaxCurvatureFlowImageFilter_swigregister(
    MinMaxCurvatureFlowImageFilter
)


def MinMaxCurvatureFlow(
    image1, timeStep=0.05, numberOfIterations=5, stencilRadius=2
):
    r"""MinMaxCurvatureFlow(Image image1, double timeStep=0.05, uint32_t numberOfIterations=5, int stencilRadius=2) -> Image"""
    return _SimpleITK.MinMaxCurvatureFlow(
        image1, timeStep, numberOfIterations, stencilRadius
    )


class MinimumImageFilter(ImageFilter):
    r"""


    Implements a pixel-wise operator Min(a,b) between two images.


    The pixel values of the output image are the minimum between the
    corresponding pixels of the two input images.

    This class is templated over the types of the two input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.
    See:
     itk::simple::Minimum for the procedural interface

     itk::MinimumImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMinimumImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MinimumImageFilter

    def __init__(self):
        r"""
        __init__(MinimumImageFilter self) -> MinimumImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MinimumImageFilter_swiginit(
            self, _SimpleITK.new_MinimumImageFilter()
        )

    def GetName(self):
        r"""
        GetName(MinimumImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MinimumImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MinimumImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MinimumImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(MinimumImageFilter self, Image image1, Image image2) -> Image
        Execute(MinimumImageFilter self, Image image1, double constant) -> Image
        Execute(MinimumImageFilter self, double constant, Image image2) -> Image


        """
        return _SimpleITK.MinimumImageFilter_Execute(self, *args)


# Register MinimumImageFilter in _SimpleITK:
_SimpleITK.MinimumImageFilter_swigregister(MinimumImageFilter)


def Minimum(*args):
    r"""
    Minimum(Image image1, Image image2) -> Image
    Minimum(Image image1, double constant) -> Image
    Minimum(double constant, Image image2) -> Image


    """
    return _SimpleITK.Minimum(*args)


class MinimumMaximumImageFilter(ImageFilter):
    r"""


    Computes the minimum and the maximum intensity values of an image.


    It is templated over input image type only.

    This filter is automatically multi-threaded and can stream its input
    when NumberOfStreamDivisions is set to more than
    The extrema are independently computed for each streamed and threaded
    region then merged.

    See:
     StatisticsImageFilter

     itk::MinimumMaximumImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMinimumMaximumImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MinimumMaximumImageFilter

    def __init__(self):
        r"""
        __init__(MinimumMaximumImageFilter self) -> MinimumMaximumImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MinimumMaximumImageFilter_swiginit(
            self, _SimpleITK.new_MinimumMaximumImageFilter()
        )

    def GetMinimum(self):
        r"""
        GetMinimum(MinimumMaximumImageFilter self) -> double


        Return the computed Minimum.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.MinimumMaximumImageFilter_GetMinimum(self)

    def GetMaximum(self):
        r"""
        GetMaximum(MinimumMaximumImageFilter self) -> double


        Return the computed Maximum.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.MinimumMaximumImageFilter_GetMaximum(self)

    def GetName(self):
        r"""
        GetName(MinimumMaximumImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MinimumMaximumImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MinimumMaximumImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MinimumMaximumImageFilter___str__(self)

    def Execute(self, image):
        r"""
        Execute(MinimumMaximumImageFilter self, Image image)


        Execute the filter on the input image


        """
        return _SimpleITK.MinimumMaximumImageFilter_Execute(self, image)


# Register MinimumMaximumImageFilter in _SimpleITK:
_SimpleITK.MinimumMaximumImageFilter_swigregister(MinimumMaximumImageFilter)


class MinimumProjectionImageFilter(ImageFilter):
    r"""


    Minimum projection.


    This class was contributed to the Insight Journal by Gaetan Lehmann.
    The original paper can be found at https://doi.org/10.54294/0pjyho


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ProjectionImageFilter

     StandardDeviationProjectionImageFilter

     SumProjectionImageFilter

     BinaryProjectionImageFilter

     MaximumProjectionImageFilter

     MeanProjectionImageFilter

     itk::simple::MinimumProjection for the procedural interface

     itk::MinimumProjectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMinimumProjectionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MinimumProjectionImageFilter

    def __init__(self):
        r"""
        __init__(MinimumProjectionImageFilter self) -> MinimumProjectionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MinimumProjectionImageFilter_swiginit(
            self, _SimpleITK.new_MinimumProjectionImageFilter()
        )

    def SetProjectionDimension(self, ProjectionDimension):
        r"""
        SetProjectionDimension(MinimumProjectionImageFilter self, unsigned int ProjectionDimension)


        """
        return _SimpleITK.MinimumProjectionImageFilter_SetProjectionDimension(
            self, ProjectionDimension
        )

    def GetProjectionDimension(self):
        r"""
        GetProjectionDimension(MinimumProjectionImageFilter self) -> unsigned int


        """
        return _SimpleITK.MinimumProjectionImageFilter_GetProjectionDimension(
            self
        )

    def GetName(self):
        r"""
        GetName(MinimumProjectionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MinimumProjectionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MinimumProjectionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MinimumProjectionImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(MinimumProjectionImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.MinimumProjectionImageFilter_Execute(self, image1)


# Register MinimumProjectionImageFilter in _SimpleITK:
_SimpleITK.MinimumProjectionImageFilter_swigregister(
    MinimumProjectionImageFilter
)


def MinimumProjection(image1, projectionDimension=0):
    r"""MinimumProjection(Image image1, unsigned int projectionDimension=0) -> Image"""
    return _SimpleITK.MinimumProjection(image1, projectionDimension)


class MirrorPadImageFilter(ImageFilter):
    r"""


    Increase the image size by padding with replicants of the input image
    value.


    MirrorPadImageFilter changes the image bounds of an image. Any added pixels are filled in
    with a mirrored replica of the input image. For instance, if the
    output image needs a pixel that is two pixels to the left of the
    LargestPossibleRegion of the input image, the value assigned will be
    from the pixel two pixels inside the left boundary of the
    LargestPossibleRegion. The image bounds of the output must be
    specified.

    Visual explanation of padding regions.

    This filter is implemented as a multithreaded filter. It provides a
    DynamicThreadedGenerateData() method for its implementation.

    Exponential decay in the bounds is enabled when DecayBase has to be in
    the range (0.0, 1.0]. When it is 1.0 it is disabled. The decay rate is
    based on the Manhattan distance.


    See:
     WrapPadImageFilter , ConstantPadImageFilter

     itk::simple::MirrorPad for the procedural interface

     itk::MirrorPadImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMirrorPadImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MirrorPadImageFilter

    def __init__(self):
        r"""
        __init__(MirrorPadImageFilter self) -> MirrorPadImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MirrorPadImageFilter_swiginit(
            self, _SimpleITK.new_MirrorPadImageFilter()
        )

    def SetPadLowerBound(self, PadLowerBound):
        r"""
        SetPadLowerBound(MirrorPadImageFilter self, VectorUInt32 PadLowerBound)


        """
        return _SimpleITK.MirrorPadImageFilter_SetPadLowerBound(
            self, PadLowerBound
        )

    def GetPadLowerBound(self):
        r"""
        GetPadLowerBound(MirrorPadImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.MirrorPadImageFilter_GetPadLowerBound(self)

    def SetPadUpperBound(self, PadUpperBound):
        r"""
        SetPadUpperBound(MirrorPadImageFilter self, VectorUInt32 PadUpperBound)


        """
        return _SimpleITK.MirrorPadImageFilter_SetPadUpperBound(
            self, PadUpperBound
        )

    def GetPadUpperBound(self):
        r"""
        GetPadUpperBound(MirrorPadImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.MirrorPadImageFilter_GetPadUpperBound(self)

    def SetDecayBase(self, DecayBase):
        r"""
        SetDecayBase(MirrorPadImageFilter self, double DecayBase)


        Get/Set the base for exponential decay in mirrored region.


        """
        return _SimpleITK.MirrorPadImageFilter_SetDecayBase(self, DecayBase)

    def GetDecayBase(self):
        r"""
        GetDecayBase(MirrorPadImageFilter self) -> double


        Get/Set the base for exponential decay in mirrored region.


        """
        return _SimpleITK.MirrorPadImageFilter_GetDecayBase(self)

    def GetName(self):
        r"""
        GetName(MirrorPadImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MirrorPadImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MirrorPadImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MirrorPadImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(MirrorPadImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.MirrorPadImageFilter_Execute(self, image1)


# Register MirrorPadImageFilter in _SimpleITK:
_SimpleITK.MirrorPadImageFilter_swigregister(MirrorPadImageFilter)


def MirrorPad(*args, **kwargs):
    r"""MirrorPad(Image image1, VectorUInt32 padLowerBound=std::vector< unsigned int >(3, 0), VectorUInt32 padUpperBound=std::vector< unsigned int >(3, 0), double decayBase=1.0) -> Image"""
    return _SimpleITK.MirrorPad(*args, **kwargs)


class ModulusImageFilter(ImageFilter):
    r"""


    Computes the modulus (x % dividend) pixel-wise.


    The input pixel type must support the c++ modulus operator (%).

    If the dividend is zero, the maximum value will be returned.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     itk::simple::Modulus for the procedural interface

     itk::ModulusImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkModulusImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ModulusImageFilter

    def __init__(self):
        r"""
        __init__(ModulusImageFilter self) -> ModulusImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ModulusImageFilter_swiginit(
            self, _SimpleITK.new_ModulusImageFilter()
        )

    def GetName(self):
        r"""
        GetName(ModulusImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ModulusImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ModulusImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ModulusImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(ModulusImageFilter self, Image image1, Image image2) -> Image
        Execute(ModulusImageFilter self, Image image1, uint32_t constant) -> Image
        Execute(ModulusImageFilter self, uint32_t constant, Image image2) -> Image


        """
        return _SimpleITK.ModulusImageFilter_Execute(self, *args)


# Register ModulusImageFilter in _SimpleITK:
_SimpleITK.ModulusImageFilter_swigregister(ModulusImageFilter)


def Modulus(*args):
    r"""
    Modulus(Image image1, Image image2) -> Image
    Modulus(Image image1, uint32_t constant) -> Image
    Modulus(uint32_t constant, Image image2) -> Image


    """
    return _SimpleITK.Modulus(*args)


class MomentsThresholdImageFilter(ImageFilter):
    r"""


    Threshold an image using the Moments Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the MomentsThresholdCalculator and applies that threshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/efycla


    See:
     HistogramThresholdImageFilter

     itk::simple::MomentsThreshold for the procedural interface

     itk::MomentsThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMomentsThresholdImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MomentsThresholdImageFilter

    def __init__(self):
        r"""
        __init__(MomentsThresholdImageFilter self) -> MomentsThresholdImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MomentsThresholdImageFilter_swiginit(
            self, _SimpleITK.new_MomentsThresholdImageFilter()
        )

    def SetInsideValue(self, InsideValue):
        r"""
        SetInsideValue(MomentsThresholdImageFilter self, uint8_t InsideValue)


        Set the "inside" pixel value.


        """
        return _SimpleITK.MomentsThresholdImageFilter_SetInsideValue(
            self, InsideValue
        )

    def GetInsideValue(self):
        r"""
        GetInsideValue(MomentsThresholdImageFilter self) -> uint8_t


        Get the "inside" pixel value.


        """
        return _SimpleITK.MomentsThresholdImageFilter_GetInsideValue(self)

    def SetOutsideValue(self, OutsideValue):
        r"""
        SetOutsideValue(MomentsThresholdImageFilter self, uint8_t OutsideValue)


        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.MomentsThresholdImageFilter_SetOutsideValue(
            self, OutsideValue
        )

    def GetOutsideValue(self):
        r"""
        GetOutsideValue(MomentsThresholdImageFilter self) -> uint8_t


        Get the "outside" pixel value.


        """
        return _SimpleITK.MomentsThresholdImageFilter_GetOutsideValue(self)

    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        r"""
        SetNumberOfHistogramBins(MomentsThresholdImageFilter self, uint32_t NumberOfHistogramBins)


        Set/Get the number of histogram bins.


        """
        return _SimpleITK.MomentsThresholdImageFilter_SetNumberOfHistogramBins(
            self, NumberOfHistogramBins
        )

    def GetNumberOfHistogramBins(self):
        r"""
        GetNumberOfHistogramBins(MomentsThresholdImageFilter self) -> uint32_t


        """
        return _SimpleITK.MomentsThresholdImageFilter_GetNumberOfHistogramBins(
            self
        )

    def SetMaskOutput(self, MaskOutput):
        r"""
        SetMaskOutput(MomentsThresholdImageFilter self, bool MaskOutput)


        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.MomentsThresholdImageFilter_SetMaskOutput(
            self, MaskOutput
        )

    def MaskOutputOn(self):
        r"""
        MaskOutputOn(MomentsThresholdImageFilter self)


        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.MomentsThresholdImageFilter_MaskOutputOn(self)

    def MaskOutputOff(self):
        r"""
        MaskOutputOff(MomentsThresholdImageFilter self)


        """
        return _SimpleITK.MomentsThresholdImageFilter_MaskOutputOff(self)

    def GetMaskOutput(self):
        r"""
        GetMaskOutput(MomentsThresholdImageFilter self) -> bool


        """
        return _SimpleITK.MomentsThresholdImageFilter_GetMaskOutput(self)

    def SetMaskValue(self, MaskValue):
        r"""
        SetMaskValue(MomentsThresholdImageFilter self, uint8_t MaskValue)


        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.MomentsThresholdImageFilter_SetMaskValue(
            self, MaskValue
        )

    def GetMaskValue(self):
        r"""
        GetMaskValue(MomentsThresholdImageFilter self) -> uint8_t


        """
        return _SimpleITK.MomentsThresholdImageFilter_GetMaskValue(self)

    def GetThreshold(self):
        r"""
        GetThreshold(MomentsThresholdImageFilter self) -> double


        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.MomentsThresholdImageFilter_GetThreshold(self)

    def GetName(self):
        r"""
        GetName(MomentsThresholdImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MomentsThresholdImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MomentsThresholdImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MomentsThresholdImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(MomentsThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(MomentsThresholdImageFilter self, Image image) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.MomentsThresholdImageFilter_Execute(self, *args)


# Register MomentsThresholdImageFilter in _SimpleITK:
_SimpleITK.MomentsThresholdImageFilter_swigregister(
    MomentsThresholdImageFilter
)


def MomentsThreshold(*args):
    r"""
    MomentsThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    MomentsThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    """
    return _SimpleITK.MomentsThreshold(*args)


class MorphologicalGradientImageFilter(ImageFilter):
    r"""


    Compute the gradient of a grayscale image.


    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel.


    See:
     MorphologyImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::MorphologicalGradient for the procedural interface

     itk::MorphologicalGradientImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMorphologicalGradientImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MorphologicalGradientImageFilter

    def __init__(self):
        r"""
        __init__(MorphologicalGradientImageFilter self) -> MorphologicalGradientImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MorphologicalGradientImageFilter_swiginit(
            self, _SimpleITK.new_MorphologicalGradientImageFilter()
        )

    def SetKernelRadius(self, *args):
        r"""
        SetKernelRadius(MorphologicalGradientImageFilter self, VectorUInt32 KernelRadius)
        SetKernelRadius(MorphologicalGradientImageFilter self, unsigned int value)


        Set the values of the KernelRadius vector all to value


        """
        return _SimpleITK.MorphologicalGradientImageFilter_SetKernelRadius(
            self, *args
        )

    def GetKernelRadius(self):
        r"""
        GetKernelRadius(MorphologicalGradientImageFilter self) -> VectorUInt32


        Get the radius of the kernel structuring element.


        """
        return _SimpleITK.MorphologicalGradientImageFilter_GetKernelRadius(
            self
        )

    def SetKernelType(self, KernelType):
        r"""
        SetKernelType(MorphologicalGradientImageFilter self, itk::simple::KernelEnum KernelType)


        Set the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.MorphologicalGradientImageFilter_SetKernelType(
            self, KernelType
        )

    def GetKernelType(self):
        r"""
        GetKernelType(MorphologicalGradientImageFilter self) -> itk::simple::KernelEnum


        Get the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.MorphologicalGradientImageFilter_GetKernelType(self)

    def GetName(self):
        r"""
        GetName(MorphologicalGradientImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MorphologicalGradientImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MorphologicalGradientImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MorphologicalGradientImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(MorphologicalGradientImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.MorphologicalGradientImageFilter_Execute(
            self, image1
        )


# Register MorphologicalGradientImageFilter in _SimpleITK:
_SimpleITK.MorphologicalGradientImageFilter_swigregister(
    MorphologicalGradientImageFilter
)


def MorphologicalGradient(*args, **kwargs):
    r"""MorphologicalGradient(Image image1, VectorUInt32 kernelRadius=std::vector< uint32_t >(3, 1), itk::simple::KernelEnum kernelType=sitkBall) -> Image"""
    return _SimpleITK.MorphologicalGradient(*args, **kwargs)


class MorphologicalWatershedFromMarkersImageFilter(ImageFilter):
    r"""


    Morphological watershed transform from markers.


    The watershed transform is a tool for image segmentation that is fast
    and flexible and potentially fairly parameter free. It was originally
    derived from a geophysical model of rain falling on a terrain and a
    variety of more formal definitions have been devised to allow
    development of practical algorithms. If an image is considered as a
    terrain and divided into catchment basins then the hope is that each
    catchment basin would contain an object of interest.

    The output is a label image. A label image, sometimes referred to as a
    categorical image, has unique values for each region. For example, if
    a watershed produces 2 regions, all pixels belonging to one region
    would have value A, and all belonging to the other might have value B.
    Unassigned pixels, such as watershed lines, might have the background
    value (0 by convention).

    The simplest way of using the watershed is to preprocess the image we
    want to segment so that the boundaries of our objects are bright (e.g
    apply an edge detector) and compute the watershed transform of the
    edge image. Watershed lines will correspond to the boundaries and our
    problem will be solved. This is rarely useful in practice because
    there are always more regional minima than there are objects, either
    due to noise or natural variations in the object surfaces. Therefore,
    while many watershed lines do lie on significant boundaries, there are
    many that don't. Various methods can be used to reduce the number of
    minima in the image, like thresholding the smallest values, filtering
    the minima and/or smoothing the image.

    This filter use another approach to avoid the problem of over
    segmentation: it let the user provide a marker image which mark the
    minima in the input image and give them a label. The minima are
    imposed in the input image by the markers. The labels of the output
    image are the label of the marker image.

    The morphological watershed transform algorithm is described in
    Chapter 9.2 of Pierre Soille's book "Morphological Image Analysis:
    Principles and Applications", Second Edition, Springer, 2003.

    This code was contributed in the Insight Journal paper: "The
    watershed transform in ITK - discussion and new developments" by
    Beare R., Lehmann G. https://doi.org/10.54294/lf8u75


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    See:
     WatershedImageFilter , MorphologicalWatershedImageFilter

     itk::simple::MorphologicalWatershedFromMarkers for the procedural interface

     itk::MorphologicalWatershedFromMarkersImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMorphologicalWatershedFromMarkersImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_MorphologicalWatershedFromMarkersImageFilter
    )

    def __init__(self):
        r"""
        __init__(MorphologicalWatershedFromMarkersImageFilter self) -> MorphologicalWatershedFromMarkersImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_swiginit(
            self, _SimpleITK.new_MorphologicalWatershedFromMarkersImageFilter()
        )

    def SetMarkWatershedLine(self, MarkWatershedLine):
        r"""
        SetMarkWatershedLine(MorphologicalWatershedFromMarkersImageFilter self, bool MarkWatershedLine)


        Set/Get whether the watershed pixel must be marked or not. Default is
        true. Set it to false do not only avoid writing watershed pixels, it
        also decrease algorithm complexity.


        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_SetMarkWatershedLine(
            self, MarkWatershedLine
        )

    def MarkWatershedLineOn(self):
        r"""
        MarkWatershedLineOn(MorphologicalWatershedFromMarkersImageFilter self)


        Set the value of MarkWatershedLine to true or false respectfully.


        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_MarkWatershedLineOn(
            self
        )

    def MarkWatershedLineOff(self):
        r"""
        MarkWatershedLineOff(MorphologicalWatershedFromMarkersImageFilter self)


        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_MarkWatershedLineOff(
            self
        )

    def GetMarkWatershedLine(self):
        r"""
        GetMarkWatershedLine(MorphologicalWatershedFromMarkersImageFilter self) -> bool


        Set/Get whether the watershed pixel must be marked or not. Default is
        true. Set it to false do not only avoid writing watershed pixels, it
        also decrease algorithm complexity.


        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_GetMarkWatershedLine(
            self
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(MorphologicalWatershedFromMarkersImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(MorphologicalWatershedFromMarkersImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_FullyConnectedOn(
            self
        )

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(MorphologicalWatershedFromMarkersImageFilter self)


        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_FullyConnectedOff(
            self
        )

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(MorphologicalWatershedFromMarkersImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_GetFullyConnected(
            self
        )

    def GetName(self):
        r"""
        GetName(MorphologicalWatershedFromMarkersImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(MorphologicalWatershedFromMarkersImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter___str__(
            self
        )

    def Execute(self, image, markerImage):
        r"""
        Execute(MorphologicalWatershedFromMarkersImageFilter self, Image image, Image markerImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_Execute(
            self, image, markerImage
        )


# Register MorphologicalWatershedFromMarkersImageFilter in _SimpleITK:
_SimpleITK.MorphologicalWatershedFromMarkersImageFilter_swigregister(
    MorphologicalWatershedFromMarkersImageFilter
)


def MorphologicalWatershedFromMarkers(
    image, markerImage, markWatershedLine=True, fullyConnected=False
):
    r"""MorphologicalWatershedFromMarkers(Image image, Image markerImage, bool markWatershedLine=True, bool fullyConnected=False) -> Image"""
    return _SimpleITK.MorphologicalWatershedFromMarkers(
        image, markerImage, markWatershedLine, fullyConnected
    )


class MorphologicalWatershedImageFilter(ImageFilter):
    r"""


    Watershed segmentation implementation with morphological operators.


    Watershed pixel are labeled 0. TOutputImage should be an integer type.
    Labels of output image are in no particular order. You can reorder the
    labels such that object labels are consecutive and sorted based on
    object size by passing the output of this filter to a RelabelComponentImageFilter .

    The morphological watershed transform algorithm is described in
    Chapter 9.2 of Pierre Soille's book "Morphological Image Analysis:
    Principles and Applications", Second Edition, Springer, 2003.

    This code was contributed in the Insight Journal paper: "The
    watershed transform in ITK - discussion and new developments" by
    Beare R., Lehmann G. https://doi.org/10.54294/lf8u75


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     WatershedImageFilter , MorphologicalWatershedFromMarkersImageFilter

     itk::simple::MorphologicalWatershed for the procedural interface

     itk::MorphologicalWatershedImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMorphologicalWatershedImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MorphologicalWatershedImageFilter

    def __init__(self):
        r"""
        __init__(MorphologicalWatershedImageFilter self) -> MorphologicalWatershedImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MorphologicalWatershedImageFilter_swiginit(
            self, _SimpleITK.new_MorphologicalWatershedImageFilter()
        )

    def SetLevel(self, Level):
        r"""
        SetLevel(MorphologicalWatershedImageFilter self, double Level)


        """
        return _SimpleITK.MorphologicalWatershedImageFilter_SetLevel(
            self, Level
        )

    def GetLevel(self):
        r"""
        GetLevel(MorphologicalWatershedImageFilter self) -> double


        """
        return _SimpleITK.MorphologicalWatershedImageFilter_GetLevel(self)

    def SetMarkWatershedLine(self, MarkWatershedLine):
        r"""
        SetMarkWatershedLine(MorphologicalWatershedImageFilter self, bool MarkWatershedLine)


        Set/Get whether the watershed pixel must be marked or not. Default is
        true. Set it to false do not only avoid writing watershed pixels, it
        also decrease algorithm complexity.


        """
        return (
            _SimpleITK.MorphologicalWatershedImageFilter_SetMarkWatershedLine(
                self, MarkWatershedLine
            )
        )

    def MarkWatershedLineOn(self):
        r"""
        MarkWatershedLineOn(MorphologicalWatershedImageFilter self)


        Set the value of MarkWatershedLine to true or false respectfully.


        """
        return (
            _SimpleITK.MorphologicalWatershedImageFilter_MarkWatershedLineOn(
                self
            )
        )

    def MarkWatershedLineOff(self):
        r"""
        MarkWatershedLineOff(MorphologicalWatershedImageFilter self)


        """
        return (
            _SimpleITK.MorphologicalWatershedImageFilter_MarkWatershedLineOff(
                self
            )
        )

    def GetMarkWatershedLine(self):
        r"""
        GetMarkWatershedLine(MorphologicalWatershedImageFilter self) -> bool


        Set/Get whether the watershed pixel must be marked or not. Default is
        true. Set it to false do not only avoid writing watershed pixels, it
        also decrease algorithm complexity.


        """
        return (
            _SimpleITK.MorphologicalWatershedImageFilter_GetMarkWatershedLine(
                self
            )
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(MorphologicalWatershedImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.MorphologicalWatershedImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(MorphologicalWatershedImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.MorphologicalWatershedImageFilter_FullyConnectedOn(
            self
        )

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(MorphologicalWatershedImageFilter self)


        """
        return _SimpleITK.MorphologicalWatershedImageFilter_FullyConnectedOff(
            self
        )

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(MorphologicalWatershedImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.MorphologicalWatershedImageFilter_GetFullyConnected(
            self
        )

    def GetName(self):
        r"""
        GetName(MorphologicalWatershedImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MorphologicalWatershedImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MorphologicalWatershedImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MorphologicalWatershedImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(MorphologicalWatershedImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.MorphologicalWatershedImageFilter_Execute(
            self, image1
        )


# Register MorphologicalWatershedImageFilter in _SimpleITK:
_SimpleITK.MorphologicalWatershedImageFilter_swigregister(
    MorphologicalWatershedImageFilter
)


def MorphologicalWatershed(
    image1, level=0.0, markWatershedLine=True, fullyConnected=False
):
    r"""MorphologicalWatershed(Image image1, double level=0.0, bool markWatershedLine=True, bool fullyConnected=False) -> Image"""
    return _SimpleITK.MorphologicalWatershed(
        image1, level, markWatershedLine, fullyConnected
    )


class MultiLabelSTAPLEImageFilter(ImageFilter):
    r"""


    This filter performs a pixelwise combination of an arbitrary number of
    input images, where each of them represents a segmentation of the same
    scene (i.e., image).


    The labelings in the images are weighted relative to each other based
    on their "performance" as estimated by an expectation-maximization
    algorithm. In the process, a ground truth segmentation is estimated,
    and the estimated performances of the individual segmentations are
    relative to this estimated ground truth.

    The algorithm is based on the binary STAPLE algorithm by Warfield et
    al. as published originally in

    S. Warfield, K. Zou, W. Wells, "Validation of image segmentation and
    expert quality with an expectation-maximization algorithm" in MICCAI
    2002: Fifth International Conference on Medical Image Computing and Computer-Assisted Intervention, Springer-Verlag,
    Heidelberg, Germany, 2002, pp. 298-306

    The multi-label algorithm implemented here is described in detail in

    T. Rohlfing, D. B. Russakoff, and C. R. Maurer, Jr., "Performance-
    based classifier combination in atlas-based image segmentation using
    expectation-maximization parameter estimation," IEEE Transactions on
    Medical Imaging, vol. 23, pp. 983-994, Aug. 2004.

    INPUTS
    All input volumes to this filter must be segmentations of an image,
    that is, they must have discrete pixel values where each value
    represents a different segmented object.
     Input volumes must all contain the same size RequestedRegions. Not all input images must contain all possible labels, but all label
    values must have the same meaning in all images.

    The filter can optionally be provided with estimates for the a priori
    class probabilities through the SetPriorProbabilities function. If no
    estimate is provided, one is automatically generated by analyzing the
    relative frequencies of the labels in the input images.

    OUTPUTS
    The filter produces a single output volume. Each output pixel contains
    the label that has the highest probability of being the correct label,
    based on the performance models of the individual segmentations. If
    the maximum probability is not unique, i.e., if more than one label
    have a maximum probability, then an "undecided" label is assigned to
    that output pixel.
     By default, the label used for undecided pixels is the maximum label
    value used in the input images plus one. Since it is possible for an
    image with 8 bit pixel values to use all 256 possible label values, it
    is permissible to combine 8 bit (i.e., byte) images into a 16 bit
    (i.e., short) output image.

    In addition to the combined image, the estimated confusion matrices
    for each of the input segmentations can be obtained through the
    GetConfusionMatrix member function.

    PARAMETERS
    The label used for "undecided" labels can be set using
    SetLabelForUndecidedPixels. This functionality can be unset by calling
    UnsetLabelForUndecidedPixels.
     A termination threshold for the EM iteration can be defined by
    calling SetTerminationUpdateThreshold. The iteration terminates once
    no single parameter of any confusion matrix changes by less than this
    threshold. Alternatively, a maximum number of iterations can be
    specified by calling SetMaximumNumberOfIterations. The algorithm may
    still terminate after a smaller number of iterations if the
    termination threshold criterion is satisfied.

    EVENTS
    This filter invokes IterationEvent() at each iteration of the E-M
    algorithm. Setting the AbortGenerateData() flag will cause the
    algorithm to halt after the current iteration and produce results just
    as if it had converged. The algorithm makes no attempt to report its
    progress since the number of iterations needed cannot be known in
    advance.

    Torsten Rohlfing, SRI International, Neuroscience Program

    See:
     itk::simple::MultiLabelSTAPLE for the procedural interface


    C++ includes: sitkMultiLabelSTAPLEImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MultiLabelSTAPLEImageFilter

    def __init__(self):
        r"""
        __init__(MultiLabelSTAPLEImageFilter self) -> MultiLabelSTAPLEImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MultiLabelSTAPLEImageFilter_swiginit(
            self, _SimpleITK.new_MultiLabelSTAPLEImageFilter()
        )

    def SetLabelForUndecidedPixels(self, LabelForUndecidedPixels):
        r"""
        SetLabelForUndecidedPixels(MultiLabelSTAPLEImageFilter self, uint64_t LabelForUndecidedPixels)


        Set label value for undecided pixels.


        """
        return (
            _SimpleITK.MultiLabelSTAPLEImageFilter_SetLabelForUndecidedPixels(
                self, LabelForUndecidedPixels
            )
        )

    def GetLabelForUndecidedPixels(self):
        r"""
        GetLabelForUndecidedPixels(MultiLabelSTAPLEImageFilter self) -> uint64_t


             Get label value used for undecided pixels.

        After updating the filter, this function returns the actual label
        value used for undecided pixels in the current output. Note that this
        value is overwritten when SetLabelForUndecidedPixels is called and the
        new value only becomes effective upon the next filter update.


        """
        return (
            _SimpleITK.MultiLabelSTAPLEImageFilter_GetLabelForUndecidedPixels(
                self
            )
        )

    def SetTerminationUpdateThreshold(self, TerminationUpdateThreshold):
        r"""
        SetTerminationUpdateThreshold(MultiLabelSTAPLEImageFilter self, float TerminationUpdateThreshold)


        Set termination threshold based on confusion matrix parameter updates.


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter_SetTerminationUpdateThreshold(
            self, TerminationUpdateThreshold
        )

    def GetTerminationUpdateThreshold(self):
        r"""
        GetTerminationUpdateThreshold(MultiLabelSTAPLEImageFilter self) -> float


        Set termination threshold based on confusion matrix parameter updates.


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter_GetTerminationUpdateThreshold(
            self
        )

    def SetMaximumNumberOfIterations(self, MaximumNumberOfIterations):
        r"""
        SetMaximumNumberOfIterations(MultiLabelSTAPLEImageFilter self, unsigned int MaximumNumberOfIterations)


        Set maximum number of iterations.


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter_SetMaximumNumberOfIterations(
            self, MaximumNumberOfIterations
        )

    def GetMaximumNumberOfIterations(self):
        r"""
        GetMaximumNumberOfIterations(MultiLabelSTAPLEImageFilter self) -> unsigned int


        Set maximum number of iterations.


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter_GetMaximumNumberOfIterations(
            self
        )

    def SetPriorProbabilities(self, PriorProbabilities):
        r"""
        SetPriorProbabilities(MultiLabelSTAPLEImageFilter self, VectorFloat PriorProbabilities)


             Set manual estimates for the a priori class probabilities. The
        size of the array must be greater than the value of the largest label. The index into the array corresponds to the label
        value in the segmented image for the class.


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter_SetPriorProbabilities(
            self, PriorProbabilities
        )

    def GetPriorProbabilities(self):
        r"""
        GetPriorProbabilities(MultiLabelSTAPLEImageFilter self) -> VectorFloat


             Get prior class probabilities.

        After updating the filter, this function returns the actual prior
        class probabilities. If these were not previously set by a call to
        SetPriorProbabilities, then they are estimated from the input
        segmentations and the result is available through this function.


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter_GetPriorProbabilities(
            self
        )

    def GetConfusionMatrix(self, input):
        r"""
        GetConfusionMatrix(MultiLabelSTAPLEImageFilter self, unsigned int input) -> VectorFloat


        Get confusion matrix for the i-th input segmentation.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter_GetConfusionMatrix(
            self, input
        )

    def GetName(self):
        r"""
        GetName(MultiLabelSTAPLEImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MultiLabelSTAPLEImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(MultiLabelSTAPLEImageFilter self, VectorOfImage images) -> Image
        Execute(MultiLabelSTAPLEImageFilter self, Image image1) -> Image
        Execute(MultiLabelSTAPLEImageFilter self, Image image1, Image image2) -> Image
        Execute(MultiLabelSTAPLEImageFilter self, Image image1, Image image2, Image image3) -> Image
        Execute(MultiLabelSTAPLEImageFilter self, Image image1, Image image2, Image image3, Image image4) -> Image
        Execute(MultiLabelSTAPLEImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5) -> Image


        Execute the filter on the input images


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter_Execute(self, *args)


# Register MultiLabelSTAPLEImageFilter in _SimpleITK:
_SimpleITK.MultiLabelSTAPLEImageFilter_swigregister(
    MultiLabelSTAPLEImageFilter
)


def MultiLabelSTAPLE(*args):
    r"""
    MultiLabelSTAPLE(VectorOfImage images, uint64_t labelForUndecidedPixels=std::numeric_limits< uint64_t >::max(), float terminationUpdateThreshold=1e-5, unsigned int maximumNumberOfIterations=std::numeric_limits< unsigned int >::max(), VectorFloat priorProbabilities=std::vector< float >()) -> Image
    MultiLabelSTAPLE(Image image1, uint64_t labelForUndecidedPixels=std::numeric_limits< uint64_t >::max(), float terminationUpdateThreshold=1e-5, unsigned int maximumNumberOfIterations=std::numeric_limits< unsigned int >::max(), VectorFloat priorProbabilities=std::vector< float >()) -> Image
    MultiLabelSTAPLE(Image image1, Image image2, uint64_t labelForUndecidedPixels=std::numeric_limits< uint64_t >::max(), float terminationUpdateThreshold=1e-5, unsigned int maximumNumberOfIterations=std::numeric_limits< unsigned int >::max(), VectorFloat priorProbabilities=std::vector< float >()) -> Image
    MultiLabelSTAPLE(Image image1, Image image2, Image image3, uint64_t labelForUndecidedPixels=std::numeric_limits< uint64_t >::max(), float terminationUpdateThreshold=1e-5, unsigned int maximumNumberOfIterations=std::numeric_limits< unsigned int >::max(), VectorFloat priorProbabilities=std::vector< float >()) -> Image
    MultiLabelSTAPLE(Image image1, Image image2, Image image3, Image image4, uint64_t labelForUndecidedPixels=std::numeric_limits< uint64_t >::max(), float terminationUpdateThreshold=1e-5, unsigned int maximumNumberOfIterations=std::numeric_limits< unsigned int >::max(), VectorFloat priorProbabilities=std::vector< float >()) -> Image
    MultiLabelSTAPLE(Image image1, Image image2, Image image3, Image image4, Image image5, uint64_t labelForUndecidedPixels=std::numeric_limits< uint64_t >::max(), float terminationUpdateThreshold=1e-5, unsigned int maximumNumberOfIterations=std::numeric_limits< unsigned int >::max(), VectorFloat priorProbabilities=std::vector< float >()) -> Image
    """
    return _SimpleITK.MultiLabelSTAPLE(*args)


class MultiplyImageFilter(ImageFilter):
    r"""


    Pixel-wise multiplication of two images.


    This class is templated over the types of the two input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.
    See:
     itk::simple::Multiply for the procedural interface

     itk::MultiplyImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMultiplyImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_MultiplyImageFilter

    def __init__(self):
        r"""
        __init__(MultiplyImageFilter self) -> MultiplyImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.MultiplyImageFilter_swiginit(
            self, _SimpleITK.new_MultiplyImageFilter()
        )

    def GetName(self):
        r"""
        GetName(MultiplyImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.MultiplyImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(MultiplyImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.MultiplyImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(MultiplyImageFilter self, Image image1, Image image2) -> Image
        Execute(MultiplyImageFilter self, Image image1, double constant) -> Image
        Execute(MultiplyImageFilter self, double constant, Image image2) -> Image


        """
        return _SimpleITK.MultiplyImageFilter_Execute(self, *args)


# Register MultiplyImageFilter in _SimpleITK:
_SimpleITK.MultiplyImageFilter_swigregister(MultiplyImageFilter)


def Multiply(*args):
    r"""
    Multiply(Image image1, Image image2) -> Image
    Multiply(Image image1, double constant) -> Image
    Multiply(double constant, Image image2) -> Image


    """
    return _SimpleITK.Multiply(*args)


class N4BiasFieldCorrectionImageFilter(ImageFilter):
    r"""


    Implementation of the N4 bias field correction algorithm.


    The nonparametric nonuniform intensity normalization (N3) algorithm,
    as introduced by Sled et al. in 1998 is a method for correcting
    nonuniformity associated with MR images. The algorithm assumes a
    simple parametric model (Gaussian) for the bias field and does not
    require tissue class segmentation. In addition, there are only a
    couple of parameters to tune with the default values performing quite
    well. N3 has been publicly available as a set of perl scripts ( https://www.bic.mni.mcgill.ca/ServicesSoftwareAdvancedImageProcessingT
    ools/HomePage )

    The N4 algorithm, encapsulated with this class, is a variation of the
    original N3 algorithm with the additional benefits of an improved
    B-spline fitting routine which allows for multiple resolutions to be
    used during the correction process. We also modify the iterative
    update component of algorithm such that the residual bias field is
    continually updated

    Notes for the user:
    Since much of the image manipulation is done in the log space of the
    intensities, input images with negative and small values (< 1) can
    produce poor results.

    The original authors recommend performing the bias field correction on
    a downsampled version of the original image.

    A binary mask or a weighted image can be supplied. If a binary mask is
    specified, those voxels in the input image which correspond to the
    voxels in the mask image are used to estimate the bias field. If a
    UseMaskLabel value is set to false (the default), all non-zero voxels
    in the MaskImage will be masked; otherwise only voxels in the
    MaskImage that match the MaskLabel will be used. If a confidence image
    is specified, the input voxels are weighted in the b-spline fitting
    routine according to the confidence voxel values.

    The filter returns the corrected image. If the bias field is wanted,
    one can reconstruct it using the class
    itkBSplineControlPointImageFilter. See the IJ article and the test
    file for an example.

    The 'Z' parameter in Sled's 1998 paper is the square root of the class
    variable 'm_WienerFilterNoise'.
     The basic algorithm iterates between sharpening the intensity
    histogram of the corrected input image and spatially smoothing those
    results with a B-spline scalar field estimate of the bias field.


    Nicholas J. Tustison
     Contributed by Nicholas J. Tustison, James C. Gee in the Insight
    Journal paper: https://doi.org/10.54294/jculxw

    REFERENCE
     J.G. Sled, A.P. Zijdenbos and A.C. Evans. "A Nonparametric Method
    for Automatic Correction of Intensity Nonuniformity in Data" IEEE
    Transactions on Medical Imaging, Vol 17, No 1. Feb 1998.

    N.J. Tustison, B.B. Avants, P.A. Cook, Y. Zheng, A. Egan, P.A.
    Yushkevich, and J.C. Gee. "N4ITK: Improved N3 Bias Correction" IEEE
    Transactions on Medical Imaging, 29(6):1310-1320, June 2010.
    See:
     itk::simple::N4BiasFieldCorrection for the procedural interface

     itk::N4BiasFieldCorrectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkN4BiasFieldCorrectionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_N4BiasFieldCorrectionImageFilter

    def __init__(self):
        r"""
        __init__(N4BiasFieldCorrectionImageFilter self) -> N4BiasFieldCorrectionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.N4BiasFieldCorrectionImageFilter_swiginit(
            self, _SimpleITK.new_N4BiasFieldCorrectionImageFilter()
        )

    def SetConvergenceThreshold(self, ConvergenceThreshold):
        r"""
        SetConvergenceThreshold(N4BiasFieldCorrectionImageFilter self, double ConvergenceThreshold)


        Set the convergence threshold. Convergence is determined by the
        coefficient of variation of the difference image between the current
        bias field estimate and the previous estimate. If this value is less
        than the specified threshold, the algorithm proceeds to the next
        fitting level or terminates if it is at the last level.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_SetConvergenceThreshold(
            self, ConvergenceThreshold
        )

    def GetConvergenceThreshold(self):
        r"""
        GetConvergenceThreshold(N4BiasFieldCorrectionImageFilter self) -> double


        Get the convergence threshold. Convergence is determined by the
        coefficient of variation of the difference image between the current
        bias field estimate and the previous estimate. If this value is less
        than the specified threshold, the algorithm proceeds to the next
        fitting level or terminates if it is at the last level.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_GetConvergenceThreshold(
            self
        )

    def SetMaximumNumberOfIterations(self, MaximumNumberOfIterations):
        r"""
        SetMaximumNumberOfIterations(N4BiasFieldCorrectionImageFilter self, VectorUInt32 MaximumNumberOfIterations)


        Set the maximum number of iterations specified at each fitting level.
        Default = 50.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_SetMaximumNumberOfIterations(
            self, MaximumNumberOfIterations
        )

    def GetMaximumNumberOfIterations(self):
        r"""
        GetMaximumNumberOfIterations(N4BiasFieldCorrectionImageFilter self) -> VectorUInt32


        Get the maximum number of iterations specified at each fitting level.
        Default = 50.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_GetMaximumNumberOfIterations(
            self
        )

    def SetBiasFieldFullWidthAtHalfMaximum(
        self, BiasFieldFullWidthAtHalfMaximum
    ):
        r"""
        SetBiasFieldFullWidthAtHalfMaximum(N4BiasFieldCorrectionImageFilter self, double BiasFieldFullWidthAtHalfMaximum)


        Set the full width at half maximum parameter characterizing the width
        of the Gaussian deconvolution. Default = 0.15.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_SetBiasFieldFullWidthAtHalfMaximum(
            self, BiasFieldFullWidthAtHalfMaximum
        )

    def GetBiasFieldFullWidthAtHalfMaximum(self):
        r"""
        GetBiasFieldFullWidthAtHalfMaximum(N4BiasFieldCorrectionImageFilter self) -> double


        Get the full width at half maximum parameter characterizing the width
        of the Gaussian deconvolution. Default = 0.15.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_GetBiasFieldFullWidthAtHalfMaximum(
            self
        )

    def SetWienerFilterNoise(self, WienerFilterNoise):
        r"""
        SetWienerFilterNoise(N4BiasFieldCorrectionImageFilter self, double WienerFilterNoise)


        Set the noise estimate defining the Wiener filter. Default = 0.01.


        """
        return (
            _SimpleITK.N4BiasFieldCorrectionImageFilter_SetWienerFilterNoise(
                self, WienerFilterNoise
            )
        )

    def GetWienerFilterNoise(self):
        r"""
        GetWienerFilterNoise(N4BiasFieldCorrectionImageFilter self) -> double


        Get the noise estimate defining the Wiener filter. Default = 0.01.


        """
        return (
            _SimpleITK.N4BiasFieldCorrectionImageFilter_GetWienerFilterNoise(
                self
            )
        )

    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        r"""
        SetNumberOfHistogramBins(N4BiasFieldCorrectionImageFilter self, uint32_t NumberOfHistogramBins)


        Set number of bins defining the log input intensity histogram. Default
        = 200.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_SetNumberOfHistogramBins(
            self, NumberOfHistogramBins
        )

    def GetNumberOfHistogramBins(self):
        r"""
        GetNumberOfHistogramBins(N4BiasFieldCorrectionImageFilter self) -> uint32_t


        Get number of bins defining the log input intensity histogram. Default
        = 200.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_GetNumberOfHistogramBins(
            self
        )

    def SetNumberOfControlPoints(self, *args):
        r"""
        SetNumberOfControlPoints(N4BiasFieldCorrectionImageFilter self, VectorUInt32 NumberOfControlPoints)
        SetNumberOfControlPoints(N4BiasFieldCorrectionImageFilter self, uint32_t value)


        Set the values of the NumberOfControlPoints vector all to value


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_SetNumberOfControlPoints(
            self, *args
        )

    def GetNumberOfControlPoints(self):
        r"""
        GetNumberOfControlPoints(N4BiasFieldCorrectionImageFilter self) -> VectorUInt32


        Get the control point grid size defining the B-spline estimate of the
        scalar bias field. In each dimension, the B-spline mesh size is equal
        to the number of control points in that dimension minus the spline
        order. Default = 4 control points in each dimension for a mesh size of
        1 in each dimension.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_GetNumberOfControlPoints(
            self
        )

    def SetSplineOrder(self, SplineOrder):
        r"""
        SetSplineOrder(N4BiasFieldCorrectionImageFilter self, uint32_t SplineOrder)


        Set the spline order defining the bias field estimate. Default = 3.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_SetSplineOrder(
            self, SplineOrder
        )

    def GetSplineOrder(self):
        r"""
        GetSplineOrder(N4BiasFieldCorrectionImageFilter self) -> uint32_t


        Get the spline order defining the bias field estimate. Default = 3.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_GetSplineOrder(self)

    def SetUseMaskLabel(self, UseMaskLabel):
        r"""
        SetUseMaskLabel(N4BiasFieldCorrectionImageFilter self, bool UseMaskLabel)


        Use a mask label for identifying mask functionality. See SetMaskLabel.
        Defaults to true.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_SetUseMaskLabel(
            self, UseMaskLabel
        )

    def UseMaskLabelOn(self):
        r"""
        UseMaskLabelOn(N4BiasFieldCorrectionImageFilter self)


        Set the value of UseMaskLabel to true or false respectfully.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_UseMaskLabelOn(self)

    def UseMaskLabelOff(self):
        r"""
        UseMaskLabelOff(N4BiasFieldCorrectionImageFilter self)


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_UseMaskLabelOff(
            self
        )

    def GetUseMaskLabel(self):
        r"""
        GetUseMaskLabel(N4BiasFieldCorrectionImageFilter self) -> bool


        Use a mask label for identifying mask functionality. See SetMaskLabel.
        Defaults to true.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_GetUseMaskLabel(
            self
        )

    def SetMaskLabel(self, MaskLabel):
        r"""
        SetMaskLabel(N4BiasFieldCorrectionImageFilter self, uint8_t MaskLabel)


        Set/Get mask label value. If a binary mask image is specified and if
        UseMaskValue is true, only those input image voxels corresponding with
        mask image values equal to MaskLabel are used in estimating the bias
        field. If a MaskImage is specified and UseMaskLabel is false, all
        input image voxels corresponding to non-zero voxels in the MaskImage
        are used in estimating the bias field. Default = 1.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_SetMaskLabel(
            self, MaskLabel
        )

    def GetMaskLabel(self):
        r"""
        GetMaskLabel(N4BiasFieldCorrectionImageFilter self) -> uint8_t


        Set/Get mask label value. If a binary mask image is specified and if
        UseMaskValue is true, only those input image voxels corresponding with
        mask image values equal to MaskLabel are used in estimating the bias
        field. If a MaskImage is specified and UseMaskLabel is false, all
        input image voxels corresponding to non-zero voxels in the MaskImage
        are used in estimating the bias field. Default = 1.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_GetMaskLabel(self)

    def GetCurrentLevel(self):
        r"""
        GetCurrentLevel(N4BiasFieldCorrectionImageFilter self) -> uint32_t


        Get the current fitting level. This is a helper function for reporting
        observations.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_GetCurrentLevel(
            self
        )

    def GetElapsedIterations(self):
        r"""
        GetElapsedIterations(N4BiasFieldCorrectionImageFilter self) -> uint32_t


        Get the number of elapsed iterations. This is a helper function for
        reporting observations.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return (
            _SimpleITK.N4BiasFieldCorrectionImageFilter_GetElapsedIterations(
                self
            )
        )

    def GetCurrentConvergenceMeasurement(self):
        r"""
        GetCurrentConvergenceMeasurement(N4BiasFieldCorrectionImageFilter self) -> double


        Get the current convergence measurement. This is a helper function for
        reporting observations.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_GetCurrentConvergenceMeasurement(
            self
        )

    def GetLogBiasFieldAsImage(self, referenceImage):
        r"""
        GetLogBiasFieldAsImage(N4BiasFieldCorrectionImageFilter self, Image referenceImage) -> Image


        The computed log bias field correction. Typically, a reduced size
        image is used as input to the N4 filter using something like
        itkShrinkImageFilter. Since the output is a corrected version of the
        input, the user will probably want to apply the bias field correction
        to the full resolution image. Returns the b-spline log bias field
        reconstructioned onto the space of the referenceImage parameter. An
        input image can be corrected by: input/exp(bias_field).


         This is an active measurement. It may be accessed while the  filter
        is being executing in command call-backs and can be  accessed after
        execution.


        """
        return (
            _SimpleITK.N4BiasFieldCorrectionImageFilter_GetLogBiasFieldAsImage(
                self, referenceImage
            )
        )

    def GetName(self):
        r"""
        GetName(N4BiasFieldCorrectionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(N4BiasFieldCorrectionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(N4BiasFieldCorrectionImageFilter self, Image image, Image maskImage) -> Image
        Execute(N4BiasFieldCorrectionImageFilter self, Image image) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_Execute(self, *args)


# Register N4BiasFieldCorrectionImageFilter in _SimpleITK:
_SimpleITK.N4BiasFieldCorrectionImageFilter_swigregister(
    N4BiasFieldCorrectionImageFilter
)


def N4BiasFieldCorrection(*args):
    r"""
    N4BiasFieldCorrection(Image image, Image maskImage, double convergenceThreshold=0.001, VectorUInt32 maximumNumberOfIterations=std::vector< uint32_t >(4,50), double biasFieldFullWidthAtHalfMaximum=0.15, double wienerFilterNoise=0.01, uint32_t numberOfHistogramBins=200, VectorUInt32 numberOfControlPoints=std::vector< uint32_t >(3, 4), uint32_t splineOrder=3, bool useMaskLabel=True, uint8_t maskLabel=1) -> Image
    N4BiasFieldCorrection(Image image, double convergenceThreshold=0.001, VectorUInt32 maximumNumberOfIterations=std::vector< uint32_t >(4,50), double biasFieldFullWidthAtHalfMaximum=0.15, double wienerFilterNoise=0.01, uint32_t numberOfHistogramBins=200, VectorUInt32 numberOfControlPoints=std::vector< uint32_t >(3, 4), uint32_t splineOrder=3, bool useMaskLabel=True, uint8_t maskLabel=1) -> Image
    """
    return _SimpleITK.N4BiasFieldCorrection(*args)


class NaryAddImageFilter(ImageFilter):
    r"""


    Pixel-wise addition of N images.


    This class is templated over the types of the input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    The pixel type of the input images must have a valid definition of the
    operator+ with each other. This condition is required because
    internally this filter will perform the operation


    Additionally the type resulting from the sum, will be cast to the
    pixel type of the output image.

    The total operation over one pixel will be


    For example, this filter could be used directly for adding images
    whose pixels are vectors of the same dimension, and to store the
    resulting vector in an output image of vector pixels.


    WARNING:
    No numeric overflow checking is performed in this filter.

    See:
     itk::simple::NaryAdd for the procedural interface


    C++ includes: sitkNaryAddImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_NaryAddImageFilter

    def __init__(self):
        r"""
        __init__(NaryAddImageFilter self) -> NaryAddImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.NaryAddImageFilter_swiginit(
            self, _SimpleITK.new_NaryAddImageFilter()
        )

    def GetName(self):
        r"""
        GetName(NaryAddImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.NaryAddImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(NaryAddImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.NaryAddImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(NaryAddImageFilter self, VectorOfImage images) -> Image
        Execute(NaryAddImageFilter self, Image image1) -> Image
        Execute(NaryAddImageFilter self, Image image1, Image image2) -> Image
        Execute(NaryAddImageFilter self, Image image1, Image image2, Image image3) -> Image
        Execute(NaryAddImageFilter self, Image image1, Image image2, Image image3, Image image4) -> Image
        Execute(NaryAddImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5) -> Image


        Execute the filter on the input images


        """
        return _SimpleITK.NaryAddImageFilter_Execute(self, *args)


# Register NaryAddImageFilter in _SimpleITK:
_SimpleITK.NaryAddImageFilter_swigregister(NaryAddImageFilter)


def NaryAdd(*args):
    r"""
    NaryAdd(VectorOfImage images) -> Image
    NaryAdd(Image image1) -> Image
    NaryAdd(Image image1, Image image2) -> Image
    NaryAdd(Image image1, Image image2, Image image3) -> Image
    NaryAdd(Image image1, Image image2, Image image3, Image image4) -> Image
    NaryAdd(Image image1, Image image2, Image image3, Image image4, Image image5) -> Image
    """
    return _SimpleITK.NaryAdd(*args)


class NaryMaximumImageFilter(ImageFilter):
    r"""


    Computes the pixel-wise maximum of several images.


    This class is templated over the types of the input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    The pixel type of the output images must have a valid definition of
    the operator<. This condition is required because internally this
    filter will perform an operation similar to:

     (where current_maximum is also of type OutputPixelType)

    for each of the n input images.

    For example, this filter could be used directly to find a "maximum
    projection" of a series of images, often used in preliminary analysis
    of time-series data.


    Zachary Pincus
     This filter was contributed by Zachary Pincus from the Department of
    Biochemistry and Program in Biomedical Informatics at Stanford
    University School of Medicine


    See:
     itk::simple::NaryMaximum for the procedural interface


    C++ includes: sitkNaryMaximumImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_NaryMaximumImageFilter

    def __init__(self):
        r"""
        __init__(NaryMaximumImageFilter self) -> NaryMaximumImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.NaryMaximumImageFilter_swiginit(
            self, _SimpleITK.new_NaryMaximumImageFilter()
        )

    def GetName(self):
        r"""
        GetName(NaryMaximumImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.NaryMaximumImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(NaryMaximumImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.NaryMaximumImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(NaryMaximumImageFilter self, VectorOfImage images) -> Image
        Execute(NaryMaximumImageFilter self, Image image1) -> Image
        Execute(NaryMaximumImageFilter self, Image image1, Image image2) -> Image
        Execute(NaryMaximumImageFilter self, Image image1, Image image2, Image image3) -> Image
        Execute(NaryMaximumImageFilter self, Image image1, Image image2, Image image3, Image image4) -> Image
        Execute(NaryMaximumImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5) -> Image


        Execute the filter on the input images


        """
        return _SimpleITK.NaryMaximumImageFilter_Execute(self, *args)


# Register NaryMaximumImageFilter in _SimpleITK:
_SimpleITK.NaryMaximumImageFilter_swigregister(NaryMaximumImageFilter)


def NaryMaximum(*args):
    r"""
    NaryMaximum(VectorOfImage images) -> Image
    NaryMaximum(Image image1) -> Image
    NaryMaximum(Image image1, Image image2) -> Image
    NaryMaximum(Image image1, Image image2, Image image3) -> Image
    NaryMaximum(Image image1, Image image2, Image image3, Image image4) -> Image
    NaryMaximum(Image image1, Image image2, Image image3, Image image4, Image image5) -> Image
    """
    return _SimpleITK.NaryMaximum(*args)


class NeighborhoodConnectedImageFilter(ImageFilter):
    r"""


    Label pixels that are connected to a seed and lie within a neighborhood.


    NeighborhoodConnectedImageFilter labels pixels with ReplaceValue that are connected to an initial Seed
    AND whose neighbors all lie within a Lower and Upper threshold range.
    See:
     itk::simple::NeighborhoodConnected for the procedural interface

     itk::NeighborhoodConnectedImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkNeighborhoodConnectedImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_NeighborhoodConnectedImageFilter

    def __init__(self):
        r"""
        __init__(NeighborhoodConnectedImageFilter self) -> NeighborhoodConnectedImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.NeighborhoodConnectedImageFilter_swiginit(
            self, _SimpleITK.new_NeighborhoodConnectedImageFilter()
        )

    def SetSeedList(self, SeedList):
        r"""
        SetSeedList(NeighborhoodConnectedImageFilter self, VectorUIntList SeedList)


        Set list of image indexes for seeds.


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_SetSeedList(
            self, SeedList
        )

    def GetSeedList(self):
        r"""
        GetSeedList(NeighborhoodConnectedImageFilter self) -> VectorUIntList


        Get list of seeds.


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_GetSeedList(self)

    def AddSeed(self, point):
        r"""
        AddSeed(NeighborhoodConnectedImageFilter self, VectorUInt32 point)


        Add SeedList point.


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_AddSeed(self, point)

    def ClearSeeds(self):
        r"""
        ClearSeeds(NeighborhoodConnectedImageFilter self)


        Remove all SeedList points.


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_ClearSeeds(self)

    def SetLower(self, Lower):
        r"""
        SetLower(NeighborhoodConnectedImageFilter self, double Lower)


        Set/Get the lower threshold. The default is 0.


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_SetLower(
            self, Lower
        )

    def GetLower(self):
        r"""
        GetLower(NeighborhoodConnectedImageFilter self) -> double


        Set/Get the lower threshold. The default is 0.


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_GetLower(self)

    def SetUpper(self, Upper):
        r"""
        SetUpper(NeighborhoodConnectedImageFilter self, double Upper)


        Set/Get the upper threshold. The default is the largest possible value
        for the InputPixelType.


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_SetUpper(
            self, Upper
        )

    def GetUpper(self):
        r"""
        GetUpper(NeighborhoodConnectedImageFilter self) -> double


        Set/Get the upper threshold. The default is the largest possible value
        for the InputPixelType.


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_GetUpper(self)

    def SetRadius(self, *args):
        r"""
        SetRadius(NeighborhoodConnectedImageFilter self, VectorUInt32 Radius)
        SetRadius(NeighborhoodConnectedImageFilter self, unsigned int value)


        Set the values of the Radius vector all to value


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_SetRadius(
            self, *args
        )

    def GetRadius(self):
        r"""
        GetRadius(NeighborhoodConnectedImageFilter self) -> VectorUInt32


        Get the radius of the neighborhood used to compute the median


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_GetRadius(self)

    def SetReplaceValue(self, ReplaceValue):
        r"""
        SetReplaceValue(NeighborhoodConnectedImageFilter self, double ReplaceValue)


        Set/Get value to replace thresholded pixels. Pixels that lie * within
        Lower and Upper (inclusive) will be replaced with this value. The
        default is 1.


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_SetReplaceValue(
            self, ReplaceValue
        )

    def GetReplaceValue(self):
        r"""
        GetReplaceValue(NeighborhoodConnectedImageFilter self) -> double


        Set/Get value to replace thresholded pixels. Pixels that lie * within
        Lower and Upper (inclusive) will be replaced with this value. The
        default is 1.


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_GetReplaceValue(
            self
        )

    def GetName(self):
        r"""
        GetName(NeighborhoodConnectedImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(NeighborhoodConnectedImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(NeighborhoodConnectedImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_Execute(
            self, image1
        )


# Register NeighborhoodConnectedImageFilter in _SimpleITK:
_SimpleITK.NeighborhoodConnectedImageFilter_swigregister(
    NeighborhoodConnectedImageFilter
)


def NeighborhoodConnected(*args, **kwargs):
    r"""NeighborhoodConnected(Image image1, VectorUIntList seedList=std::vector< std::vector< unsigned int > >(), double lower=0, double upper=1, VectorUInt32 radius=std::vector< unsigned int >(3, 1), double replaceValue=1) -> Image"""
    return _SimpleITK.NeighborhoodConnected(*args, **kwargs)


class NoiseImageFilter(ImageFilter):
    r"""


    Calculate the local noise in an image.


    Computes an image where a given pixel is the standard deviation of the
    pixels in a neighborhood about the corresponding input pixel. This
    serves as an estimate of the local noise (or texture) in an image.
    Currently, this noise estimate assume a piecewise constant image. This
    filter should be extended to fitting a (hyper) plane to the
    neighborhood and calculating the standard deviation of the residuals
    to this (hyper) plane.


    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     itk::simple::Noise for the procedural interface

     itk::NoiseImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkNoiseImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_NoiseImageFilter

    def __init__(self):
        r"""
        __init__(NoiseImageFilter self) -> NoiseImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.NoiseImageFilter_swiginit(
            self, _SimpleITK.new_NoiseImageFilter()
        )

    def SetRadius(self, *args):
        r"""
        SetRadius(NoiseImageFilter self, VectorUInt32 Radius)
        SetRadius(NoiseImageFilter self, unsigned int value)


        Set the values of the Radius vector all to value


        """
        return _SimpleITK.NoiseImageFilter_SetRadius(self, *args)

    def GetRadius(self):
        r"""
        GetRadius(NoiseImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.NoiseImageFilter_GetRadius(self)

    def GetName(self):
        r"""
        GetName(NoiseImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.NoiseImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(NoiseImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.NoiseImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(NoiseImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.NoiseImageFilter_Execute(self, image1)


# Register NoiseImageFilter in _SimpleITK:
_SimpleITK.NoiseImageFilter_swigregister(NoiseImageFilter)


def Noise(*args, **kwargs):
    r"""Noise(Image image1, VectorUInt32 radius=std::vector< unsigned int >(3, 1)) -> Image"""
    return _SimpleITK.Noise(*args, **kwargs)


class NormalizeImageFilter(ImageFilter):
    r"""


    Normalize an image by setting its mean to zero and variance to one.


    NormalizeImageFilter shifts and scales an image so that the pixels in the image have a
    zero mean and unit variance. This filter uses StatisticsImageFilter to compute the mean and variance of the input and then applies ShiftScaleImageFilter to shift and scale the pixels.

    NB: since this filter normalizes the data such that the mean is at 0,
    and $-\\sigma$ to $+\\sigma$ is mapped to -1.0 to 1.0, output image integral types will produce an
    image that DOES NOT HAVE a unit variance due to 68% of the intensity
    values being mapped to the real number range of -1.0 to 1.0 and then
    cast to the output integral value.


    See:
     NormalizeToConstantImageFilter

     itk::simple::Normalize for the procedural interface

     itk::NormalizeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkNormalizeImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_NormalizeImageFilter

    def __init__(self):
        r"""
        __init__(NormalizeImageFilter self) -> NormalizeImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.NormalizeImageFilter_swiginit(
            self, _SimpleITK.new_NormalizeImageFilter()
        )

    def GetName(self):
        r"""
        GetName(NormalizeImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.NormalizeImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(NormalizeImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.NormalizeImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(NormalizeImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.NormalizeImageFilter_Execute(self, image1)


# Register NormalizeImageFilter in _SimpleITK:
_SimpleITK.NormalizeImageFilter_swigregister(NormalizeImageFilter)


def Normalize(image1):
    r"""Normalize(Image image1) -> Image"""
    return _SimpleITK.Normalize(image1)


class NormalizeToConstantImageFilter(ImageFilter):
    r"""


    Scales image pixel intensities to make the sum of all pixels equal a
    user-defined constant.


    The default value of the constant is 1. It can be changed with SetConstant() .

    This transform is especially useful for normalizing a convolution
    kernel.

    This code was contributed in the Insight Journal paper: "FFT based
    convolution" by Lehmann G. https://doi.org/10.54294/0iky0u


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     NormalizeImageFilter

     StatisticsImageFilter

     DivideImageFilter

     itk::simple::NormalizeToConstant for the procedural interface

     itk::NormalizeToConstantImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkNormalizeToConstantImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_NormalizeToConstantImageFilter

    def __init__(self):
        r"""
        __init__(NormalizeToConstantImageFilter self) -> NormalizeToConstantImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.NormalizeToConstantImageFilter_swiginit(
            self, _SimpleITK.new_NormalizeToConstantImageFilter()
        )

    def SetConstant(self, Constant):
        r"""
        SetConstant(NormalizeToConstantImageFilter self, double Constant)


        Set/get the normalization constant.


        """
        return _SimpleITK.NormalizeToConstantImageFilter_SetConstant(
            self, Constant
        )

    def GetConstant(self):
        r"""
        GetConstant(NormalizeToConstantImageFilter self) -> double


        Set/get the normalization constant.


        """
        return _SimpleITK.NormalizeToConstantImageFilter_GetConstant(self)

    def GetName(self):
        r"""
        GetName(NormalizeToConstantImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.NormalizeToConstantImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(NormalizeToConstantImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.NormalizeToConstantImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(NormalizeToConstantImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.NormalizeToConstantImageFilter_Execute(self, image1)


# Register NormalizeToConstantImageFilter in _SimpleITK:
_SimpleITK.NormalizeToConstantImageFilter_swigregister(
    NormalizeToConstantImageFilter
)


def NormalizeToConstant(image1, constant=1.0):
    r"""NormalizeToConstant(Image image1, double constant=1.0) -> Image"""
    return _SimpleITK.NormalizeToConstant(image1, constant)


class NormalizedCorrelationImageFilter(ImageFilter):
    r"""


    Computes the normalized correlation of an image and a template.


    This filter calculates the normalized correlation between an image and
    the template. Normalized correlation is frequently use in feature
    detection because it is invariant to local changes in contrast.

    The filter can be given a mask. When presented with an input image and
    a mask, the normalized correlation is only calculated at those pixels
    under the mask.


    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     itk::simple::NormalizedCorrelation for the procedural interface

     itk::NormalizedCorrelationImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkNormalizedCorrelationImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_NormalizedCorrelationImageFilter

    def __init__(self):
        r"""
        __init__(NormalizedCorrelationImageFilter self) -> NormalizedCorrelationImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.NormalizedCorrelationImageFilter_swiginit(
            self, _SimpleITK.new_NormalizedCorrelationImageFilter()
        )

    def GetName(self):
        r"""
        GetName(NormalizedCorrelationImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.NormalizedCorrelationImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(NormalizedCorrelationImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.NormalizedCorrelationImageFilter___str__(self)

    def Execute(self, image, maskImage, templateImage):
        r"""
        Execute(NormalizedCorrelationImageFilter self, Image image, Image maskImage, Image templateImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.NormalizedCorrelationImageFilter_Execute(
            self, image, maskImage, templateImage
        )


# Register NormalizedCorrelationImageFilter in _SimpleITK:
_SimpleITK.NormalizedCorrelationImageFilter_swigregister(
    NormalizedCorrelationImageFilter
)


def NormalizedCorrelation(image, maskImage, templateImage):
    r"""NormalizedCorrelation(Image image, Image maskImage, Image templateImage) -> Image"""
    return _SimpleITK.NormalizedCorrelation(image, maskImage, templateImage)


class NotEqualImageFilter(ImageFilter):
    r"""


    Implements pixel-wise generic operation of two images, or of an image
    and a constant.


    This class is parameterized over the types of the two input images and
    the type of the output image. It is also parameterized by the
    operation to be applied. A Functor style is used.

    The constant must be of the same type than the pixel type of the
    corresponding image. It is wrapped in a SimpleDataObjectDecorator so it can be updated through the pipeline. The SetConstant() and
    GetConstant() methods are provided as shortcuts to set or get the
    constant value without manipulating the decorator.


    See:
     BinaryGeneratorImagFilter

     UnaryFunctorImageFilter TernaryFunctorImageFilter

     itk::simple::NotEqual for the procedural interface

     itk::BinaryFunctorImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkNotEqualImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_NotEqualImageFilter

    def __init__(self):
        r"""
        __init__(NotEqualImageFilter self) -> NotEqualImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.NotEqualImageFilter_swiginit(
            self, _SimpleITK.new_NotEqualImageFilter()
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(NotEqualImageFilter self, uint8_t BackgroundValue)


        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.NotEqualImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(NotEqualImageFilter self) -> uint8_t


        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.NotEqualImageFilter_GetBackgroundValue(self)

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(NotEqualImageFilter self, uint8_t ForegroundValue)


        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.NotEqualImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(NotEqualImageFilter self) -> uint8_t


        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.NotEqualImageFilter_GetForegroundValue(self)

    def GetName(self):
        r"""
        GetName(NotEqualImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.NotEqualImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(NotEqualImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.NotEqualImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(NotEqualImageFilter self, Image image1, Image image2) -> Image
        Execute(NotEqualImageFilter self, Image image1, double constant) -> Image
        Execute(NotEqualImageFilter self, double constant, Image image2) -> Image
        Execute(NotEqualImageFilter self, Image image1, double constant, uint8_t backgroundValue, uint8_t foregroundValue) -> Image
        Execute(NotEqualImageFilter self, double constant, Image image2, uint8_t backgroundValue, uint8_t foregroundValue) -> Image


        """
        return _SimpleITK.NotEqualImageFilter_Execute(self, *args)


# Register NotEqualImageFilter in _SimpleITK:
_SimpleITK.NotEqualImageFilter_swigregister(NotEqualImageFilter)


def NotEqual(*args):
    r"""
    NotEqual(Image image1, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    NotEqual(Image image1, double constant, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    NotEqual(double constant, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image


    """
    return _SimpleITK.NotEqual(*args)


class NotImageFilter(ImageFilter):
    r"""


    Implements the NOT logical operator pixel-wise on an image.


    This class is templated over the type of an input image and the type
    of the output image. Numeric conversions (castings) are done by the
    C++ defaults.

    Since the logical NOT operation operates only on boolean types, the
    input type must be implicitly convertible to bool, which is only
    defined in C++ for integer types, the images passed to this filter
    must comply with the requirement of using integer pixel type.

    The total operation over one pixel will be


    Where "!" is the unary Logical NOT operator in C++.
    See:
     itk::simple::Not for the procedural interface

     itk::NotImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkNotImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_NotImageFilter

    def __init__(self):
        r"""
        __init__(NotImageFilter self) -> NotImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.NotImageFilter_swiginit(
            self, _SimpleITK.new_NotImageFilter()
        )

    def GetName(self):
        r"""
        GetName(NotImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.NotImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(NotImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.NotImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(NotImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.NotImageFilter_Execute(self, image1)


# Register NotImageFilter in _SimpleITK:
_SimpleITK.NotImageFilter_swigregister(NotImageFilter)


def Not(image1):
    r"""Not(Image image1) -> Image"""
    return _SimpleITK.Not(image1)


class ObjectnessMeasureImageFilter(ImageFilter):
    r"""


    Enhance M-dimensional objects in N-dimensional images.


    This filter is a generalization of Frangi's vesselness measurement for
    detecting M-dimensional object in N-dimensional space. For example a
    vessel is a 1-D object in 3-D space. The filter can enhance blob-like
    structures (M=0), vessel-like structures (M=1), 2D plate-like
    structures (M=2), hyper-plate-like structures (M=3) in N-dimensional
    images, with M<N.

    This filter takes a scalar image as input and produces a real valued
    image as output which contains the objectness measure at each pixel.
    Internally, it computes a Hessian via discrete central differences.
    Before applying this filter it is expected that a Gaussian smoothing
    filter at an appropriate scale (sigma) was applied to the input image.

    The enhancement is based on the eigenvalues of the Hessian matrix. For
    the Frangi's vesselness case were M=1 and N=3 we have the 3
    eigenvalues such that $ | \\lambda_1 | < | \\lambda_2 | < |\\lambda_3 | $ . The formula follows:

    \\[ R_A = \\frac{|\\lambda_2|}{|\\lambda_3|}, \\; R_B =
    \\frac{|\\lambda_2|}{|\\lambda_2\\lambda_3|}, \\; S =
    \\sqrt{\\lambda_1^2+\\lambda_2^2+\\lambda_3^2} \\] \\[ V_{\\sigma}= \\begin{cases}
    (1-e^{-\\frac{R_A^2}{2\\alpha^2}}) \\cdot
    e^{\\frac{R_B^2}{2\\beta^2}} \\cdot
    (1-e^{-\\frac{S^2}{2\\gamma^2}}) & \\text{if } \\lambda_2<0
    \\text{ and } \\lambda_3<0 \\text{,}\\\\ 0 &
    \\text{otherwise} \\end{cases} \\]

    References
    Antiga, L. Generalizing vesselness with respect to dimensionality and
    shape. https://hdl.handle.net/1926/576

    Frangi, AF, Niessen, WJ, Vincken, KL, & Viergever, MA (1998).
    Multiscale Vessel Enhancement Filtering. In Wells, WM, Colchester, A,
    & Delp, S, Editors, MICCAI '98 Medical Image Computing and Computer-Assisted Intervention, Lecture Notes in
    Computer Science, pages 130-137, Springer Verlag, 1998.

    See:
     itk::HessianToObjectnessMeasureImageFilter

     itk::simple::ObjectnessMeasure for the procedural interface

     itk::ObjectnessMeasureImageFilter for the Doxygen on the original ITK
    class.


    C++ includes: sitkObjectnessMeasureImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ObjectnessMeasureImageFilter

    def __init__(self):
        r"""
        __init__(ObjectnessMeasureImageFilter self) -> ObjectnessMeasureImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ObjectnessMeasureImageFilter_swiginit(
            self, _SimpleITK.new_ObjectnessMeasureImageFilter()
        )

    def SetAlpha(self, Alpha):
        r"""
        SetAlpha(ObjectnessMeasureImageFilter self, double Alpha)


        Set/Get Alpha, the weight corresponding to R_A (the ratio of the
        smallest eigenvalue that has to be large to the larger ones). Smaller
        values lead to increased sensitivity to the object dimensionality.


        """
        return _SimpleITK.ObjectnessMeasureImageFilter_SetAlpha(self, Alpha)

    def GetAlpha(self):
        r"""
        GetAlpha(ObjectnessMeasureImageFilter self) -> double


        Set/Get Alpha, the weight corresponding to R_A (the ratio of the
        smallest eigenvalue that has to be large to the larger ones). Smaller
        values lead to increased sensitivity to the object dimensionality.


        """
        return _SimpleITK.ObjectnessMeasureImageFilter_GetAlpha(self)

    def SetBeta(self, Beta):
        r"""
        SetBeta(ObjectnessMeasureImageFilter self, double Beta)


        Set/Get Beta, the weight corresponding to R_B (the ratio of the
        largest eigenvalue that has to be small to the larger ones). Smaller
        values lead to increased sensitivity to the object dimensionality.


        """
        return _SimpleITK.ObjectnessMeasureImageFilter_SetBeta(self, Beta)

    def GetBeta(self):
        r"""
        GetBeta(ObjectnessMeasureImageFilter self) -> double


        Set/Get Beta, the weight corresponding to R_B (the ratio of the
        largest eigenvalue that has to be small to the larger ones). Smaller
        values lead to increased sensitivity to the object dimensionality.


        """
        return _SimpleITK.ObjectnessMeasureImageFilter_GetBeta(self)

    def SetGamma(self, Gamma):
        r"""
        SetGamma(ObjectnessMeasureImageFilter self, double Gamma)


        Set/Get Gamma, the weight corresponding to S (the Frobenius norm of
        the Hessian matrix, or second-order structureness)


        """
        return _SimpleITK.ObjectnessMeasureImageFilter_SetGamma(self, Gamma)

    def GetGamma(self):
        r"""
        GetGamma(ObjectnessMeasureImageFilter self) -> double


        Set/Get Gamma, the weight corresponding to S (the Frobenius norm of
        the Hessian matrix, or second-order structureness)


        """
        return _SimpleITK.ObjectnessMeasureImageFilter_GetGamma(self)

    def SetScaleObjectnessMeasure(self, ScaleObjectnessMeasure):
        r"""
        SetScaleObjectnessMeasure(ObjectnessMeasureImageFilter self, bool ScaleObjectnessMeasure)


        Toggle scaling the objectness measure with the magnitude of the
        largest absolute eigenvalue


        """
        return (
            _SimpleITK.ObjectnessMeasureImageFilter_SetScaleObjectnessMeasure(
                self, ScaleObjectnessMeasure
            )
        )

    def ScaleObjectnessMeasureOn(self):
        r"""
        ScaleObjectnessMeasureOn(ObjectnessMeasureImageFilter self)


        Set the value of ScaleObjectnessMeasure to true or false respectfully.


        """
        return (
            _SimpleITK.ObjectnessMeasureImageFilter_ScaleObjectnessMeasureOn(
                self
            )
        )

    def ScaleObjectnessMeasureOff(self):
        r"""
        ScaleObjectnessMeasureOff(ObjectnessMeasureImageFilter self)


        """
        return (
            _SimpleITK.ObjectnessMeasureImageFilter_ScaleObjectnessMeasureOff(
                self
            )
        )

    def GetScaleObjectnessMeasure(self):
        r"""
        GetScaleObjectnessMeasure(ObjectnessMeasureImageFilter self) -> bool


        Toggle scaling the objectness measure with the magnitude of the
        largest absolute eigenvalue


        """
        return (
            _SimpleITK.ObjectnessMeasureImageFilter_GetScaleObjectnessMeasure(
                self
            )
        )

    def SetObjectDimension(self, ObjectDimension):
        r"""
        SetObjectDimension(ObjectnessMeasureImageFilter self, unsigned int ObjectDimension)


        Set/Get the dimensionality of the object (0: points (blobs), 1: lines
        (vessels), 2: planes (plate-like structures), 3: hyper-planes.
        ObjectDimension must be smaller than ImageDimension.


        """
        return _SimpleITK.ObjectnessMeasureImageFilter_SetObjectDimension(
            self, ObjectDimension
        )

    def GetObjectDimension(self):
        r"""
        GetObjectDimension(ObjectnessMeasureImageFilter self) -> unsigned int


        Set/Get the dimensionality of the object (0: points (blobs), 1: lines
        (vessels), 2: planes (plate-like structures), 3: hyper-planes.
        ObjectDimension must be smaller than ImageDimension.


        """
        return _SimpleITK.ObjectnessMeasureImageFilter_GetObjectDimension(self)

    def SetBrightObject(self, BrightObject):
        r"""
        SetBrightObject(ObjectnessMeasureImageFilter self, bool BrightObject)


        Enhance bright structures on a dark background if true, the opposite
        if false.


        """
        return _SimpleITK.ObjectnessMeasureImageFilter_SetBrightObject(
            self, BrightObject
        )

    def BrightObjectOn(self):
        r"""
        BrightObjectOn(ObjectnessMeasureImageFilter self)


        Set the value of BrightObject to true or false respectfully.


        """
        return _SimpleITK.ObjectnessMeasureImageFilter_BrightObjectOn(self)

    def BrightObjectOff(self):
        r"""
        BrightObjectOff(ObjectnessMeasureImageFilter self)


        """
        return _SimpleITK.ObjectnessMeasureImageFilter_BrightObjectOff(self)

    def GetBrightObject(self):
        r"""
        GetBrightObject(ObjectnessMeasureImageFilter self) -> bool


        Enhance bright structures on a dark background if true, the opposite
        if false.


        """
        return _SimpleITK.ObjectnessMeasureImageFilter_GetBrightObject(self)

    def GetName(self):
        r"""
        GetName(ObjectnessMeasureImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ObjectnessMeasureImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ObjectnessMeasureImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ObjectnessMeasureImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ObjectnessMeasureImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ObjectnessMeasureImageFilter_Execute(self, image1)


# Register ObjectnessMeasureImageFilter in _SimpleITK:
_SimpleITK.ObjectnessMeasureImageFilter_swigregister(
    ObjectnessMeasureImageFilter
)


def ObjectnessMeasure(
    image1,
    alpha=0.5,
    beta=0.5,
    gamma=5.0,
    scaleObjectnessMeasure=True,
    objectDimension=1,
    brightObject=True,
):
    r"""ObjectnessMeasure(Image image1, double alpha=0.5, double beta=0.5, double gamma=5.0, bool scaleObjectnessMeasure=True, unsigned int objectDimension=1, bool brightObject=True) -> Image"""
    return _SimpleITK.ObjectnessMeasure(
        image1,
        alpha,
        beta,
        gamma,
        scaleObjectnessMeasure,
        objectDimension,
        brightObject,
    )


class OpeningByReconstructionImageFilter(ImageFilter):
    r"""


    Opening by reconstruction of an image.


    This filter preserves regions, in the foreground, that can completely
    contain the structuring element. At the same time, this filter
    eliminates all other regions of foreground pixels. Contrary to the
    morphological opening, the opening by reconstruction preserves the
    shape of the components that are not removed by erosion. The opening
    by reconstruction of an image "f" is defined as:

    OpeningByReconstruction(f) = DilationByReconstruction(f, Erosion(f)).

    Opening by reconstruction not only removes structures destroyed by the
    erosion, but also levels down the contrast of the brightest regions.
    If PreserveIntensities is on, a subsequent reconstruction by dilation
    using a marker image that is the original image for all unaffected
    pixels.

    Opening by reconstruction is described in Chapter 6.3.9 of Pierre
    Soille's book "Morphological Image Analysis: Principles and
    Applications", Second Edition, Springer, 2003.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     GrayscaleMorphologicalOpeningImageFilter

     itk::simple::OpeningByReconstruction for the procedural interface

     itk::OpeningByReconstructionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkOpeningByReconstructionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_OpeningByReconstructionImageFilter

    def __init__(self):
        r"""
        __init__(OpeningByReconstructionImageFilter self) -> OpeningByReconstructionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.OpeningByReconstructionImageFilter_swiginit(
            self, _SimpleITK.new_OpeningByReconstructionImageFilter()
        )

    def SetKernelRadius(self, *args):
        r"""
        SetKernelRadius(OpeningByReconstructionImageFilter self, VectorUInt32 KernelRadius)
        SetKernelRadius(OpeningByReconstructionImageFilter self, unsigned int value)


        Set the values of the KernelRadius vector all to value


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_SetKernelRadius(
            self, *args
        )

    def GetKernelRadius(self):
        r"""
        GetKernelRadius(OpeningByReconstructionImageFilter self) -> VectorUInt32


        Get the radius of the kernel structuring element.


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_GetKernelRadius(
            self
        )

    def SetKernelType(self, KernelType):
        r"""
        SetKernelType(OpeningByReconstructionImageFilter self, itk::simple::KernelEnum KernelType)


        Set the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_SetKernelType(
            self, KernelType
        )

    def GetKernelType(self):
        r"""
        GetKernelType(OpeningByReconstructionImageFilter self) -> itk::simple::KernelEnum


        Get the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_GetKernelType(
            self
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(OpeningByReconstructionImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(OpeningByReconstructionImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_FullyConnectedOn(
            self
        )

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(OpeningByReconstructionImageFilter self)


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_FullyConnectedOff(
            self
        )

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(OpeningByReconstructionImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_GetFullyConnected(
            self
        )

    def SetPreserveIntensities(self, PreserveIntensities):
        r"""
        SetPreserveIntensities(OpeningByReconstructionImageFilter self, bool PreserveIntensities)


        Set/Get whether the original intensities of the image retained for
        those pixels unaffected by the opening by reconstruction. If Off, the
        output pixel contrast will be reduced.


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_SetPreserveIntensities(
            self, PreserveIntensities
        )

    def PreserveIntensitiesOn(self):
        r"""
        PreserveIntensitiesOn(OpeningByReconstructionImageFilter self)


        Set the value of PreserveIntensities to true or false respectfully.


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_PreserveIntensitiesOn(
            self
        )

    def PreserveIntensitiesOff(self):
        r"""
        PreserveIntensitiesOff(OpeningByReconstructionImageFilter self)


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_PreserveIntensitiesOff(
            self
        )

    def GetPreserveIntensities(self):
        r"""
        GetPreserveIntensities(OpeningByReconstructionImageFilter self) -> bool


        Set/Get whether the original intensities of the image retained for
        those pixels unaffected by the opening by reconstruction. If Off, the
        output pixel contrast will be reduced.


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_GetPreserveIntensities(
            self
        )

    def GetName(self):
        r"""
        GetName(OpeningByReconstructionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(OpeningByReconstructionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.OpeningByReconstructionImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(OpeningByReconstructionImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_Execute(
            self, image1
        )


# Register OpeningByReconstructionImageFilter in _SimpleITK:
_SimpleITK.OpeningByReconstructionImageFilter_swigregister(
    OpeningByReconstructionImageFilter
)


def OpeningByReconstruction(*args, **kwargs):
    r"""OpeningByReconstruction(Image image1, VectorUInt32 kernelRadius=std::vector< uint32_t >(3, 1), itk::simple::KernelEnum kernelType=sitkBall, bool fullyConnected=False, bool preserveIntensities=False) -> Image"""
    return _SimpleITK.OpeningByReconstruction(*args, **kwargs)


class OrImageFilter(ImageFilter):
    r"""


    Implements the OR bitwise operator pixel-wise between two images.


    This class is templated over the types of the two input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    Since the bitwise OR operation is only defined in C++ for integer
    types, the images passed to this filter must comply with the
    requirement of using integer pixel type.

    The total operation over one pixel will be


    Where "|" is the boolean OR operator in C++.
    See:
     itk::simple::Or for the procedural interface

     itk::OrImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkOrImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_OrImageFilter

    def __init__(self):
        r"""
        __init__(OrImageFilter self) -> OrImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.OrImageFilter_swiginit(self, _SimpleITK.new_OrImageFilter())

    def GetName(self):
        r"""
        GetName(OrImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.OrImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(OrImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.OrImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(OrImageFilter self, Image image1, Image image2) -> Image
        Execute(OrImageFilter self, Image image1, int constant) -> Image
        Execute(OrImageFilter self, int constant, Image image2) -> Image


        """
        return _SimpleITK.OrImageFilter_Execute(self, *args)


# Register OrImageFilter in _SimpleITK:
_SimpleITK.OrImageFilter_swigregister(OrImageFilter)


def Or(*args):
    r"""
    Or(Image image1, Image image2) -> Image
    Or(Image image1, int constant) -> Image
    Or(int constant, Image image2) -> Image


    """
    return _SimpleITK.Or(*args)


class OtsuMultipleThresholdsImageFilter(ImageFilter):
    r"""


    Threshold an image using multiple Otsu Thresholds.


    This filter creates a labeled image that separates the input image
    into various classes. The filter computes the thresholds using the OtsuMultipleThresholdsCalculator and applies those thresholds to the input image using the ThresholdLabelerImageFilter . The NumberOfHistogramBins and NumberOfThresholds can be set for the
    Calculator. The LabelOffset can be set for the ThresholdLabelerImageFilter .

    This filter also includes an option to use the valley emphasis
    algorithm from H.F. Ng, "Automatic thresholding for defect
    detection", Pattern Recognition Letters, (27): 1644-1649, 2006. The
    valley emphasis algorithm is particularly effective when the object to
    be thresholded is small. See the following tests for examples:
    itkOtsuMultipleThresholdsImageFilterTest3 and
    itkOtsuMultipleThresholdsImageFilterTest4 To use this algorithm,
    simple call the setter: SetValleyEmphasis(true) It is turned off by
    default.


    See:
     ScalarImageToHistogramGenerator

     OtsuMultipleThresholdsCalculator

     ThresholdLabelerImageFilter

     itk::simple::OtsuMultipleThresholds for the procedural interface

     itk::OtsuMultipleThresholdsImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkOtsuMultipleThresholdsImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_OtsuMultipleThresholdsImageFilter

    def __init__(self):
        r"""
        __init__(OtsuMultipleThresholdsImageFilter self) -> OtsuMultipleThresholdsImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.OtsuMultipleThresholdsImageFilter_swiginit(
            self, _SimpleITK.new_OtsuMultipleThresholdsImageFilter()
        )

    def SetNumberOfThresholds(self, NumberOfThresholds):
        r"""
        SetNumberOfThresholds(OtsuMultipleThresholdsImageFilter self, uint8_t NumberOfThresholds)


        Set/Get the number of thresholds. Default is 1.


        """
        return (
            _SimpleITK.OtsuMultipleThresholdsImageFilter_SetNumberOfThresholds(
                self, NumberOfThresholds
            )
        )

    def GetNumberOfThresholds(self):
        r"""
        GetNumberOfThresholds(OtsuMultipleThresholdsImageFilter self) -> uint8_t


        Set/Get the number of thresholds. Default is 1.


        """
        return (
            _SimpleITK.OtsuMultipleThresholdsImageFilter_GetNumberOfThresholds(
                self
            )
        )

    def SetLabelOffset(self, LabelOffset):
        r"""
        SetLabelOffset(OtsuMultipleThresholdsImageFilter self, uint8_t LabelOffset)


        Set/Get the offset which labels have to start from. Default is 0.


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_SetLabelOffset(
            self, LabelOffset
        )

    def GetLabelOffset(self):
        r"""
        GetLabelOffset(OtsuMultipleThresholdsImageFilter self) -> uint8_t


        Set/Get the offset which labels have to start from. Default is 0.


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_GetLabelOffset(
            self
        )

    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        r"""
        SetNumberOfHistogramBins(OtsuMultipleThresholdsImageFilter self, uint32_t NumberOfHistogramBins)


        Set/Get the number of histogram bins. Default is 128.


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_SetNumberOfHistogramBins(
            self, NumberOfHistogramBins
        )

    def GetNumberOfHistogramBins(self):
        r"""
        GetNumberOfHistogramBins(OtsuMultipleThresholdsImageFilter self) -> uint32_t


        Set/Get the number of histogram bins. Default is 128.


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_GetNumberOfHistogramBins(
            self
        )

    def SetValleyEmphasis(self, ValleyEmphasis):
        r"""
        SetValleyEmphasis(OtsuMultipleThresholdsImageFilter self, bool ValleyEmphasis)


        Set/Get the use of valley emphasis. Default is false.


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_SetValleyEmphasis(
            self, ValleyEmphasis
        )

    def ValleyEmphasisOn(self):
        r"""
        ValleyEmphasisOn(OtsuMultipleThresholdsImageFilter self)


        Set the value of ValleyEmphasis to true or false respectfully.


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_ValleyEmphasisOn(
            self
        )

    def ValleyEmphasisOff(self):
        r"""
        ValleyEmphasisOff(OtsuMultipleThresholdsImageFilter self)


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_ValleyEmphasisOff(
            self
        )

    def GetValleyEmphasis(self):
        r"""
        GetValleyEmphasis(OtsuMultipleThresholdsImageFilter self) -> bool


        Set/Get the use of valley emphasis. Default is false.


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_GetValleyEmphasis(
            self
        )

    def SetReturnBinMidpoint(self, ReturnBinMidpoint):
        r"""
        SetReturnBinMidpoint(OtsuMultipleThresholdsImageFilter self, bool ReturnBinMidpoint)


        Should the threshold value be mid-point of the bin or the maximum?
        Default is to return bin maximum.


        """
        return (
            _SimpleITK.OtsuMultipleThresholdsImageFilter_SetReturnBinMidpoint(
                self, ReturnBinMidpoint
            )
        )

    def ReturnBinMidpointOn(self):
        r"""
        ReturnBinMidpointOn(OtsuMultipleThresholdsImageFilter self)


        Set the value of ReturnBinMidpoint to true or false respectfully.


        """
        return (
            _SimpleITK.OtsuMultipleThresholdsImageFilter_ReturnBinMidpointOn(
                self
            )
        )

    def ReturnBinMidpointOff(self):
        r"""
        ReturnBinMidpointOff(OtsuMultipleThresholdsImageFilter self)


        """
        return (
            _SimpleITK.OtsuMultipleThresholdsImageFilter_ReturnBinMidpointOff(
                self
            )
        )

    def GetReturnBinMidpoint(self):
        r"""
        GetReturnBinMidpoint(OtsuMultipleThresholdsImageFilter self) -> bool


        Should the threshold value be mid-point of the bin or the maximum?
        Default is to return bin maximum.


        """
        return (
            _SimpleITK.OtsuMultipleThresholdsImageFilter_GetReturnBinMidpoint(
                self
            )
        )

    def GetThresholds(self):
        r"""
        GetThresholds(OtsuMultipleThresholdsImageFilter self) -> VectorDouble


        Get the computed threshold.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_GetThresholds(self)

    def GetName(self):
        r"""
        GetName(OtsuMultipleThresholdsImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(OtsuMultipleThresholdsImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(OtsuMultipleThresholdsImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_Execute(
            self, image1
        )


# Register OtsuMultipleThresholdsImageFilter in _SimpleITK:
_SimpleITK.OtsuMultipleThresholdsImageFilter_swigregister(
    OtsuMultipleThresholdsImageFilter
)


def OtsuMultipleThresholds(
    image1,
    numberOfThresholds=1,
    labelOffset=0,
    numberOfHistogramBins=128,
    valleyEmphasis=False,
    returnBinMidpoint=False,
):
    r"""OtsuMultipleThresholds(Image image1, uint8_t numberOfThresholds=1, uint8_t labelOffset=0, uint32_t numberOfHistogramBins=128, bool valleyEmphasis=False, bool returnBinMidpoint=False) -> Image"""
    return _SimpleITK.OtsuMultipleThresholds(
        image1,
        numberOfThresholds,
        labelOffset,
        numberOfHistogramBins,
        valleyEmphasis,
        returnBinMidpoint,
    )


class OtsuThresholdImageFilter(ImageFilter):
    r"""


    Threshold an image using the Otsu Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the OtsuThresholdCalculator and applies that threshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare

    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/efycla


    See:
     HistogramThresholdImageFilter

     itk::simple::OtsuThreshold for the procedural interface

     itk::OtsuThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkOtsuThresholdImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_OtsuThresholdImageFilter

    def __init__(self):
        r"""
        __init__(OtsuThresholdImageFilter self) -> OtsuThresholdImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.OtsuThresholdImageFilter_swiginit(
            self, _SimpleITK.new_OtsuThresholdImageFilter()
        )

    def SetInsideValue(self, InsideValue):
        r"""
        SetInsideValue(OtsuThresholdImageFilter self, uint8_t InsideValue)


        Set the "inside" pixel value. The default value NumericTraits<OutputPixelType>::max()


        """
        return _SimpleITK.OtsuThresholdImageFilter_SetInsideValue(
            self, InsideValue
        )

    def GetInsideValue(self):
        r"""
        GetInsideValue(OtsuThresholdImageFilter self) -> uint8_t


        Get the "inside" pixel value.


        """
        return _SimpleITK.OtsuThresholdImageFilter_GetInsideValue(self)

    def SetOutsideValue(self, OutsideValue):
        r"""
        SetOutsideValue(OtsuThresholdImageFilter self, uint8_t OutsideValue)


        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.OtsuThresholdImageFilter_SetOutsideValue(
            self, OutsideValue
        )

    def GetOutsideValue(self):
        r"""
        GetOutsideValue(OtsuThresholdImageFilter self) -> uint8_t


        Get the "outside" pixel value.


        """
        return _SimpleITK.OtsuThresholdImageFilter_GetOutsideValue(self)

    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        r"""
        SetNumberOfHistogramBins(OtsuThresholdImageFilter self, uint32_t NumberOfHistogramBins)


        Set/Get the number of histogram bins. Defaults is 128.


        """
        return _SimpleITK.OtsuThresholdImageFilter_SetNumberOfHistogramBins(
            self, NumberOfHistogramBins
        )

    def GetNumberOfHistogramBins(self):
        r"""
        GetNumberOfHistogramBins(OtsuThresholdImageFilter self) -> uint32_t


        """
        return _SimpleITK.OtsuThresholdImageFilter_GetNumberOfHistogramBins(
            self
        )

    def SetMaskOutput(self, MaskOutput):
        r"""
        SetMaskOutput(OtsuThresholdImageFilter self, bool MaskOutput)


        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.OtsuThresholdImageFilter_SetMaskOutput(
            self, MaskOutput
        )

    def MaskOutputOn(self):
        r"""
        MaskOutputOn(OtsuThresholdImageFilter self)


        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.OtsuThresholdImageFilter_MaskOutputOn(self)

    def MaskOutputOff(self):
        r"""
        MaskOutputOff(OtsuThresholdImageFilter self)


        """
        return _SimpleITK.OtsuThresholdImageFilter_MaskOutputOff(self)

    def GetMaskOutput(self):
        r"""
        GetMaskOutput(OtsuThresholdImageFilter self) -> bool


        """
        return _SimpleITK.OtsuThresholdImageFilter_GetMaskOutput(self)

    def SetMaskValue(self, MaskValue):
        r"""
        SetMaskValue(OtsuThresholdImageFilter self, uint8_t MaskValue)


        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.OtsuThresholdImageFilter_SetMaskValue(
            self, MaskValue
        )

    def GetMaskValue(self):
        r"""
        GetMaskValue(OtsuThresholdImageFilter self) -> uint8_t


        """
        return _SimpleITK.OtsuThresholdImageFilter_GetMaskValue(self)

    def SetReturnBinMidpoint(self, ReturnBinMidpoint):
        r"""
        SetReturnBinMidpoint(OtsuThresholdImageFilter self, bool ReturnBinMidpoint)


        Should the threshold value be mid-point of the bin or the maximum?
        Default is to return bin maximum.


        """
        return _SimpleITK.OtsuThresholdImageFilter_SetReturnBinMidpoint(
            self, ReturnBinMidpoint
        )

    def ReturnBinMidpointOn(self):
        r"""
        ReturnBinMidpointOn(OtsuThresholdImageFilter self)


        Set the value of ReturnBinMidpoint to true or false respectfully.


        """
        return _SimpleITK.OtsuThresholdImageFilter_ReturnBinMidpointOn(self)

    def ReturnBinMidpointOff(self):
        r"""
        ReturnBinMidpointOff(OtsuThresholdImageFilter self)


        """
        return _SimpleITK.OtsuThresholdImageFilter_ReturnBinMidpointOff(self)

    def GetReturnBinMidpoint(self):
        r"""
        GetReturnBinMidpoint(OtsuThresholdImageFilter self) -> bool


        Should the threshold value be mid-point of the bin or the maximum?
        Default is to return bin maximum.


        """
        return _SimpleITK.OtsuThresholdImageFilter_GetReturnBinMidpoint(self)

    def GetThreshold(self):
        r"""
        GetThreshold(OtsuThresholdImageFilter self) -> double


        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.OtsuThresholdImageFilter_GetThreshold(self)

    def GetName(self):
        r"""
        GetName(OtsuThresholdImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.OtsuThresholdImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(OtsuThresholdImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.OtsuThresholdImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(OtsuThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(OtsuThresholdImageFilter self, Image image) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.OtsuThresholdImageFilter_Execute(self, *args)


# Register OtsuThresholdImageFilter in _SimpleITK:
_SimpleITK.OtsuThresholdImageFilter_swigregister(OtsuThresholdImageFilter)


def OtsuThreshold(*args):
    r"""
    OtsuThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=128, bool maskOutput=True, uint8_t maskValue=255, bool returnBinMidpoint=False) -> Image
    OtsuThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=128, bool maskOutput=True, uint8_t maskValue=255, bool returnBinMidpoint=False) -> Image
    """
    return _SimpleITK.OtsuThreshold(*args)


class PatchBasedDenoisingImageFilter(ImageFilter):
    r"""


    Derived class implementing a specific patch-based denoising algorithm,
    as detailed below.


    This class is derived from the base class PatchBasedDenoisingBaseImageFilter ; please refer to the documentation of the base class first. This
    class implements a denoising filter that uses iterative non-local, or
    semi-local, weighted averaging of image patches for image denoising.
    The intensity at each pixel 'p' gets updated as a weighted average of
    intensities of a chosen subset of pixels from the image.

    This class implements the denoising algorithm using a Gaussian kernel
    function for nonparametric density estimation. The class implements a
    scheme to automatically estimated the kernel bandwidth parameter
    (namely, sigma) using leave-one-out cross validation. It implements
    schemes for random sampling of patches non-locally (from the entire
    image) as well as semi-locally (from the spatial proximity of the
    pixel being denoised at the specific point in time). It implements a
    specific scheme for defining patch weights (mask) as described in
    Awate and Whitaker 2005 IEEE CVPR and 2006 IEEE TPAMI.


    See:
     PatchBasedDenoisingBaseImageFilter

     itk::PatchBasedDenoisingImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkPatchBasedDenoisingImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_PatchBasedDenoisingImageFilter

    def __init__(self):
        r"""
        __init__(PatchBasedDenoisingImageFilter self) -> PatchBasedDenoisingImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.PatchBasedDenoisingImageFilter_swiginit(
            self, _SimpleITK.new_PatchBasedDenoisingImageFilter()
        )

    def SetKernelBandwidthSigma(self, KernelBandwidthSigma):
        r"""
        SetKernelBandwidthSigma(PatchBasedDenoisingImageFilter self, double KernelBandwidthSigma)


        Set/Get initial kernel bandwidth estimate. To prevent the class from
        automatically modifying this estimate, set KernelBandwidthEstimation
        to false in the base class.


        """
        return (
            _SimpleITK.PatchBasedDenoisingImageFilter_SetKernelBandwidthSigma(
                self, KernelBandwidthSigma
            )
        )

    def GetKernelBandwidthSigma(self):
        r"""
        GetKernelBandwidthSigma(PatchBasedDenoisingImageFilter self) -> double


        Set/Get initial kernel bandwidth estimate. To prevent the class from
        automatically modifying this estimate, set KernelBandwidthEstimation
        to false in the base class.


        """
        return (
            _SimpleITK.PatchBasedDenoisingImageFilter_GetKernelBandwidthSigma(
                self
            )
        )

    def SetPatchRadius(self, PatchRadius):
        r"""
        SetPatchRadius(PatchBasedDenoisingImageFilter self, uint32_t PatchRadius)


        Set/Get the patch radius specified in physical coordinates. Patch
        radius is preferably set to an even number. Currently, only isotropic
        patches in physical space are allowed; patches can be anisotropic in
        voxel space.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetPatchRadius(
            self, PatchRadius
        )

    def GetPatchRadius(self):
        r"""
        GetPatchRadius(PatchBasedDenoisingImageFilter self) -> uint32_t


        Set/Get the patch radius specified in physical coordinates. Patch
        radius is preferably set to an even number. Currently, only isotropic
        patches in physical space are allowed; patches can be anisotropic in
        voxel space.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetPatchRadius(self)

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(PatchBasedDenoisingImageFilter self, uint32_t NumberOfIterations)


        Set/Get the number of denoising iterations to perform. Must be a
        positive integer. Defaults to 1.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(PatchBasedDenoisingImageFilter self) -> uint32_t


        Set/Get the number of denoising iterations to perform. Must be a
        positive integer. Defaults to 1.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetNumberOfIterations(
            self
        )

    def SetNumberOfSamplePatches(self, NumberOfSamplePatches):
        r"""
        SetNumberOfSamplePatches(PatchBasedDenoisingImageFilter self, uint32_t NumberOfSamplePatches)


        Set/Get the number of patches to sample for each pixel.


        """
        return (
            _SimpleITK.PatchBasedDenoisingImageFilter_SetNumberOfSamplePatches(
                self, NumberOfSamplePatches
            )
        )

    def GetNumberOfSamplePatches(self):
        r"""
        GetNumberOfSamplePatches(PatchBasedDenoisingImageFilter self) -> uint32_t


        """
        return (
            _SimpleITK.PatchBasedDenoisingImageFilter_GetNumberOfSamplePatches(
                self
            )
        )

    def SetSampleVariance(self, SampleVariance):
        r"""
        SetSampleVariance(PatchBasedDenoisingImageFilter self, double SampleVariance)


        Set/Get the variance of the domain where patches are sampled.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetSampleVariance(
            self, SampleVariance
        )

    def GetSampleVariance(self):
        r"""
        GetSampleVariance(PatchBasedDenoisingImageFilter self) -> double


        Set/Get the variance of the domain where patches are sampled.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetSampleVariance(
            self
        )

    NOMODEL = _SimpleITK.PatchBasedDenoisingImageFilter_NOMODEL

    GAUSSIAN = _SimpleITK.PatchBasedDenoisingImageFilter_GAUSSIAN

    RICIAN = _SimpleITK.PatchBasedDenoisingImageFilter_RICIAN

    POISSON = _SimpleITK.PatchBasedDenoisingImageFilter_POISSON

    def SetNoiseModel(self, NoiseModel):
        r"""
        SetNoiseModel(PatchBasedDenoisingImageFilter self, itk::simple::PatchBasedDenoisingImageFilter::NoiseModelType NoiseModel)


        Set/Get the noise model type. Defaults to GAUSSIAN. To use the noise
        model during denoising, FidelityWeight must be positive.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetNoiseModel(
            self, NoiseModel
        )

    def GetNoiseModel(self):
        r"""
        GetNoiseModel(PatchBasedDenoisingImageFilter self) -> itk::simple::PatchBasedDenoisingImageFilter::NoiseModelType


        Set/Get the noise model type. Defaults to GAUSSIAN. To use the noise
        model during denoising, FidelityWeight must be positive.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetNoiseModel(self)

    def SetNoiseSigma(self, NoiseSigma):
        r"""
        SetNoiseSigma(PatchBasedDenoisingImageFilter self, double NoiseSigma)


        Set/Get the noise sigma. Used by the noise model where appropriate,
        defaults to 5% of the image intensity range


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetNoiseSigma(
            self, NoiseSigma
        )

    def GetNoiseSigma(self):
        r"""
        GetNoiseSigma(PatchBasedDenoisingImageFilter self) -> double


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetNoiseSigma(self)

    def SetNoiseModelFidelityWeight(self, NoiseModelFidelityWeight):
        r"""
        SetNoiseModelFidelityWeight(PatchBasedDenoisingImageFilter self, double NoiseModelFidelityWeight)


        Set/Get the weight on the fidelity term (penalizes deviations from the
        noisy data). This option is used when a noise model is specified. This
        weight controls the balance between the smoothing and the closeness to
        the noisy data.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetNoiseModelFidelityWeight(
            self, NoiseModelFidelityWeight
        )

    def GetNoiseModelFidelityWeight(self):
        r"""
        GetNoiseModelFidelityWeight(PatchBasedDenoisingImageFilter self) -> double


        Set/Get the weight on the fidelity term (penalizes deviations from the
        noisy data). This option is used when a noise model is specified. This
        weight controls the balance between the smoothing and the closeness to
        the noisy data.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetNoiseModelFidelityWeight(
            self
        )

    def SetAlwaysTreatComponentsAsEuclidean(
        self, AlwaysTreatComponentsAsEuclidean
    ):
        r"""
        SetAlwaysTreatComponentsAsEuclidean(PatchBasedDenoisingImageFilter self, bool AlwaysTreatComponentsAsEuclidean)


        Set/Get flag indicating whether all components should always be
        treated as if they are in euclidean space regardless of pixel type.
        Defaults to false.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetAlwaysTreatComponentsAsEuclidean(
            self, AlwaysTreatComponentsAsEuclidean
        )

    def AlwaysTreatComponentsAsEuclideanOn(self):
        r"""
        AlwaysTreatComponentsAsEuclideanOn(PatchBasedDenoisingImageFilter self)


        Set the value of AlwaysTreatComponentsAsEuclidean to true or false
        respectfully.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_AlwaysTreatComponentsAsEuclideanOn(
            self
        )

    def AlwaysTreatComponentsAsEuclideanOff(self):
        r"""
        AlwaysTreatComponentsAsEuclideanOff(PatchBasedDenoisingImageFilter self)


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_AlwaysTreatComponentsAsEuclideanOff(
            self
        )

    def GetAlwaysTreatComponentsAsEuclidean(self):
        r"""
        GetAlwaysTreatComponentsAsEuclidean(PatchBasedDenoisingImageFilter self) -> bool


        Set/Get flag indicating whether all components should always be
        treated as if they are in euclidean space regardless of pixel type.
        Defaults to false.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetAlwaysTreatComponentsAsEuclidean(
            self
        )

    def SetKernelBandwidthEstimation(self, KernelBandwidthEstimation):
        r"""
        SetKernelBandwidthEstimation(PatchBasedDenoisingImageFilter self, bool KernelBandwidthEstimation)


        Set/Get flag indicating whether kernel-bandwidth should be estimated
        automatically from the image data. Defaults to true.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetKernelBandwidthEstimation(
            self, KernelBandwidthEstimation
        )

    def KernelBandwidthEstimationOn(self):
        r"""
        KernelBandwidthEstimationOn(PatchBasedDenoisingImageFilter self)


        Set the value of KernelBandwidthEstimation to true or false
        respectfully.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_KernelBandwidthEstimationOn(
            self
        )

    def KernelBandwidthEstimationOff(self):
        r"""
        KernelBandwidthEstimationOff(PatchBasedDenoisingImageFilter self)


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_KernelBandwidthEstimationOff(
            self
        )

    def GetKernelBandwidthEstimation(self):
        r"""
        GetKernelBandwidthEstimation(PatchBasedDenoisingImageFilter self) -> bool


        Set/Get flag indicating whether kernel-bandwidth should be estimated
        automatically from the image data. Defaults to true.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetKernelBandwidthEstimation(
            self
        )

    def SetKernelBandwidthMultiplicationFactor(
        self, KernelBandwidthMultiplicationFactor
    ):
        r"""
        SetKernelBandwidthMultiplicationFactor(PatchBasedDenoisingImageFilter self, double KernelBandwidthMultiplicationFactor)


        Set/Get the kernel bandwidth sigma multiplication factor used to
        modify the automatically-estimated kernel bandwidth sigma. At times,
        it may be desirable to modify the value of the automatically-estimated
        sigma. Typically, this number isn't very far from 1. Note: This is
        used only when KernelBandwidthEstimation is True/On.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetKernelBandwidthMultiplicationFactor(
            self, KernelBandwidthMultiplicationFactor
        )

    def GetKernelBandwidthMultiplicationFactor(self):
        r"""
        GetKernelBandwidthMultiplicationFactor(PatchBasedDenoisingImageFilter self) -> double


        Set/Get the kernel bandwidth sigma multiplication factor used to
        modify the automatically-estimated kernel bandwidth sigma. At times,
        it may be desirable to modify the value of the automatically-estimated
        sigma. Typically, this number isn't very far from 1. Note: This is
        used only when KernelBandwidthEstimation is True/On.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetKernelBandwidthMultiplicationFactor(
            self
        )

    def SetKernelBandwidthUpdateFrequency(
        self, KernelBandwidthUpdateFrequency
    ):
        r"""
        SetKernelBandwidthUpdateFrequency(PatchBasedDenoisingImageFilter self, uint32_t KernelBandwidthUpdateFrequency)


        Set/Get the update frequency for the kernel bandwidth estimation. An
        optimal bandwidth will be re-estimated based on the denoised image
        after every 'n' iterations. Must be a positive integer. Defaults to 3,
        i.e. bandwidth updated after every 3 denoising iteration.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetKernelBandwidthUpdateFrequency(
            self, KernelBandwidthUpdateFrequency
        )

    def GetKernelBandwidthUpdateFrequency(self):
        r"""
        GetKernelBandwidthUpdateFrequency(PatchBasedDenoisingImageFilter self) -> uint32_t


        Set/Get the update frequency for the kernel bandwidth estimation. An
        optimal bandwidth will be re-estimated based on the denoised image
        after every 'n' iterations. Must be a positive integer. Defaults to 3,
        i.e. bandwidth updated after every 3 denoising iteration.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetKernelBandwidthUpdateFrequency(
            self
        )

    def SetKernelBandwidthFractionPixelsForEstimation(
        self, KernelBandwidthFractionPixelsForEstimation
    ):
        r"""
        SetKernelBandwidthFractionPixelsForEstimation(PatchBasedDenoisingImageFilter self, double KernelBandwidthFractionPixelsForEstimation)


        Set/Get the fraction of the image to use for kernel bandwidth sigma
        estimation. To reduce the computational burden for computing sigma, a
        small random fraction of the image pixels can be used.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetKernelBandwidthFractionPixelsForEstimation(
            self, KernelBandwidthFractionPixelsForEstimation
        )

    def GetKernelBandwidthFractionPixelsForEstimation(self):
        r"""
        GetKernelBandwidthFractionPixelsForEstimation(PatchBasedDenoisingImageFilter self) -> double


        Set/Get the fraction of the image to use for kernel bandwidth sigma
        estimation. To reduce the computational burden for computing sigma, a
        small random fraction of the image pixels can be used.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetKernelBandwidthFractionPixelsForEstimation(
            self
        )

    def GetName(self):
        r"""
        GetName(PatchBasedDenoisingImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(PatchBasedDenoisingImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(PatchBasedDenoisingImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_Execute(self, image1)


# Register PatchBasedDenoisingImageFilter in _SimpleITK:
_SimpleITK.PatchBasedDenoisingImageFilter_swigregister(
    PatchBasedDenoisingImageFilter
)


class PermuteAxesImageFilter(ImageFilter):
    r"""


    Permutes the image axes according to a user specified order.


    PermuateAxesImageFilter permutes the image axes according to a user
    specified order. The permutation order is set via method SetOrder(
    order ) where the input is an array of ImageDimension number of
    unsigned int. The elements of the array must be a rearrangement of the
    numbers from 0 to ImageDimension - 1.

    The i-th axis of the output image corresponds with the order[i]-th
    axis of the input image.

    The output meta image information (LargestPossibleRegion, spacing,
    origin) is computed by permuting the corresponding input meta
    information.
    See:
     itk::simple::PermuteAxes for the procedural interface

     itk::PermuteAxesImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkPermuteAxesImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_PermuteAxesImageFilter

    def __init__(self):
        r"""
        __init__(PermuteAxesImageFilter self) -> PermuteAxesImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.PermuteAxesImageFilter_swiginit(
            self, _SimpleITK.new_PermuteAxesImageFilter()
        )

    def SetOrder(self, Order):
        r"""
        SetOrder(PermuteAxesImageFilter self, VectorUInt32 Order)


        Set the permutation order. The elements of order must be a
        rearrangement of the numbers from 0 to ImageDimension - 1.


        """
        return _SimpleITK.PermuteAxesImageFilter_SetOrder(self, Order)

    def GetOrder(self):
        r"""
        GetOrder(PermuteAxesImageFilter self) -> VectorUInt32


        Get the permutation order.


        """
        return _SimpleITK.PermuteAxesImageFilter_GetOrder(self)

    def GetName(self):
        r"""
        GetName(PermuteAxesImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.PermuteAxesImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(PermuteAxesImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.PermuteAxesImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(PermuteAxesImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.PermuteAxesImageFilter_Execute(self, image1)


# Register PermuteAxesImageFilter in _SimpleITK:
_SimpleITK.PermuteAxesImageFilter_swigregister(PermuteAxesImageFilter)
cvar = _SimpleITK.cvar
PermuteAxesImageFilter.DefaultOrder = (
    _SimpleITK.cvar.PermuteAxesImageFilter_DefaultOrder
)


def PermuteAxes(*args, **kwargs):
    r"""PermuteAxes(Image image1, VectorUInt32 order=std::vector< unsigned int >(itk::simple::PermuteAxesImageFilter::DefaultOrder)) -> Image"""
    return _SimpleITK.PermuteAxes(*args, **kwargs)


class PhysicalPointImageSource(ImageFilter):
    r"""


    Generate an image of the physical locations of each pixel.


    This image source supports image which have a multi-component pixel
    equal to the image dimension, and variable length VectorImages. It is
    recommended that the component type be a real valued type.
    See:
     itk::simple::PhysicalPointSource for the procedural interface

     itk::PhysicalPointImageSource for the Doxygen on the original ITK class.


    C++ includes: sitkPhysicalPointImageSource.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_PhysicalPointImageSource

    def __init__(self):
        r"""
        __init__(PhysicalPointImageSource self) -> PhysicalPointImageSource


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.PhysicalPointImageSource_swiginit(
            self, _SimpleITK.new_PhysicalPointImageSource()
        )

    def SetOutputPixelType(self, OutputPixelType):
        r"""
        SetOutputPixelType(PhysicalPointImageSource self, itk::simple::PixelIDValueEnum OutputPixelType)


        """
        return _SimpleITK.PhysicalPointImageSource_SetOutputPixelType(
            self, OutputPixelType
        )

    def GetOutputPixelType(self):
        r"""
        GetOutputPixelType(PhysicalPointImageSource self) -> itk::simple::PixelIDValueEnum


        """
        return _SimpleITK.PhysicalPointImageSource_GetOutputPixelType(self)

    def SetSize(self, Size):
        r"""
        SetSize(PhysicalPointImageSource self, VectorUInt32 Size)


        """
        return _SimpleITK.PhysicalPointImageSource_SetSize(self, Size)

    def GetSize(self):
        r"""
        GetSize(PhysicalPointImageSource self) -> VectorUInt32


        """
        return _SimpleITK.PhysicalPointImageSource_GetSize(self)

    def SetOrigin(self, Origin):
        r"""
        SetOrigin(PhysicalPointImageSource self, VectorDouble Origin)


        """
        return _SimpleITK.PhysicalPointImageSource_SetOrigin(self, Origin)

    def GetOrigin(self):
        r"""
        GetOrigin(PhysicalPointImageSource self) -> VectorDouble


        """
        return _SimpleITK.PhysicalPointImageSource_GetOrigin(self)

    def SetSpacing(self, Spacing):
        r"""
        SetSpacing(PhysicalPointImageSource self, VectorDouble Spacing)


        """
        return _SimpleITK.PhysicalPointImageSource_SetSpacing(self, Spacing)

    def GetSpacing(self):
        r"""
        GetSpacing(PhysicalPointImageSource self) -> VectorDouble


        """
        return _SimpleITK.PhysicalPointImageSource_GetSpacing(self)

    def SetDirection(self, Direction):
        r"""
        SetDirection(PhysicalPointImageSource self, VectorDouble Direction)


        """
        return _SimpleITK.PhysicalPointImageSource_SetDirection(
            self, Direction
        )

    def GetDirection(self):
        r"""
        GetDirection(PhysicalPointImageSource self) -> VectorDouble


        """
        return _SimpleITK.PhysicalPointImageSource_GetDirection(self)

    def GetName(self):
        r"""
        GetName(PhysicalPointImageSource self) -> std::string


        Name of this class


        """
        return _SimpleITK.PhysicalPointImageSource_GetName(self)

    def __str__(self):
        r"""
        __str__(PhysicalPointImageSource self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.PhysicalPointImageSource___str__(self)

    def Execute(self):
        r"""
        Execute(PhysicalPointImageSource self) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.PhysicalPointImageSource_Execute(self)

    def SetReferenceImage(self, refImage):
        r"""
        SetReferenceImage(PhysicalPointImageSource self, Image refImage)


        This methods sets the size, origin, spacing and direction to that of
        the provided image


        """
        return _SimpleITK.PhysicalPointImageSource_SetReferenceImage(
            self, refImage
        )


# Register PhysicalPointImageSource in _SimpleITK:
_SimpleITK.PhysicalPointImageSource_swigregister(PhysicalPointImageSource)


def PhysicalPointSource(*args, **kwargs):
    r"""
    PhysicalPointSource(itk::simple::PixelIDValueEnum outputPixelType=sitkVectorFloat32, VectorUInt32 size=std::vector< unsigned int >(3, 64), VectorDouble origin=std::vector< double >(3, 0.0), VectorDouble spacing=std::vector< double >(3, 1.0), VectorDouble direction=std::vector< double >()) -> Image


    Generate an image of the physical locations of each pixel.


    This function directly calls the execute method of PhysicalPointImageSource in order to support a procedural API


    See:
     itk::simple::PhysicalPointImageSource for the object oriented interface



    """
    return _SimpleITK.PhysicalPointSource(*args, **kwargs)


class PowImageFilter(ImageFilter):
    r"""


    Computes the powers of 2 images.


    This class is templated over the types of the two input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    The output of the pow function will be cast to the pixel type of the
    output image.

    The total operation over one pixel will be

    The pow function can be applied to two images with the following:

    Additionally, this filter can be used to raise every pixel of an image
    to a power of a constant by using
    See:
     itk::simple::Pow for the procedural interface

     itk::PowImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkPowImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_PowImageFilter

    def __init__(self):
        r"""
        __init__(PowImageFilter self) -> PowImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.PowImageFilter_swiginit(
            self, _SimpleITK.new_PowImageFilter()
        )

    def GetName(self):
        r"""
        GetName(PowImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.PowImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(PowImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.PowImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(PowImageFilter self, Image image1, Image image2) -> Image
        Execute(PowImageFilter self, Image image1, double constant) -> Image
        Execute(PowImageFilter self, double constant, Image image2) -> Image


        """
        return _SimpleITK.PowImageFilter_Execute(self, *args)


# Register PowImageFilter in _SimpleITK:
_SimpleITK.PowImageFilter_swigregister(PowImageFilter)


def Pow(*args):
    r"""
    Pow(Image image1, Image image2) -> Image
    Pow(Image image1, double constant) -> Image
    Pow(double constant, Image image2) -> Image


    """
    return _SimpleITK.Pow(*args)


class ProjectedLandweberDeconvolutionImageFilter(ImageFilter):
    r"""


    Deconvolve an image using the projected Landweber deconvolution
    algorithm.


    This filter performs the same calculation per iteration as the LandweberDeconvolutionImageFilter . However, at each iteration, negative pixels in the intermediate
    result are projected (set) to zero. This is useful if the solution is
    assumed to always be non-negative, which is the case when dealing with
    images formed by counting photons, for example.

    This code was adapted from the Insight Journal contribution:

    "Deconvolution: infrastructure and reference algorithms" by Gaetan
    Lehmann https://doi.org/10.54294/tvgfv1


    Gaetan Lehmann, Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France

    Cory Quammen, The University of North Carolina at Chapel Hill

    See:
     IterativeDeconvolutionImageFilter

     RichardsonLucyDeconvolutionImageFilter

     LandweberDeconvolutionImageFilter

     itk::simple::ProjectedLandweberDeconvolution for the procedural interface

     itk::ProjectedLandweberDeconvolutionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkProjectedLandweberDeconvolutionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_ProjectedLandweberDeconvolutionImageFilter
    )

    def __init__(self):
        r"""
        __init__(ProjectedLandweberDeconvolutionImageFilter self) -> ProjectedLandweberDeconvolutionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_swiginit(
            self, _SimpleITK.new_ProjectedLandweberDeconvolutionImageFilter()
        )

    def SetAlpha(self, Alpha):
        r"""
        SetAlpha(ProjectedLandweberDeconvolutionImageFilter self, double Alpha)


        Set the relaxation factor.


        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_SetAlpha(
            self, Alpha
        )

    def GetAlpha(self):
        r"""
        GetAlpha(ProjectedLandweberDeconvolutionImageFilter self) -> double


        Get the relaxation factor.


        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_GetAlpha(
            self
        )

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(ProjectedLandweberDeconvolutionImageFilter self, int NumberOfIterations)


        Set the number of iterations.


        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(ProjectedLandweberDeconvolutionImageFilter self) -> int


        Get the number of iterations.


        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_GetNumberOfIterations(
            self
        )

    def SetNormalize(self, Normalize):
        r"""
        SetNormalize(ProjectedLandweberDeconvolutionImageFilter self, bool Normalize)


        Normalize the output image by the sum of the kernel components


        """
        return (
            _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_SetNormalize(
                self, Normalize
            )
        )

    def NormalizeOn(self):
        r"""
        NormalizeOn(ProjectedLandweberDeconvolutionImageFilter self)


        Set the value of Normalize to true or false respectfully.


        """
        return (
            _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_NormalizeOn(
                self
            )
        )

    def NormalizeOff(self):
        r"""
        NormalizeOff(ProjectedLandweberDeconvolutionImageFilter self)


        """
        return (
            _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_NormalizeOff(
                self
            )
        )

    def GetNormalize(self):
        r"""
        GetNormalize(ProjectedLandweberDeconvolutionImageFilter self) -> bool


        """
        return (
            _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_GetNormalize(
                self
            )
        )

    ZERO_PAD = _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_ZERO_PAD

    ZERO_FLUX_NEUMANN_PAD = _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_ZERO_FLUX_NEUMANN_PAD

    PERIODIC_PAD = (
        _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_PERIODIC_PAD
    )

    def SetBoundaryCondition(self, BoundaryCondition):
        r"""
        SetBoundaryCondition(ProjectedLandweberDeconvolutionImageFilter self, itk::simple::ProjectedLandweberDeconvolutionImageFilter::BoundaryConditionType BoundaryCondition)


        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_SetBoundaryCondition(
            self, BoundaryCondition
        )

    def GetBoundaryCondition(self):
        r"""
        GetBoundaryCondition(ProjectedLandweberDeconvolutionImageFilter self) -> itk::simple::ProjectedLandweberDeconvolutionImageFilter::BoundaryConditionType


        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_GetBoundaryCondition(
            self
        )

    SAME = _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_SAME

    VALID = _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_VALID

    def SetOutputRegionMode(self, OutputRegionMode):
        r"""
        SetOutputRegionMode(ProjectedLandweberDeconvolutionImageFilter self, itk::simple::ProjectedLandweberDeconvolutionImageFilter::OutputRegionModeType OutputRegionMode)


        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_SetOutputRegionMode(
            self, OutputRegionMode
        )

    def GetOutputRegionMode(self):
        r"""
        GetOutputRegionMode(ProjectedLandweberDeconvolutionImageFilter self) -> itk::simple::ProjectedLandweberDeconvolutionImageFilter::OutputRegionModeType


        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_GetOutputRegionMode(
            self
        )

    def GetName(self):
        r"""
        GetName(ProjectedLandweberDeconvolutionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(ProjectedLandweberDeconvolutionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter___str__(
            self
        )

    def Execute(self, image1, image2):
        r"""
        Execute(ProjectedLandweberDeconvolutionImageFilter self, Image image1, Image image2) -> Image


        Execute the filter on the input images


        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_Execute(
            self, image1, image2
        )


# Register ProjectedLandweberDeconvolutionImageFilter in _SimpleITK:
_SimpleITK.ProjectedLandweberDeconvolutionImageFilter_swigregister(
    ProjectedLandweberDeconvolutionImageFilter
)


def ProjectedLandweberDeconvolution(*args, **kwargs):
    r"""ProjectedLandweberDeconvolution(Image image1, Image image2, double alpha=0.1, int numberOfIterations=1, bool normalize=False, itk::simple::ProjectedLandweberDeconvolutionImageFilter::BoundaryConditionType boundaryCondition=ZERO_FLUX_NEUMANN_PAD, itk::simple::ProjectedLandweberDeconvolutionImageFilter::OutputRegionModeType outputRegionMode=SAME) -> Image"""
    return _SimpleITK.ProjectedLandweberDeconvolution(*args, **kwargs)


class RankImageFilter(ImageFilter):
    r"""


    Rank filter of a greyscale image.


    Nonlinear filter in which each output pixel is a user defined rank of
    input pixels in a user defined neighborhood. The default rank is 0.5
    (median). The boundary conditions are different to the standard
    itkMedianImageFilter. In this filter the neighborhood is cropped at
    the boundary, and is therefore smaller.

    This filter uses a recursive implementation - essentially the one by
    Huang 1979, I believe, to compute the rank, and is therefore usually a
    lot faster than the direct implementation. The extensions to Huang are
    support for arbitrary pixel types (using c++ maps) and arbitrary
    neighborhoods. I presume that these are not new ideas.

    This filter is based on the sliding window code from the
    consolidatedMorphology package on InsightJournal.

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel.

    This code was contributed in the Insight Journal paper: "Efficient
    implementation of kernel filtering" by Beare R., Lehmann G https://doi.org/10.54294/igq8fn


    See:
     MedianImageFilter

    Richard Beare

    See:
     itk::simple::Rank for the procedural interface

     itk::RankImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkRankImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_RankImageFilter

    def __init__(self):
        r"""
        __init__(RankImageFilter self) -> RankImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.RankImageFilter_swiginit(
            self, _SimpleITK.new_RankImageFilter()
        )

    def SetRank(self, Rank):
        r"""
        SetRank(RankImageFilter self, double Rank)


        """
        return _SimpleITK.RankImageFilter_SetRank(self, Rank)

    def GetRank(self):
        r"""
        GetRank(RankImageFilter self) -> double


        """
        return _SimpleITK.RankImageFilter_GetRank(self)

    def SetRadius(self, Radius):
        r"""
        SetRadius(RankImageFilter self, VectorUInt32 Radius)


        """
        return _SimpleITK.RankImageFilter_SetRadius(self, Radius)

    def GetRadius(self):
        r"""
        GetRadius(RankImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.RankImageFilter_GetRadius(self)

    def SetKernelType(self, KernelType):
        r"""
        SetKernelType(RankImageFilter self, itk::simple::KernelEnum KernelType)


        Set the kernel or structuring element.


        """
        return _SimpleITK.RankImageFilter_SetKernelType(self, KernelType)

    def GetKernelType(self):
        r"""
        GetKernelType(RankImageFilter self) -> itk::simple::KernelEnum


        Get the kernel or structuring element .


        """
        return _SimpleITK.RankImageFilter_GetKernelType(self)

    def GetName(self):
        r"""
        GetName(RankImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.RankImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(RankImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.RankImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(RankImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.RankImageFilter_Execute(self, image1)


# Register RankImageFilter in _SimpleITK:
_SimpleITK.RankImageFilter_swigregister(RankImageFilter)


def Rank(*args, **kwargs):
    r"""Rank(Image image1, double rank=0.5, VectorUInt32 radius=std::vector< unsigned int >(3, 1), itk::simple::KernelEnum kernelType=sitkBox) -> Image"""
    return _SimpleITK.Rank(*args, **kwargs)


class RealAndImaginaryToComplexImageFilter(ImageFilter):
    r"""


    ComposeImageFilter combine several scalar images into a multicomponent image.


    ComposeImageFilter combine several scalar images into an itk::Image of vector pixel ( itk::Vector , itk::RGBPixel , ...), of std::complex pixel, or in an itk::VectorImage .

    Inputs and Usage
     All input images are expected to have the same template parameters
    and have the same size and origin.

    See:
     VectorImage

     VectorIndexSelectionCastImageFilter

     itk::simple::RealAndImaginaryToComplex for the procedural interface

     itk::ComposeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkRealAndImaginaryToComplexImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_RealAndImaginaryToComplexImageFilter

    def __init__(self):
        r"""
        __init__(RealAndImaginaryToComplexImageFilter self) -> RealAndImaginaryToComplexImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.RealAndImaginaryToComplexImageFilter_swiginit(
            self, _SimpleITK.new_RealAndImaginaryToComplexImageFilter()
        )

    def GetName(self):
        r"""
        GetName(RealAndImaginaryToComplexImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.RealAndImaginaryToComplexImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(RealAndImaginaryToComplexImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.RealAndImaginaryToComplexImageFilter___str__(self)

    def Execute(self, image1, image2):
        r"""
        Execute(RealAndImaginaryToComplexImageFilter self, Image image1, Image image2) -> Image


        Execute the filter on the input images


        """
        return _SimpleITK.RealAndImaginaryToComplexImageFilter_Execute(
            self, image1, image2
        )


# Register RealAndImaginaryToComplexImageFilter in _SimpleITK:
_SimpleITK.RealAndImaginaryToComplexImageFilter_swigregister(
    RealAndImaginaryToComplexImageFilter
)


def RealAndImaginaryToComplex(image1, image2):
    r"""RealAndImaginaryToComplex(Image image1, Image image2) -> Image"""
    return _SimpleITK.RealAndImaginaryToComplex(image1, image2)


class RealToHalfHermitianForwardFFTImageFilter(ImageFilter):
    r"""


    Base class for specialized real-to-complex forward Fast Fourier Transform .


    This is a base class for the "forward" or "direct" discrete
    Fourier Transform . This is an abstract base class: the actual implementation is
    provided by the best child class available on the system when the
    object is created via the object factory system.

    This class transforms a real input image into its complex Fourier
    transform. The Fourier transform of a real input image has Hermitian
    symmetry: $ f(\\mathbf{x}) = f^*(-\\mathbf{x}) $ . That is, when the result of the transform is split in half along
    the X-dimension, the values in the second half of the transform are
    the complex conjugates of values in the first half reflected about the
    center of the image in each dimension. This filter takes advantage of
    the Hermitian symmetry property and reduces the size of the output in
    the first dimension to N/2+1, where N is the size of the input image
    in that dimension and the division by 2 is rounded down.


    See:
     HalfHermitianToRealInverseFFTImageFilter

     ForwardFFTImageFilter

     itk::simple::RealToHalfHermitianForwardFFT for the procedural interface

     itk::RealToHalfHermitianForwardFFTImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkRealToHalfHermitianForwardFFTImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_RealToHalfHermitianForwardFFTImageFilter
    )

    def __init__(self):
        r"""
        __init__(RealToHalfHermitianForwardFFTImageFilter self) -> RealToHalfHermitianForwardFFTImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.RealToHalfHermitianForwardFFTImageFilter_swiginit(
            self, _SimpleITK.new_RealToHalfHermitianForwardFFTImageFilter()
        )

    def GetName(self):
        r"""
        GetName(RealToHalfHermitianForwardFFTImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.RealToHalfHermitianForwardFFTImageFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(RealToHalfHermitianForwardFFTImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.RealToHalfHermitianForwardFFTImageFilter___str__(
            self
        )

    def Execute(self, image1):
        r"""
        Execute(RealToHalfHermitianForwardFFTImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.RealToHalfHermitianForwardFFTImageFilter_Execute(
            self, image1
        )


# Register RealToHalfHermitianForwardFFTImageFilter in _SimpleITK:
_SimpleITK.RealToHalfHermitianForwardFFTImageFilter_swigregister(
    RealToHalfHermitianForwardFFTImageFilter
)


def RealToHalfHermitianForwardFFT(image1):
    r"""RealToHalfHermitianForwardFFT(Image image1) -> Image"""
    return _SimpleITK.RealToHalfHermitianForwardFFT(image1)


class ReconstructionByDilationImageFilter(ImageFilter):
    r"""


    grayscale reconstruction by dilation of an image


    Reconstruction by dilation operates on a "marker" image and a
    "mask" image, and is defined as the dilation of the marker image
    with respect to the mask image iterated until stability.

    The marker image must be less than or equal to the mask image (on a
    pixel by pixel basis).

    Geodesic morphology is described in Chapter 6.2 of Pierre Soille's
    book "Morphological Image Analysis: Principles and Applications",
    Second Edition, Springer, 2003.

    Algorithm implemented in this filter is based on algorithm described by Kevin
    Robinson and Paul F. Whelan in "Efficient Morphological
    Reconstruction: A Downhill Filter", Pattern Recognition Letters,
    Volume 25, Issue 15, November 2004, Pages 1759-1767.

    The algorithm, a description of the transform and some applications
    can be found in "Morphological Grayscale Reconstruction in Image
    Analysis:  Applications and Efficient Algorithms", Luc Vincent, IEEE
    Transactions on image processing, Vol. 2, April 1993.


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    See:
     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter , ReconstructionByErosionImageFilter , OpeningByReconstructionImageFilter , ClosingByReconstructionImageFilter , ReconstructionImageFilter

     itk::simple::ReconstructionByDilation for the procedural interface

     itk::ReconstructionByDilationImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkReconstructionByDilationImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ReconstructionByDilationImageFilter

    def __init__(self):
        r"""
        __init__(ReconstructionByDilationImageFilter self) -> ReconstructionByDilationImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ReconstructionByDilationImageFilter_swiginit(
            self, _SimpleITK.new_ReconstructionByDilationImageFilter()
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(ReconstructionByDilationImageFilter self, bool FullyConnected)


        """
        return (
            _SimpleITK.ReconstructionByDilationImageFilter_SetFullyConnected(
                self, FullyConnected
            )
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(ReconstructionByDilationImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.ReconstructionByDilationImageFilter_FullyConnectedOn(
            self
        )

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(ReconstructionByDilationImageFilter self)


        """
        return (
            _SimpleITK.ReconstructionByDilationImageFilter_FullyConnectedOff(
                self
            )
        )

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(ReconstructionByDilationImageFilter self) -> bool


        """
        return (
            _SimpleITK.ReconstructionByDilationImageFilter_GetFullyConnected(
                self
            )
        )

    def SetUseInternalCopy(self, UseInternalCopy):
        r"""
        SetUseInternalCopy(ReconstructionByDilationImageFilter self, bool UseInternalCopy)


        """
        return (
            _SimpleITK.ReconstructionByDilationImageFilter_SetUseInternalCopy(
                self, UseInternalCopy
            )
        )

    def UseInternalCopyOn(self):
        r"""
        UseInternalCopyOn(ReconstructionByDilationImageFilter self)


        Set the value of UseInternalCopy to true or false respectfully.


        """
        return (
            _SimpleITK.ReconstructionByDilationImageFilter_UseInternalCopyOn(
                self
            )
        )

    def UseInternalCopyOff(self):
        r"""
        UseInternalCopyOff(ReconstructionByDilationImageFilter self)


        """
        return (
            _SimpleITK.ReconstructionByDilationImageFilter_UseInternalCopyOff(
                self
            )
        )

    def GetUseInternalCopy(self):
        r"""
        GetUseInternalCopy(ReconstructionByDilationImageFilter self) -> bool


        """
        return (
            _SimpleITK.ReconstructionByDilationImageFilter_GetUseInternalCopy(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(ReconstructionByDilationImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ReconstructionByDilationImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ReconstructionByDilationImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ReconstructionByDilationImageFilter___str__(self)

    def Execute(self, markerImage, maskImage):
        r"""
        Execute(ReconstructionByDilationImageFilter self, Image markerImage, Image maskImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ReconstructionByDilationImageFilter_Execute(
            self, markerImage, maskImage
        )


# Register ReconstructionByDilationImageFilter in _SimpleITK:
_SimpleITK.ReconstructionByDilationImageFilter_swigregister(
    ReconstructionByDilationImageFilter
)


def ReconstructionByDilation(
    markerImage, maskImage, fullyConnected=False, useInternalCopy=True
):
    r"""ReconstructionByDilation(Image markerImage, Image maskImage, bool fullyConnected=False, bool useInternalCopy=True) -> Image"""
    return _SimpleITK.ReconstructionByDilation(
        markerImage, maskImage, fullyConnected, useInternalCopy
    )


class ReconstructionByErosionImageFilter(ImageFilter):
    r"""


    grayscale reconstruction by erosion of an image


    Reconstruction by erosion operates on a "marker" image and a
    "mask" image, and is defined as the erosion of the marker image with
    respect to the mask image iterated until stability.

    The marker image must be less than or equal to the mask image (on a
    pixel by pixel basis).

    Geodesic morphology is described in Chapter 6.2 of Pierre Soille's
    book "Morphological Image Analysis: Principles and Applications",
    Second Edition, Springer, 2003.

    Algorithm implemented in this filter is based on algorithm described by Kevin
    Robinson and Paul F. Whelan in "Efficient Morphological
    Reconstruction: A Downhill Filter", Pattern Recognition Letters,
    Volume 25, Issue 15, November 2004, Pages 1759-1767.

    The algorithm, a description of the transform and some applications
    can be found in "Morphological Grayscale Reconstruction in Image
    Analysis:  Applications and Efficient Algorithms", Luc Vincent, IEEE
    Transactions on image processing, Vol. 2, April 1993.


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    See:
     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter , ReconstructionByErosionImageFilter , OpeningByReconstructionImageFilter , ClosingByReconstructionImageFilter , ReconstructionImageFilter

     itk::simple::ReconstructionByErosion for the procedural interface

     itk::ReconstructionByErosionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkReconstructionByErosionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ReconstructionByErosionImageFilter

    def __init__(self):
        r"""
        __init__(ReconstructionByErosionImageFilter self) -> ReconstructionByErosionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ReconstructionByErosionImageFilter_swiginit(
            self, _SimpleITK.new_ReconstructionByErosionImageFilter()
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(ReconstructionByErosionImageFilter self, bool FullyConnected)


        """
        return _SimpleITK.ReconstructionByErosionImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(ReconstructionByErosionImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.ReconstructionByErosionImageFilter_FullyConnectedOn(
            self
        )

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(ReconstructionByErosionImageFilter self)


        """
        return _SimpleITK.ReconstructionByErosionImageFilter_FullyConnectedOff(
            self
        )

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(ReconstructionByErosionImageFilter self) -> bool


        """
        return _SimpleITK.ReconstructionByErosionImageFilter_GetFullyConnected(
            self
        )

    def SetUseInternalCopy(self, UseInternalCopy):
        r"""
        SetUseInternalCopy(ReconstructionByErosionImageFilter self, bool UseInternalCopy)


        """
        return (
            _SimpleITK.ReconstructionByErosionImageFilter_SetUseInternalCopy(
                self, UseInternalCopy
            )
        )

    def UseInternalCopyOn(self):
        r"""
        UseInternalCopyOn(ReconstructionByErosionImageFilter self)


        Set the value of UseInternalCopy to true or false respectfully.


        """
        return _SimpleITK.ReconstructionByErosionImageFilter_UseInternalCopyOn(
            self
        )

    def UseInternalCopyOff(self):
        r"""
        UseInternalCopyOff(ReconstructionByErosionImageFilter self)


        """
        return (
            _SimpleITK.ReconstructionByErosionImageFilter_UseInternalCopyOff(
                self
            )
        )

    def GetUseInternalCopy(self):
        r"""
        GetUseInternalCopy(ReconstructionByErosionImageFilter self) -> bool


        """
        return (
            _SimpleITK.ReconstructionByErosionImageFilter_GetUseInternalCopy(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(ReconstructionByErosionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ReconstructionByErosionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ReconstructionByErosionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ReconstructionByErosionImageFilter___str__(self)

    def Execute(self, markerImage, maskImage):
        r"""
        Execute(ReconstructionByErosionImageFilter self, Image markerImage, Image maskImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ReconstructionByErosionImageFilter_Execute(
            self, markerImage, maskImage
        )


# Register ReconstructionByErosionImageFilter in _SimpleITK:
_SimpleITK.ReconstructionByErosionImageFilter_swigregister(
    ReconstructionByErosionImageFilter
)


def ReconstructionByErosion(
    markerImage, maskImage, fullyConnected=False, useInternalCopy=True
):
    r"""ReconstructionByErosion(Image markerImage, Image maskImage, bool fullyConnected=False, bool useInternalCopy=True) -> Image"""
    return _SimpleITK.ReconstructionByErosion(
        markerImage, maskImage, fullyConnected, useInternalCopy
    )


class RecursiveGaussianImageFilter(ImageFilter):
    r"""


    Base class for computing IIR convolution with an approximation of a
    Gaussian kernel.


    \\[ \\frac{ 1 }{ \\sigma \\sqrt{ 2 \\pi } } \\exp{
    \\left( - \\frac{x^2}{ 2 \\sigma^2 } \\right) } \\]

    RecursiveGaussianImageFilter is the base class for recursive filters that approximate convolution
    with the Gaussian kernel. This class implements the recursive
    filtering method proposed by R.Deriche in IEEE-PAMI Vol.12, No.1,
    January 1990, pp 78-87, "Fast Algorithms for Low-Level Vision"

    Details of the implementation are described in the technical report: R.
    Deriche, "Recursively Implementing The Gaussian and Its
    Derivatives", INRIA, 1993, ftp://ftp.inria.fr/INRIA/tech-reports/RR/RR-1893.ps.gz

    Further improvements of the algorithm are described in: G. Farnebäck &
    C.-F. Westin, "Improving Deriche-style Recursive Gaussian Filters".
    J Math Imaging Vis 26, 293–299 (2006). https://doi.org/10.1007/s10851-006-8464-z

    As compared to itk::DiscreteGaussianImageFilter , this filter tends to be faster for large kernels, and it can take
    the derivative of the blurred image in one step. Also, note that we
    have itk::RecursiveGaussianImageFilter::SetSigma() , but itk::DiscreteGaussianImageFilter::SetVariance() .


    See:
     DiscreteGaussianImageFilter

     itk::simple::RecursiveGaussian for the procedural interface

     itk::RecursiveGaussianImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkRecursiveGaussianImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_RecursiveGaussianImageFilter

    def __init__(self):
        r"""
        __init__(RecursiveGaussianImageFilter self) -> RecursiveGaussianImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.RecursiveGaussianImageFilter_swiginit(
            self, _SimpleITK.new_RecursiveGaussianImageFilter()
        )

    def SetSigma(self, Sigma):
        r"""
        SetSigma(RecursiveGaussianImageFilter self, double Sigma)


        Set/Get the Sigma, measured in world coordinates, of the Gaussian
        kernel. The default is 1.0. An exception will be generated if the
        Sigma value is less than or equal to zero.


        """
        return _SimpleITK.RecursiveGaussianImageFilter_SetSigma(self, Sigma)

    def GetSigma(self):
        r"""
        GetSigma(RecursiveGaussianImageFilter self) -> double


        Set/Get the Sigma, measured in world coordinates, of the Gaussian
        kernel. The default is 1.0. An exception will be generated if the
        Sigma value is less than or equal to zero.


        """
        return _SimpleITK.RecursiveGaussianImageFilter_GetSigma(self)

    def SetNormalizeAcrossScale(self, NormalizeAcrossScale):
        r"""
        SetNormalizeAcrossScale(RecursiveGaussianImageFilter self, bool NormalizeAcrossScale)


             Set/Get the flag for normalizing the gaussian over scale-space.

        This flag enables the analysis of the differential shape of features
        independent of their size ( both pixels and physical size ). Following
        the notation of Tony Lindeberg:

        Let \\[ L(x; t) = g(x; t) \\ast f(x) \\] be the scale-space representation of image \\[ f(x) \\] where \\[ g(x; t) = \\frac{1}{ \\sqrt{ 2 \\pi t} } \\exp{
        \\left( -\\frac{x^2}{ 2 t } \\right) } \\] is the Gaussian function and \\[\\ast\\] denotes convolution. This is a change from above with \\[ t = \\sigma^2 \\] .

        Then the normalized derivative operator for normalized coordinates
        across scale is:

        \\[ \\partial_\\xi = \\sqrt{t} \\partial_x \\]

        The resulting scaling factor is \\[ \\sigma^N \\] where N is the order of the derivative.

        When this flag is ON the filter will be normalized in such a way that
        the values of derivatives are not biased by the size of the object.
        That is to say the maximum value a feature reaches across scale is
        independent of the scale of the object.

        For analyzing an image across scale-space you want to enable this
        flag. It is disabled by default.


        Not all scale space axioms are satisfied by this filter, some are only
        approximated. Particularly, at fine scales ( say less than 1 pixel )
        other methods such as a discrete Gaussian kernel should be considered.



        """
        return _SimpleITK.RecursiveGaussianImageFilter_SetNormalizeAcrossScale(
            self, NormalizeAcrossScale
        )

    def NormalizeAcrossScaleOn(self):
        r"""
        NormalizeAcrossScaleOn(RecursiveGaussianImageFilter self)


        Set the value of NormalizeAcrossScale to true or false respectfully.


        """
        return _SimpleITK.RecursiveGaussianImageFilter_NormalizeAcrossScaleOn(
            self
        )

    def NormalizeAcrossScaleOff(self):
        r"""
        NormalizeAcrossScaleOff(RecursiveGaussianImageFilter self)


        """
        return _SimpleITK.RecursiveGaussianImageFilter_NormalizeAcrossScaleOff(
            self
        )

    def GetNormalizeAcrossScale(self):
        r"""
        GetNormalizeAcrossScale(RecursiveGaussianImageFilter self) -> bool


        """
        return _SimpleITK.RecursiveGaussianImageFilter_GetNormalizeAcrossScale(
            self
        )

    ZeroOrder = _SimpleITK.RecursiveGaussianImageFilter_ZeroOrder

    FirstOrder = _SimpleITK.RecursiveGaussianImageFilter_FirstOrder

    SecondOrder = _SimpleITK.RecursiveGaussianImageFilter_SecondOrder

    def SetOrder(self, Order):
        r"""
        SetOrder(RecursiveGaussianImageFilter self, itk::simple::RecursiveGaussianImageFilter::OrderType Order)


             Set/Get the Order of the Gaussian to convolve with.


        ZeroOrder is equivalent to convolving with a Gaussian. This is the
        default.

        FirstOrder is equivalent to convolving with the first derivative of a
        Gaussian.

        SecondOrder is equivalent to convolving with the second derivative of
        a Gaussian.



        """
        return _SimpleITK.RecursiveGaussianImageFilter_SetOrder(self, Order)

    def GetOrder(self):
        r"""
        GetOrder(RecursiveGaussianImageFilter self) -> itk::simple::RecursiveGaussianImageFilter::OrderType


             Set/Get the Order of the Gaussian to convolve with.


        ZeroOrder is equivalent to convolving with a Gaussian. This is the
        default.

        FirstOrder is equivalent to convolving with the first derivative of a
        Gaussian.

        SecondOrder is equivalent to convolving with the second derivative of
        a Gaussian.



        """
        return _SimpleITK.RecursiveGaussianImageFilter_GetOrder(self)

    def SetDirection(self, Direction):
        r"""
        SetDirection(RecursiveGaussianImageFilter self, unsigned int Direction)


        """
        return _SimpleITK.RecursiveGaussianImageFilter_SetDirection(
            self, Direction
        )

    def GetDirection(self):
        r"""
        GetDirection(RecursiveGaussianImageFilter self) -> unsigned int


        """
        return _SimpleITK.RecursiveGaussianImageFilter_GetDirection(self)

    def GetName(self):
        r"""
        GetName(RecursiveGaussianImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.RecursiveGaussianImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(RecursiveGaussianImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.RecursiveGaussianImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(RecursiveGaussianImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.RecursiveGaussianImageFilter_Execute(self, image1)


# Register RecursiveGaussianImageFilter in _SimpleITK:
_SimpleITK.RecursiveGaussianImageFilter_swigregister(
    RecursiveGaussianImageFilter
)


def RecursiveGaussian(*args, **kwargs):
    r"""RecursiveGaussian(Image image1, double sigma=1.0, bool normalizeAcrossScale=False, itk::simple::RecursiveGaussianImageFilter::OrderType order=ZeroOrder, unsigned int direction=0) -> Image"""
    return _SimpleITK.RecursiveGaussian(*args, **kwargs)


class RegionOfInterestImageFilter(ImageFilter):
    r"""


    Extract a region of interest from the input image.


    This filter produces an output image of the same dimension as the
    input image. The user specifies the region of the input image that
    will be contained in the output image. The origin coordinates of the
    output images will be computed in such a way that if mapped to
    physical space, the output image will overlay the input image with
    perfect registration. In other words, a registration process between
    the output image and the input image will return an identity
    transform.

    If you are interested in changing the dimension of the image, you may
    want to consider the ExtractImageFilter . For example for extracting a 2D image from a slice of a 3D image.

    The region to extract is set using the method SetRegionOfInterest.


    See:
     ExtractImageFilter

     itk::simple::RegionOfInterest for the procedural interface

     itk::RegionOfInterestImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkRegionOfInterestImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_RegionOfInterestImageFilter

    def __init__(self):
        r"""
        __init__(RegionOfInterestImageFilter self) -> RegionOfInterestImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.RegionOfInterestImageFilter_swiginit(
            self, _SimpleITK.new_RegionOfInterestImageFilter()
        )

    def SetSize(self, Size):
        r"""
        SetSize(RegionOfInterestImageFilter self, VectorUInt32 Size)


        Size in pixels of the region extracted.


        """
        return _SimpleITK.RegionOfInterestImageFilter_SetSize(self, Size)

    def GetSize(self):
        r"""
        GetSize(RegionOfInterestImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.RegionOfInterestImageFilter_GetSize(self)

    def SetIndex(self, Index):
        r"""
        SetIndex(RegionOfInterestImageFilter self, VectorInt32 Index)


        Set the inclusive starting index of the region extracted.


        """
        return _SimpleITK.RegionOfInterestImageFilter_SetIndex(self, Index)

    def GetIndex(self):
        r"""
        GetIndex(RegionOfInterestImageFilter self) -> VectorInt32


        """
        return _SimpleITK.RegionOfInterestImageFilter_GetIndex(self)

    def GetName(self):
        r"""
        GetName(RegionOfInterestImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.RegionOfInterestImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(RegionOfInterestImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.RegionOfInterestImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(RegionOfInterestImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.RegionOfInterestImageFilter_Execute(self, image1)

    def SetRegionOfInterest(self, Region):
        r"""
        SetRegionOfInterest(RegionOfInterestImageFilter self, VectorUInt32 Region)


        Sets the region extracted by a single array of the starting indexes
        followed by the sizes in pixels.


        """
        return _SimpleITK.RegionOfInterestImageFilter_SetRegionOfInterest(
            self, Region
        )


# Register RegionOfInterestImageFilter in _SimpleITK:
_SimpleITK.RegionOfInterestImageFilter_swigregister(
    RegionOfInterestImageFilter
)


def RegionOfInterest(*args, **kwargs):
    r"""RegionOfInterest(Image image1, VectorUInt32 size=std::vector< unsigned int >(3, 1), VectorInt32 index=std::vector< int >(3, 0)) -> Image"""
    return _SimpleITK.RegionOfInterest(*args, **kwargs)


class RegionalMaximaImageFilter(ImageFilter):
    r"""


    Produce a binary image where foreground is the regional maxima of the
    input image.


    Regional maxima are flat zones surrounded by pixels of lower value.

    If the input image is constant, the entire image can be considered as
    a maxima or not. The desired behavior can be selected with the SetFlatIsMaxima() method.


    Gaetan Lehmann
     This class was contributed to the Insight Journal by author Gaetan
    Lehmann. Biologie du Developpement et de la Reproduction, INRA de
    Jouy-en-Josas, France. The paper can be found at https://doi.org/10.54294/hva3gz


    See:
     ValuedRegionalMaximaImageFilter

     HConvexImageFilter

     RegionalMinimaImageFilter

     itk::simple::RegionalMaxima for the procedural interface

     itk::RegionalMaximaImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkRegionalMaximaImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_RegionalMaximaImageFilter

    def __init__(self):
        r"""
        __init__(RegionalMaximaImageFilter self) -> RegionalMaximaImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.RegionalMaximaImageFilter_swiginit(
            self, _SimpleITK.new_RegionalMaximaImageFilter()
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(RegionalMaximaImageFilter self, double BackgroundValue)


        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.RegionalMaximaImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(RegionalMaximaImageFilter self) -> double


        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.RegionalMaximaImageFilter_GetBackgroundValue(self)

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(RegionalMaximaImageFilter self, double ForegroundValue)


        Set/Get the value in the output image to consider as "foreground".
        Defaults to maximum value of PixelType.


        """
        return _SimpleITK.RegionalMaximaImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(RegionalMaximaImageFilter self) -> double


        Set/Get the value in the output image to consider as "foreground".
        Defaults to maximum value of PixelType.


        """
        return _SimpleITK.RegionalMaximaImageFilter_GetForegroundValue(self)

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(RegionalMaximaImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.RegionalMaximaImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(RegionalMaximaImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.RegionalMaximaImageFilter_FullyConnectedOn(self)

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(RegionalMaximaImageFilter self)


        """
        return _SimpleITK.RegionalMaximaImageFilter_FullyConnectedOff(self)

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(RegionalMaximaImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.RegionalMaximaImageFilter_GetFullyConnected(self)

    def SetFlatIsMaxima(self, FlatIsMaxima):
        r"""
        SetFlatIsMaxima(RegionalMaximaImageFilter self, bool FlatIsMaxima)


        Set/Get whether a flat image must be considered as a maxima or not.
        Defaults to true.


        """
        return _SimpleITK.RegionalMaximaImageFilter_SetFlatIsMaxima(
            self, FlatIsMaxima
        )

    def FlatIsMaximaOn(self):
        r"""
        FlatIsMaximaOn(RegionalMaximaImageFilter self)


        Set the value of FlatIsMaxima to true or false respectfully.


        """
        return _SimpleITK.RegionalMaximaImageFilter_FlatIsMaximaOn(self)

    def FlatIsMaximaOff(self):
        r"""
        FlatIsMaximaOff(RegionalMaximaImageFilter self)


        """
        return _SimpleITK.RegionalMaximaImageFilter_FlatIsMaximaOff(self)

    def GetFlatIsMaxima(self):
        r"""
        GetFlatIsMaxima(RegionalMaximaImageFilter self) -> bool


        Set/Get whether a flat image must be considered as a maxima or not.
        Defaults to true.


        """
        return _SimpleITK.RegionalMaximaImageFilter_GetFlatIsMaxima(self)

    def GetName(self):
        r"""
        GetName(RegionalMaximaImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.RegionalMaximaImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(RegionalMaximaImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.RegionalMaximaImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(RegionalMaximaImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.RegionalMaximaImageFilter_Execute(self, image1)


# Register RegionalMaximaImageFilter in _SimpleITK:
_SimpleITK.RegionalMaximaImageFilter_swigregister(RegionalMaximaImageFilter)


def RegionalMaxima(
    image1,
    backgroundValue=0.0,
    foregroundValue=1.0,
    fullyConnected=False,
    flatIsMaxima=True,
):
    r"""RegionalMaxima(Image image1, double backgroundValue=0.0, double foregroundValue=1.0, bool fullyConnected=False, bool flatIsMaxima=True) -> Image"""
    return _SimpleITK.RegionalMaxima(
        image1, backgroundValue, foregroundValue, fullyConnected, flatIsMaxima
    )


class RegionalMinimaImageFilter(ImageFilter):
    r"""


    Produce a binary image where foreground is the regional minima of the
    input image.


    Regional minima are flat zones surrounded by pixels of greater value.

    If the input image is constant, the entire image can be considered as
    a minima or not. The SetFlatIsMinima() method let the user choose which behavior to use.

    This class was contributed to the Insight Journal by
    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France. https://doi.org/10.54294/hva3gz

    See:
     RegionalMaximaImageFilter

     ValuedRegionalMinimaImageFilter

     HConcaveImageFilter

     itk::simple::RegionalMinima for the procedural interface

     itk::RegionalMinimaImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkRegionalMinimaImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_RegionalMinimaImageFilter

    def __init__(self):
        r"""
        __init__(RegionalMinimaImageFilter self) -> RegionalMinimaImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.RegionalMinimaImageFilter_swiginit(
            self, _SimpleITK.new_RegionalMinimaImageFilter()
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(RegionalMinimaImageFilter self, double BackgroundValue)


        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.RegionalMinimaImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(RegionalMinimaImageFilter self) -> double


        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.RegionalMinimaImageFilter_GetBackgroundValue(self)

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(RegionalMinimaImageFilter self, double ForegroundValue)


        Set/Get the value in the output image to consider as "foreground".
        Defaults to maximum value of PixelType.


        """
        return _SimpleITK.RegionalMinimaImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(RegionalMinimaImageFilter self) -> double


        Set/Get the value in the output image to consider as "foreground".
        Defaults to maximum value of PixelType.


        """
        return _SimpleITK.RegionalMinimaImageFilter_GetForegroundValue(self)

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(RegionalMinimaImageFilter self, bool FullyConnected)


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.RegionalMinimaImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(RegionalMinimaImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.RegionalMinimaImageFilter_FullyConnectedOn(self)

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(RegionalMinimaImageFilter self)


        """
        return _SimpleITK.RegionalMinimaImageFilter_FullyConnectedOff(self)

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(RegionalMinimaImageFilter self) -> bool


        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.RegionalMinimaImageFilter_GetFullyConnected(self)

    def SetFlatIsMinima(self, FlatIsMinima):
        r"""
        SetFlatIsMinima(RegionalMinimaImageFilter self, bool FlatIsMinima)


        Set/Get whether a flat image must be considered as a minima or not.
        Defaults to true.


        """
        return _SimpleITK.RegionalMinimaImageFilter_SetFlatIsMinima(
            self, FlatIsMinima
        )

    def FlatIsMinimaOn(self):
        r"""
        FlatIsMinimaOn(RegionalMinimaImageFilter self)


        Set the value of FlatIsMinima to true or false respectfully.


        """
        return _SimpleITK.RegionalMinimaImageFilter_FlatIsMinimaOn(self)

    def FlatIsMinimaOff(self):
        r"""
        FlatIsMinimaOff(RegionalMinimaImageFilter self)


        """
        return _SimpleITK.RegionalMinimaImageFilter_FlatIsMinimaOff(self)

    def GetFlatIsMinima(self):
        r"""
        GetFlatIsMinima(RegionalMinimaImageFilter self) -> bool


        Set/Get whether a flat image must be considered as a minima or not.
        Defaults to true.


        """
        return _SimpleITK.RegionalMinimaImageFilter_GetFlatIsMinima(self)

    def GetName(self):
        r"""
        GetName(RegionalMinimaImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.RegionalMinimaImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(RegionalMinimaImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.RegionalMinimaImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(RegionalMinimaImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.RegionalMinimaImageFilter_Execute(self, image1)


# Register RegionalMinimaImageFilter in _SimpleITK:
_SimpleITK.RegionalMinimaImageFilter_swigregister(RegionalMinimaImageFilter)


def RegionalMinima(
    image1,
    backgroundValue=0.0,
    foregroundValue=1.0,
    fullyConnected=False,
    flatIsMinima=True,
):
    r"""RegionalMinima(Image image1, double backgroundValue=0.0, double foregroundValue=1.0, bool fullyConnected=False, bool flatIsMinima=True) -> Image"""
    return _SimpleITK.RegionalMinima(
        image1, backgroundValue, foregroundValue, fullyConnected, flatIsMinima
    )


class RelabelComponentImageFilter(ImageFilter):
    r"""


    Relabel the components in an image such that consecutive labels are
    used.


    RelabelComponentImageFilter remaps the labels associated with the objects in an image (as from
    the output of ConnectedComponentImageFilter ) such that the label numbers are consecutive with no gaps between
    the label numbers used. By default, the relabeling will also sort the
    labels based on the size of the object: the largest object will have
    label #1, the second largest will have label #2, etc. If two labels
    have the same size their initial order is kept. The sorting by size
    can be disabled using SetSortByObjectSize.

    Label #0 is assumed to be the background and is left unaltered by the
    relabeling.

    RelabelComponentImageFilter is typically used on the output of the ConnectedComponentImageFilter for those applications that want to extract the largest object or the
    "k" largest objects. Any particular object can be extracted from the
    relabeled output using a BinaryThresholdImageFilter . A group of objects can be extracted from the relabeled output using
    a ThresholdImageFilter .

    Once all the objects are relabeled, the application can query the
    number of objects and the size of each object. Object sizes are returned in a vector. The size of the background is not
    calculated. So the size of object #1 is GetSizeOfObjectsInPixels() [0], the size of object #2 is GetSizeOfObjectsInPixels() [1], etc.

    If user sets a minimum object size, all objects with fewer pixels than
    the minimum will be discarded, so that the number of objects reported
    will be only those remaining. The GetOriginalNumberOfObjects method
    can be called to find out how many objects were present before the
    small ones were discarded.

    RelabelComponentImageFilter can be run as an "in place" filter, where it will overwrite its
    output. The default is run out of place (or generate a separate
    output). "In place" operation can be controlled via methods in the
    superclass, InPlaceImageFilter::InPlaceOn() and InPlaceImageFilter::InPlaceOff().


    See:
     ConnectedComponentImageFilter , BinaryThresholdImageFilter , ThresholdImageFilter

     itk::simple::RelabelComponent for the procedural interface

     itk::RelabelComponentImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkRelabelComponentImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_RelabelComponentImageFilter

    def __init__(self):
        r"""
        __init__(RelabelComponentImageFilter self) -> RelabelComponentImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.RelabelComponentImageFilter_swiginit(
            self, _SimpleITK.new_RelabelComponentImageFilter()
        )

    def SetMinimumObjectSize(self, MinimumObjectSize):
        r"""
        SetMinimumObjectSize(RelabelComponentImageFilter self, uint64_t MinimumObjectSize)


        Set the minimum size in pixels for an object. All objects smaller than
        this size will be discarded and will not appear in the output label
        map. NumberOfObjects will count only the objects whose pixel counts
        are greater than or equal to the minimum size. Call
        GetOriginalNumberOfObjects to find out how many objects were present
        in the original label map.


        """
        return _SimpleITK.RelabelComponentImageFilter_SetMinimumObjectSize(
            self, MinimumObjectSize
        )

    def GetMinimumObjectSize(self):
        r"""
        GetMinimumObjectSize(RelabelComponentImageFilter self) -> uint64_t


        Get the caller-defined minimum size of an object in pixels. If the
        caller has not set the minimum, 0 will be returned, which is to be
        interpreted as meaning that no minimum exists, and all objects in the
        original label map will be passed through to the output.


        """
        return _SimpleITK.RelabelComponentImageFilter_GetMinimumObjectSize(
            self
        )

    def SetSortByObjectSize(self, SortByObjectSize):
        r"""
        SetSortByObjectSize(RelabelComponentImageFilter self, bool SortByObjectSize)


        Controls whether the object labels are sorted by size. If false,
        initial order of labels is kept.


        """
        return _SimpleITK.RelabelComponentImageFilter_SetSortByObjectSize(
            self, SortByObjectSize
        )

    def SortByObjectSizeOn(self):
        r"""
        SortByObjectSizeOn(RelabelComponentImageFilter self)


        Set the value of SortByObjectSize to true or false respectfully.


        """
        return _SimpleITK.RelabelComponentImageFilter_SortByObjectSizeOn(self)

    def SortByObjectSizeOff(self):
        r"""
        SortByObjectSizeOff(RelabelComponentImageFilter self)


        """
        return _SimpleITK.RelabelComponentImageFilter_SortByObjectSizeOff(self)

    def GetSortByObjectSize(self):
        r"""
        GetSortByObjectSize(RelabelComponentImageFilter self) -> bool


        Controls whether the object labels are sorted by size. If false,
        initial order of labels is kept.


        """
        return _SimpleITK.RelabelComponentImageFilter_GetSortByObjectSize(self)

    def GetNumberOfObjects(self):
        r"""
        GetNumberOfObjects(RelabelComponentImageFilter self) -> uint32_t


        Get the number of objects in the image. This information is only valid
        after the filter has executed.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.RelabelComponentImageFilter_GetNumberOfObjects(self)

    def GetOriginalNumberOfObjects(self):
        r"""
        GetOriginalNumberOfObjects(RelabelComponentImageFilter self) -> uint32_t


        Get the original number of objects in the image before small objects
        were discarded. This information is only valid after the filter has
        executed. If the caller has not specified a minimum object size,
        OriginalNumberOfObjects is the same as NumberOfObjects.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return (
            _SimpleITK.RelabelComponentImageFilter_GetOriginalNumberOfObjects(
                self
            )
        )

    def GetSizeOfObjectsInPhysicalUnits(self):
        r"""
        GetSizeOfObjectsInPhysicalUnits(RelabelComponentImageFilter self) -> VectorFloat


        Get the size of each object in physical space (in units of pixel
        size). This information is only valid after the filter has executed. Size of the background is not calculated. Size of object #1 is GetSizeOfObjectsInPhysicalUnits() [0]. Size of object #2 is GetSizeOfObjectsInPhysicalUnits() [1]. Etc.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.RelabelComponentImageFilter_GetSizeOfObjectsInPhysicalUnits(
            self
        )

    def GetSizeOfObjectsInPixels(self):
        r"""
        GetSizeOfObjectsInPixels(RelabelComponentImageFilter self) -> VectorUInt64


        Get the size of each object in pixels. This information is only valid
        after the filter has executed. Size of the background is not calculated. Size of object #1 is GetSizeOfObjectsInPixels() [0]. Size of object #2 is GetSizeOfObjectsInPixels() [1]. Etc.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.RelabelComponentImageFilter_GetSizeOfObjectsInPixels(
            self
        )

    def GetName(self):
        r"""
        GetName(RelabelComponentImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.RelabelComponentImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(RelabelComponentImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.RelabelComponentImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(RelabelComponentImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.RelabelComponentImageFilter_Execute(self, image1)


# Register RelabelComponentImageFilter in _SimpleITK:
_SimpleITK.RelabelComponentImageFilter_swigregister(
    RelabelComponentImageFilter
)


def RelabelComponent(image1, minimumObjectSize=0, sortByObjectSize=True):
    r"""RelabelComponent(Image image1, uint64_t minimumObjectSize=0, bool sortByObjectSize=True) -> Image"""
    return _SimpleITK.RelabelComponent(
        image1, minimumObjectSize, sortByObjectSize
    )


class RelabelLabelMapFilter(ImageFilter):
    r"""


    This filter relabels the LabelObjects; the new labels are arranged
    consecutively with consideration for the background value.


    This filter takes the LabelObjects from the input and reassigns them
    to the output by calling the PushLabelObject method, which by default,
    attempts to reorganize the labels consecutively. The user can assign
    an arbitrary value to the background; the filter will assign the
    labels consecutively by skipping the background value.

    This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/q6auw4
    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ShapeLabelObject , RelabelComponentImageFilter

     itk::simple::RelabelLabelMapFilter for the procedural interface

     itk::RelabelLabelMapFilter for the Doxygen on the original ITK class.


    C++ includes: sitkRelabelLabelMapFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_RelabelLabelMapFilter

    def __init__(self):
        r"""
        __init__(RelabelLabelMapFilter self) -> RelabelLabelMapFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.RelabelLabelMapFilter_swiginit(
            self, _SimpleITK.new_RelabelLabelMapFilter()
        )

    def SetReverseOrdering(self, ReverseOrdering):
        r"""
        SetReverseOrdering(RelabelLabelMapFilter self, bool ReverseOrdering)


        """
        return _SimpleITK.RelabelLabelMapFilter_SetReverseOrdering(
            self, ReverseOrdering
        )

    def ReverseOrderingOn(self):
        r"""
        ReverseOrderingOn(RelabelLabelMapFilter self)


        Set the value of ReverseOrdering to true or false respectfully.


        """
        return _SimpleITK.RelabelLabelMapFilter_ReverseOrderingOn(self)

    def ReverseOrderingOff(self):
        r"""
        ReverseOrderingOff(RelabelLabelMapFilter self)


        """
        return _SimpleITK.RelabelLabelMapFilter_ReverseOrderingOff(self)

    def GetReverseOrdering(self):
        r"""
        GetReverseOrdering(RelabelLabelMapFilter self) -> bool


        """
        return _SimpleITK.RelabelLabelMapFilter_GetReverseOrdering(self)

    def GetName(self):
        r"""
        GetName(RelabelLabelMapFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.RelabelLabelMapFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(RelabelLabelMapFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.RelabelLabelMapFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(RelabelLabelMapFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.RelabelLabelMapFilter_Execute(self, image1)


# Register RelabelLabelMapFilter in _SimpleITK:
_SimpleITK.RelabelLabelMapFilter_swigregister(RelabelLabelMapFilter)


def RelabelLabelMap(image1, reverseOrdering=True):
    r"""RelabelLabelMap(Image image1, bool reverseOrdering=True) -> Image"""
    return _SimpleITK.RelabelLabelMap(image1, reverseOrdering)


class RenyiEntropyThresholdImageFilter(ImageFilter):
    r"""


    Threshold an image using the RenyiEntropy Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the RenyiEntropyThresholdCalculator and applies that threshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/efycla


    See:
     HistogramThresholdImageFilter

     itk::simple::RenyiEntropyThreshold for the procedural interface

     itk::RenyiEntropyThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkRenyiEntropyThresholdImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_RenyiEntropyThresholdImageFilter

    def __init__(self):
        r"""
        __init__(RenyiEntropyThresholdImageFilter self) -> RenyiEntropyThresholdImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.RenyiEntropyThresholdImageFilter_swiginit(
            self, _SimpleITK.new_RenyiEntropyThresholdImageFilter()
        )

    def SetInsideValue(self, InsideValue):
        r"""
        SetInsideValue(RenyiEntropyThresholdImageFilter self, uint8_t InsideValue)


        Set the "inside" pixel value.


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_SetInsideValue(
            self, InsideValue
        )

    def GetInsideValue(self):
        r"""
        GetInsideValue(RenyiEntropyThresholdImageFilter self) -> uint8_t


        Get the "inside" pixel value.


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_GetInsideValue(self)

    def SetOutsideValue(self, OutsideValue):
        r"""
        SetOutsideValue(RenyiEntropyThresholdImageFilter self, uint8_t OutsideValue)


        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_SetOutsideValue(
            self, OutsideValue
        )

    def GetOutsideValue(self):
        r"""
        GetOutsideValue(RenyiEntropyThresholdImageFilter self) -> uint8_t


        Get the "outside" pixel value.


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_GetOutsideValue(
            self
        )

    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        r"""
        SetNumberOfHistogramBins(RenyiEntropyThresholdImageFilter self, uint32_t NumberOfHistogramBins)


        Set/Get the number of histogram bins.


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_SetNumberOfHistogramBins(
            self, NumberOfHistogramBins
        )

    def GetNumberOfHistogramBins(self):
        r"""
        GetNumberOfHistogramBins(RenyiEntropyThresholdImageFilter self) -> uint32_t


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_GetNumberOfHistogramBins(
            self
        )

    def SetMaskOutput(self, MaskOutput):
        r"""
        SetMaskOutput(RenyiEntropyThresholdImageFilter self, bool MaskOutput)


        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_SetMaskOutput(
            self, MaskOutput
        )

    def MaskOutputOn(self):
        r"""
        MaskOutputOn(RenyiEntropyThresholdImageFilter self)


        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_MaskOutputOn(self)

    def MaskOutputOff(self):
        r"""
        MaskOutputOff(RenyiEntropyThresholdImageFilter self)


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_MaskOutputOff(self)

    def GetMaskOutput(self):
        r"""
        GetMaskOutput(RenyiEntropyThresholdImageFilter self) -> bool


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_GetMaskOutput(self)

    def SetMaskValue(self, MaskValue):
        r"""
        SetMaskValue(RenyiEntropyThresholdImageFilter self, uint8_t MaskValue)


        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_SetMaskValue(
            self, MaskValue
        )

    def GetMaskValue(self):
        r"""
        GetMaskValue(RenyiEntropyThresholdImageFilter self) -> uint8_t


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_GetMaskValue(self)

    def GetThreshold(self):
        r"""
        GetThreshold(RenyiEntropyThresholdImageFilter self) -> double


        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_GetThreshold(self)

    def GetName(self):
        r"""
        GetName(RenyiEntropyThresholdImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(RenyiEntropyThresholdImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(RenyiEntropyThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(RenyiEntropyThresholdImageFilter self, Image image) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_Execute(self, *args)


# Register RenyiEntropyThresholdImageFilter in _SimpleITK:
_SimpleITK.RenyiEntropyThresholdImageFilter_swigregister(
    RenyiEntropyThresholdImageFilter
)


def RenyiEntropyThreshold(*args):
    r"""
    RenyiEntropyThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    RenyiEntropyThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    """
    return _SimpleITK.RenyiEntropyThreshold(*args)


class ResampleImageFilter(ImageFilter):
    r"""


    Resample an image via a coordinate transform.


    ResampleImageFilter resamples an existing image through some coordinate transform,
    interpolating via some image function. The class is templated over the
    types of the input and output images.

    Note that the choice of interpolator function can be important. This
    function is set via SetInterpolator() . The default is LinearInterpolateImageFunction <InputImageType, TInterpolatorPrecisionType>, which is reasonable for
    ordinary medical images. However, some synthetic images have pixels
    drawn from a finite prescribed set. An example would be a mask
    indicating the segmentation of a brain into a small number of tissue
    types. For such an image, one does not want to interpolate between
    different pixel values, and so NearestNeighborInterpolateImageFunction < InputImageType, TCoordRep > would be a better choice.

    If an sample is taken from outside the image domain, the default
    behavior is to use a default pixel value. If different behavior is
    desired, an extrapolator function can be set with SetExtrapolator() .

    Output information (spacing, size and direction) for the output image
    should be set. This information has the normal defaults of unit
    spacing, zero origin and identity direction. Optionally, the output
    information can be obtained from a reference image. If the reference
    image is provided and UseReferenceImage is On, then the spacing,
    origin and direction of the reference image will be used.

    Since this filter produces an image which is a different size than its
    input, it needs to override several of the methods defined in ProcessObject in order to properly manage the pipeline execution model. In
    particular, this filter overrides ProcessObject::GenerateInputRequestedRegion() and ProcessObject::GenerateOutputInformation() .

    This filter is implemented as a multithreaded filter. It provides a
    DynamicThreadedGenerateData() method for its implementation.
    WARNING:
    For multithreading, the TransformPoint method of the user-designated
    coordinate transform must be threadsafe.

    See:
     itk::ResampleImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkResampleImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ResampleImageFilter

    def __init__(self):
        r"""
        __init__(ResampleImageFilter self) -> ResampleImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ResampleImageFilter_swiginit(
            self, _SimpleITK.new_ResampleImageFilter()
        )

    def SetSize(self, Size):
        r"""
        SetSize(ResampleImageFilter self, VectorUInt32 Size)


        Get/Set the size of the output image.


        """
        return _SimpleITK.ResampleImageFilter_SetSize(self, Size)

    def GetSize(self):
        r"""
        GetSize(ResampleImageFilter self) -> VectorUInt32


        Get/Set the size of the output image.


        """
        return _SimpleITK.ResampleImageFilter_GetSize(self)

    def SetTransform(self, Transform):
        r"""
        SetTransform(ResampleImageFilter self, Transform Transform)


        """
        return _SimpleITK.ResampleImageFilter_SetTransform(self, Transform)

    def GetTransform(self):
        r"""
        GetTransform(ResampleImageFilter self) -> Transform


        """
        return _SimpleITK.ResampleImageFilter_GetTransform(self)

    def SetInterpolator(self, Interpolator):
        r"""
        SetInterpolator(ResampleImageFilter self, itk::simple::InterpolatorEnum Interpolator)


        Get/Set the interpolator function. The default is LinearInterpolateImageFunction <InputImageType, TInterpolatorPrecisionType>. Some other options are NearestNeighborInterpolateImageFunction (useful for binary masks and other images with a small number of
        possible pixel values), and BSplineInterpolateImageFunction (which provides a higher order of interpolation).


        """
        return _SimpleITK.ResampleImageFilter_SetInterpolator(
            self, Interpolator
        )

    def GetInterpolator(self):
        r"""
        GetInterpolator(ResampleImageFilter self) -> itk::simple::InterpolatorEnum


        Get/Set the interpolator function. The default is LinearInterpolateImageFunction <InputImageType, TInterpolatorPrecisionType>. Some other options are NearestNeighborInterpolateImageFunction (useful for binary masks and other images with a small number of
        possible pixel values), and BSplineInterpolateImageFunction (which provides a higher order of interpolation).


        """
        return _SimpleITK.ResampleImageFilter_GetInterpolator(self)

    def SetOutputOrigin(self, OutputOrigin):
        r"""
        SetOutputOrigin(ResampleImageFilter self, VectorDouble OutputOrigin)


        Set the output image origin.


        """
        return _SimpleITK.ResampleImageFilter_SetOutputOrigin(
            self, OutputOrigin
        )

    def GetOutputOrigin(self):
        r"""
        GetOutputOrigin(ResampleImageFilter self) -> VectorDouble


        Get the output image origin.


        """
        return _SimpleITK.ResampleImageFilter_GetOutputOrigin(self)

    def SetOutputSpacing(self, OutputSpacing):
        r"""
        SetOutputSpacing(ResampleImageFilter self, VectorDouble OutputSpacing)


        Set the output image spacing.


        """
        return _SimpleITK.ResampleImageFilter_SetOutputSpacing(
            self, OutputSpacing
        )

    def GetOutputSpacing(self):
        r"""
        GetOutputSpacing(ResampleImageFilter self) -> VectorDouble


        Get the output image spacing.


        """
        return _SimpleITK.ResampleImageFilter_GetOutputSpacing(self)

    def SetOutputDirection(self, OutputDirection):
        r"""
        SetOutputDirection(ResampleImageFilter self, VectorDouble OutputDirection)


        Set the output direction cosine matrix.


        """
        return _SimpleITK.ResampleImageFilter_SetOutputDirection(
            self, OutputDirection
        )

    def GetOutputDirection(self):
        r"""
        GetOutputDirection(ResampleImageFilter self) -> VectorDouble


        Set the output direction cosine matrix.


        """
        return _SimpleITK.ResampleImageFilter_GetOutputDirection(self)

    def SetDefaultPixelValue(self, DefaultPixelValue):
        r"""
        SetDefaultPixelValue(ResampleImageFilter self, double DefaultPixelValue)


        Get/Set the pixel value when a transformed pixel is outside of the
        image. The default default pixel value is 0.


        """
        return _SimpleITK.ResampleImageFilter_SetDefaultPixelValue(
            self, DefaultPixelValue
        )

    def GetDefaultPixelValue(self):
        r"""
        GetDefaultPixelValue(ResampleImageFilter self) -> double


        Get/Set the pixel value when a transformed pixel is outside of the
        image. The default default pixel value is 0.


        """
        return _SimpleITK.ResampleImageFilter_GetDefaultPixelValue(self)

    def SetOutputPixelType(self, OutputPixelType):
        r"""
        SetOutputPixelType(ResampleImageFilter self, itk::simple::PixelIDValueEnum OutputPixelType)


        Set the output pixel type, if sitkUnknown then the input type is used.


        """
        return _SimpleITK.ResampleImageFilter_SetOutputPixelType(
            self, OutputPixelType
        )

    def GetOutputPixelType(self):
        r"""
        GetOutputPixelType(ResampleImageFilter self) -> itk::simple::PixelIDValueEnum


        Get the ouput pixel type.


        """
        return _SimpleITK.ResampleImageFilter_GetOutputPixelType(self)

    def SetUseNearestNeighborExtrapolator(
        self, UseNearestNeighborExtrapolator
    ):
        r"""
        SetUseNearestNeighborExtrapolator(ResampleImageFilter self, bool UseNearestNeighborExtrapolator)


        Enables the nearest neighbor extrapolator as opposed to the constant
        pixel value.


        """
        return (
            _SimpleITK.ResampleImageFilter_SetUseNearestNeighborExtrapolator(
                self, UseNearestNeighborExtrapolator
            )
        )

    def UseNearestNeighborExtrapolatorOn(self):
        r"""
        UseNearestNeighborExtrapolatorOn(ResampleImageFilter self)


        Set the value of UseNearestNeighborExtrapolator to true or false
        respectfully.


        """
        return _SimpleITK.ResampleImageFilter_UseNearestNeighborExtrapolatorOn(
            self
        )

    def UseNearestNeighborExtrapolatorOff(self):
        r"""
        UseNearestNeighborExtrapolatorOff(ResampleImageFilter self)


        """
        return (
            _SimpleITK.ResampleImageFilter_UseNearestNeighborExtrapolatorOff(
                self
            )
        )

    def GetUseNearestNeighborExtrapolator(self):
        r"""
        GetUseNearestNeighborExtrapolator(ResampleImageFilter self) -> bool


        """
        return (
            _SimpleITK.ResampleImageFilter_GetUseNearestNeighborExtrapolator(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(ResampleImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ResampleImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ResampleImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ResampleImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ResampleImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ResampleImageFilter_Execute(self, image1)

    def SetReferenceImage(self, refImage):
        r"""
        SetReferenceImage(ResampleImageFilter self, Image refImage)


        This methods sets the output size, origin, spacing and direction to
        that of the provided image


        """
        return _SimpleITK.ResampleImageFilter_SetReferenceImage(self, refImage)


# Register ResampleImageFilter in _SimpleITK:
_SimpleITK.ResampleImageFilter_swigregister(ResampleImageFilter)


class RescaleIntensityImageFilter(ImageFilter):
    r"""


    Applies a linear transformation to the intensity levels of the input Image .


    RescaleIntensityImageFilter applies pixel-wise a linear transformation to the intensity values of
    input image pixels. The linear transformation is defined by the user
    in terms of the minimum and maximum values that the output image
    should have.

    The following equation gives the mapping of the intensity values


    \\[ outputPixel = ( inputPixel - inputMin) \\cdot
    \\frac{(outputMax - outputMin )}{(inputMax - inputMin)} + outputMin
    \\]
     All computations are performed in the precision of the input pixel's
    RealType. Before assigning the computed value to the output pixel.

    NOTE: In this filter the minimum and maximum values of the input image
    are computed internally using the MinimumMaximumImageCalculator . Users are not supposed to set those values in this filter. If you
    need a filter where you can set the minimum and maximum values of the
    input, please use the IntensityWindowingImageFilter . If you want a filter that can use a user-defined linear
    transformation for the intensity, then please use the ShiftScaleImageFilter .


    See:
     IntensityWindowingImageFilter

     itk::simple::RescaleIntensity for the procedural interface

     itk::RescaleIntensityImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkRescaleIntensityImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_RescaleIntensityImageFilter

    def __init__(self):
        r"""
        __init__(RescaleIntensityImageFilter self) -> RescaleIntensityImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.RescaleIntensityImageFilter_swiginit(
            self, _SimpleITK.new_RescaleIntensityImageFilter()
        )

    def SetOutputMinimum(self, OutputMinimum):
        r"""
        SetOutputMinimum(RescaleIntensityImageFilter self, double OutputMinimum)


        """
        return _SimpleITK.RescaleIntensityImageFilter_SetOutputMinimum(
            self, OutputMinimum
        )

    def GetOutputMinimum(self):
        r"""
        GetOutputMinimum(RescaleIntensityImageFilter self) -> double


        """
        return _SimpleITK.RescaleIntensityImageFilter_GetOutputMinimum(self)

    def SetOutputMaximum(self, OutputMaximum):
        r"""
        SetOutputMaximum(RescaleIntensityImageFilter self, double OutputMaximum)


        """
        return _SimpleITK.RescaleIntensityImageFilter_SetOutputMaximum(
            self, OutputMaximum
        )

    def GetOutputMaximum(self):
        r"""
        GetOutputMaximum(RescaleIntensityImageFilter self) -> double


        """
        return _SimpleITK.RescaleIntensityImageFilter_GetOutputMaximum(self)

    def GetName(self):
        r"""
        GetName(RescaleIntensityImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.RescaleIntensityImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(RescaleIntensityImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.RescaleIntensityImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(RescaleIntensityImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.RescaleIntensityImageFilter_Execute(self, image1)


# Register RescaleIntensityImageFilter in _SimpleITK:
_SimpleITK.RescaleIntensityImageFilter_swigregister(
    RescaleIntensityImageFilter
)


def RescaleIntensity(image1, outputMinimum=0, outputMaximum=255):
    r"""RescaleIntensity(Image image1, double outputMinimum=0, double outputMaximum=255) -> Image"""
    return _SimpleITK.RescaleIntensity(image1, outputMinimum, outputMaximum)


class RichardsonLucyDeconvolutionImageFilter(ImageFilter):
    r"""


    Deconvolve an image using the Richardson-Lucy deconvolution algorithm.


    This filter implements the Richardson-Lucy deconvolution algorithm as
    defined in Bertero M and Boccacci P, "Introduction to Inverse
    Problems in Imaging", 1998. The algorithm assumes that the input
    image has been formed by a linear shift-invariant system with a known
    kernel.

    The Richardson-Lucy algorithm assumes that noise in the image follows
    a Poisson distribution and that the distribution for each pixel is
    independent of the other pixels.

    This code was adapted from the Insight Journal contribution:

    "Deconvolution: infrastructure and reference algorithms" by Gaetan
    Lehmann https://doi.org/10.54294/tvgfv1


    Gaetan Lehmann, Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France

    Cory Quammen, The University of North Carolina at Chapel Hill

    See:
     IterativeDeconvolutionImageFilter

     LandweberDeconvolutionImageFilter

     ProjectedLandweberDeconvolutionImageFilter

     itk::simple::RichardsonLucyDeconvolution for the procedural interface

     itk::RichardsonLucyDeconvolutionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkRichardsonLucyDeconvolutionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_RichardsonLucyDeconvolutionImageFilter

    def __init__(self):
        r"""
        __init__(RichardsonLucyDeconvolutionImageFilter self) -> RichardsonLucyDeconvolutionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.RichardsonLucyDeconvolutionImageFilter_swiginit(
            self, _SimpleITK.new_RichardsonLucyDeconvolutionImageFilter()
        )

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(RichardsonLucyDeconvolutionImageFilter self, int NumberOfIterations)


        Set the number of iterations.


        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(RichardsonLucyDeconvolutionImageFilter self) -> int


        Get the number of iterations.


        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_GetNumberOfIterations(
            self
        )

    def SetNormalize(self, Normalize):
        r"""
        SetNormalize(RichardsonLucyDeconvolutionImageFilter self, bool Normalize)


        Normalize the output image by the sum of the kernel components


        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_SetNormalize(
            self, Normalize
        )

    def NormalizeOn(self):
        r"""
        NormalizeOn(RichardsonLucyDeconvolutionImageFilter self)


        Set the value of Normalize to true or false respectfully.


        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_NormalizeOn(
            self
        )

    def NormalizeOff(self):
        r"""
        NormalizeOff(RichardsonLucyDeconvolutionImageFilter self)


        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_NormalizeOff(
            self
        )

    def GetNormalize(self):
        r"""
        GetNormalize(RichardsonLucyDeconvolutionImageFilter self) -> bool


        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_GetNormalize(
            self
        )

    ZERO_PAD = _SimpleITK.RichardsonLucyDeconvolutionImageFilter_ZERO_PAD

    ZERO_FLUX_NEUMANN_PAD = (
        _SimpleITK.RichardsonLucyDeconvolutionImageFilter_ZERO_FLUX_NEUMANN_PAD
    )

    PERIODIC_PAD = (
        _SimpleITK.RichardsonLucyDeconvolutionImageFilter_PERIODIC_PAD
    )

    def SetBoundaryCondition(self, BoundaryCondition):
        r"""
        SetBoundaryCondition(RichardsonLucyDeconvolutionImageFilter self, itk::simple::RichardsonLucyDeconvolutionImageFilter::BoundaryConditionType BoundaryCondition)


        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_SetBoundaryCondition(
            self, BoundaryCondition
        )

    def GetBoundaryCondition(self):
        r"""
        GetBoundaryCondition(RichardsonLucyDeconvolutionImageFilter self) -> itk::simple::RichardsonLucyDeconvolutionImageFilter::BoundaryConditionType


        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_GetBoundaryCondition(
            self
        )

    SAME = _SimpleITK.RichardsonLucyDeconvolutionImageFilter_SAME

    VALID = _SimpleITK.RichardsonLucyDeconvolutionImageFilter_VALID

    def SetOutputRegionMode(self, OutputRegionMode):
        r"""
        SetOutputRegionMode(RichardsonLucyDeconvolutionImageFilter self, itk::simple::RichardsonLucyDeconvolutionImageFilter::OutputRegionModeType OutputRegionMode)


        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_SetOutputRegionMode(
            self, OutputRegionMode
        )

    def GetOutputRegionMode(self):
        r"""
        GetOutputRegionMode(RichardsonLucyDeconvolutionImageFilter self) -> itk::simple::RichardsonLucyDeconvolutionImageFilter::OutputRegionModeType


        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_GetOutputRegionMode(
            self
        )

    def GetName(self):
        r"""
        GetName(RichardsonLucyDeconvolutionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(RichardsonLucyDeconvolutionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter___str__(self)

    def Execute(self, image1, image2):
        r"""
        Execute(RichardsonLucyDeconvolutionImageFilter self, Image image1, Image image2) -> Image


        Execute the filter on the input images


        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_Execute(
            self, image1, image2
        )


# Register RichardsonLucyDeconvolutionImageFilter in _SimpleITK:
_SimpleITK.RichardsonLucyDeconvolutionImageFilter_swigregister(
    RichardsonLucyDeconvolutionImageFilter
)


def RichardsonLucyDeconvolution(*args, **kwargs):
    r"""RichardsonLucyDeconvolution(Image image1, Image image2, int numberOfIterations=1, bool normalize=False, itk::simple::RichardsonLucyDeconvolutionImageFilter::BoundaryConditionType boundaryCondition=ZERO_FLUX_NEUMANN_PAD, itk::simple::RichardsonLucyDeconvolutionImageFilter::OutputRegionModeType outputRegionMode=SAME) -> Image"""
    return _SimpleITK.RichardsonLucyDeconvolution(*args, **kwargs)


class RoundImageFilter(ImageFilter):
    r"""


    Rounds the value of each pixel.


    The computations are performed using itk::Math::Round(x).
    See:
     itk::simple::Round for the procedural interface

     itk::RoundImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkRoundImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_RoundImageFilter

    def __init__(self):
        r"""
        __init__(RoundImageFilter self) -> RoundImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.RoundImageFilter_swiginit(
            self, _SimpleITK.new_RoundImageFilter()
        )

    def GetName(self):
        r"""
        GetName(RoundImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.RoundImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(RoundImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.RoundImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(RoundImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.RoundImageFilter_Execute(self, image1)


# Register RoundImageFilter in _SimpleITK:
_SimpleITK.RoundImageFilter_swigregister(RoundImageFilter)


def Round(image1):
    r"""Round(Image image1) -> Image"""
    return _SimpleITK.Round(image1)


class SLICImageFilter(ImageFilter):
    r"""


    Simple Linear Iterative Clustering (SLIC) super-pixel segmentation.


    The Simple Linear Iterative Clustering (SLIC) algorithm groups pixels
    into a set of labeled regions or super-pixels. Super-pixels follow
    natural image boundaries, are compact, and are nearly uniform regions
    which can be used as a larger primitive for more efficient
    computation. The SLIC algorithm can be viewed as a spatially
    constrained iterative k-means method.

    The original algorithm was designed to cluster on the joint domain of
    the images index space and its CIELAB color space. This implementation
    works with images of arbitrary dimension as well as scalar, single
    channel, images and most multi-component image types including ITK's
    arbitrary length VectorImage .

    The distance between a pixel and a cluster is the sum of squares of
    the difference between their joint range and domains ( index and value
    ). The computation is done in index space with scales provided by the
    SpatialProximityWeight parameters.

    The output is a label image with each label representing a superpixel
    cluster. Every pixel in the output is labeled, and the starting label
    id is zero.

    This code was contributed in the Insight Journal paper: "Scalable
    Simple Linear Iterative Clustering (SSLIC) Using a Generic and
    Parallel Approach" by Lowekamp B. C., Chen D. T., Yaniv Z., Yoo T. S. https://doi.org/10.54294/8hic7f
    See:
     itk::simple::SLIC for the procedural interface

     itk::SLICImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSLICImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_SLICImageFilter

    def __init__(self):
        r"""
        __init__(SLICImageFilter self) -> SLICImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.SLICImageFilter_swiginit(
            self, _SimpleITK.new_SLICImageFilter()
        )

    def SetSuperGridSize(self, SuperGridSize):
        r"""
        SetSuperGridSize(SLICImageFilter self, VectorUInt32 SuperGridSize)


        """
        return _SimpleITK.SLICImageFilter_SetSuperGridSize(self, SuperGridSize)

    def GetSuperGridSize(self):
        r"""
        GetSuperGridSize(SLICImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.SLICImageFilter_GetSuperGridSize(self)

    def SetSpatialProximityWeight(self, SpatialProximityWeight):
        r"""
        SetSpatialProximityWeight(SLICImageFilter self, double SpatialProximityWeight)


        The spatial weight for the distance function. Increasing this value
        makes the superpixel shape more regular, but more varied in image
        values. The range of the pixel values and image dimension can effect
        the appropriate value.


        """
        return _SimpleITK.SLICImageFilter_SetSpatialProximityWeight(
            self, SpatialProximityWeight
        )

    def GetSpatialProximityWeight(self):
        r"""
        GetSpatialProximityWeight(SLICImageFilter self) -> double


        """
        return _SimpleITK.SLICImageFilter_GetSpatialProximityWeight(self)

    def SetMaximumNumberOfIterations(self, MaximumNumberOfIterations):
        r"""
        SetMaximumNumberOfIterations(SLICImageFilter self, uint32_t MaximumNumberOfIterations)


        Number of iterations to run. Specify the number of iterations to run
        when optimizing the clusters.


        """
        return _SimpleITK.SLICImageFilter_SetMaximumNumberOfIterations(
            self, MaximumNumberOfIterations
        )

    def GetMaximumNumberOfIterations(self):
        r"""
        GetMaximumNumberOfIterations(SLICImageFilter self) -> uint32_t


        """
        return _SimpleITK.SLICImageFilter_GetMaximumNumberOfIterations(self)

    def SetEnforceConnectivity(self, EnforceConnectivity):
        r"""
        SetEnforceConnectivity(SLICImageFilter self, bool EnforceConnectivity)


        Post processing step to enforce superpixel morphology. Enable an
        additional computation which ensures all label pixels of the same
        value are spatially connected. Disconnected labeled components are
        assigned a new value if of sufficient size, or are relabeled to the
        previously encountered value if small.


        """
        return _SimpleITK.SLICImageFilter_SetEnforceConnectivity(
            self, EnforceConnectivity
        )

    def EnforceConnectivityOn(self):
        r"""
        EnforceConnectivityOn(SLICImageFilter self)


        Set the value of EnforceConnectivity to true or false respectfully.


        """
        return _SimpleITK.SLICImageFilter_EnforceConnectivityOn(self)

    def EnforceConnectivityOff(self):
        r"""
        EnforceConnectivityOff(SLICImageFilter self)


        """
        return _SimpleITK.SLICImageFilter_EnforceConnectivityOff(self)

    def GetEnforceConnectivity(self):
        r"""
        GetEnforceConnectivity(SLICImageFilter self) -> bool


        """
        return _SimpleITK.SLICImageFilter_GetEnforceConnectivity(self)

    def SetInitializationPerturbation(self, InitializationPerturbation):
        r"""
        SetInitializationPerturbation(SLICImageFilter self, bool InitializationPerturbation)


        Enable perturbation of initial cluster center location. After grid
        based initialization, this option enables moving the initial cluster
        center location to the minimum gradient in a small neighborhood. If
        the grid size is less than three this is automatically disabled.


        """
        return _SimpleITK.SLICImageFilter_SetInitializationPerturbation(
            self, InitializationPerturbation
        )

    def InitializationPerturbationOn(self):
        r"""
        InitializationPerturbationOn(SLICImageFilter self)


        Set the value of InitializationPerturbation to true or false
        respectfully.


        """
        return _SimpleITK.SLICImageFilter_InitializationPerturbationOn(self)

    def InitializationPerturbationOff(self):
        r"""
        InitializationPerturbationOff(SLICImageFilter self)


        """
        return _SimpleITK.SLICImageFilter_InitializationPerturbationOff(self)

    def GetInitializationPerturbation(self):
        r"""
        GetInitializationPerturbation(SLICImageFilter self) -> bool


        """
        return _SimpleITK.SLICImageFilter_GetInitializationPerturbation(self)

    def GetAverageResidual(self):
        r"""
        GetAverageResidual(SLICImageFilter self) -> double


        Get the current average cluster residual. After each iteration the
        residual is computed as the distance between the current clusters and
        the previous. This is averaged so that the value is independent of the
        number of clusters.


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.SLICImageFilter_GetAverageResidual(self)

    def GetName(self):
        r"""
        GetName(SLICImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.SLICImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(SLICImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.SLICImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(SLICImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.SLICImageFilter_Execute(self, image1)


# Register SLICImageFilter in _SimpleITK:
_SimpleITK.SLICImageFilter_swigregister(SLICImageFilter)


def SLIC(*args, **kwargs):
    r"""SLIC(Image image1, VectorUInt32 superGridSize=std::vector< unsigned int >(3, 50), double spatialProximityWeight=10.0, uint32_t maximumNumberOfIterations=5, bool enforceConnectivity=True, bool initializationPerturbation=True) -> Image"""
    return _SimpleITK.SLIC(*args, **kwargs)


class STAPLEImageFilter(ImageFilter):
    r"""


    The STAPLE filter implements the Simultaneous Truth and Performance
    Level Estimation algorithm for generating ground truth volumes from a
    set of binary expert segmentations.


    The STAPLE algorithm treats segmentation as a pixelwise
    classification, which leads to an averaging scheme that accounts for
    systematic biases in the behavior of experts in order to generate a
    fuzzy ground truth volume and simultaneous accuracy assessment of each
    expert. The ground truth volumes produced by this filter are floating
    point volumes of values between zero and one that indicate probability
    of each pixel being in the object targeted by the segmentation.

    The STAPLE algorithm is described in

    S. Warfield, K. Zou, W. Wells, "Validation of image segmentation and
    expert quality with an expectation-maximization algorithm" in MICCAI
    2002: Fifth International Conference on Medical Image Computing and Computer-Assisted Intervention, Springer-Verlag,
    Heidelberg, Germany, 2002, pp. 298-306

    INPUTS
    Input volumes to the STAPLE filter must be binary segmentations of an
    image, that is, there must be a single foreground value that
    represents positively classified pixels (pixels that are considered to
    belong inside the segmentation). Any number of background pixel values
    may be present in the input images. You can, for example, input
    volumes with many different labels as long as the structure you are
    interested in creating ground truth for is consistently labeled among
    all input volumes. Pixel type of the input volumes does not matter.
    Specify the label value for positively classified pixels using
    SetForegroundValue. All other labels will be considered to be
    negatively classified pixels (background).
     Input volumes must all contain the same size RequestedRegions.

    OUTPUTS
    The STAPLE filter produces a single output volume with a range of
    floating point values from zero to one. IT IS VERY IMPORTANT TO
    INSTANTIATE THIS FILTER WITH A FLOATING POINT OUTPUT TYPE (floats or
    doubles). You may threshold the output above some probability
    threshold if you wish to produce a binary ground truth.
    PARAMETERS
    The STAPLE algorithm requires a number of inputs. You may specify any
    number of input volumes using the SetInput(i, p_i) method, where i
    ranges from zero to N-1, N is the total number of input segmentations,
    and p_i is the SmartPointer to the i-th segmentation.
     The SetConfidenceWeight parameter is a modifier for the prior
    probability that any pixel would be classified as inside the target
    object. This implementation of the STAPLE algorithm automatically
    calculates prior positive classification probability as the average
    fraction of the image volume filled by the target object in each input
    segmentation. The ConfidenceWeight parameter allows for scaling the of
    this default prior probability: if g_t is the prior probability that a
    pixel would be classified inside the target object, then g_t is set to
    g_t * ConfidenceWeight before iterating on the solution. In general
    ConfidenceWeight should be left to the default of 1.0.

    You must provide a foreground value using SetForegroundValue that the
    STAPLE algorithm will use to identify positively classified pixels in
    the input images. All other values in the image will be treated as
    background values. For example, if your input segmentations consist of
    1's everywhere inside the segmented region, then use
    SetForegroundValue(1).

    The STAPLE algorithm is an iterative E-M algorithm and will converge
    on a solution after some number of iterations that cannot be known a
    priori. After updating the filter, the total elapsed iterations taken
    to converge on the solution can be queried through GetElapsedIterations() . You may also specify a MaximumNumberOfIterations, after which the
    algorithm will stop iterating regardless of whether or not it has
    converged. This implementation of the STAPLE algorithm will find the
    solution to within seven digits of precision unless it is stopped
    early.

    Once updated, the Sensitivity (true positive fraction, q) and
    Specificity (true negative fraction, q) for each expert input volume
    can be queried using GetSensitivity(i) and GetSpecificity(i), where i
    is the i-th input volume.

    REQUIRED PARAMETERS
    The only required parameters for this filter are the ForegroundValue
    and the input volumes. All other parameters may be safely left to
    their default values. Please see the paper cited above for more
    information on the STAPLE algorithm and its parameters. A proper
    understanding of the algorithm is important for interpreting the
    results that it produces.
    EVENTS
    This filter invokes IterationEvent() at each iteration of the E-M
    algorithm. Setting the AbortGenerateData() flag will cause the
    algorithm to halt after the current iteration and produce results just
    as if it had converged. The algorithm makes no attempt to report its
    progress since the number of iterations needed cannot be known in
    advance.

    See:
     itk::simple::STAPLE for the procedural interface


    C++ includes: sitkSTAPLEImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_STAPLEImageFilter

    def __init__(self):
        r"""
        __init__(STAPLEImageFilter self) -> STAPLEImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.STAPLEImageFilter_swiginit(
            self, _SimpleITK.new_STAPLEImageFilter()
        )

    def SetConfidenceWeight(self, ConfidenceWeight):
        r"""
        SetConfidenceWeight(STAPLEImageFilter self, double ConfidenceWeight)


        Scales the estimated prior probability that a pixel will be inside the
        targeted object of segmentation. The default prior probability g_t is
        calculated automatically as the average fraction of positively
        classified pixels to the total size of the volume (across all input
        volumes). ConfidenceWeight will scale this default value as g_t = g_t
        * ConfidenceWeight. In general, ConfidenceWeight should be left to the
        default of 1.0.


        """
        return _SimpleITK.STAPLEImageFilter_SetConfidenceWeight(
            self, ConfidenceWeight
        )

    def GetConfidenceWeight(self):
        r"""
        GetConfidenceWeight(STAPLEImageFilter self) -> double


        Scales the estimated prior probability that a pixel will be inside the
        targeted object of segmentation. The default prior probability g_t is
        calculated automatically as the average fraction of positively
        classified pixels to the total size of the volume (across all input
        volumes). ConfidenceWeight will scale this default value as g_t = g_t
        * ConfidenceWeight. In general, ConfidenceWeight should be left to the
        default of 1.0.


        """
        return _SimpleITK.STAPLEImageFilter_GetConfidenceWeight(self)

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(STAPLEImageFilter self, double ForegroundValue)


        Set get the binary ON value of the input image.


        """
        return _SimpleITK.STAPLEImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(STAPLEImageFilter self) -> double


        Set get the binary ON value of the input image.


        """
        return _SimpleITK.STAPLEImageFilter_GetForegroundValue(self)

    def SetMaximumIterations(self, MaximumIterations):
        r"""
        SetMaximumIterations(STAPLEImageFilter self, unsigned int MaximumIterations)


        Set/Get the maximum number of iterations after which the STAPLE
        algorithm will be considered to have converged. In general this SHOULD
        NOT be set and the algorithm should be allowed to converge on its own.


        """
        return _SimpleITK.STAPLEImageFilter_SetMaximumIterations(
            self, MaximumIterations
        )

    def GetMaximumIterations(self):
        r"""
        GetMaximumIterations(STAPLEImageFilter self) -> unsigned int


        Set/Get the maximum number of iterations after which the STAPLE
        algorithm will be considered to have converged. In general this SHOULD
        NOT be set and the algorithm should be allowed to converge on its own.


        """
        return _SimpleITK.STAPLEImageFilter_GetMaximumIterations(self)

    def GetElapsedIterations(self):
        r"""
        GetElapsedIterations(STAPLEImageFilter self) -> uint32_t


        Get the number of elapsed iterations of the iterative E-M algorithm.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.STAPLEImageFilter_GetElapsedIterations(self)

    def GetSensitivity(self):
        r"""
        GetSensitivity(STAPLEImageFilter self) -> VectorDouble


        After the filter is updated, this method returns a std::vector<double>
        of all Sensitivity (true positive fraction, p) values for the expert
        input volumes.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.STAPLEImageFilter_GetSensitivity(self)

    def GetSpecificity(self):
        r"""
        GetSpecificity(STAPLEImageFilter self) -> VectorDouble


        After the filter is updated, this method returns the Specificity (true
        negative fraction, q) value for the i-th expert input volume.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.STAPLEImageFilter_GetSpecificity(self)

    def GetName(self):
        r"""
        GetName(STAPLEImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.STAPLEImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(STAPLEImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.STAPLEImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(STAPLEImageFilter self, VectorOfImage images) -> Image
        Execute(STAPLEImageFilter self, Image image1) -> Image
        Execute(STAPLEImageFilter self, Image image1, Image image2) -> Image
        Execute(STAPLEImageFilter self, Image image1, Image image2, Image image3) -> Image
        Execute(STAPLEImageFilter self, Image image1, Image image2, Image image3, Image image4) -> Image
        Execute(STAPLEImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5) -> Image


        Execute the filter on the input images


        """
        return _SimpleITK.STAPLEImageFilter_Execute(self, *args)


# Register STAPLEImageFilter in _SimpleITK:
_SimpleITK.STAPLEImageFilter_swigregister(STAPLEImageFilter)


def STAPLE(*args):
    r"""
    STAPLE(VectorOfImage images, double confidenceWeight=1.0, double foregroundValue=1.0, unsigned int maximumIterations=std::numeric_limits< unsigned int >::max()) -> Image
    STAPLE(Image image1, double confidenceWeight=1.0, double foregroundValue=1.0, unsigned int maximumIterations=std::numeric_limits< unsigned int >::max()) -> Image
    STAPLE(Image image1, Image image2, double confidenceWeight=1.0, double foregroundValue=1.0, unsigned int maximumIterations=std::numeric_limits< unsigned int >::max()) -> Image
    STAPLE(Image image1, Image image2, Image image3, double confidenceWeight=1.0, double foregroundValue=1.0, unsigned int maximumIterations=std::numeric_limits< unsigned int >::max()) -> Image
    STAPLE(Image image1, Image image2, Image image3, Image image4, double confidenceWeight=1.0, double foregroundValue=1.0, unsigned int maximumIterations=std::numeric_limits< unsigned int >::max()) -> Image
    STAPLE(Image image1, Image image2, Image image3, Image image4, Image image5, double confidenceWeight=1.0, double foregroundValue=1.0, unsigned int maximumIterations=std::numeric_limits< unsigned int >::max()) -> Image
    """
    return _SimpleITK.STAPLE(*args)


class SaltAndPepperNoiseImageFilter(ImageFilter):
    r"""


    Alter an image with fixed value impulse noise, often called salt and
    pepper noise.


    Salt (sensor saturation) and pepper (dead pixels) noise is a special
    kind of impulse noise where the value of the noise is either the
    maximum possible value in the image or its minimum. This is not
    necessarily the maximal/minimal possible intensity value based on the
    pixel type. For example, the native pixel type for CT is a signed 16
    bit integer, but only 12 bits used, so we would like to set the salt
    and pepper values to match this smaller intensity range and not the
    range the pixel type represents. It can be modeled as:


    $ I = \\begin{cases} M, & \\quad \\text{if } U < p/2 \\\\ m,
    & \\quad \\text{if } U > 1 - p/2 \\\\ I_0, & \\quad
    \\text{if } p/2 \\geq U \\leq 1 - p/2 \\end{cases} $

    where $ p $ is the probability of the noise event, $ U $ is a uniformly distributed random variable in the $ [0,1] $ range, $ M $ is the greatest possible pixel value, and $ m $ the smallest possible pixel value.
     Pixel alteration occurs at a user defined probability. Salt and
    pepper pixels are equally distributed.


    Gaetan Lehmann
     This code was contributed in the Insight Journal paper "Noise
    Simulation". https://doi.org/10.54294/vh6vbw
    See:
     itk::simple::SaltAndPepperNoise for the procedural interface

     itk::SaltAndPepperNoiseImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSaltAndPepperNoiseImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_SaltAndPepperNoiseImageFilter

    def __init__(self):
        r"""
        __init__(SaltAndPepperNoiseImageFilter self) -> SaltAndPepperNoiseImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.SaltAndPepperNoiseImageFilter_swiginit(
            self, _SimpleITK.new_SaltAndPepperNoiseImageFilter()
        )

    def SetProbability(self, Probability):
        r"""
        SetProbability(SaltAndPepperNoiseImageFilter self, double Probability)


        Set/Get the probability of the salt and pepper noise event. Defaults
        to 0.01.


        """
        return _SimpleITK.SaltAndPepperNoiseImageFilter_SetProbability(
            self, Probability
        )

    def GetProbability(self):
        r"""
        GetProbability(SaltAndPepperNoiseImageFilter self) -> double


        Set/Get the probability of the salt and pepper noise event. Defaults
        to 0.01.


        """
        return _SimpleITK.SaltAndPepperNoiseImageFilter_GetProbability(self)

    def SetSeed(self, Seed):
        r"""
        SetSeed(SaltAndPepperNoiseImageFilter self, uint32_t Seed)


        """
        return _SimpleITK.SaltAndPepperNoiseImageFilter_SetSeed(self, Seed)

    def GetSeed(self):
        r"""
        GetSeed(SaltAndPepperNoiseImageFilter self) -> uint32_t


        """
        return _SimpleITK.SaltAndPepperNoiseImageFilter_GetSeed(self)

    def GetName(self):
        r"""
        GetName(SaltAndPepperNoiseImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.SaltAndPepperNoiseImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(SaltAndPepperNoiseImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.SaltAndPepperNoiseImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(SaltAndPepperNoiseImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.SaltAndPepperNoiseImageFilter_Execute(self, image1)


# Register SaltAndPepperNoiseImageFilter in _SimpleITK:
_SimpleITK.SaltAndPepperNoiseImageFilter_swigregister(
    SaltAndPepperNoiseImageFilter
)


def SaltAndPepperNoise(*args, **kwargs):
    r"""SaltAndPepperNoise(Image image1, double probability=0.01, uint32_t seed=(uint32_t) itk::simple::sitkWallClock) -> Image"""
    return _SimpleITK.SaltAndPepperNoise(*args, **kwargs)


class ScalarChanAndVeseDenseLevelSetImageFilter(ImageFilter):
    r"""


    Dense implementation of the Chan and Vese multiphase level set image
    filter.


    This code was adapted from the paper: "An active contour model
    without edges" T. Chan and L. Vese. In Scale-Space Theories in
    Computer Vision, pages 141-151, 1999.
    Mosaliganti K., Smith B., Gelas A., Gouaillard A., Megason S.
     This code was taken from the Insight Journal paper: "Cell Tracking
    using Coupled Active Surfaces for Nuclei and Membranes" https://doi.org/10.54294/wvwmf8 That is based on the papers: "Level Set Segmentation: Active
    Contours without edge" https://doi.org/10.54294/8jk6oy

    and

    "Level set segmentation using coupled active surfaces" https://doi.org/10.54294/23ugmy
    See:
     itk::simple::ScalarChanAndVeseDenseLevelSet for the procedural interface

     itk::ScalarChanAndVeseDenseLevelSetImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkScalarChanAndVeseDenseLevelSetImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_ScalarChanAndVeseDenseLevelSetImageFilter
    )

    def __init__(self):
        r"""
        __init__(ScalarChanAndVeseDenseLevelSetImageFilter self) -> ScalarChanAndVeseDenseLevelSetImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_swiginit(
            self, _SimpleITK.new_ScalarChanAndVeseDenseLevelSetImageFilter()
        )

    def SetMaximumRMSError(self, MaximumRMSError):
        r"""
        SetMaximumRMSError(ScalarChanAndVeseDenseLevelSetImageFilter self, double MaximumRMSError)


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetMaximumRMSError(
            self, MaximumRMSError
        )

    def GetMaximumRMSError(self):
        r"""
        GetMaximumRMSError(ScalarChanAndVeseDenseLevelSetImageFilter self) -> double


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetMaximumRMSError(
            self
        )

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(ScalarChanAndVeseDenseLevelSetImageFilter self, uint32_t NumberOfIterations)


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(ScalarChanAndVeseDenseLevelSetImageFilter self) -> uint32_t


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetNumberOfIterations(
            self
        )

    def SetLambda1(self, Lambda1):
        r"""
        SetLambda1(ScalarChanAndVeseDenseLevelSetImageFilter self, double Lambda1)


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetLambda1(
            self, Lambda1
        )

    def GetLambda1(self):
        r"""
        GetLambda1(ScalarChanAndVeseDenseLevelSetImageFilter self) -> double


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetLambda1(
            self
        )

    def SetLambda2(self, Lambda2):
        r"""
        SetLambda2(ScalarChanAndVeseDenseLevelSetImageFilter self, double Lambda2)


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetLambda2(
            self, Lambda2
        )

    def GetLambda2(self):
        r"""
        GetLambda2(ScalarChanAndVeseDenseLevelSetImageFilter self) -> double


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetLambda2(
            self
        )

    def SetEpsilon(self, Epsilon):
        r"""
        SetEpsilon(ScalarChanAndVeseDenseLevelSetImageFilter self, double Epsilon)


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetEpsilon(
            self, Epsilon
        )

    def GetEpsilon(self):
        r"""
        GetEpsilon(ScalarChanAndVeseDenseLevelSetImageFilter self) -> double


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetEpsilon(
            self
        )

    def SetCurvatureWeight(self, CurvatureWeight):
        r"""
        SetCurvatureWeight(ScalarChanAndVeseDenseLevelSetImageFilter self, double CurvatureWeight)


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetCurvatureWeight(
            self, CurvatureWeight
        )

    def GetCurvatureWeight(self):
        r"""
        GetCurvatureWeight(ScalarChanAndVeseDenseLevelSetImageFilter self) -> double


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetCurvatureWeight(
            self
        )

    def SetAreaWeight(self, AreaWeight):
        r"""
        SetAreaWeight(ScalarChanAndVeseDenseLevelSetImageFilter self, double AreaWeight)


        """
        return (
            _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetAreaWeight(
                self, AreaWeight
            )
        )

    def GetAreaWeight(self):
        r"""
        GetAreaWeight(ScalarChanAndVeseDenseLevelSetImageFilter self) -> double


        """
        return (
            _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetAreaWeight(
                self
            )
        )

    def SetReinitializationSmoothingWeight(
        self, ReinitializationSmoothingWeight
    ):
        r"""
        SetReinitializationSmoothingWeight(ScalarChanAndVeseDenseLevelSetImageFilter self, double ReinitializationSmoothingWeight)


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetReinitializationSmoothingWeight(
            self, ReinitializationSmoothingWeight
        )

    def GetReinitializationSmoothingWeight(self):
        r"""
        GetReinitializationSmoothingWeight(ScalarChanAndVeseDenseLevelSetImageFilter self) -> double


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetReinitializationSmoothingWeight(
            self
        )

    def SetVolume(self, Volume):
        r"""
        SetVolume(ScalarChanAndVeseDenseLevelSetImageFilter self, double Volume)


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetVolume(
            self, Volume
        )

    def GetVolume(self):
        r"""
        GetVolume(ScalarChanAndVeseDenseLevelSetImageFilter self) -> double


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetVolume(
            self
        )

    def SetVolumeMatchingWeight(self, VolumeMatchingWeight):
        r"""
        SetVolumeMatchingWeight(ScalarChanAndVeseDenseLevelSetImageFilter self, double VolumeMatchingWeight)


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetVolumeMatchingWeight(
            self, VolumeMatchingWeight
        )

    def GetVolumeMatchingWeight(self):
        r"""
        GetVolumeMatchingWeight(ScalarChanAndVeseDenseLevelSetImageFilter self) -> double


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetVolumeMatchingWeight(
            self
        )

    AtanRegularizedHeaviside = _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_AtanRegularizedHeaviside

    SinRegularizedHeaviside = _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SinRegularizedHeaviside

    Heaviside = _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_Heaviside

    def SetHeavisideStepFunction(self, HeavisideStepFunction):
        r"""
        SetHeavisideStepFunction(ScalarChanAndVeseDenseLevelSetImageFilter self, itk::simple::ScalarChanAndVeseDenseLevelSetImageFilter::HeavisideStepFunctionType HeavisideStepFunction)


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetHeavisideStepFunction(
            self, HeavisideStepFunction
        )

    def GetHeavisideStepFunction(self):
        r"""
        GetHeavisideStepFunction(ScalarChanAndVeseDenseLevelSetImageFilter self) -> itk::simple::ScalarChanAndVeseDenseLevelSetImageFilter::HeavisideStepFunctionType


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetHeavisideStepFunction(
            self
        )

    def SetUseImageSpacing(self, UseImageSpacing):
        r"""
        SetUseImageSpacing(ScalarChanAndVeseDenseLevelSetImageFilter self, bool UseImageSpacing)


        Use the image spacing information in calculations. Use this option if
        you want derivatives in physical space. Default is UseImageSpacingOn.


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetUseImageSpacing(
            self, UseImageSpacing
        )

    def UseImageSpacingOn(self):
        r"""
        UseImageSpacingOn(ScalarChanAndVeseDenseLevelSetImageFilter self)


        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_UseImageSpacingOn(
            self
        )

    def UseImageSpacingOff(self):
        r"""
        UseImageSpacingOff(ScalarChanAndVeseDenseLevelSetImageFilter self)


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_UseImageSpacingOff(
            self
        )

    def GetUseImageSpacing(self):
        r"""
        GetUseImageSpacing(ScalarChanAndVeseDenseLevelSetImageFilter self) -> bool


        Use the image spacing information in calculations. Use this option if
        you want derivatives in physical space. Default is UseImageSpacingOn.


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetUseImageSpacing(
            self
        )

    def GetElapsedIterations(self):
        r"""
        GetElapsedIterations(ScalarChanAndVeseDenseLevelSetImageFilter self) -> uint32_t


        Number of iterations run.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetElapsedIterations(
            self
        )

    def GetRMSChange(self):
        r"""
        GetRMSChange(ScalarChanAndVeseDenseLevelSetImageFilter self) -> double


        The Root Mean Square of the levelset upon termination.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return (
            _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetRMSChange(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(ScalarChanAndVeseDenseLevelSetImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(ScalarChanAndVeseDenseLevelSetImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter___str__(
            self
        )

    def Execute(self, initialImage, featureImage):
        r"""
        Execute(ScalarChanAndVeseDenseLevelSetImageFilter self, Image initialImage, Image featureImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_Execute(
            self, initialImage, featureImage
        )


# Register ScalarChanAndVeseDenseLevelSetImageFilter in _SimpleITK:
_SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_swigregister(
    ScalarChanAndVeseDenseLevelSetImageFilter
)


def ScalarChanAndVeseDenseLevelSet(*args, **kwargs):
    r"""ScalarChanAndVeseDenseLevelSet(Image initialImage, Image featureImage, double maximumRMSError=0.02, uint32_t numberOfIterations=1000, double lambda1=1.0, double lambda2=1.0, double epsilon=1.0, double curvatureWeight=1.0, double areaWeight=0.0, double reinitializationSmoothingWeight=0.0, double volume=0.0, double volumeMatchingWeight=0.0, itk::simple::ScalarChanAndVeseDenseLevelSetImageFilter::HeavisideStepFunctionType heavisideStepFunction=AtanRegularizedHeaviside, bool useImageSpacing=True) -> Image"""
    return _SimpleITK.ScalarChanAndVeseDenseLevelSet(*args, **kwargs)


class ScalarConnectedComponentImageFilter(ImageFilter):
    r"""


    A connected components filter that labels the objects in an arbitrary
    image. Two pixels are similar if they are within threshold of each
    other. Uses ConnectedComponentFunctorImageFilter .



    See:
     itk::simple::ScalarConnectedComponent for the procedural interface

     itk::ScalarConnectedComponentImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkScalarConnectedComponentImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ScalarConnectedComponentImageFilter

    def __init__(self):
        r"""
        __init__(ScalarConnectedComponentImageFilter self) -> ScalarConnectedComponentImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ScalarConnectedComponentImageFilter_swiginit(
            self, _SimpleITK.new_ScalarConnectedComponentImageFilter()
        )

    def SetDistanceThreshold(self, DistanceThreshold):
        r"""
        SetDistanceThreshold(ScalarConnectedComponentImageFilter self, double DistanceThreshold)


        """
        return _SimpleITK.ScalarConnectedComponentImageFilter_SetDistanceThreshold(
            self, DistanceThreshold
        )

    def GetDistanceThreshold(self):
        r"""
        GetDistanceThreshold(ScalarConnectedComponentImageFilter self) -> double


        """
        return _SimpleITK.ScalarConnectedComponentImageFilter_GetDistanceThreshold(
            self
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(ScalarConnectedComponentImageFilter self, bool FullyConnected)


        """
        return (
            _SimpleITK.ScalarConnectedComponentImageFilter_SetFullyConnected(
                self, FullyConnected
            )
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(ScalarConnectedComponentImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.ScalarConnectedComponentImageFilter_FullyConnectedOn(
            self
        )

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(ScalarConnectedComponentImageFilter self)


        """
        return (
            _SimpleITK.ScalarConnectedComponentImageFilter_FullyConnectedOff(
                self
            )
        )

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(ScalarConnectedComponentImageFilter self) -> bool


        """
        return (
            _SimpleITK.ScalarConnectedComponentImageFilter_GetFullyConnected(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(ScalarConnectedComponentImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ScalarConnectedComponentImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ScalarConnectedComponentImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ScalarConnectedComponentImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(ScalarConnectedComponentImageFilter self, Image image, Image maskImage) -> Image
        Execute(ScalarConnectedComponentImageFilter self, Image image) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ScalarConnectedComponentImageFilter_Execute(
            self, *args
        )


# Register ScalarConnectedComponentImageFilter in _SimpleITK:
_SimpleITK.ScalarConnectedComponentImageFilter_swigregister(
    ScalarConnectedComponentImageFilter
)


def ScalarConnectedComponent(*args):
    r"""
    ScalarConnectedComponent(Image image, Image maskImage, double distanceThreshold=0.0, bool fullyConnected=False) -> Image
    ScalarConnectedComponent(Image image, double distanceThreshold=0.0, bool fullyConnected=False) -> Image
    """
    return _SimpleITK.ScalarConnectedComponent(*args)


class ScalarImageKmeansImageFilter(ImageFilter):
    r"""


    Classifies the intensity values of a scalar image using the K-Means
    algorithm.


    Given an input image with scalar values, it uses the K-Means
    statistical classifier in order to define labels for every pixel in
    the image. The filter is templated over the type of the input image.
    The output image is predefined as having the same dimension of the
    input image and pixel type unsigned char, under the assumption that
    the classifier will generate less than 256 classes.

    You may want to look also at the RelabelImageFilter that may be used
    as a postprocessing stage, in particular if you are interested in
    ordering the labels by their relative size in number of pixels.


    See:
     Image

     ImageKmeansModelEstimator

     KdTreeBasedKmeansEstimator, WeightedCentroidKdTreeGenerator, KdTree

     RelabelImageFilter

     itk::simple::ScalarImageKmeans for the procedural interface

     itk::ScalarImageKmeansImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkScalarImageKmeansImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ScalarImageKmeansImageFilter

    def __init__(self):
        r"""
        __init__(ScalarImageKmeansImageFilter self) -> ScalarImageKmeansImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ScalarImageKmeansImageFilter_swiginit(
            self, _SimpleITK.new_ScalarImageKmeansImageFilter()
        )

    def SetClassWithInitialMean(self, ClassWithInitialMean):
        r"""
        SetClassWithInitialMean(ScalarImageKmeansImageFilter self, VectorDouble ClassWithInitialMean)


        """
        return _SimpleITK.ScalarImageKmeansImageFilter_SetClassWithInitialMean(
            self, ClassWithInitialMean
        )

    def GetClassWithInitialMean(self):
        r"""
        GetClassWithInitialMean(ScalarImageKmeansImageFilter self) -> VectorDouble


        """
        return _SimpleITK.ScalarImageKmeansImageFilter_GetClassWithInitialMean(
            self
        )

    def SetUseNonContiguousLabels(self, UseNonContiguousLabels):
        r"""
        SetUseNonContiguousLabels(ScalarImageKmeansImageFilter self, bool UseNonContiguousLabels)


        Set/Get the UseNonContiguousLabels flag. When this is set to false the
        labels are numbered contiguously, like in {0,1,3..N}. When the flag is
        set to true, the labels are selected in order to span the dynamic
        range of the output image. This last option is useful when the output
        image is intended only for display. The default value is false.


        """
        return (
            _SimpleITK.ScalarImageKmeansImageFilter_SetUseNonContiguousLabels(
                self, UseNonContiguousLabels
            )
        )

    def UseNonContiguousLabelsOn(self):
        r"""
        UseNonContiguousLabelsOn(ScalarImageKmeansImageFilter self)


        Set the value of UseNonContiguousLabels to true or false respectfully.


        """
        return (
            _SimpleITK.ScalarImageKmeansImageFilter_UseNonContiguousLabelsOn(
                self
            )
        )

    def UseNonContiguousLabelsOff(self):
        r"""
        UseNonContiguousLabelsOff(ScalarImageKmeansImageFilter self)


        """
        return (
            _SimpleITK.ScalarImageKmeansImageFilter_UseNonContiguousLabelsOff(
                self
            )
        )

    def GetUseNonContiguousLabels(self):
        r"""
        GetUseNonContiguousLabels(ScalarImageKmeansImageFilter self) -> bool


        Set/Get the UseNonContiguousLabels flag. When this is set to false the
        labels are numbered contiguously, like in {0,1,3..N}. When the flag is
        set to true, the labels are selected in order to span the dynamic
        range of the output image. This last option is useful when the output
        image is intended only for display. The default value is false.


        """
        return (
            _SimpleITK.ScalarImageKmeansImageFilter_GetUseNonContiguousLabels(
                self
            )
        )

    def GetFinalMeans(self):
        r"""
        GetFinalMeans(ScalarImageKmeansImageFilter self) -> VectorDouble


        Return the array of Means found after the classification.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ScalarImageKmeansImageFilter_GetFinalMeans(self)

    def GetName(self):
        r"""
        GetName(ScalarImageKmeansImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ScalarImageKmeansImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ScalarImageKmeansImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ScalarImageKmeansImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ScalarImageKmeansImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ScalarImageKmeansImageFilter_Execute(self, image1)


# Register ScalarImageKmeansImageFilter in _SimpleITK:
_SimpleITK.ScalarImageKmeansImageFilter_swigregister(
    ScalarImageKmeansImageFilter
)


def ScalarImageKmeans(*args, **kwargs):
    r"""ScalarImageKmeans(Image image1, VectorDouble classWithInitialMean=std::vector< double >(), bool useNonContiguousLabels=False) -> Image"""
    return _SimpleITK.ScalarImageKmeans(*args, **kwargs)


class ScalarToRGBColormapImageFilter(ImageFilter):
    r"""


    Implements pixel-wise intensity->rgb mapping operation on one image.


    This class is parameterized over the type of the input image and the
    type of the output image.

    The input image's scalar pixel values are mapped into a color map. The
    color map is specified by passing the SetColormap function one of the
    predefined maps. The following selects the
    "RGBColormapFilterEnum::Hot" colormap:

    You can also specify a custom color map. This is done by creating a
    CustomColormapFunction, and then creating lists of values for the red,
    green, and blue channel. An example of setting the red channel of a
    colormap with only 2 colors is given below. The blue and green
    channels should be specified in the same manner.


    The range of values present in the input image is the range that is
    mapped to the entire range of colors.

    This code was contributed in the Insight Journal paper: "Meeting Andy
    Warhol Somewhere Over the Rainbow: RGB Colormapping and ITK" by
    Tustison N., Zhang H., Lehmann G., Yushkevich P., Gee J. https://doi.org/10.54294/tmojbk


    See:
     BinaryFunctionImageFilter TernaryFunctionImageFilter

     itk::simple::ScalarToRGBColormap for the procedural interface

     itk::ScalarToRGBColormapImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkScalarToRGBColormapImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ScalarToRGBColormapImageFilter

    def __init__(self):
        r"""
        __init__(ScalarToRGBColormapImageFilter self) -> ScalarToRGBColormapImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ScalarToRGBColormapImageFilter_swiginit(
            self, _SimpleITK.new_ScalarToRGBColormapImageFilter()
        )

    Red = _SimpleITK.ScalarToRGBColormapImageFilter_Red

    Green = _SimpleITK.ScalarToRGBColormapImageFilter_Green

    Blue = _SimpleITK.ScalarToRGBColormapImageFilter_Blue

    Grey = _SimpleITK.ScalarToRGBColormapImageFilter_Grey

    Hot = _SimpleITK.ScalarToRGBColormapImageFilter_Hot

    Cool = _SimpleITK.ScalarToRGBColormapImageFilter_Cool

    Spring = _SimpleITK.ScalarToRGBColormapImageFilter_Spring

    Summer = _SimpleITK.ScalarToRGBColormapImageFilter_Summer

    Autumn = _SimpleITK.ScalarToRGBColormapImageFilter_Autumn

    Winter = _SimpleITK.ScalarToRGBColormapImageFilter_Winter

    Copper = _SimpleITK.ScalarToRGBColormapImageFilter_Copper

    Jet = _SimpleITK.ScalarToRGBColormapImageFilter_Jet

    HSV = _SimpleITK.ScalarToRGBColormapImageFilter_HSV

    OverUnder = _SimpleITK.ScalarToRGBColormapImageFilter_OverUnder

    def SetColormap(self, Colormap):
        r"""
        SetColormap(ScalarToRGBColormapImageFilter self, itk::simple::ScalarToRGBColormapImageFilter::ColormapType Colormap)


        """
        return _SimpleITK.ScalarToRGBColormapImageFilter_SetColormap(
            self, Colormap
        )

    def GetColormap(self):
        r"""
        GetColormap(ScalarToRGBColormapImageFilter self) -> itk::simple::ScalarToRGBColormapImageFilter::ColormapType


        Set/Get the colormap object.


        """
        return _SimpleITK.ScalarToRGBColormapImageFilter_GetColormap(self)

    def SetUseInputImageExtremaForScaling(
        self, UseInputImageExtremaForScaling
    ):
        r"""
        SetUseInputImageExtremaForScaling(ScalarToRGBColormapImageFilter self, bool UseInputImageExtremaForScaling)


        Set/Get UseInputImageExtremaForScaling. If true, the colormap uses the
        min and max values from the image to scale appropriately. Otherwise,
        these values can be set in the colormap manually.


        """
        return _SimpleITK.ScalarToRGBColormapImageFilter_SetUseInputImageExtremaForScaling(
            self, UseInputImageExtremaForScaling
        )

    def UseInputImageExtremaForScalingOn(self):
        r"""
        UseInputImageExtremaForScalingOn(ScalarToRGBColormapImageFilter self)


        Set the value of UseInputImageExtremaForScaling to true or false
        respectfully.


        """
        return _SimpleITK.ScalarToRGBColormapImageFilter_UseInputImageExtremaForScalingOn(
            self
        )

    def UseInputImageExtremaForScalingOff(self):
        r"""
        UseInputImageExtremaForScalingOff(ScalarToRGBColormapImageFilter self)


        """
        return _SimpleITK.ScalarToRGBColormapImageFilter_UseInputImageExtremaForScalingOff(
            self
        )

    def GetUseInputImageExtremaForScaling(self):
        r"""
        GetUseInputImageExtremaForScaling(ScalarToRGBColormapImageFilter self) -> bool


        Set/Get UseInputImageExtremaForScaling. If true, the colormap uses the
        min and max values from the image to scale appropriately. Otherwise,
        these values can be set in the colormap manually.


        """
        return _SimpleITK.ScalarToRGBColormapImageFilter_GetUseInputImageExtremaForScaling(
            self
        )

    def GetName(self):
        r"""
        GetName(ScalarToRGBColormapImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ScalarToRGBColormapImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ScalarToRGBColormapImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ScalarToRGBColormapImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ScalarToRGBColormapImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ScalarToRGBColormapImageFilter_Execute(self, image1)


# Register ScalarToRGBColormapImageFilter in _SimpleITK:
_SimpleITK.ScalarToRGBColormapImageFilter_swigregister(
    ScalarToRGBColormapImageFilter
)


def ScalarToRGBColormap(*args, **kwargs):
    r"""ScalarToRGBColormap(Image image1, itk::simple::ScalarToRGBColormapImageFilter::ColormapType colormap=Grey, bool useInputImageExtremaForScaling=True) -> Image"""
    return _SimpleITK.ScalarToRGBColormap(*args, **kwargs)


class ShanbhagThresholdImageFilter(ImageFilter):
    r"""


    Threshold an image using the Shanbhag Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the ShanbhagThresholdCalculator and applies that threshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/efycla


    See:
     HistogramThresholdImageFilter

     itk::simple::ShanbhagThreshold for the procedural interface

     itk::ShanbhagThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkShanbhagThresholdImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ShanbhagThresholdImageFilter

    def __init__(self):
        r"""
        __init__(ShanbhagThresholdImageFilter self) -> ShanbhagThresholdImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ShanbhagThresholdImageFilter_swiginit(
            self, _SimpleITK.new_ShanbhagThresholdImageFilter()
        )

    def SetInsideValue(self, InsideValue):
        r"""
        SetInsideValue(ShanbhagThresholdImageFilter self, uint8_t InsideValue)


        Set the "inside" pixel value.


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_SetInsideValue(
            self, InsideValue
        )

    def GetInsideValue(self):
        r"""
        GetInsideValue(ShanbhagThresholdImageFilter self) -> uint8_t


        Get the "inside" pixel value.


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_GetInsideValue(self)

    def SetOutsideValue(self, OutsideValue):
        r"""
        SetOutsideValue(ShanbhagThresholdImageFilter self, uint8_t OutsideValue)


        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_SetOutsideValue(
            self, OutsideValue
        )

    def GetOutsideValue(self):
        r"""
        GetOutsideValue(ShanbhagThresholdImageFilter self) -> uint8_t


        Get the "outside" pixel value.


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_GetOutsideValue(self)

    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        r"""
        SetNumberOfHistogramBins(ShanbhagThresholdImageFilter self, uint32_t NumberOfHistogramBins)


        Set/Get the number of histogram bins.


        """
        return (
            _SimpleITK.ShanbhagThresholdImageFilter_SetNumberOfHistogramBins(
                self, NumberOfHistogramBins
            )
        )

    def GetNumberOfHistogramBins(self):
        r"""
        GetNumberOfHistogramBins(ShanbhagThresholdImageFilter self) -> uint32_t


        """
        return (
            _SimpleITK.ShanbhagThresholdImageFilter_GetNumberOfHistogramBins(
                self
            )
        )

    def SetMaskOutput(self, MaskOutput):
        r"""
        SetMaskOutput(ShanbhagThresholdImageFilter self, bool MaskOutput)


        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_SetMaskOutput(
            self, MaskOutput
        )

    def MaskOutputOn(self):
        r"""
        MaskOutputOn(ShanbhagThresholdImageFilter self)


        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_MaskOutputOn(self)

    def MaskOutputOff(self):
        r"""
        MaskOutputOff(ShanbhagThresholdImageFilter self)


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_MaskOutputOff(self)

    def GetMaskOutput(self):
        r"""
        GetMaskOutput(ShanbhagThresholdImageFilter self) -> bool


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_GetMaskOutput(self)

    def SetMaskValue(self, MaskValue):
        r"""
        SetMaskValue(ShanbhagThresholdImageFilter self, uint8_t MaskValue)


        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_SetMaskValue(
            self, MaskValue
        )

    def GetMaskValue(self):
        r"""
        GetMaskValue(ShanbhagThresholdImageFilter self) -> uint8_t


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_GetMaskValue(self)

    def GetThreshold(self):
        r"""
        GetThreshold(ShanbhagThresholdImageFilter self) -> double


        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_GetThreshold(self)

    def GetName(self):
        r"""
        GetName(ShanbhagThresholdImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ShanbhagThresholdImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ShanbhagThresholdImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(ShanbhagThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(ShanbhagThresholdImageFilter self, Image image) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_Execute(self, *args)


# Register ShanbhagThresholdImageFilter in _SimpleITK:
_SimpleITK.ShanbhagThresholdImageFilter_swigregister(
    ShanbhagThresholdImageFilter
)


def ShanbhagThreshold(*args):
    r"""
    ShanbhagThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    ShanbhagThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    """
    return _SimpleITK.ShanbhagThreshold(*args)


class ShapeDetectionLevelSetImageFilter(ImageFilter):
    r"""


    Segments structures in images based on a user supplied edge potential
    map.


    IMPORTANT
    The SegmentationLevelSetImageFilter class and the ShapeDetectionLevelSetFunction class contain additional information necessary to gain full
    understanding of how to use this filter.
    OVERVIEW
    This class is a level set method segmentation filter. An initial
    contour is propagated outwards (or inwards) until it ''sticks'' to the
    shape boundaries. This is done by using a level set speed function
    based on a user supplied edge potential map. This approach for
    segmentation follows that of Malladi et al (1995).
    INPUTS
    This filter requires two inputs. The first input is a initial level
    set. The initial level set is a real image which contains the initial
    contour/surface as the zero level set. For example, a signed distance
    function from the initial contour/surface is typically used. Note that
    for this algorithm the initial contour has to be wholly within (or
    wholly outside) the structure to be segmented.

    The second input is the feature image. For this filter, this is the
    edge potential map. General characteristics of an edge potential map
    is that it has values close to zero in regions near the edges and
    values close to one inside the shape itself. Typically, the edge
    potential map is compute from the image gradient, for example:
    \\[ g(I) = 1 / ( 1 + | (\\nabla * G)(I)| ) \\] \\[ g(I) = \\exp^{-|(\\nabla * G)(I)|} \\]

    where $ I $ is image intensity and $ (\\nabla * G) $ is the derivative of Gaussian operator.


    See SegmentationLevelSetImageFilter and SparseFieldLevelSetImageFilter for more information on Inputs.
    PARAMETERS
    The PropagationScaling parameter can be used to switch from
    propagation outwards (POSITIVE scaling parameter) versus propagating
    inwards (NEGATIVE scaling parameter).
     The smoothness of the resulting contour/surface can be adjusted using
    a combination of PropagationScaling and CurvatureScaling parameters.
    The larger the CurvatureScaling parameter, the smoother the resulting
    contour. The CurvatureScaling parameter should be non-negative for
    proper operation of this algorithm. To follow the implementation in
    Malladi et al paper, set the PropagationScaling to $\\pm 1.0$ and CurvatureScaling to $ \\epsilon $ .

    Note that there is no advection term for this filter. Setting the
    advection scaling will have no effect.

    OUTPUTS
    The filter outputs a single, scalar, real-valued image. Negative
    values in the output image represent the inside of the segmented
    region and positive values in the image represent the outside of the
    segmented region. The zero crossings of the image correspond to the
    position of the propagating front.

    See SparseFieldLevelSetImageFilter and SegmentationLevelSetImageFilter for more information.
    REFERENCES

    "Shape Modeling with Front Propagation: A Level Set Approach", R.
    Malladi, J. A. Sethian and B. C. Vermuri. IEEE Trans. on Pattern
    Analysis and Machine Intelligence, Vol 17, No. 2, pp 158-174, February
    1995

    See:
     SegmentationLevelSetImageFilter

     ShapeDetectionLevelSetFunction

     SparseFieldLevelSetImageFilter

     itk::simple::ShapeDetectionLevelSet for the procedural interface

     itk::ShapeDetectionLevelSetImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkShapeDetectionLevelSetImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ShapeDetectionLevelSetImageFilter

    def __init__(self):
        r"""
        __init__(ShapeDetectionLevelSetImageFilter self) -> ShapeDetectionLevelSetImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ShapeDetectionLevelSetImageFilter_swiginit(
            self, _SimpleITK.new_ShapeDetectionLevelSetImageFilter()
        )

    def SetMaximumRMSError(self, MaximumRMSError):
        r"""
        SetMaximumRMSError(ShapeDetectionLevelSetImageFilter self, double MaximumRMSError)


        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_SetMaximumRMSError(
            self, MaximumRMSError
        )

    def GetMaximumRMSError(self):
        r"""
        GetMaximumRMSError(ShapeDetectionLevelSetImageFilter self) -> double


        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_GetMaximumRMSError(
            self
        )

    def SetPropagationScaling(self, PropagationScaling):
        r"""
        SetPropagationScaling(ShapeDetectionLevelSetImageFilter self, double PropagationScaling)


        """
        return (
            _SimpleITK.ShapeDetectionLevelSetImageFilter_SetPropagationScaling(
                self, PropagationScaling
            )
        )

    def GetPropagationScaling(self):
        r"""
        GetPropagationScaling(ShapeDetectionLevelSetImageFilter self) -> double


        """
        return (
            _SimpleITK.ShapeDetectionLevelSetImageFilter_GetPropagationScaling(
                self
            )
        )

    def SetCurvatureScaling(self, CurvatureScaling):
        r"""
        SetCurvatureScaling(ShapeDetectionLevelSetImageFilter self, double CurvatureScaling)


        """
        return (
            _SimpleITK.ShapeDetectionLevelSetImageFilter_SetCurvatureScaling(
                self, CurvatureScaling
            )
        )

    def GetCurvatureScaling(self):
        r"""
        GetCurvatureScaling(ShapeDetectionLevelSetImageFilter self) -> double


        """
        return (
            _SimpleITK.ShapeDetectionLevelSetImageFilter_GetCurvatureScaling(
                self
            )
        )

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(ShapeDetectionLevelSetImageFilter self, uint32_t NumberOfIterations)


        """
        return (
            _SimpleITK.ShapeDetectionLevelSetImageFilter_SetNumberOfIterations(
                self, NumberOfIterations
            )
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(ShapeDetectionLevelSetImageFilter self) -> uint32_t


        """
        return (
            _SimpleITK.ShapeDetectionLevelSetImageFilter_GetNumberOfIterations(
                self
            )
        )

    def SetReverseExpansionDirection(self, ReverseExpansionDirection):
        r"""
        SetReverseExpansionDirection(ShapeDetectionLevelSetImageFilter self, bool ReverseExpansionDirection)


        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_SetReverseExpansionDirection(
            self, ReverseExpansionDirection
        )

    def ReverseExpansionDirectionOn(self):
        r"""
        ReverseExpansionDirectionOn(ShapeDetectionLevelSetImageFilter self)


        Set the value of ReverseExpansionDirection to true or false
        respectfully.


        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_ReverseExpansionDirectionOn(
            self
        )

    def ReverseExpansionDirectionOff(self):
        r"""
        ReverseExpansionDirectionOff(ShapeDetectionLevelSetImageFilter self)


        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_ReverseExpansionDirectionOff(
            self
        )

    def GetReverseExpansionDirection(self):
        r"""
        GetReverseExpansionDirection(ShapeDetectionLevelSetImageFilter self) -> bool


        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_GetReverseExpansionDirection(
            self
        )

    def GetElapsedIterations(self):
        r"""
        GetElapsedIterations(ShapeDetectionLevelSetImageFilter self) -> uint32_t


        Number of iterations run.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return (
            _SimpleITK.ShapeDetectionLevelSetImageFilter_GetElapsedIterations(
                self
            )
        )

    def GetRMSChange(self):
        r"""
        GetRMSChange(ShapeDetectionLevelSetImageFilter self) -> double


        The Root Mean Square of the levelset upon termination.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_GetRMSChange(self)

    def GetName(self):
        r"""
        GetName(ShapeDetectionLevelSetImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ShapeDetectionLevelSetImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter___str__(self)

    def Execute(self, initialImage, featureImage):
        r"""
        Execute(ShapeDetectionLevelSetImageFilter self, Image initialImage, Image featureImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_Execute(
            self, initialImage, featureImage
        )


# Register ShapeDetectionLevelSetImageFilter in _SimpleITK:
_SimpleITK.ShapeDetectionLevelSetImageFilter_swigregister(
    ShapeDetectionLevelSetImageFilter
)


def ShapeDetectionLevelSet(
    initialImage,
    featureImage,
    maximumRMSError=0.02,
    propagationScaling=1.0,
    curvatureScaling=1.0,
    numberOfIterations=1000,
    reverseExpansionDirection=False,
):
    r"""ShapeDetectionLevelSet(Image initialImage, Image featureImage, double maximumRMSError=0.02, double propagationScaling=1.0, double curvatureScaling=1.0, uint32_t numberOfIterations=1000, bool reverseExpansionDirection=False) -> Image"""
    return _SimpleITK.ShapeDetectionLevelSet(
        initialImage,
        featureImage,
        maximumRMSError,
        propagationScaling,
        curvatureScaling,
        numberOfIterations,
        reverseExpansionDirection,
    )


class ShiftScaleImageFilter(ImageFilter):
    r"""


    Shift and scale the pixels in an image.


    ShiftScaleImageFilter shifts the input pixel by Shift (default 0.0) and then scales the
    pixel by Scale (default 1.0). All computations are performed in the
    precision of the input pixel's RealType. Before assigning the computed
    value to the output pixel, the value is clamped at the NonpositiveMin
    and max of the pixel type.
    See:
     itk::simple::ShiftScale for the procedural interface

     itk::ShiftScaleImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkShiftScaleImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ShiftScaleImageFilter

    def __init__(self):
        r"""
        __init__(ShiftScaleImageFilter self) -> ShiftScaleImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ShiftScaleImageFilter_swiginit(
            self, _SimpleITK.new_ShiftScaleImageFilter()
        )

    def SetShift(self, Shift):
        r"""
        SetShift(ShiftScaleImageFilter self, double Shift)


        Set/Get the amount to Shift each Pixel. The shift is followed by a
        Scale.


        """
        return _SimpleITK.ShiftScaleImageFilter_SetShift(self, Shift)

    def GetShift(self):
        r"""
        GetShift(ShiftScaleImageFilter self) -> double


        Set/Get the amount to Shift each Pixel. The shift is followed by a
        Scale.


        """
        return _SimpleITK.ShiftScaleImageFilter_GetShift(self)

    def SetScale(self, Scale):
        r"""
        SetScale(ShiftScaleImageFilter self, double Scale)


        Set/Get the amount to Scale each Pixel. The Scale is applied after the
        Shift.


        """
        return _SimpleITK.ShiftScaleImageFilter_SetScale(self, Scale)

    def GetScale(self):
        r"""
        GetScale(ShiftScaleImageFilter self) -> double


        Set/Get the amount to Scale each Pixel. The Scale is applied after the
        Shift.


        """
        return _SimpleITK.ShiftScaleImageFilter_GetScale(self)

    def SetOutputPixelType(self, OutputPixelType):
        r"""
        SetOutputPixelType(ShiftScaleImageFilter self, itk::simple::PixelIDValueEnum OutputPixelType)


        Set the output pixel type, if sitkUnknown then the input type is used.


        """
        return _SimpleITK.ShiftScaleImageFilter_SetOutputPixelType(
            self, OutputPixelType
        )

    def GetOutputPixelType(self):
        r"""
        GetOutputPixelType(ShiftScaleImageFilter self) -> itk::simple::PixelIDValueEnum


        Get the output pixel type.


        """
        return _SimpleITK.ShiftScaleImageFilter_GetOutputPixelType(self)

    def GetUnderflowCount(self):
        r"""
        GetUnderflowCount(ShiftScaleImageFilter self) -> int64_t


        Get the number of pixels that underflowed and overflowed.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ShiftScaleImageFilter_GetUnderflowCount(self)

    def GetOverflowCount(self):
        r"""
        GetOverflowCount(ShiftScaleImageFilter self) -> int64_t


        Get the number of pixels that underflowed and overflowed.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ShiftScaleImageFilter_GetOverflowCount(self)

    def GetName(self):
        r"""
        GetName(ShiftScaleImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ShiftScaleImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ShiftScaleImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ShiftScaleImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ShiftScaleImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ShiftScaleImageFilter_Execute(self, image1)


# Register ShiftScaleImageFilter in _SimpleITK:
_SimpleITK.ShiftScaleImageFilter_swigregister(ShiftScaleImageFilter)


def ShiftScale(*args, **kwargs):
    r"""ShiftScale(Image image1, double shift=0, double scale=1.0, itk::simple::PixelIDValueEnum outputPixelType=sitkUnknown) -> Image"""
    return _SimpleITK.ShiftScale(*args, **kwargs)


class ShotNoiseImageFilter(ImageFilter):
    r"""


    Alter an image with shot noise.


    The shot noise follows a Poisson distribution:


    $ I = N(I_0) $

    where $ N(I_0) $ is a Poisson-distributed random variable of mean $ I_0 $ . The noise is thus dependent on the pixel intensities in the image.
     The intensities in the image can be scaled by a user provided value
    to map pixel values to the actual number of particles. The scaling can
    be seen as the inverse of the gain used during the acquisition. The
    noisy signal is then scaled back to its input intensity range:


    $ I = \\frac{N(I_0 \\times s)}{s} $

    where $ s $ is the scale factor.
     The Poisson-distributed variable $ \\lambda $ is computed by using the algorithm:


    $ \\begin{array}{l} k \\leftarrow 0 \\\\ p \\leftarrow 1
    \\\\ \\textbf{repeat} \\\\ \\left\\{ \\begin{array}{l}
    k \\leftarrow k+1 \\\\ p \\leftarrow p \\ast U()
    \\end{array} \\right. \\\\ \\textbf{until } p >
    e^{\\lambda} \\\\ \\textbf{return} (k) \\end{array} $

    where $ U() $ provides a uniformly distributed random variable in the interval $ [0,1] $ .
     This algorithm is very inefficient for large values of $ \\lambda $ , though. Fortunately, the Poisson distribution can be accurately
    approximated by a Gaussian distribution of mean and variance $ \\lambda $ when $ \\lambda $ is large enough. In this implementation, this value is considered to
    be 50. This leads to the faster algorithm:


    $ \\lambda + \\sqrt{\\lambda} \\times N()$

    where $ N() $ is a normally distributed random variable of mean 0 and variance 1.

    Gaetan Lehmann
     This code was contributed in the Insight Journal paper "Noise
    Simulation". https://doi.org/10.54294/vh6vbw
    See:
     itk::simple::ShotNoise for the procedural interface

     itk::ShotNoiseImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkShotNoiseImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ShotNoiseImageFilter

    def __init__(self):
        r"""
        __init__(ShotNoiseImageFilter self) -> ShotNoiseImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ShotNoiseImageFilter_swiginit(
            self, _SimpleITK.new_ShotNoiseImageFilter()
        )

    def SetScale(self, Scale):
        r"""
        SetScale(ShotNoiseImageFilter self, double Scale)


        Set/Get the value to map the pixel value to the actual particle
        counting. The scaling can be seen as the inverse of the gain used
        during the acquisition. The noisy signal is then scaled back to its
        input intensity range. Defaults to 1.0.


        """
        return _SimpleITK.ShotNoiseImageFilter_SetScale(self, Scale)

    def GetScale(self):
        r"""
        GetScale(ShotNoiseImageFilter self) -> double


        Set/Get the value to map the pixel value to the actual particle
        counting. The scaling can be seen as the inverse of the gain used
        during the acquisition. The noisy signal is then scaled back to its
        input intensity range. Defaults to 1.0.


        """
        return _SimpleITK.ShotNoiseImageFilter_GetScale(self)

    def SetSeed(self, Seed):
        r"""
        SetSeed(ShotNoiseImageFilter self, uint32_t Seed)


        """
        return _SimpleITK.ShotNoiseImageFilter_SetSeed(self, Seed)

    def GetSeed(self):
        r"""
        GetSeed(ShotNoiseImageFilter self) -> uint32_t


        """
        return _SimpleITK.ShotNoiseImageFilter_GetSeed(self)

    def GetName(self):
        r"""
        GetName(ShotNoiseImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ShotNoiseImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ShotNoiseImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ShotNoiseImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ShotNoiseImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ShotNoiseImageFilter_Execute(self, image1)


# Register ShotNoiseImageFilter in _SimpleITK:
_SimpleITK.ShotNoiseImageFilter_swigregister(ShotNoiseImageFilter)


def ShotNoise(*args, **kwargs):
    r"""ShotNoise(Image image1, double scale=1.0, uint32_t seed=(uint32_t) itk::simple::sitkWallClock) -> Image"""
    return _SimpleITK.ShotNoise(*args, **kwargs)


class ShrinkImageFilter(ImageFilter):
    r"""


    Reduce the size of an image by an integer factor in each dimension.


    ShrinkImageFilter reduces the size of an image by an integer factor in each dimension.
    The algorithm implemented is a simple subsample. The output image size
    in each dimension is given by:

    outputSize[j] = max( std::floor(inputSize[j]/shrinkFactor[j]), 1 );

    NOTE: The physical centers of the input and output will be the same.
    Because of this, the Origin of the output may not be the same as the
    Origin of the input. Since this filter produces an image which is a
    different resolution, origin and with different pixel spacing than its
    input image, it needs to override several of the methods defined in ProcessObject in order to properly manage the pipeline execution model. In
    particular, this filter overrides ProcessObject::GenerateInputRequestedRegion() and ProcessObject::GenerateOutputInformation() .

    This filter is implemented as a multithreaded filter. It provides a
    DynamicThreadedGenerateData() method for its implementation.
    See:
     itk::simple::Shrink for the procedural interface

     itk::ShrinkImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkShrinkImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ShrinkImageFilter

    def __init__(self):
        r"""
        __init__(ShrinkImageFilter self) -> ShrinkImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ShrinkImageFilter_swiginit(
            self, _SimpleITK.new_ShrinkImageFilter()
        )

    def SetShrinkFactor(self, s):
        r"""
        SetShrinkFactor(ShrinkImageFilter self, unsigned int s)


        Custom public declarations


        """
        return _SimpleITK.ShrinkImageFilter_SetShrinkFactor(self, s)

    def SetShrinkFactors(self, ShrinkFactors):
        r"""
        SetShrinkFactors(ShrinkImageFilter self, VectorUInt32 ShrinkFactors)


        Set the shrink factors. Values are clamped to a minimum value of 1.
        Default is 1 for all dimensions.


        """
        return _SimpleITK.ShrinkImageFilter_SetShrinkFactors(
            self, ShrinkFactors
        )

    def GetShrinkFactors(self):
        r"""
        GetShrinkFactors(ShrinkImageFilter self) -> VectorUInt32


        Get the shrink factors.


        """
        return _SimpleITK.ShrinkImageFilter_GetShrinkFactors(self)

    def GetName(self):
        r"""
        GetName(ShrinkImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ShrinkImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ShrinkImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ShrinkImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ShrinkImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ShrinkImageFilter_Execute(self, image1)


# Register ShrinkImageFilter in _SimpleITK:
_SimpleITK.ShrinkImageFilter_swigregister(ShrinkImageFilter)


def Shrink(*args, **kwargs):
    r"""Shrink(Image image1, VectorUInt32 shrinkFactors=std::vector< unsigned int >(3, 1)) -> Image"""
    return _SimpleITK.Shrink(*args, **kwargs)


class SigmoidImageFilter(ImageFilter):
    r"""


    Computes the sigmoid function pixel-wise.


    A linear transformation is applied first on the argument of the
    sigmoid function. The resulting total transform is given by

    \\[ f(x) = (Max-Min) \\cdot \\frac{1}{\\left(1+e^{- \\frac{
    x - \\beta }{\\alpha}}\\right)} + Min \\]

    Every output pixel is equal to f(x). Where x is the intensity of the
    homologous input pixel, and alpha and beta are user-provided
    constants.
    See:
     itk::simple::Sigmoid for the procedural interface

     itk::SigmoidImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSigmoidImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_SigmoidImageFilter

    def __init__(self):
        r"""
        __init__(SigmoidImageFilter self) -> SigmoidImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.SigmoidImageFilter_swiginit(
            self, _SimpleITK.new_SigmoidImageFilter()
        )

    def SetAlpha(self, Alpha):
        r"""
        SetAlpha(SigmoidImageFilter self, double Alpha)


        """
        return _SimpleITK.SigmoidImageFilter_SetAlpha(self, Alpha)

    def GetAlpha(self):
        r"""
        GetAlpha(SigmoidImageFilter self) -> double


        """
        return _SimpleITK.SigmoidImageFilter_GetAlpha(self)

    def SetBeta(self, Beta):
        r"""
        SetBeta(SigmoidImageFilter self, double Beta)


        """
        return _SimpleITK.SigmoidImageFilter_SetBeta(self, Beta)

    def GetBeta(self):
        r"""
        GetBeta(SigmoidImageFilter self) -> double


        """
        return _SimpleITK.SigmoidImageFilter_GetBeta(self)

    def SetOutputMaximum(self, OutputMaximum):
        r"""
        SetOutputMaximum(SigmoidImageFilter self, double OutputMaximum)


        """
        return _SimpleITK.SigmoidImageFilter_SetOutputMaximum(
            self, OutputMaximum
        )

    def GetOutputMaximum(self):
        r"""
        GetOutputMaximum(SigmoidImageFilter self) -> double


        """
        return _SimpleITK.SigmoidImageFilter_GetOutputMaximum(self)

    def SetOutputMinimum(self, OutputMinimum):
        r"""
        SetOutputMinimum(SigmoidImageFilter self, double OutputMinimum)


        """
        return _SimpleITK.SigmoidImageFilter_SetOutputMinimum(
            self, OutputMinimum
        )

    def GetOutputMinimum(self):
        r"""
        GetOutputMinimum(SigmoidImageFilter self) -> double


        """
        return _SimpleITK.SigmoidImageFilter_GetOutputMinimum(self)

    def GetName(self):
        r"""
        GetName(SigmoidImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.SigmoidImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(SigmoidImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.SigmoidImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(SigmoidImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.SigmoidImageFilter_Execute(self, image1)


# Register SigmoidImageFilter in _SimpleITK:
_SimpleITK.SigmoidImageFilter_swigregister(SigmoidImageFilter)


def Sigmoid(image1, alpha=1, beta=0, outputMaximum=255, outputMinimum=0):
    r"""Sigmoid(Image image1, double alpha=1, double beta=0, double outputMaximum=255, double outputMinimum=0) -> Image"""
    return _SimpleITK.Sigmoid(
        image1, alpha, beta, outputMaximum, outputMinimum
    )


class SignedDanielssonDistanceMapImageFilter(ImageFilter):
    r"""


    This filter computes the signed distance map of the input image as an
    approximation with pixel accuracy to the Euclidean distance.


    This class is parameterized over the type of the input image and the
    type of the output image.

    For purposes of evaluating the signed distance map, the input is
    assumed to be binary composed of pixels with value 0 and non-zero.

    The inside is considered as having negative distances. Outside is
    treated as having positive distances. To change the convention, use
    the InsideIsPositive(bool) function.

    As a convention, the distance is evaluated from the boundary of the ON
    pixels.

    The filter returns


    A signed distance map with the approximation to the euclidean
    distance.

    A voronoi partition. (See itkDanielssonDistanceMapImageFilter)

    A vector map containing the component of the vector relating the
    current pixel with the closest point of the closest object to this
    pixel. Given that the components of the distance are computed in
    "pixels", the vector is represented by an itk::Offset . That is, physical coordinates are not used. (See
    itkDanielssonDistanceMapImageFilter)
     This filter internally uses the DanielssonDistanceMap filter. This
    filter is N-dimensional.


    See:
     itkDanielssonDistanceMapImageFilter

     itk::simple::SignedDanielssonDistanceMap for the procedural interface

     itk::SignedDanielssonDistanceMapImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSignedDanielssonDistanceMapImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_SignedDanielssonDistanceMapImageFilter

    def __init__(self):
        r"""
        __init__(SignedDanielssonDistanceMapImageFilter self) -> SignedDanielssonDistanceMapImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.SignedDanielssonDistanceMapImageFilter_swiginit(
            self, _SimpleITK.new_SignedDanielssonDistanceMapImageFilter()
        )

    def SetInsideIsPositive(self, InsideIsPositive):
        r"""
        SetInsideIsPositive(SignedDanielssonDistanceMapImageFilter self, bool InsideIsPositive)


        Set if the inside represents positive values in the signed distance
        map. By convention ON pixels are treated as inside pixels.


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_SetInsideIsPositive(
            self, InsideIsPositive
        )

    def InsideIsPositiveOn(self):
        r"""
        InsideIsPositiveOn(SignedDanielssonDistanceMapImageFilter self)


        Set the value of InsideIsPositive to true or false respectfully.


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_InsideIsPositiveOn(
            self
        )

    def InsideIsPositiveOff(self):
        r"""
        InsideIsPositiveOff(SignedDanielssonDistanceMapImageFilter self)


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_InsideIsPositiveOff(
            self
        )

    def GetInsideIsPositive(self):
        r"""
        GetInsideIsPositive(SignedDanielssonDistanceMapImageFilter self) -> bool


        Get if the inside represents positive values in the signed distance
        map. See GetInsideIsPositive()


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_GetInsideIsPositive(
            self
        )

    def SetSquaredDistance(self, SquaredDistance):
        r"""
        SetSquaredDistance(SignedDanielssonDistanceMapImageFilter self, bool SquaredDistance)


        Set if the distance should be squared.


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_SetSquaredDistance(
            self, SquaredDistance
        )

    def SquaredDistanceOn(self):
        r"""
        SquaredDistanceOn(SignedDanielssonDistanceMapImageFilter self)


        Set the value of SquaredDistance to true or false respectfully.


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_SquaredDistanceOn(
            self
        )

    def SquaredDistanceOff(self):
        r"""
        SquaredDistanceOff(SignedDanielssonDistanceMapImageFilter self)


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_SquaredDistanceOff(
            self
        )

    def GetSquaredDistance(self):
        r"""
        GetSquaredDistance(SignedDanielssonDistanceMapImageFilter self) -> bool


        Get the distance squared.


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_GetSquaredDistance(
            self
        )

    def SetUseImageSpacing(self, UseImageSpacing):
        r"""
        SetUseImageSpacing(SignedDanielssonDistanceMapImageFilter self, bool UseImageSpacing)


        Set if image spacing should be used in computing distances.


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_SetUseImageSpacing(
            self, UseImageSpacing
        )

    def UseImageSpacingOn(self):
        r"""
        UseImageSpacingOn(SignedDanielssonDistanceMapImageFilter self)


        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_UseImageSpacingOn(
            self
        )

    def UseImageSpacingOff(self):
        r"""
        UseImageSpacingOff(SignedDanielssonDistanceMapImageFilter self)


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_UseImageSpacingOff(
            self
        )

    def GetUseImageSpacing(self):
        r"""
        GetUseImageSpacing(SignedDanielssonDistanceMapImageFilter self) -> bool


        Get whether spacing is used.


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_GetUseImageSpacing(
            self
        )

    def GetVoronoiMap(self):
        r"""
        GetVoronoiMap(SignedDanielssonDistanceMapImageFilter self) -> Image


        Get Voronoi Map This map shows for each pixel what object is closest
        to it. Each object should be labeled by a number (larger than 0), so
        the map has a value for each pixel corresponding to the label of the
        closest object.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_GetVoronoiMap(
            self
        )

    def GetVectorDistanceMap(self):
        r"""
        GetVectorDistanceMap(SignedDanielssonDistanceMapImageFilter self) -> Image


        Get vector field of distances.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_GetVectorDistanceMap(
            self
        )

    def GetName(self):
        r"""
        GetName(SignedDanielssonDistanceMapImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(SignedDanielssonDistanceMapImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(SignedDanielssonDistanceMapImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_Execute(
            self, image1
        )


# Register SignedDanielssonDistanceMapImageFilter in _SimpleITK:
_SimpleITK.SignedDanielssonDistanceMapImageFilter_swigregister(
    SignedDanielssonDistanceMapImageFilter
)


def SignedDanielssonDistanceMap(
    image1,
    insideIsPositive=False,
    squaredDistance=False,
    useImageSpacing=False,
):
    r"""SignedDanielssonDistanceMap(Image image1, bool insideIsPositive=False, bool squaredDistance=False, bool useImageSpacing=False) -> Image"""
    return _SimpleITK.SignedDanielssonDistanceMap(
        image1, insideIsPositive, squaredDistance, useImageSpacing
    )


class SignedMaurerDistanceMapImageFilter(ImageFilter):
    r"""


    This filter calculates the Euclidean distance transform of a binary
    image in linear time for arbitrary dimensions.


    Inputs and Outputs
    This is an image-to-image filter. The dimensionality is arbitrary. The
    only dimensionality constraint is that the input and output images be
    of the same dimensions and size. To maintain integer arithmetic within
    the filter, the default output is the signed squared distance. This
    implies that the input image should be of type "unsigned int" or
    "int" whereas the output image is of type "int". Obviously, if the
    user wishes to utilize the image spacing or to have a filter with the
    Euclidean distance (as opposed to the squared distance), output image
    types of float or double should be used.
     The inside is considered as having negative distances. Outside is
    treated as having positive distances. To change the convention, use
    the InsideIsPositive(bool) function.

    Parameters
    Set/GetBackgroundValue specifies the background of the value of the
    input binary image. Normally this is zero and, as such, zero is the
    default value. Other than that, the usage is completely analogous to
    the itk::DanielssonDistanceImageFilter class except it does not return
    the Voronoi map.
     Reference: C. R. Maurer, Jr., R. Qi, and V. Raghavan, "A Linear Time Algorithm for Computing Exact Euclidean Distance Transforms of Binary Images in
    Arbitrary Dimensions", IEEE - Transactions on Pattern Analysis and
    Machine Intelligence, 25(2): 265-270, 2003.
    See:
     itk::simple::SignedMaurerDistanceMap for the procedural interface

     itk::SignedMaurerDistanceMapImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSignedMaurerDistanceMapImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_SignedMaurerDistanceMapImageFilter

    def __init__(self):
        r"""
        __init__(SignedMaurerDistanceMapImageFilter self) -> SignedMaurerDistanceMapImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.SignedMaurerDistanceMapImageFilter_swiginit(
            self, _SimpleITK.new_SignedMaurerDistanceMapImageFilter()
        )

    def SetInsideIsPositive(self, InsideIsPositive):
        r"""
        SetInsideIsPositive(SignedMaurerDistanceMapImageFilter self, bool InsideIsPositive)


        Set if the inside represents positive values in the signed distance
        map. By convention ON pixels are treated as inside pixels.


        """
        return (
            _SimpleITK.SignedMaurerDistanceMapImageFilter_SetInsideIsPositive(
                self, InsideIsPositive
            )
        )

    def InsideIsPositiveOn(self):
        r"""
        InsideIsPositiveOn(SignedMaurerDistanceMapImageFilter self)


        Set the value of InsideIsPositive to true or false respectfully.


        """
        return (
            _SimpleITK.SignedMaurerDistanceMapImageFilter_InsideIsPositiveOn(
                self
            )
        )

    def InsideIsPositiveOff(self):
        r"""
        InsideIsPositiveOff(SignedMaurerDistanceMapImageFilter self)


        """
        return (
            _SimpleITK.SignedMaurerDistanceMapImageFilter_InsideIsPositiveOff(
                self
            )
        )

    def GetInsideIsPositive(self):
        r"""
        GetInsideIsPositive(SignedMaurerDistanceMapImageFilter self) -> bool


        Get if the inside represents positive values in the signed distance
        map.
        See:
         GetInsideIsPositive()



        """
        return (
            _SimpleITK.SignedMaurerDistanceMapImageFilter_GetInsideIsPositive(
                self
            )
        )

    def SetSquaredDistance(self, SquaredDistance):
        r"""
        SetSquaredDistance(SignedMaurerDistanceMapImageFilter self, bool SquaredDistance)


        Set if the distance should be squared.


        """
        return (
            _SimpleITK.SignedMaurerDistanceMapImageFilter_SetSquaredDistance(
                self, SquaredDistance
            )
        )

    def SquaredDistanceOn(self):
        r"""
        SquaredDistanceOn(SignedMaurerDistanceMapImageFilter self)


        Set the value of SquaredDistance to true or false respectfully.


        """
        return _SimpleITK.SignedMaurerDistanceMapImageFilter_SquaredDistanceOn(
            self
        )

    def SquaredDistanceOff(self):
        r"""
        SquaredDistanceOff(SignedMaurerDistanceMapImageFilter self)


        """
        return (
            _SimpleITK.SignedMaurerDistanceMapImageFilter_SquaredDistanceOff(
                self
            )
        )

    def GetSquaredDistance(self):
        r"""
        GetSquaredDistance(SignedMaurerDistanceMapImageFilter self) -> bool


        Get the distance squared.


        """
        return (
            _SimpleITK.SignedMaurerDistanceMapImageFilter_GetSquaredDistance(
                self
            )
        )

    def SetUseImageSpacing(self, UseImageSpacing):
        r"""
        SetUseImageSpacing(SignedMaurerDistanceMapImageFilter self, bool UseImageSpacing)


        Set if image spacing should be used in computing distances.


        """
        return (
            _SimpleITK.SignedMaurerDistanceMapImageFilter_SetUseImageSpacing(
                self, UseImageSpacing
            )
        )

    def UseImageSpacingOn(self):
        r"""
        UseImageSpacingOn(SignedMaurerDistanceMapImageFilter self)


        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.SignedMaurerDistanceMapImageFilter_UseImageSpacingOn(
            self
        )

    def UseImageSpacingOff(self):
        r"""
        UseImageSpacingOff(SignedMaurerDistanceMapImageFilter self)


        """
        return (
            _SimpleITK.SignedMaurerDistanceMapImageFilter_UseImageSpacingOff(
                self
            )
        )

    def GetUseImageSpacing(self):
        r"""
        GetUseImageSpacing(SignedMaurerDistanceMapImageFilter self) -> bool


        Get whether spacing is used.


        """
        return (
            _SimpleITK.SignedMaurerDistanceMapImageFilter_GetUseImageSpacing(
                self
            )
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(SignedMaurerDistanceMapImageFilter self, double BackgroundValue)


        Set the background value which defines the object. Usually this value
        is = 0.


        """
        return (
            _SimpleITK.SignedMaurerDistanceMapImageFilter_SetBackgroundValue(
                self, BackgroundValue
            )
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(SignedMaurerDistanceMapImageFilter self) -> double


        Set the background value which defines the object. Usually this value
        is = 0.


        """
        return (
            _SimpleITK.SignedMaurerDistanceMapImageFilter_GetBackgroundValue(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(SignedMaurerDistanceMapImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.SignedMaurerDistanceMapImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(SignedMaurerDistanceMapImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.SignedMaurerDistanceMapImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(SignedMaurerDistanceMapImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.SignedMaurerDistanceMapImageFilter_Execute(
            self, image1
        )


# Register SignedMaurerDistanceMapImageFilter in _SimpleITK:
_SimpleITK.SignedMaurerDistanceMapImageFilter_swigregister(
    SignedMaurerDistanceMapImageFilter
)


def SignedMaurerDistanceMap(
    image1,
    insideIsPositive=False,
    squaredDistance=True,
    useImageSpacing=False,
    backgroundValue=0.0,
):
    r"""SignedMaurerDistanceMap(Image image1, bool insideIsPositive=False, bool squaredDistance=True, bool useImageSpacing=False, double backgroundValue=0.0) -> Image"""
    return _SimpleITK.SignedMaurerDistanceMap(
        image1,
        insideIsPositive,
        squaredDistance,
        useImageSpacing,
        backgroundValue,
    )


class SimilarityIndexImageFilter(ImageFilter):
    r"""


    Measures the similarity between the set of non-zero pixels of two
    images.


    SimilarityIndexImageFilter measures the similarity between the set non-zero pixels of two images
    using the following formula: \\[ S = \\frac{2 | A \\cap B |}{|A| + |B|} \\] where $A$ and $B$ are respectively the set of non-zero pixels in the first and second
    input images. Operator $|\\cdot|$ represents the size of a set and $\\cap$ represents the intersection of two sets.

    The measure is derived from a reliability measure known as the kappa
    statistic. $S$ is sensitive to both differences in size and in location and have
    been in the literature for comparing two segmentation masks. For more
    information see: "Morphometric Analysis of White Matter Lesions in MR
    Images: Method and Validation", A. P. Zijdenbos, B. M. Dawant, R. A.
    Margolin and A. C. Palmer, IEEE Trans. on Medical Imaging, 13(4) pp
    716-724,1994

    This filter requires the largest possible region of the first image
    and the same corresponding region in the second image. It behaves as
    filter with two input and one output. Thus it can be inserted in a
    pipeline with other filters. The filter passes the first input through
    unmodified.

    This filter is templated over the two input image type. It assume both
    image have the same number of dimensions.


    See:
     itk::SimilarityIndexImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSimilarityIndexImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_SimilarityIndexImageFilter

    def __init__(self):
        r"""
        __init__(SimilarityIndexImageFilter self) -> SimilarityIndexImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.SimilarityIndexImageFilter_swiginit(
            self, _SimpleITK.new_SimilarityIndexImageFilter()
        )

    def GetSimilarityIndex(self):
        r"""
        GetSimilarityIndex(SimilarityIndexImageFilter self) -> double


        Return the computed similarity index.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.SimilarityIndexImageFilter_GetSimilarityIndex(self)

    def GetName(self):
        r"""
        GetName(SimilarityIndexImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.SimilarityIndexImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(SimilarityIndexImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.SimilarityIndexImageFilter___str__(self)

    def Execute(self, image1, image2):
        r"""
        Execute(SimilarityIndexImageFilter self, Image image1, Image image2)


        Execute the filter on the input images


        """
        return _SimpleITK.SimilarityIndexImageFilter_Execute(
            self, image1, image2
        )


# Register SimilarityIndexImageFilter in _SimpleITK:
_SimpleITK.SimilarityIndexImageFilter_swigregister(SimilarityIndexImageFilter)


class SimpleContourExtractorImageFilter(ImageFilter):
    r"""


    Computes an image of contours which will be the contour of the first
    image.


    A pixel of the source image is considered to belong to the contour if
    its pixel value is equal to the input foreground value and it has in
    its neighborhood at least one pixel which its pixel value is equal to
    the input background value. The output image will have pixels which
    will be set to the output foreground value if they belong to the
    contour, otherwise they will be set to the output background value.

    The neighborhood "radius" is set thanks to the radius params.
    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     itk::simple::SimpleContourExtractor for the procedural interface

     itk::SimpleContourExtractorImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSimpleContourExtractorImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_SimpleContourExtractorImageFilter

    def __init__(self):
        r"""
        __init__(SimpleContourExtractorImageFilter self) -> SimpleContourExtractorImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.SimpleContourExtractorImageFilter_swiginit(
            self, _SimpleITK.new_SimpleContourExtractorImageFilter()
        )

    def SetInputForegroundValue(self, InputForegroundValue):
        r"""
        SetInputForegroundValue(SimpleContourExtractorImageFilter self, double InputForegroundValue)


        Set the foreground value used in order to identify a foreground pixel
        in the input image.


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_SetInputForegroundValue(
            self, InputForegroundValue
        )

    def GetInputForegroundValue(self):
        r"""
        GetInputForegroundValue(SimpleContourExtractorImageFilter self) -> double


        Get the foreground value used in order to identify a foreground pixel
        in the input image.


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_GetInputForegroundValue(
            self
        )

    def SetInputBackgroundValue(self, InputBackgroundValue):
        r"""
        SetInputBackgroundValue(SimpleContourExtractorImageFilter self, double InputBackgroundValue)


        Set the background value used in order to identify a background pixel
        in the input image.


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_SetInputBackgroundValue(
            self, InputBackgroundValue
        )

    def GetInputBackgroundValue(self):
        r"""
        GetInputBackgroundValue(SimpleContourExtractorImageFilter self) -> double


        Get the background value used in order to identify a background pixel
        in the input image.


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_GetInputBackgroundValue(
            self
        )

    def SetRadius(self, *args):
        r"""
        SetRadius(SimpleContourExtractorImageFilter self, VectorUInt32 Radius)
        SetRadius(SimpleContourExtractorImageFilter self, unsigned int value)


        Set the values of the Radius vector all to value


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_SetRadius(
            self, *args
        )

    def GetRadius(self):
        r"""
        GetRadius(SimpleContourExtractorImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_GetRadius(self)

    def SetOutputForegroundValue(self, OutputForegroundValue):
        r"""
        SetOutputForegroundValue(SimpleContourExtractorImageFilter self, double OutputForegroundValue)


        Set the foreground value used in order to identify a foreground pixel
        in the output image.


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_SetOutputForegroundValue(
            self, OutputForegroundValue
        )

    def GetOutputForegroundValue(self):
        r"""
        GetOutputForegroundValue(SimpleContourExtractorImageFilter self) -> double


        Get the foreground value used in order to identify a foreground pixel
        in the output image.


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_GetOutputForegroundValue(
            self
        )

    def SetOutputBackgroundValue(self, OutputBackgroundValue):
        r"""
        SetOutputBackgroundValue(SimpleContourExtractorImageFilter self, double OutputBackgroundValue)


        Set the background value used in order to identify a background pixel
        in the output image.


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_SetOutputBackgroundValue(
            self, OutputBackgroundValue
        )

    def GetOutputBackgroundValue(self):
        r"""
        GetOutputBackgroundValue(SimpleContourExtractorImageFilter self) -> double


        Get the background value used in order to identify a background pixel
        in the output image.


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_GetOutputBackgroundValue(
            self
        )

    def GetName(self):
        r"""
        GetName(SimpleContourExtractorImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(SimpleContourExtractorImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.SimpleContourExtractorImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(SimpleContourExtractorImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_Execute(
            self, image1
        )


# Register SimpleContourExtractorImageFilter in _SimpleITK:
_SimpleITK.SimpleContourExtractorImageFilter_swigregister(
    SimpleContourExtractorImageFilter
)


def SimpleContourExtractor(*args, **kwargs):
    r"""SimpleContourExtractor(Image image1, double inputForegroundValue=1.0, double inputBackgroundValue=0.0, VectorUInt32 radius=std::vector< unsigned int >(3, 1), double outputForegroundValue=1.0, double outputBackgroundValue=0.0) -> Image"""
    return _SimpleITK.SimpleContourExtractor(*args, **kwargs)


class SinImageFilter(ImageFilter):
    r"""


    Computes the sine of each pixel.


    The computations are performed using std::sin(x).
    See:
     itk::simple::Sin for the procedural interface

     itk::SinImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSinImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_SinImageFilter

    def __init__(self):
        r"""
        __init__(SinImageFilter self) -> SinImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.SinImageFilter_swiginit(
            self, _SimpleITK.new_SinImageFilter()
        )

    def GetName(self):
        r"""
        GetName(SinImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.SinImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(SinImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.SinImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(SinImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.SinImageFilter_Execute(self, image1)


# Register SinImageFilter in _SimpleITK:
_SimpleITK.SinImageFilter_swigregister(SinImageFilter)


def Sin(image1):
    r"""Sin(Image image1) -> Image"""
    return _SimpleITK.Sin(image1)


class SliceImageFilter(ImageFilter):
    r"""


    Slices an image based on a starting index and a stopping index, and a
    step size.


    This class is designed to facilitate the implementation of extended
    sliced based indexing into images.

    The input and output image must be of the same dimension.

    The input parameters are a starting and stopping index as well as a
    stepping size. The starting index indicates the first pixels to be
    used and for each dimension the index is incremented by the step until
    the index is equal to or "beyond" the stopping index. If the step is
    negative then the image will be reversed in the dimension, and the
    stopping index is expected to be less then the starting index. If the
    stopping index is already beyond the starting index then an image of
    size zero will be returned.

    The output image's starting index is always zero. The origin is the
    physical location of the starting index. The output directions cosine
    matrix is that of the input but with sign changes matching that of the
    step's sign.


    In certain combinations such as with start=1, and step>1 while the
    physical location of the center of the pixel remains the same, the
    extent (edge to edge space) of the output image will be beyond the
    extent of the original image.

    See:
     itk::simple::Slice for the procedural interface

     itk::SliceImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSliceImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_SliceImageFilter

    def __init__(self):
        r"""
        __init__(SliceImageFilter self) -> SliceImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.SliceImageFilter_swiginit(
            self, _SimpleITK.new_SliceImageFilter()
        )

    def SetStart(self, Start):
        r"""
        SetStart(SliceImageFilter self, VectorInt32 Start)


        Set/Get the first index extracted from the input image


        """
        return _SimpleITK.SliceImageFilter_SetStart(self, Start)

    def GetStart(self):
        r"""
        GetStart(SliceImageFilter self) -> VectorInt32


        Set/Get the first index extracted from the input image


        """
        return _SimpleITK.SliceImageFilter_GetStart(self)

    def SetStop(self, Stop):
        r"""
        SetStop(SliceImageFilter self, VectorInt32 Stop)


        Set/Get the excluded end of the range


        """
        return _SimpleITK.SliceImageFilter_SetStop(self, Stop)

    def GetStop(self):
        r"""
        GetStop(SliceImageFilter self) -> VectorInt32


        Set/Get the excluded end of the range


        """
        return _SimpleITK.SliceImageFilter_GetStop(self)

    def SetStep(self, *args):
        r"""
        SetStep(SliceImageFilter self, VectorInt32 Step)
        SetStep(SliceImageFilter self, int value)


        Set/Get the stride of indexes extracted An exception will be generated
        if 0.


        """
        return _SimpleITK.SliceImageFilter_SetStep(self, *args)

    def GetStep(self):
        r"""
        GetStep(SliceImageFilter self) -> VectorInt32


        Set/Get the stride of indexes extracted An exception will be generated
        if 0.


        """
        return _SimpleITK.SliceImageFilter_GetStep(self)

    def GetName(self):
        r"""
        GetName(SliceImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.SliceImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(SliceImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.SliceImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(SliceImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.SliceImageFilter_Execute(self, image1)


# Register SliceImageFilter in _SimpleITK:
_SimpleITK.SliceImageFilter_swigregister(SliceImageFilter)


def Slice(*args, **kwargs):
    r"""Slice(Image image1, VectorInt32 start=std::vector< int32_t >(3, 0), VectorInt32 stop=std::vector< int32_t >(3, std::numeric_limits<int32_t>::max()), VectorInt32 step=std::vector< int >(3, 1)) -> Image"""
    return _SimpleITK.Slice(*args, **kwargs)


class SmoothingRecursiveGaussianImageFilter(ImageFilter):
    r"""


    Computes the smoothing of an image by convolution with the Gaussian
    kernels implemented as IIR filters.


    This filter is implemented using the recursive gaussian filters. For
    multi-component images, the filter works on each component
    independently.

    For this filter to be able to run in-place the input and output image
    types need to be the same and/or the same type as the RealImageType.
    See:
     itk::simple::SmoothingRecursiveGaussian for the procedural interface

     itk::SmoothingRecursiveGaussianImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSmoothingRecursiveGaussianImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_SmoothingRecursiveGaussianImageFilter

    def __init__(self):
        r"""
        __init__(SmoothingRecursiveGaussianImageFilter self) -> SmoothingRecursiveGaussianImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.SmoothingRecursiveGaussianImageFilter_swiginit(
            self, _SimpleITK.new_SmoothingRecursiveGaussianImageFilter()
        )

    def SetSigma(self, *args):
        r"""
        SetSigma(SmoothingRecursiveGaussianImageFilter self, VectorDouble Sigma)
        SetSigma(SmoothingRecursiveGaussianImageFilter self, double value)


        Set the standard deviation of the Gaussian used for smoothing. Sigma
        is measured in the units of image spacing. You may use the method
        SetSigma to set the same value across each axis or use the method
        SetSigmaArray if you need different values along each axis.


        """
        return _SimpleITK.SmoothingRecursiveGaussianImageFilter_SetSigma(
            self, *args
        )

    def GetSigma(self):
        r"""
        GetSigma(SmoothingRecursiveGaussianImageFilter self) -> VectorDouble


        Get the Sigma scalar. If the Sigma is anisotropic, we will just return
        the Sigma along the first dimension.


        """
        return _SimpleITK.SmoothingRecursiveGaussianImageFilter_GetSigma(self)

    def SetNormalizeAcrossScale(self, NormalizeAcrossScale):
        r"""
        SetNormalizeAcrossScale(SmoothingRecursiveGaussianImageFilter self, bool NormalizeAcrossScale)


             Set/Get the flag for normalizing the Gaussian over scale-space.
        This method does not effect the output of this filter.


        See:
         RecursiveGaussianImageFilter::SetNormalizeAcrossScale



        """
        return _SimpleITK.SmoothingRecursiveGaussianImageFilter_SetNormalizeAcrossScale(
            self, NormalizeAcrossScale
        )

    def NormalizeAcrossScaleOn(self):
        r"""
        NormalizeAcrossScaleOn(SmoothingRecursiveGaussianImageFilter self)


        Set the value of NormalizeAcrossScale to true or false respectfully.


        """
        return _SimpleITK.SmoothingRecursiveGaussianImageFilter_NormalizeAcrossScaleOn(
            self
        )

    def NormalizeAcrossScaleOff(self):
        r"""
        NormalizeAcrossScaleOff(SmoothingRecursiveGaussianImageFilter self)


        """
        return _SimpleITK.SmoothingRecursiveGaussianImageFilter_NormalizeAcrossScaleOff(
            self
        )

    def GetNormalizeAcrossScale(self):
        r"""
        GetNormalizeAcrossScale(SmoothingRecursiveGaussianImageFilter self) -> bool


             Set/Get the flag for normalizing the Gaussian over scale-space.
        This method does not effect the output of this filter.


        See:
         RecursiveGaussianImageFilter::SetNormalizeAcrossScale



        """
        return _SimpleITK.SmoothingRecursiveGaussianImageFilter_GetNormalizeAcrossScale(
            self
        )

    def GetName(self):
        r"""
        GetName(SmoothingRecursiveGaussianImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.SmoothingRecursiveGaussianImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(SmoothingRecursiveGaussianImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.SmoothingRecursiveGaussianImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(SmoothingRecursiveGaussianImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.SmoothingRecursiveGaussianImageFilter_Execute(
            self, image1
        )


# Register SmoothingRecursiveGaussianImageFilter in _SimpleITK:
_SimpleITK.SmoothingRecursiveGaussianImageFilter_swigregister(
    SmoothingRecursiveGaussianImageFilter
)


def SmoothingRecursiveGaussian(*args):
    r"""
    SmoothingRecursiveGaussian(Image image1, double sigma, bool normalizeAcrossScale=False) -> Image
    SmoothingRecursiveGaussian(Image image1, VectorDouble sigma=std::vector< double >(3,1.0), bool normalizeAcrossScale=False) -> Image


    Computes the smoothing of an image by convolution with the Gaussian
    kernels implemented as IIR filters.


    This function directly calls the execute method of SmoothingRecursiveGaussianImageFilter in order to support a procedural API


    See:
     itk::simple::SmoothingRecursiveGaussianImageFilter for the object oriented interface



    """
    return _SimpleITK.SmoothingRecursiveGaussian(*args)


class SobelEdgeDetectionImageFilter(ImageFilter):
    r"""


    A 2D or 3D edge detection using the Sobel operator.


    This filter uses the Sobel operator to calculate the image gradient
    and then finds the magnitude of this gradient vector. The Sobel
    gradient magnitude (square-root sum of squares) is an indication of
    edge strength.


    See:
     ImageToImageFilter

     SobelOperator

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     itk::simple::SobelEdgeDetection for the procedural interface

     itk::SobelEdgeDetectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSobelEdgeDetectionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_SobelEdgeDetectionImageFilter

    def __init__(self):
        r"""
        __init__(SobelEdgeDetectionImageFilter self) -> SobelEdgeDetectionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.SobelEdgeDetectionImageFilter_swiginit(
            self, _SimpleITK.new_SobelEdgeDetectionImageFilter()
        )

    def GetName(self):
        r"""
        GetName(SobelEdgeDetectionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.SobelEdgeDetectionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(SobelEdgeDetectionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.SobelEdgeDetectionImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(SobelEdgeDetectionImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.SobelEdgeDetectionImageFilter_Execute(self, image1)


# Register SobelEdgeDetectionImageFilter in _SimpleITK:
_SimpleITK.SobelEdgeDetectionImageFilter_swigregister(
    SobelEdgeDetectionImageFilter
)


def SobelEdgeDetection(image1):
    r"""SobelEdgeDetection(Image image1) -> Image"""
    return _SimpleITK.SobelEdgeDetection(image1)


class SpeckleNoiseImageFilter(ImageFilter):
    r"""


    Alter an image with speckle (multiplicative) noise.


    The speckle noise follows a gamma distribution of mean 1 and standard
    deviation provided by the user. The noise is proportional to the pixel
    intensity.

    It can be modeled as:


    $ I = I_0 \\ast G $

    where $ G $ is a is a gamma distributed random variable of mean 1 and variance
    proportional to the noise level:

    $ G \\sim \\Gamma(\\frac{1}{\\sigma^2}, \\sigma^2) $

    Gaetan Lehmann
     This code was contributed in the Insight Journal paper "Noise
    Simulation". https://doi.org/10.54294/vh6vbw
    See:
     itk::simple::SpeckleNoise for the procedural interface

     itk::SpeckleNoiseImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSpeckleNoiseImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_SpeckleNoiseImageFilter

    def __init__(self):
        r"""
        __init__(SpeckleNoiseImageFilter self) -> SpeckleNoiseImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.SpeckleNoiseImageFilter_swiginit(
            self, _SimpleITK.new_SpeckleNoiseImageFilter()
        )

    def SetStandardDeviation(self, StandardDeviation):
        r"""
        SetStandardDeviation(SpeckleNoiseImageFilter self, double StandardDeviation)


        Set/Get the standard deviation of the gamma distribution. Defaults to
        1.0.


        """
        return _SimpleITK.SpeckleNoiseImageFilter_SetStandardDeviation(
            self, StandardDeviation
        )

    def GetStandardDeviation(self):
        r"""
        GetStandardDeviation(SpeckleNoiseImageFilter self) -> double


        Set/Get the standard deviation of the gamma distribution. Defaults to
        1.0.


        """
        return _SimpleITK.SpeckleNoiseImageFilter_GetStandardDeviation(self)

    def SetSeed(self, Seed):
        r"""
        SetSeed(SpeckleNoiseImageFilter self, uint32_t Seed)


        """
        return _SimpleITK.SpeckleNoiseImageFilter_SetSeed(self, Seed)

    def GetSeed(self):
        r"""
        GetSeed(SpeckleNoiseImageFilter self) -> uint32_t


        """
        return _SimpleITK.SpeckleNoiseImageFilter_GetSeed(self)

    def GetName(self):
        r"""
        GetName(SpeckleNoiseImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.SpeckleNoiseImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(SpeckleNoiseImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.SpeckleNoiseImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(SpeckleNoiseImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.SpeckleNoiseImageFilter_Execute(self, image1)


# Register SpeckleNoiseImageFilter in _SimpleITK:
_SimpleITK.SpeckleNoiseImageFilter_swigregister(SpeckleNoiseImageFilter)


def SpeckleNoise(*args, **kwargs):
    r"""SpeckleNoise(Image image1, double standardDeviation=1.0, uint32_t seed=(uint32_t) itk::simple::sitkWallClock) -> Image"""
    return _SimpleITK.SpeckleNoise(*args, **kwargs)


class SqrtImageFilter(ImageFilter):
    r"""


    Computes the square root of each pixel.


    The computations are performed using std::sqrt(x).
    See:
     itk::simple::Sqrt for the procedural interface

     itk::SqrtImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSqrtImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_SqrtImageFilter

    def __init__(self):
        r"""
        __init__(SqrtImageFilter self) -> SqrtImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.SqrtImageFilter_swiginit(
            self, _SimpleITK.new_SqrtImageFilter()
        )

    def GetName(self):
        r"""
        GetName(SqrtImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.SqrtImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(SqrtImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.SqrtImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(SqrtImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.SqrtImageFilter_Execute(self, image1)


# Register SqrtImageFilter in _SimpleITK:
_SimpleITK.SqrtImageFilter_swigregister(SqrtImageFilter)


def Sqrt(image1):
    r"""Sqrt(Image image1) -> Image"""
    return _SimpleITK.Sqrt(image1)


class SquareImageFilter(ImageFilter):
    r"""


    Computes the square of the intensity values pixel-wise.



    See:
     itk::simple::Square for the procedural interface

     itk::SquareImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSquareImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_SquareImageFilter

    def __init__(self):
        r"""
        __init__(SquareImageFilter self) -> SquareImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.SquareImageFilter_swiginit(
            self, _SimpleITK.new_SquareImageFilter()
        )

    def GetName(self):
        r"""
        GetName(SquareImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.SquareImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(SquareImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.SquareImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(SquareImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.SquareImageFilter_Execute(self, image1)


# Register SquareImageFilter in _SimpleITK:
_SimpleITK.SquareImageFilter_swigregister(SquareImageFilter)


def Square(image1):
    r"""Square(Image image1) -> Image"""
    return _SimpleITK.Square(image1)


class SquaredDifferenceImageFilter(ImageFilter):
    r"""


    Implements pixel-wise the computation of squared difference.


    This filter is parameterized over the types of the two input images
    and the type of the output image.

    Numeric conversions (castings) are done by the C++ defaults.

    The filter will walk over all the pixels in the two input images, and
    for each one of them it will do the following:


    cast the input 1 pixel value to double

    cast the input 2 pixel value to double

    compute the difference of the two pixel values

    compute the square of the difference

    cast the double value resulting from sqr() to the pixel type of the
    output image

    store the casted value into the output image.
     The filter expect all images to have the same dimension (e.g. all 2D,
    or all 3D, or all ND)
    See:
     itk::simple::SquaredDifference for the procedural interface

     itk::SquaredDifferenceImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSquaredDifferenceImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_SquaredDifferenceImageFilter

    def __init__(self):
        r"""
        __init__(SquaredDifferenceImageFilter self) -> SquaredDifferenceImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.SquaredDifferenceImageFilter_swiginit(
            self, _SimpleITK.new_SquaredDifferenceImageFilter()
        )

    def GetName(self):
        r"""
        GetName(SquaredDifferenceImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.SquaredDifferenceImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(SquaredDifferenceImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.SquaredDifferenceImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(SquaredDifferenceImageFilter self, Image image1, Image image2) -> Image
        Execute(SquaredDifferenceImageFilter self, Image image1, double constant) -> Image
        Execute(SquaredDifferenceImageFilter self, double constant, Image image2) -> Image


        """
        return _SimpleITK.SquaredDifferenceImageFilter_Execute(self, *args)


# Register SquaredDifferenceImageFilter in _SimpleITK:
_SimpleITK.SquaredDifferenceImageFilter_swigregister(
    SquaredDifferenceImageFilter
)


def SquaredDifference(*args):
    r"""
    SquaredDifference(Image image1, Image image2) -> Image
    SquaredDifference(Image image1, double constant) -> Image
    SquaredDifference(double constant, Image image2) -> Image


    """
    return _SimpleITK.SquaredDifference(*args)


class StandardDeviationProjectionImageFilter(ImageFilter):
    r"""


    Mean projection.


    This class was contributed to the Insight Journal by Gaetan Lehmann.
    The original paper can be found at https://doi.org/10.54294/0pjyho


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ProjectionImageFilter

     MedianProjectionImageFilter

     MeanProjectionImageFilter

     SumProjectionImageFilter

     MeanProjectionImageFilter

     MaximumProjectionImageFilter

     MinimumProjectionImageFilter

     BinaryProjectionImageFilter

     itk::simple::StandardDeviationProjection for the procedural interface

     itk::StandardDeviationProjectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkStandardDeviationProjectionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_StandardDeviationProjectionImageFilter

    def __init__(self):
        r"""
        __init__(StandardDeviationProjectionImageFilter self) -> StandardDeviationProjectionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.StandardDeviationProjectionImageFilter_swiginit(
            self, _SimpleITK.new_StandardDeviationProjectionImageFilter()
        )

    def SetProjectionDimension(self, ProjectionDimension):
        r"""
        SetProjectionDimension(StandardDeviationProjectionImageFilter self, unsigned int ProjectionDimension)


        """
        return _SimpleITK.StandardDeviationProjectionImageFilter_SetProjectionDimension(
            self, ProjectionDimension
        )

    def GetProjectionDimension(self):
        r"""
        GetProjectionDimension(StandardDeviationProjectionImageFilter self) -> unsigned int


        """
        return _SimpleITK.StandardDeviationProjectionImageFilter_GetProjectionDimension(
            self
        )

    def GetName(self):
        r"""
        GetName(StandardDeviationProjectionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.StandardDeviationProjectionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(StandardDeviationProjectionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.StandardDeviationProjectionImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(StandardDeviationProjectionImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.StandardDeviationProjectionImageFilter_Execute(
            self, image1
        )


# Register StandardDeviationProjectionImageFilter in _SimpleITK:
_SimpleITK.StandardDeviationProjectionImageFilter_swigregister(
    StandardDeviationProjectionImageFilter
)


def StandardDeviationProjection(image1, projectionDimension=0):
    r"""StandardDeviationProjection(Image image1, unsigned int projectionDimension=0) -> Image"""
    return _SimpleITK.StandardDeviationProjection(image1, projectionDimension)


class StatisticsImageFilter(ImageFilter):
    r"""


    Compute min, max, variance and mean of an Image .


    StatisticsImageFilter computes the minimum, maximum, sum, sum of squares, mean, variance
    sigma of an image. The filter needs all of its input image. It behaves
    as a filter with an input and output. Thus it can be inserted in a
    pipeline with other filters and the statistics will only be recomputed
    if a downstream filter changes.

    This filter is automatically multi-threaded and can stream its input
    when NumberOfStreamDivisions is set to more than one. Statistics are independently computed for each streamed and threaded region then
    merged.

    Internally a compensated summation algorithm is used for the
    accumulation of intensities to improve accuracy for large images.


    See:
     itk::StatisticsImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkStatisticsImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_StatisticsImageFilter

    def __init__(self):
        r"""
        __init__(StatisticsImageFilter self) -> StatisticsImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.StatisticsImageFilter_swiginit(
            self, _SimpleITK.new_StatisticsImageFilter()
        )

    def GetMinimum(self):
        r"""
        GetMinimum(StatisticsImageFilter self) -> double


        Return the computed Minimum.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.StatisticsImageFilter_GetMinimum(self)

    def GetMaximum(self):
        r"""
        GetMaximum(StatisticsImageFilter self) -> double


        Return the computed Maximum.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.StatisticsImageFilter_GetMaximum(self)

    def GetMean(self):
        r"""
        GetMean(StatisticsImageFilter self) -> double


        Return the computed Mean.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.StatisticsImageFilter_GetMean(self)

    def GetSigma(self):
        r"""
        GetSigma(StatisticsImageFilter self) -> double


        Return the computed Standard Deviation.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.StatisticsImageFilter_GetSigma(self)

    def GetVariance(self):
        r"""
        GetVariance(StatisticsImageFilter self) -> double


        Return the computed Variance.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.StatisticsImageFilter_GetVariance(self)

    def GetSum(self):
        r"""
        GetSum(StatisticsImageFilter self) -> double


        Return the compute Sum.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.StatisticsImageFilter_GetSum(self)

    def GetName(self):
        r"""
        GetName(StatisticsImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.StatisticsImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(StatisticsImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.StatisticsImageFilter___str__(self)

    def Execute(self, image):
        r"""
        Execute(StatisticsImageFilter self, Image image)


        Execute the filter on the input image


        """
        return _SimpleITK.StatisticsImageFilter_Execute(self, image)


# Register StatisticsImageFilter in _SimpleITK:
_SimpleITK.StatisticsImageFilter_swigregister(StatisticsImageFilter)


class StochasticFractalDimensionImageFilter(ImageFilter):
    r"""


    This filter computes the stochastic fractal dimension of the input
    image.


    The methodology is based on Mandelbrot's fractal theory and the
    concept of fractional Brownian motion and yields images which have
    been used for classification and edge enhancement.

    This class which is templated over the input and output images as well
    as a mask image type. The input is a scalar image, an optional
    neighborhood radius (default = 2), and an optional mask. The mask can
    be specified to decrease computation time since, as the authors point
    out, calculation is time-consuming.

    This filter was contributed by Nick Tustison and James Gee from the
    PICSL lab, at the University of Pennsylvania as an paper to the
    Insight Journal:

    "Stochastic Fractal Dimension Image" https://doi.org/10.54294/ne109t


    Nick Tustison

    See:
     itk::simple::StochasticFractalDimension for the procedural interface

     itk::StochasticFractalDimensionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkStochasticFractalDimensionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_StochasticFractalDimensionImageFilter

    def __init__(self):
        r"""
        __init__(StochasticFractalDimensionImageFilter self) -> StochasticFractalDimensionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.StochasticFractalDimensionImageFilter_swiginit(
            self, _SimpleITK.new_StochasticFractalDimensionImageFilter()
        )

    def SetNeighborhoodRadius(self, *args):
        r"""
        SetNeighborhoodRadius(StochasticFractalDimensionImageFilter self, VectorUInt32 NeighborhoodRadius)
        SetNeighborhoodRadius(StochasticFractalDimensionImageFilter self, unsigned int value)


        Set the values of the NeighborhoodRadius vector all to value


        """
        return _SimpleITK.StochasticFractalDimensionImageFilter_SetNeighborhoodRadius(
            self, *args
        )

    def GetNeighborhoodRadius(self):
        r"""
        GetNeighborhoodRadius(StochasticFractalDimensionImageFilter self) -> VectorUInt32


        Manhattan radius used for evaluating the fractal dimension.


        """
        return _SimpleITK.StochasticFractalDimensionImageFilter_GetNeighborhoodRadius(
            self
        )

    def GetName(self):
        r"""
        GetName(StochasticFractalDimensionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.StochasticFractalDimensionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(StochasticFractalDimensionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.StochasticFractalDimensionImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(StochasticFractalDimensionImageFilter self, Image image, Image maskImage) -> Image
        Execute(StochasticFractalDimensionImageFilter self, Image image) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.StochasticFractalDimensionImageFilter_Execute(
            self, *args
        )


# Register StochasticFractalDimensionImageFilter in _SimpleITK:
_SimpleITK.StochasticFractalDimensionImageFilter_swigregister(
    StochasticFractalDimensionImageFilter
)


def StochasticFractalDimension(*args):
    r"""
    StochasticFractalDimension(Image image, Image maskImage, VectorUInt32 neighborhoodRadius=std::vector< unsigned int >(3, 2u)) -> Image
    StochasticFractalDimension(Image image, VectorUInt32 neighborhoodRadius=std::vector< unsigned int >(3, 2u)) -> Image
    """
    return _SimpleITK.StochasticFractalDimension(*args)


class SubtractImageFilter(ImageFilter):
    r"""


    Pixel-wise subtraction of two images.


    Subtract each pixel from image2 from its corresponding pixel in
    image1:


    This is done using


    This class is templated over the types of the two input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    Additionally, a constant can be subtracted from every pixel in an
    image using:



    The result of AddImageFilter with a negative constant is not necessarily the same as SubtractImageFilter . This would be the case when the PixelType defines an operator-() that is not the inverse of operator+()

    See:
     itk::simple::Subtract for the procedural interface

     itk::SubtractImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSubtractImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_SubtractImageFilter

    def __init__(self):
        r"""
        __init__(SubtractImageFilter self) -> SubtractImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.SubtractImageFilter_swiginit(
            self, _SimpleITK.new_SubtractImageFilter()
        )

    def GetName(self):
        r"""
        GetName(SubtractImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.SubtractImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(SubtractImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.SubtractImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(SubtractImageFilter self, Image image1, Image image2) -> Image
        Execute(SubtractImageFilter self, Image image1, double constant) -> Image
        Execute(SubtractImageFilter self, double constant, Image image2) -> Image


        """
        return _SimpleITK.SubtractImageFilter_Execute(self, *args)


# Register SubtractImageFilter in _SimpleITK:
_SimpleITK.SubtractImageFilter_swigregister(SubtractImageFilter)


def Subtract(*args):
    r"""
    Subtract(Image image1, Image image2) -> Image
    Subtract(Image image1, double constant) -> Image
    Subtract(double constant, Image image2) -> Image


    """
    return _SimpleITK.Subtract(*args)


class SumProjectionImageFilter(ImageFilter):
    r"""


    Sum projection.


    This class was contributed to the Insight Journal by Gaetan Lehmann.
    The original paper can be found at https://doi.org/10.54294/0pjyho


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ProjectionImageFilter

     MedianProjectionImageFilter

     MeanProjectionImageFilter

     MeanProjectionImageFilter

     MaximumProjectionImageFilter

     MinimumProjectionImageFilter

     BinaryProjectionImageFilter

     StandardDeviationProjectionImageFilter

     itk::simple::SumProjection for the procedural interface

     itk::SumProjectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSumProjectionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_SumProjectionImageFilter

    def __init__(self):
        r"""
        __init__(SumProjectionImageFilter self) -> SumProjectionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.SumProjectionImageFilter_swiginit(
            self, _SimpleITK.new_SumProjectionImageFilter()
        )

    def SetProjectionDimension(self, ProjectionDimension):
        r"""
        SetProjectionDimension(SumProjectionImageFilter self, unsigned int ProjectionDimension)


        """
        return _SimpleITK.SumProjectionImageFilter_SetProjectionDimension(
            self, ProjectionDimension
        )

    def GetProjectionDimension(self):
        r"""
        GetProjectionDimension(SumProjectionImageFilter self) -> unsigned int


        """
        return _SimpleITK.SumProjectionImageFilter_GetProjectionDimension(self)

    def GetName(self):
        r"""
        GetName(SumProjectionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.SumProjectionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(SumProjectionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.SumProjectionImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(SumProjectionImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.SumProjectionImageFilter_Execute(self, image1)


# Register SumProjectionImageFilter in _SimpleITK:
_SimpleITK.SumProjectionImageFilter_swigregister(SumProjectionImageFilter)


def SumProjection(image1, projectionDimension=0):
    r"""SumProjection(Image image1, unsigned int projectionDimension=0) -> Image"""
    return _SimpleITK.SumProjection(image1, projectionDimension)


class SymmetricForcesDemonsRegistrationFilter(ImageFilter):
    r"""


    Deformably register two images using the demons algorithm.


    This class was contributed by Corinne Mattmann, ETH Zurich,
    Switzerland. based on a variation of the DemonsRegistrationFilter . The basic modification is to use equation (5) from Thirion's paper
    along with the modification for avoiding large deformations when
    gradients have small values.

    SymmetricForcesDemonsRegistrationFilter implements the demons deformable algorithm that register two images
    by computing the deformation field which will map a moving image onto
    a fixed image.

    A deformation field is represented as a image whose pixel type is some
    vector type with at least N elements, where N is the dimension of the
    fixed image. The vector type must support element access via operator
    []. It is assumed that the vector elements behave like floating point
    scalars.

    This class is templated over the fixed image type, moving image type
    and the deformation field type.

    The input fixed and moving images are set via methods SetFixedImage
    and SetMovingImage respectively. An initial deformation field maybe
    set via SetInitialDisplacementField or SetInput. If no initial field
    is set, a zero field is used as the initial condition.

    The algorithm has one parameters: the number of iteration to be
    performed.

    The output deformation field can be obtained via methods GetOutput or
    GetDisplacementField.

    This class make use of the finite difference solver hierarchy. Update
    for each iteration is computed in DemonsRegistrationFunction .


    WARNING:
    This filter assumes that the fixed image type, moving image type and
    deformation field type all have the same number of dimensions.

    See:
     SymmetricForcesDemonsRegistrationFunction

     DemonsRegistrationFilter

     DemonsRegistrationFunction

     itk::SymmetricForcesDemonsRegistrationFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSymmetricForcesDemonsRegistrationFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_SymmetricForcesDemonsRegistrationFilter
    )

    def __init__(self):
        r"""
        __init__(SymmetricForcesDemonsRegistrationFilter self) -> SymmetricForcesDemonsRegistrationFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.SymmetricForcesDemonsRegistrationFilter_swiginit(
            self, _SimpleITK.new_SymmetricForcesDemonsRegistrationFilter()
        )

    def SetStandardDeviations(self, *args):
        r"""
        SetStandardDeviations(SymmetricForcesDemonsRegistrationFilter self, VectorDouble StandardDeviations)
        SetStandardDeviations(SymmetricForcesDemonsRegistrationFilter self, double value)


        Set/Get the Gaussian smoothing standard deviations for the
        displacement field. The values are set with respect to pixel
        coordinates.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SetStandardDeviations(
            self, *args
        )

    def GetStandardDeviations(self):
        r"""
        GetStandardDeviations(SymmetricForcesDemonsRegistrationFilter self) -> VectorDouble


        Set/Get the Gaussian smoothing standard deviations for the
        displacement field. The values are set with respect to pixel
        coordinates.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetStandardDeviations(
            self
        )

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(SymmetricForcesDemonsRegistrationFilter self, uint32_t NumberOfIterations)


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(SymmetricForcesDemonsRegistrationFilter self) -> uint32_t


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetNumberOfIterations(
            self
        )

    def SetMaximumRMSError(self, MaximumRMSError):
        r"""
        SetMaximumRMSError(SymmetricForcesDemonsRegistrationFilter self, double MaximumRMSError)


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SetMaximumRMSError(
            self, MaximumRMSError
        )

    def GetMaximumRMSError(self):
        r"""
        GetMaximumRMSError(SymmetricForcesDemonsRegistrationFilter self) -> double


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetMaximumRMSError(
            self
        )

    def SetSmoothDisplacementField(self, SmoothDisplacementField):
        r"""
        SetSmoothDisplacementField(SymmetricForcesDemonsRegistrationFilter self, bool SmoothDisplacementField)


        Set/Get whether the displacement field is smoothed (regularized).
        Smoothing the displacement yields a solution elastic in nature. If
        SmoothDisplacementField is on, then the displacement field is smoothed
        with a Gaussian whose standard deviations are specified with SetStandardDeviations()


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SetSmoothDisplacementField(
            self, SmoothDisplacementField
        )

    def SmoothDisplacementFieldOn(self):
        r"""
        SmoothDisplacementFieldOn(SymmetricForcesDemonsRegistrationFilter self)


        Set the value of SmoothDisplacementField to true or false
        respectfully.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SmoothDisplacementFieldOn(
            self
        )

    def SmoothDisplacementFieldOff(self):
        r"""
        SmoothDisplacementFieldOff(SymmetricForcesDemonsRegistrationFilter self)


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SmoothDisplacementFieldOff(
            self
        )

    def GetSmoothDisplacementField(self):
        r"""
        GetSmoothDisplacementField(SymmetricForcesDemonsRegistrationFilter self) -> bool


        Set/Get whether the displacement field is smoothed (regularized).
        Smoothing the displacement yields a solution elastic in nature. If
        SmoothDisplacementField is on, then the displacement field is smoothed
        with a Gaussian whose standard deviations are specified with SetStandardDeviations()


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetSmoothDisplacementField(
            self
        )

    def SetSmoothUpdateField(self, SmoothUpdateField):
        r"""
        SetSmoothUpdateField(SymmetricForcesDemonsRegistrationFilter self, bool SmoothUpdateField)


        Set/Get whether the update field is smoothed (regularized). Smoothing
        the update field yields a solution viscous in nature. If
        SmoothUpdateField is on, then the update field is smoothed with a
        Gaussian whose standard deviations are specified with SetUpdateFieldStandardDeviations()


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SetSmoothUpdateField(
            self, SmoothUpdateField
        )

    def SmoothUpdateFieldOn(self):
        r"""
        SmoothUpdateFieldOn(SymmetricForcesDemonsRegistrationFilter self)


        Set the value of SmoothUpdateField to true or false respectfully.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SmoothUpdateFieldOn(
            self
        )

    def SmoothUpdateFieldOff(self):
        r"""
        SmoothUpdateFieldOff(SymmetricForcesDemonsRegistrationFilter self)


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SmoothUpdateFieldOff(
            self
        )

    def GetSmoothUpdateField(self):
        r"""
        GetSmoothUpdateField(SymmetricForcesDemonsRegistrationFilter self) -> bool


        Set/Get whether the update field is smoothed (regularized). Smoothing
        the update field yields a solution viscous in nature. If
        SmoothUpdateField is on, then the update field is smoothed with a
        Gaussian whose standard deviations are specified with SetUpdateFieldStandardDeviations()


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetSmoothUpdateField(
            self
        )

    def SetUpdateFieldStandardDeviations(self, *args):
        r"""
        SetUpdateFieldStandardDeviations(SymmetricForcesDemonsRegistrationFilter self, VectorDouble UpdateFieldStandardDeviations)
        SetUpdateFieldStandardDeviations(SymmetricForcesDemonsRegistrationFilter self, double value)


        Set the Gaussian smoothing standard deviations for the update field.
        The values are set with respect to pixel coordinates.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SetUpdateFieldStandardDeviations(
            self, *args
        )

    def GetUpdateFieldStandardDeviations(self):
        r"""
        GetUpdateFieldStandardDeviations(SymmetricForcesDemonsRegistrationFilter self) -> VectorDouble


        Set the Gaussian smoothing standard deviations for the update field.
        The values are set with respect to pixel coordinates.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetUpdateFieldStandardDeviations(
            self
        )

    def SetMaximumKernelWidth(self, MaximumKernelWidth):
        r"""
        SetMaximumKernelWidth(SymmetricForcesDemonsRegistrationFilter self, unsigned int MaximumKernelWidth)


        Set/Get the desired limits of the Gaussian kernel width.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SetMaximumKernelWidth(
            self, MaximumKernelWidth
        )

    def GetMaximumKernelWidth(self):
        r"""
        GetMaximumKernelWidth(SymmetricForcesDemonsRegistrationFilter self) -> unsigned int


        Set/Get the desired limits of the Gaussian kernel width.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetMaximumKernelWidth(
            self
        )

    def SetMaximumError(self, MaximumError):
        r"""
        SetMaximumError(SymmetricForcesDemonsRegistrationFilter self, double MaximumError)


        Set/Get the desired maximum error of the Guassian kernel approximate.


        """
        return (
            _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SetMaximumError(
                self, MaximumError
            )
        )

    def GetMaximumError(self):
        r"""
        GetMaximumError(SymmetricForcesDemonsRegistrationFilter self) -> double


        Set/Get the desired maximum error of the Guassian kernel approximate.


        """
        return (
            _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetMaximumError(
                self
            )
        )

    def SetIntensityDifferenceThreshold(self, IntensityDifferenceThreshold):
        r"""
        SetIntensityDifferenceThreshold(SymmetricForcesDemonsRegistrationFilter self, double IntensityDifferenceThreshold)


        Set/Get the threshold below which the absolute difference of intensity
        yields a match. When the intensities match between a moving and fixed
        image pixel, the update vector (for that iteration) will be the zero
        vector. Default is 0.001.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SetIntensityDifferenceThreshold(
            self, IntensityDifferenceThreshold
        )

    def GetIntensityDifferenceThreshold(self):
        r"""
        GetIntensityDifferenceThreshold(SymmetricForcesDemonsRegistrationFilter self) -> double


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetIntensityDifferenceThreshold(
            self
        )

    def SetUseImageSpacing(self, UseImageSpacing):
        r"""
        SetUseImageSpacing(SymmetricForcesDemonsRegistrationFilter self, bool UseImageSpacing)


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SetUseImageSpacing(
            self, UseImageSpacing
        )

    def UseImageSpacingOn(self):
        r"""
        UseImageSpacingOn(SymmetricForcesDemonsRegistrationFilter self)


        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_UseImageSpacingOn(
            self
        )

    def UseImageSpacingOff(self):
        r"""
        UseImageSpacingOff(SymmetricForcesDemonsRegistrationFilter self)


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_UseImageSpacingOff(
            self
        )

    def GetUseImageSpacing(self):
        r"""
        GetUseImageSpacing(SymmetricForcesDemonsRegistrationFilter self) -> bool


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetUseImageSpacing(
            self
        )

    def GetElapsedIterations(self):
        r"""
        GetElapsedIterations(SymmetricForcesDemonsRegistrationFilter self) -> uint32_t


        Number of iterations run.


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetElapsedIterations(
            self
        )

    def GetRMSChange(self):
        r"""
        GetRMSChange(SymmetricForcesDemonsRegistrationFilter self) -> double


        Set/Get the root mean squared change of the previous iteration. May
        not be used by all solvers.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetRMSChange(
            self
        )

    def GetMetric(self):
        r"""
        GetMetric(SymmetricForcesDemonsRegistrationFilter self) -> double


        Get the metric value. The metric value is the mean square difference
        in intensity between the fixed image and transforming moving image
        computed over the overlapping region between the two images. This
        value is calculated for the current iteration

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetMetric(
            self
        )

    def StopRegistration(self):
        r"""
        StopRegistration(SymmetricForcesDemonsRegistrationFilter self)


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_StopRegistration(
            self
        )

    def GetName(self):
        r"""
        GetName(SymmetricForcesDemonsRegistrationFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(SymmetricForcesDemonsRegistrationFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(SymmetricForcesDemonsRegistrationFilter self, Image fixedImage, Image movingImage, Image initialDisplacementField) -> Image
        Execute(SymmetricForcesDemonsRegistrationFilter self, Image fixedImage, Image movingImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_Execute(
            self, *args
        )


# Register SymmetricForcesDemonsRegistrationFilter in _SimpleITK:
_SimpleITK.SymmetricForcesDemonsRegistrationFilter_swigregister(
    SymmetricForcesDemonsRegistrationFilter
)


class TanImageFilter(ImageFilter):
    r"""


    Computes the tangent of each input pixel.


    The computations are performed using std::tan(x).
    See:
     itk::simple::Tan for the procedural interface

     itk::TanImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkTanImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_TanImageFilter

    def __init__(self):
        r"""
        __init__(TanImageFilter self) -> TanImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.TanImageFilter_swiginit(
            self, _SimpleITK.new_TanImageFilter()
        )

    def GetName(self):
        r"""
        GetName(TanImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.TanImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(TanImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.TanImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(TanImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.TanImageFilter_Execute(self, image1)


# Register TanImageFilter in _SimpleITK:
_SimpleITK.TanImageFilter_swigregister(TanImageFilter)


def Tan(image1):
    r"""Tan(Image image1) -> Image"""
    return _SimpleITK.Tan(image1)


class TernaryAddImageFilter(ImageFilter):
    r"""


    Pixel-wise addition of three images.


    This class is templated over the types of the three input images and
    the type of the output image. Numeric conversions (castings) are done
    by the C++ defaults.
    See:
     itk::simple::TernaryAdd for the procedural interface

     itk::TernaryAddImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkTernaryAddImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_TernaryAddImageFilter

    def __init__(self):
        r"""
        __init__(TernaryAddImageFilter self) -> TernaryAddImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.TernaryAddImageFilter_swiginit(
            self, _SimpleITK.new_TernaryAddImageFilter()
        )

    def GetName(self):
        r"""
        GetName(TernaryAddImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.TernaryAddImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(TernaryAddImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.TernaryAddImageFilter___str__(self)

    def Execute(self, image1, image2, image3):
        r"""
        Execute(TernaryAddImageFilter self, Image image1, Image image2, Image image3) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.TernaryAddImageFilter_Execute(
            self, image1, image2, image3
        )


# Register TernaryAddImageFilter in _SimpleITK:
_SimpleITK.TernaryAddImageFilter_swigregister(TernaryAddImageFilter)


def TernaryAdd(image1, image2, image3):
    r"""TernaryAdd(Image image1, Image image2, Image image3) -> Image"""
    return _SimpleITK.TernaryAdd(image1, image2, image3)


class TernaryMagnitudeImageFilter(ImageFilter):
    r"""


    Compute the pixel-wise magnitude of three images.


    This class is templated over the types of the three input images and
    the type of the output image. Numeric conversions (castings) are done
    by the C++ defaults.
    See:
     itk::simple::TernaryMagnitude for the procedural interface

     itk::TernaryMagnitudeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkTernaryMagnitudeImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_TernaryMagnitudeImageFilter

    def __init__(self):
        r"""
        __init__(TernaryMagnitudeImageFilter self) -> TernaryMagnitudeImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.TernaryMagnitudeImageFilter_swiginit(
            self, _SimpleITK.new_TernaryMagnitudeImageFilter()
        )

    def GetName(self):
        r"""
        GetName(TernaryMagnitudeImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.TernaryMagnitudeImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(TernaryMagnitudeImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.TernaryMagnitudeImageFilter___str__(self)

    def Execute(self, image1, image2, image3):
        r"""
        Execute(TernaryMagnitudeImageFilter self, Image image1, Image image2, Image image3) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.TernaryMagnitudeImageFilter_Execute(
            self, image1, image2, image3
        )


# Register TernaryMagnitudeImageFilter in _SimpleITK:
_SimpleITK.TernaryMagnitudeImageFilter_swigregister(
    TernaryMagnitudeImageFilter
)


def TernaryMagnitude(image1, image2, image3):
    r"""TernaryMagnitude(Image image1, Image image2, Image image3) -> Image"""
    return _SimpleITK.TernaryMagnitude(image1, image2, image3)


class TernaryMagnitudeSquaredImageFilter(ImageFilter):
    r"""


    Compute the pixel-wise squared magnitude of three images.


    This class is templated over the types of the three input images and
    the type of the output image. Numeric conversions (castings) are done
    by the C++ defaults.
    See:
     itk::simple::TernaryMagnitudeSquared for the procedural interface

     itk::TernaryMagnitudeSquaredImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkTernaryMagnitudeSquaredImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_TernaryMagnitudeSquaredImageFilter

    def __init__(self):
        r"""
        __init__(TernaryMagnitudeSquaredImageFilter self) -> TernaryMagnitudeSquaredImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.TernaryMagnitudeSquaredImageFilter_swiginit(
            self, _SimpleITK.new_TernaryMagnitudeSquaredImageFilter()
        )

    def GetName(self):
        r"""
        GetName(TernaryMagnitudeSquaredImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.TernaryMagnitudeSquaredImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(TernaryMagnitudeSquaredImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.TernaryMagnitudeSquaredImageFilter___str__(self)

    def Execute(self, image1, image2, image3):
        r"""
        Execute(TernaryMagnitudeSquaredImageFilter self, Image image1, Image image2, Image image3) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.TernaryMagnitudeSquaredImageFilter_Execute(
            self, image1, image2, image3
        )


# Register TernaryMagnitudeSquaredImageFilter in _SimpleITK:
_SimpleITK.TernaryMagnitudeSquaredImageFilter_swigregister(
    TernaryMagnitudeSquaredImageFilter
)


def TernaryMagnitudeSquared(image1, image2, image3):
    r"""TernaryMagnitudeSquared(Image image1, Image image2, Image image3) -> Image"""
    return _SimpleITK.TernaryMagnitudeSquared(image1, image2, image3)


class ThresholdImageFilter(ImageFilter):
    r"""


    Set image values to a user-specified value if they are below, above,
    or outside threshold values.


    ThresholdImageFilter sets image values to a user-specified "outside" value (by default,
    zero) if the image values are below, above, or outside threshold
    values.

    The available methods are:

    ThresholdAbove() : The values greater than the threshold value are set to OutsideValue

    ThresholdBelow() : The values less than the threshold value are set to OutsideValue

    ThresholdOutside() : The values outside the threshold range (less than lower or greater
    than upper) are set to OutsideValue

    Note that these definitions indicate that pixels equal to the
    threshold value are not set to OutsideValue in any of these methods

    The pixels must support the operators >= and <=.
    See:
     itk::simple::Threshold for the procedural interface

     itk::ThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkThresholdImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ThresholdImageFilter

    def __init__(self):
        r"""
        __init__(ThresholdImageFilter self) -> ThresholdImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ThresholdImageFilter_swiginit(
            self, _SimpleITK.new_ThresholdImageFilter()
        )

    def SetLower(self, Lower):
        r"""
        SetLower(ThresholdImageFilter self, double Lower)


        Set/Get methods to set the lower threshold.


        """
        return _SimpleITK.ThresholdImageFilter_SetLower(self, Lower)

    def GetLower(self):
        r"""
        GetLower(ThresholdImageFilter self) -> double


        Set/Get methods to set the lower threshold.


        """
        return _SimpleITK.ThresholdImageFilter_GetLower(self)

    def SetUpper(self, Upper):
        r"""
        SetUpper(ThresholdImageFilter self, double Upper)


        Set/Get methods to set the upper threshold.


        """
        return _SimpleITK.ThresholdImageFilter_SetUpper(self, Upper)

    def GetUpper(self):
        r"""
        GetUpper(ThresholdImageFilter self) -> double


        Set/Get methods to set the upper threshold.


        """
        return _SimpleITK.ThresholdImageFilter_GetUpper(self)

    def SetOutsideValue(self, OutsideValue):
        r"""
        SetOutsideValue(ThresholdImageFilter self, double OutsideValue)


        The pixel type must support comparison operators. Set the "outside"
        pixel value. The default value NumericTraits<PixelType>::ZeroValue() .


        """
        return _SimpleITK.ThresholdImageFilter_SetOutsideValue(
            self, OutsideValue
        )

    def GetOutsideValue(self):
        r"""
        GetOutsideValue(ThresholdImageFilter self) -> double


        Get the "outside" pixel value.


        """
        return _SimpleITK.ThresholdImageFilter_GetOutsideValue(self)

    def GetName(self):
        r"""
        GetName(ThresholdImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ThresholdImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ThresholdImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ThresholdImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ThresholdImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ThresholdImageFilter_Execute(self, image1)

    def ThresholdAbove(self, threshold):
        r"""
        ThresholdAbove(ThresholdImageFilter self, double threshold)


        """
        return _SimpleITK.ThresholdImageFilter_ThresholdAbove(self, threshold)

    def ThresholdBelow(self, threshold):
        r"""
        ThresholdBelow(ThresholdImageFilter self, double threshold)


        """
        return _SimpleITK.ThresholdImageFilter_ThresholdBelow(self, threshold)

    def ThresholdOutside(self, lower, upper):
        r"""
        ThresholdOutside(ThresholdImageFilter self, double lower, double upper)


        """
        return _SimpleITK.ThresholdImageFilter_ThresholdOutside(
            self, lower, upper
        )


# Register ThresholdImageFilter in _SimpleITK:
_SimpleITK.ThresholdImageFilter_swigregister(ThresholdImageFilter)


def Threshold(image1, lower=0.0, upper=1.0, outsideValue=0.0):
    r"""Threshold(Image image1, double lower=0.0, double upper=1.0, double outsideValue=0.0) -> Image"""
    return _SimpleITK.Threshold(image1, lower, upper, outsideValue)


class ThresholdMaximumConnectedComponentsImageFilter(ImageFilter):
    r"""


    Finds the threshold value of an image based on maximizing the number
    of objects in the image that are larger than a given minimal size.



    This method is based on Topological Stable State Thresholding to
    calculate the threshold set point. This method is particularly
    effective when there are a large number of objects in a microscopy
    image. Compiling in Debug mode and enable the debug flag for this
    filter to print debug information to see how the filter focuses in on
    a threshold value. Please see the Insight Journal's MICCAI 2005
    workshop for a complete description. References are below.
    Parameters
    The MinimumObjectSizeInPixels parameter is controlled through the
    class Get/SetMinimumObjectSizeInPixels() method. Similar to the
    standard itk::BinaryThresholdImageFilter the Get/SetInside and Get/SetOutside values of the threshold can be
    set. The GetNumberOfObjects() and GetThresholdValue() methods return
    the number of objects above the minimum pixel size and the calculated
    threshold value.
    Automatic Thresholding in ITK
    There are multiple methods to automatically calculate the threshold
    intensity value of an image. As of version 4.0, ITK has a Thresholding
    ( ITKThresholding ) module which contains numerous automatic
    thresholding methods.implements two of these. Topological Stable State
    Thresholding works well on images with a large number of objects to be
    counted.
    References:
    1) Urish KL, August J, Huard J. "Unsupervised segmentation for
    myofiber counting in immunofluorescent microscopy images". Insight
    Journal. ISC/NA-MIC/MICCAI Workshop on Open-Source Software (2005) https://doi.org/10.54294/h1vbsl 2) Pikaz A, Averbuch, A. "Digital image thresholding based on
    topological stable-state". Pattern Recognition, 29(5): 829-843, 1996.

    Questions: email Ken Urish at ken.urish(at)gmail.com Please cc the itk
    list serve for archival purposes.

    See:
     itk::simple::ThresholdMaximumConnectedComponents for the procedural interface

     itk::ThresholdMaximumConnectedComponentsImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkThresholdMaximumConnectedComponentsImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_ThresholdMaximumConnectedComponentsImageFilter
    )

    def __init__(self):
        r"""
        __init__(ThresholdMaximumConnectedComponentsImageFilter self) -> ThresholdMaximumConnectedComponentsImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_swiginit(
            self,
            _SimpleITK.new_ThresholdMaximumConnectedComponentsImageFilter(),
        )

    def SetMinimumObjectSizeInPixels(self, MinimumObjectSizeInPixels):
        r"""
        SetMinimumObjectSizeInPixels(ThresholdMaximumConnectedComponentsImageFilter self, uint32_t MinimumObjectSizeInPixels)


        The pixel type must support comparison operators. Set the minimum
        pixel area used to count objects on the image. Thus, only objects that
        have a pixel area greater than the minimum pixel area will be counted
        as an object in the optimization portion of this filter. Essentially,
        it eliminates noise from being counted as an object. The default value
        is zero.


        """
        return _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_SetMinimumObjectSizeInPixels(
            self, MinimumObjectSizeInPixels
        )

    def GetMinimumObjectSizeInPixels(self):
        r"""
        GetMinimumObjectSizeInPixels(ThresholdMaximumConnectedComponentsImageFilter self) -> uint32_t


        The pixel type must support comparison operators. Set the minimum
        pixel area used to count objects on the image. Thus, only objects that
        have a pixel area greater than the minimum pixel area will be counted
        as an object in the optimization portion of this filter. Essentially,
        it eliminates noise from being counted as an object. The default value
        is zero.


        """
        return _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_GetMinimumObjectSizeInPixels(
            self
        )

    def SetUpperBoundary(self, UpperBoundary):
        r"""
        SetUpperBoundary(ThresholdMaximumConnectedComponentsImageFilter self, double UpperBoundary)


        The following Set/Get methods are for the binary threshold function.
        This class automatically calculates the lower threshold boundary. The
        upper threshold boundary, inside value, and outside value can be
        defined by the user, however the standard values are used as default
        if not set by the user. The default value of the: Inside value is the
        maximum pixel type intensity. Outside value is the minimum pixel type
        intensity. Upper threshold boundary is the maximum pixel type
        intensity.


        """
        return _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_SetUpperBoundary(
            self, UpperBoundary
        )

    def GetUpperBoundary(self):
        r"""
        GetUpperBoundary(ThresholdMaximumConnectedComponentsImageFilter self) -> double


        The following Set/Get methods are for the binary threshold function.
        This class automatically calculates the lower threshold boundary. The
        upper threshold boundary, inside value, and outside value can be
        defined by the user, however the standard values are used as default
        if not set by the user. The default value of the: Inside value is the
        maximum pixel type intensity. Outside value is the minimum pixel type
        intensity. Upper threshold boundary is the maximum pixel type
        intensity.


        """
        return _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_GetUpperBoundary(
            self
        )

    def SetInsideValue(self, InsideValue):
        r"""
        SetInsideValue(ThresholdMaximumConnectedComponentsImageFilter self, uint8_t InsideValue)


        The following Set/Get methods are for the binary threshold function.
        This class automatically calculates the lower threshold boundary. The
        upper threshold boundary, inside value, and outside value can be
        defined by the user, however the standard values are used as default
        if not set by the user. The default value of the: Inside value is the
        maximum pixel type intensity. Outside value is the minimum pixel type
        intensity. Upper threshold boundary is the maximum pixel type
        intensity.


        """
        return _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_SetInsideValue(
            self, InsideValue
        )

    def GetInsideValue(self):
        r"""
        GetInsideValue(ThresholdMaximumConnectedComponentsImageFilter self) -> uint8_t


        The following Set/Get methods are for the binary threshold function.
        This class automatically calculates the lower threshold boundary. The
        upper threshold boundary, inside value, and outside value can be
        defined by the user, however the standard values are used as default
        if not set by the user. The default value of the: Inside value is the
        maximum pixel type intensity. Outside value is the minimum pixel type
        intensity. Upper threshold boundary is the maximum pixel type
        intensity.


        """
        return _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_GetInsideValue(
            self
        )

    def SetOutsideValue(self, OutsideValue):
        r"""
        SetOutsideValue(ThresholdMaximumConnectedComponentsImageFilter self, uint8_t OutsideValue)


        The following Set/Get methods are for the binary threshold function.
        This class automatically calculates the lower threshold boundary. The
        upper threshold boundary, inside value, and outside value can be
        defined by the user, however the standard values are used as default
        if not set by the user. The default value of the: Inside value is the
        maximum pixel type intensity. Outside value is the minimum pixel type
        intensity. Upper threshold boundary is the maximum pixel type
        intensity.


        """
        return _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_SetOutsideValue(
            self, OutsideValue
        )

    def GetOutsideValue(self):
        r"""
        GetOutsideValue(ThresholdMaximumConnectedComponentsImageFilter self) -> uint8_t


        The following Set/Get methods are for the binary threshold function.
        This class automatically calculates the lower threshold boundary. The
        upper threshold boundary, inside value, and outside value can be
        defined by the user, however the standard values are used as default
        if not set by the user. The default value of the: Inside value is the
        maximum pixel type intensity. Outside value is the minimum pixel type
        intensity. Upper threshold boundary is the maximum pixel type
        intensity.


        """
        return _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_GetOutsideValue(
            self
        )

    def GetName(self):
        r"""
        GetName(ThresholdMaximumConnectedComponentsImageFilter self) -> std::string


        Name of this class


        """
        return (
            _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_GetName(
                self
            )
        )

    def __str__(self):
        r"""
        __str__(ThresholdMaximumConnectedComponentsImageFilter self) -> std::string


        Print ourselves out


        """
        return (
            _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter___str__(
                self
            )
        )

    def Execute(self, image1):
        r"""
        Execute(ThresholdMaximumConnectedComponentsImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return (
            _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_Execute(
                self, image1
            )
        )


# Register ThresholdMaximumConnectedComponentsImageFilter in _SimpleITK:
_SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_swigregister(
    ThresholdMaximumConnectedComponentsImageFilter
)


def ThresholdMaximumConnectedComponents(*args, **kwargs):
    r"""ThresholdMaximumConnectedComponents(Image image1, uint32_t minimumObjectSizeInPixels=0, double upperBoundary=std::numeric_limits< double >::max(), uint8_t insideValue=1, uint8_t outsideValue=0) -> Image"""
    return _SimpleITK.ThresholdMaximumConnectedComponents(*args, **kwargs)


class ThresholdSegmentationLevelSetImageFilter(ImageFilter):
    r"""


    Segments structures in images based on intensity values.


    IMPORTANT
    The SegmentationLevelSetImageFilter class and the ThresholdSegmentationLevelSetFunction class contain additional information necessary to the full
    understanding of how to use this filter.
    OVERVIEW
    This class is a level set method segmentation filter. It constructs a
    speed function which is close to zero at the upper and lower bounds of
    an intensity window, effectively locking the propagating front onto
    those edges. Elsewhere, the front will propagate quickly.
    INPUTS
    This filter requires two inputs. The first input is a seed image. This
    seed image must contain an isosurface that you want to use as the seed
    for your segmentation. It can be a binary, graylevel, or floating
    point image. The only requirement is that it contain a closed
    isosurface that you will identify as the seed by setting the
    IsosurfaceValue parameter of the filter. For a binary image you will
    want to set your isosurface value halfway between your on and off
    values (i.e. for 0's and 1's, use an isosurface value of 0.5).

    The second input is the feature image. This is the image from which
    the speed function will be calculated. For most applications, this is
    the image that you want to segment. The desired isosurface in your
    seed image should lie within the region of your feature image that you
    are trying to segment. Note that this filter does no preprocessing of
    the feature image before thresholding.

    See SegmentationLevelSetImageFilter for more information on Inputs.
    OUTPUTS
    The filter outputs a single, scalar, real-valued image. Positive
    values in the output image are inside the segmented region and
    negative values in the image are outside of the inside region. The
    zero crossings of the image correspond to the position of the level
    set front.

    See SparseFieldLevelSetImageFilter and SegmentationLevelSetImageFilter for more information.
    PARAMETERS
    In addition to parameters described in SegmentationLevelSetImageFilter , this filter adds the UpperThreshold and LowerThreshold. See ThresholdSegmentationLevelSetFunction for a description of how these values affect the segmentation.

    See:
     SegmentationLevelSetImageFilter

     ThresholdSegmentationLevelSetFunction ,

     SparseFieldLevelSetImageFilter

     itk::simple::ThresholdSegmentationLevelSet for the procedural interface

     itk::ThresholdSegmentationLevelSetImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkThresholdSegmentationLevelSetImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_ThresholdSegmentationLevelSetImageFilter
    )

    def __init__(self):
        r"""
        __init__(ThresholdSegmentationLevelSetImageFilter self) -> ThresholdSegmentationLevelSetImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ThresholdSegmentationLevelSetImageFilter_swiginit(
            self, _SimpleITK.new_ThresholdSegmentationLevelSetImageFilter()
        )

    def SetLowerThreshold(self, LowerThreshold):
        r"""
        SetLowerThreshold(ThresholdSegmentationLevelSetImageFilter self, double LowerThreshold)


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_SetLowerThreshold(
            self, LowerThreshold
        )

    def GetLowerThreshold(self):
        r"""
        GetLowerThreshold(ThresholdSegmentationLevelSetImageFilter self) -> double


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_GetLowerThreshold(
            self
        )

    def SetUpperThreshold(self, UpperThreshold):
        r"""
        SetUpperThreshold(ThresholdSegmentationLevelSetImageFilter self, double UpperThreshold)


        Get/Set the threshold values that will be used to calculate the speed
        function.


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_SetUpperThreshold(
            self, UpperThreshold
        )

    def GetUpperThreshold(self):
        r"""
        GetUpperThreshold(ThresholdSegmentationLevelSetImageFilter self) -> double


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_GetUpperThreshold(
            self
        )

    def SetMaximumRMSError(self, MaximumRMSError):
        r"""
        SetMaximumRMSError(ThresholdSegmentationLevelSetImageFilter self, double MaximumRMSError)


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_SetMaximumRMSError(
            self, MaximumRMSError
        )

    def GetMaximumRMSError(self):
        r"""
        GetMaximumRMSError(ThresholdSegmentationLevelSetImageFilter self) -> double


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_GetMaximumRMSError(
            self
        )

    def SetPropagationScaling(self, PropagationScaling):
        r"""
        SetPropagationScaling(ThresholdSegmentationLevelSetImageFilter self, double PropagationScaling)


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_SetPropagationScaling(
            self, PropagationScaling
        )

    def GetPropagationScaling(self):
        r"""
        GetPropagationScaling(ThresholdSegmentationLevelSetImageFilter self) -> double


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_GetPropagationScaling(
            self
        )

    def SetCurvatureScaling(self, CurvatureScaling):
        r"""
        SetCurvatureScaling(ThresholdSegmentationLevelSetImageFilter self, double CurvatureScaling)


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_SetCurvatureScaling(
            self, CurvatureScaling
        )

    def GetCurvatureScaling(self):
        r"""
        GetCurvatureScaling(ThresholdSegmentationLevelSetImageFilter self) -> double


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_GetCurvatureScaling(
            self
        )

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(ThresholdSegmentationLevelSetImageFilter self, uint32_t NumberOfIterations)


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(ThresholdSegmentationLevelSetImageFilter self) -> uint32_t


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_GetNumberOfIterations(
            self
        )

    def SetReverseExpansionDirection(self, ReverseExpansionDirection):
        r"""
        SetReverseExpansionDirection(ThresholdSegmentationLevelSetImageFilter self, bool ReverseExpansionDirection)


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_SetReverseExpansionDirection(
            self, ReverseExpansionDirection
        )

    def ReverseExpansionDirectionOn(self):
        r"""
        ReverseExpansionDirectionOn(ThresholdSegmentationLevelSetImageFilter self)


        Set the value of ReverseExpansionDirection to true or false
        respectfully.


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_ReverseExpansionDirectionOn(
            self
        )

    def ReverseExpansionDirectionOff(self):
        r"""
        ReverseExpansionDirectionOff(ThresholdSegmentationLevelSetImageFilter self)


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_ReverseExpansionDirectionOff(
            self
        )

    def GetReverseExpansionDirection(self):
        r"""
        GetReverseExpansionDirection(ThresholdSegmentationLevelSetImageFilter self) -> bool


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_GetReverseExpansionDirection(
            self
        )

    def GetElapsedIterations(self):
        r"""
        GetElapsedIterations(ThresholdSegmentationLevelSetImageFilter self) -> uint32_t


        Number of iterations run.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_GetElapsedIterations(
            self
        )

    def GetRMSChange(self):
        r"""
        GetRMSChange(ThresholdSegmentationLevelSetImageFilter self) -> double


        The Root Mean Square of the levelset upon termination.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return (
            _SimpleITK.ThresholdSegmentationLevelSetImageFilter_GetRMSChange(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(ThresholdSegmentationLevelSetImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(ThresholdSegmentationLevelSetImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter___str__(
            self
        )

    def Execute(self, initialImage, featureImage):
        r"""
        Execute(ThresholdSegmentationLevelSetImageFilter self, Image initialImage, Image featureImage) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_Execute(
            self, initialImage, featureImage
        )


# Register ThresholdSegmentationLevelSetImageFilter in _SimpleITK:
_SimpleITK.ThresholdSegmentationLevelSetImageFilter_swigregister(
    ThresholdSegmentationLevelSetImageFilter
)


def ThresholdSegmentationLevelSet(
    initialImage,
    featureImage,
    lowerThreshold=0.0,
    upperThreshold=255.0,
    maximumRMSError=0.02,
    propagationScaling=1.0,
    curvatureScaling=1.0,
    numberOfIterations=1000,
    reverseExpansionDirection=False,
):
    r"""ThresholdSegmentationLevelSet(Image initialImage, Image featureImage, double lowerThreshold=0.0, double upperThreshold=255.0, double maximumRMSError=0.02, double propagationScaling=1.0, double curvatureScaling=1.0, uint32_t numberOfIterations=1000, bool reverseExpansionDirection=False) -> Image"""
    return _SimpleITK.ThresholdSegmentationLevelSet(
        initialImage,
        featureImage,
        lowerThreshold,
        upperThreshold,
        maximumRMSError,
        propagationScaling,
        curvatureScaling,
        numberOfIterations,
        reverseExpansionDirection,
    )


class TikhonovDeconvolutionImageFilter(ImageFilter):
    r"""


    An inverse deconvolution filter regularized in the Tikhonov sense.


    The Tikhonov deconvolution filter is the inverse deconvolution filter
    with a regularization term added to the denominator. The filter
    minimizes the equation \\[ ||\\hat{f} \\otimes h - g||_{L_2}^2 + \\mu||\\hat{f}||^2
    \\] where $\\hat{f}$ is the estimate of the unblurred image, $h$ is the blurring kernel, $g$ is the blurred image, and $\\mu$ is a non-negative real regularization function.

    The filter applies a kernel described in the Fourier domain as $H^*(\\omega) / (|H(\\omega)|^2 + \\mu)$ where $H(\\omega)$ is the Fourier transform of $h$ . The term $\\mu$ is called RegularizationConstant in this filter. If $\\mu$ is set to zero, this filter is equivalent to the InverseDeconvolutionImageFilter .


    Gaetan Lehmann, Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France

    Cory Quammen, The University of North Carolina at Chapel Hill

    See:
     itk::simple::TikhonovDeconvolution for the procedural interface

     itk::TikhonovDeconvolutionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkTikhonovDeconvolutionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_TikhonovDeconvolutionImageFilter

    def __init__(self):
        r"""
        __init__(TikhonovDeconvolutionImageFilter self) -> TikhonovDeconvolutionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.TikhonovDeconvolutionImageFilter_swiginit(
            self, _SimpleITK.new_TikhonovDeconvolutionImageFilter()
        )

    def SetRegularizationConstant(self, RegularizationConstant):
        r"""
        SetRegularizationConstant(TikhonovDeconvolutionImageFilter self, double RegularizationConstant)


        The regularization factor. Larger values reduce the dominance of noise
        in the solution, but results in higher approximation error in the
        deblurred image. Default value is 0.0, yielding the same results as
        the InverseDeconvolutionImageFilter .


        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_SetRegularizationConstant(
            self, RegularizationConstant
        )

    def GetRegularizationConstant(self):
        r"""
        GetRegularizationConstant(TikhonovDeconvolutionImageFilter self) -> double


        The regularization factor. Larger values reduce the dominance of noise
        in the solution, but results in higher approximation error in the
        deblurred image. Default value is 0.0, yielding the same results as
        the InverseDeconvolutionImageFilter .


        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_GetRegularizationConstant(
            self
        )

    def SetNormalize(self, Normalize):
        r"""
        SetNormalize(TikhonovDeconvolutionImageFilter self, bool Normalize)


        Normalize the output image by the sum of the kernel components


        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_SetNormalize(
            self, Normalize
        )

    def NormalizeOn(self):
        r"""
        NormalizeOn(TikhonovDeconvolutionImageFilter self)


        Set the value of Normalize to true or false respectfully.


        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_NormalizeOn(self)

    def NormalizeOff(self):
        r"""
        NormalizeOff(TikhonovDeconvolutionImageFilter self)


        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_NormalizeOff(self)

    def GetNormalize(self):
        r"""
        GetNormalize(TikhonovDeconvolutionImageFilter self) -> bool


        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_GetNormalize(self)

    ZERO_PAD = _SimpleITK.TikhonovDeconvolutionImageFilter_ZERO_PAD

    ZERO_FLUX_NEUMANN_PAD = (
        _SimpleITK.TikhonovDeconvolutionImageFilter_ZERO_FLUX_NEUMANN_PAD
    )

    PERIODIC_PAD = _SimpleITK.TikhonovDeconvolutionImageFilter_PERIODIC_PAD

    def SetBoundaryCondition(self, BoundaryCondition):
        r"""
        SetBoundaryCondition(TikhonovDeconvolutionImageFilter self, itk::simple::TikhonovDeconvolutionImageFilter::BoundaryConditionType BoundaryCondition)


        """
        return (
            _SimpleITK.TikhonovDeconvolutionImageFilter_SetBoundaryCondition(
                self, BoundaryCondition
            )
        )

    def GetBoundaryCondition(self):
        r"""
        GetBoundaryCondition(TikhonovDeconvolutionImageFilter self) -> itk::simple::TikhonovDeconvolutionImageFilter::BoundaryConditionType


        """
        return (
            _SimpleITK.TikhonovDeconvolutionImageFilter_GetBoundaryCondition(
                self
            )
        )

    SAME = _SimpleITK.TikhonovDeconvolutionImageFilter_SAME

    VALID = _SimpleITK.TikhonovDeconvolutionImageFilter_VALID

    def SetOutputRegionMode(self, OutputRegionMode):
        r"""
        SetOutputRegionMode(TikhonovDeconvolutionImageFilter self, itk::simple::TikhonovDeconvolutionImageFilter::OutputRegionModeType OutputRegionMode)


        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_SetOutputRegionMode(
            self, OutputRegionMode
        )

    def GetOutputRegionMode(self):
        r"""
        GetOutputRegionMode(TikhonovDeconvolutionImageFilter self) -> itk::simple::TikhonovDeconvolutionImageFilter::OutputRegionModeType


        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_GetOutputRegionMode(
            self
        )

    def GetName(self):
        r"""
        GetName(TikhonovDeconvolutionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(TikhonovDeconvolutionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter___str__(self)

    def Execute(self, image1, image2):
        r"""
        Execute(TikhonovDeconvolutionImageFilter self, Image image1, Image image2) -> Image


        Execute the filter on the input images


        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_Execute(
            self, image1, image2
        )


# Register TikhonovDeconvolutionImageFilter in _SimpleITK:
_SimpleITK.TikhonovDeconvolutionImageFilter_swigregister(
    TikhonovDeconvolutionImageFilter
)


def TikhonovDeconvolution(*args, **kwargs):
    r"""TikhonovDeconvolution(Image image1, Image image2, double regularizationConstant=0.0, bool normalize=False, itk::simple::TikhonovDeconvolutionImageFilter::BoundaryConditionType boundaryCondition=ZERO_FLUX_NEUMANN_PAD, itk::simple::TikhonovDeconvolutionImageFilter::OutputRegionModeType outputRegionMode=SAME) -> Image"""
    return _SimpleITK.TikhonovDeconvolution(*args, **kwargs)


class TileImageFilter(ImageFilter):
    r"""


    Tile multiple input images into a single output image.


    This filter will tile multiple images using a user-specified layout.
    The tile sizes will be large enough to accommodate the largest image
    for each tile. The layout is specified with the SetLayout method. The
    layout has the same dimension as the output image. If all entries of
    the layout are positive, the tiled output will contain the exact
    number of tiles. If the layout contains a 0 in the last dimension, the
    filter will compute a size that will accommodate all of the images.
    Empty tiles are filled with the value specified with the SetDefault
    value method. The input images must have a dimension less than or
    equal to the output image. The output image have a larger dimension
    than the input images. This filter can be used to create a volume from
    a series of inputs by specifying a layout of 1,1,0.


    See:
     itk::simple::Tile for the procedural interface


    C++ includes: sitkTileImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_TileImageFilter

    def __init__(self):
        r"""
        __init__(TileImageFilter self) -> TileImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.TileImageFilter_swiginit(
            self, _SimpleITK.new_TileImageFilter()
        )

    def SetLayout(self, Layout):
        r"""
        SetLayout(TileImageFilter self, VectorUInt32 Layout)


        Set/Get the layout of the tiles. If the last Layout value is 0, the
        filter will compute a value that will accommodate all of the images.


        """
        return _SimpleITK.TileImageFilter_SetLayout(self, Layout)

    def GetLayout(self):
        r"""
        GetLayout(TileImageFilter self) -> VectorUInt32


        Set/Get the layout of the tiles. If the last Layout value is 0, the
        filter will compute a value that will accommodate all of the images.


        """
        return _SimpleITK.TileImageFilter_GetLayout(self)

    def SetDefaultPixelValue(self, DefaultPixelValue):
        r"""
        SetDefaultPixelValue(TileImageFilter self, double DefaultPixelValue)


        Set the pixel value for locations that are not covered by an input
        image. The default default pixel value is Zero.


        """
        return _SimpleITK.TileImageFilter_SetDefaultPixelValue(
            self, DefaultPixelValue
        )

    def GetDefaultPixelValue(self):
        r"""
        GetDefaultPixelValue(TileImageFilter self) -> double


        Get the pixel value for locations that are not covered by an input
        image.


        """
        return _SimpleITK.TileImageFilter_GetDefaultPixelValue(self)

    def GetName(self):
        r"""
        GetName(TileImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.TileImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(TileImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.TileImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(TileImageFilter self, VectorOfImage images) -> Image
        Execute(TileImageFilter self, Image image1) -> Image
        Execute(TileImageFilter self, Image image1, Image image2) -> Image
        Execute(TileImageFilter self, Image image1, Image image2, Image image3) -> Image
        Execute(TileImageFilter self, Image image1, Image image2, Image image3, Image image4) -> Image
        Execute(TileImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5) -> Image


        Execute the filter on the input images


        """
        return _SimpleITK.TileImageFilter_Execute(self, *args)


# Register TileImageFilter in _SimpleITK:
_SimpleITK.TileImageFilter_swigregister(TileImageFilter)


def Tile(*args):
    r"""
    Tile(VectorOfImage images, VectorUInt32 layout=std::vector< uint32_t >(3, 100), double defaultPixelValue=0.0) -> Image
    Tile(Image image1, VectorUInt32 layout=std::vector< uint32_t >(3, 100), double defaultPixelValue=0.0) -> Image
    Tile(Image image1, Image image2, VectorUInt32 layout=std::vector< uint32_t >(3, 100), double defaultPixelValue=0.0) -> Image
    Tile(Image image1, Image image2, Image image3, VectorUInt32 layout=std::vector< uint32_t >(3, 100), double defaultPixelValue=0.0) -> Image
    Tile(Image image1, Image image2, Image image3, Image image4, VectorUInt32 layout=std::vector< uint32_t >(3, 100), double defaultPixelValue=0.0) -> Image
    Tile(Image image1, Image image2, Image image3, Image image4, Image image5, VectorUInt32 layout=std::vector< uint32_t >(3, 100), double defaultPixelValue=0.0) -> Image
    """
    return _SimpleITK.Tile(*args)


class TobogganImageFilter(ImageFilter):
    r"""


    toboggan image segmentation The Toboggan segmentation takes a gradient
    magnitude image as input and produces an (over-)segmentation of the
    image based on connecting each pixel to a local minimum of gradient.
    It is roughly equivalent to a watershed segmentation of the lowest
    level.


    The output is a 4 connected labeled map of the image.
    See:
     itk::simple::Toboggan for the procedural interface

     itk::TobogganImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkTobogganImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_TobogganImageFilter

    def __init__(self):
        r"""
        __init__(TobogganImageFilter self) -> TobogganImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.TobogganImageFilter_swiginit(
            self, _SimpleITK.new_TobogganImageFilter()
        )

    def GetName(self):
        r"""
        GetName(TobogganImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.TobogganImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(TobogganImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.TobogganImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(TobogganImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.TobogganImageFilter_Execute(self, image1)


# Register TobogganImageFilter in _SimpleITK:
_SimpleITK.TobogganImageFilter_swigregister(TobogganImageFilter)


def Toboggan(image1):
    r"""Toboggan(Image image1) -> Image"""
    return _SimpleITK.Toboggan(image1)


class TransformGeometryImageFilter(ImageFilter):
    r"""


    Modify an image's geometric meta-data, changing its "physical"
    extent.


    The TransformGeometryImageFilter "physically" changes the image in space using the given
    transformation. The resulting image is an image with the same voxel
    values as the input, but with different physical space representation
    as affected by the transform.

    The specific transformation type can be any type derived from the MatrixOffsetTransformBase and the TranslationTransform . The modification of the geometric meta-data is an alternative to
    resampling the moving image onto the fixed image grid, after
    registration. The advantages of using this approach over resampling
    are two-fold, it does not introduce artifacts into the result because
    the original intensity information is not modified, and it is
    computationally more efficient.

    When the filter is used with a rigid or translation transformation the
    resulting image can be saved in any desired format. When the filter is
    used with an affine transformation the resulting image should be saved
    in a format that supports a non ortho-normal direction cosine matrix
    (e.g. nrrd).

    Let us call the transform operation from the fixed image to moving
    image TfmF2M . Given a set of points from the fixed image in physical
    space (i.e. physicalFixedImagePoints ), the aim is to convert those
    points into the moving image physical space as
    physicalMovingImagePoints = TfmF2M( physicalFixedImagePoints ) , and
    then be able to get the image values as movingContinuousIndexPoints =
    movingImage->TransformPhysicalPointToContinuousIndex(
    physicalMovingImagePoints ) .

    We desire to change the moving image direction cosine $\\mathbf{D}$ and origin $\\mathbf{o}$ such that we can compute the moving image points as
    movingContinuousIndexPoints =
    newMovingImage->TransformPhysicalPointToContinuousIndex(
    physicalFixedImagePoints )

    Let us introduce the notation that will be used to formalize the
    transformation:


    Image-related parameters:

    $\\mathbf{D}$ : direction cosine matrix

    $\\mathbf{o}$ : origin vector

    $\\mathbf{S}$ : spacing

    $\\mathbf{ci}$ : continuous index

    $\\mathbf{D}^{'}$ : new direction cosine matrix

    $\\mathbf{o}^{'}$ : new origin vector

    Image content in corresponding space:

    $\\mathbf{f}_{p}$ : fixed image points in physical space

    $\\mathbf{m}_{p}$ : moving image points in physical space

    Rigid transform-related parameters:

    $\\mathbf{R}$ : rotation matrix

    $\\mathbf{c}$ : center of rotation vector

    $\\mathbf{t}$ : translation vector
     The TransformPhysicalPointToContinuousIndex method performs then:
    \\begin{eqnarray*} \\mathbf{ci} &=
    \\mathbf{S}^{-1}\\mathbf{D}^{-1}( \\mathbf{m}_{p} -
    \\mathbf{o} ) \\ \\mathbf{m}_{p} &=
    \\mathbf{R}(\\mathbf{f}_{p} - \\mathbf{c}) + \\mathbf{c} +
    \\mathbf{t} \\end{eqnarray*}

    After substitution:

    \\begin{eqnarray*} \\mathbf{m}_{c} &=
    \\underbrace{\\mathbf{R}^{-1}\\mathbf{D}}_\\text{new
    cosine}\\mathbf{S} * \\mathbf{i} +
    \\underbrace{\\mathbf{R}^{-1} * \\mathbf{o} - \\mathbf{R}^{-1}
    * \\mathbf{c} - \\mathbf{R}^{-1}*t}_\\text{new origin} +
    \\mathbf{c} \\ \\ \\mathbf{D}^{'} &=
    \\mathbf{R}^{-1}\\mathbf{D} \\ \\mathbf{o}^{'} &=
    \\mathbf{R}^{-1} * ( \\mathbf{o} - \\mathbf{c} - \\mathbf{t} )
    + \\mathbf{c} \\end{eqnarray*}
    See:
     itk::simple::TransformGeometry for the procedural interface

     itk::TransformGeometryImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkTransformGeometryImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_TransformGeometryImageFilter

    def __init__(self):
        r"""
        __init__(TransformGeometryImageFilter self) -> TransformGeometryImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.TransformGeometryImageFilter_swiginit(
            self, _SimpleITK.new_TransformGeometryImageFilter()
        )

    def GetName(self):
        r"""
        GetName(TransformGeometryImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.TransformGeometryImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(TransformGeometryImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.TransformGeometryImageFilter___str__(self)

    def Execute(self, image, transform):
        r"""
        Execute(TransformGeometryImageFilter self, Image image, Transform transform) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.TransformGeometryImageFilter_Execute(
            self, image, transform
        )


# Register TransformGeometryImageFilter in _SimpleITK:
_SimpleITK.TransformGeometryImageFilter_swigregister(
    TransformGeometryImageFilter
)


def TransformGeometry(image, transform):
    r"""TransformGeometry(Image image, Transform transform) -> Image"""
    return _SimpleITK.TransformGeometry(image, transform)


class TransformToDisplacementFieldFilter(ImageFilter):
    r"""


    Generate a displacement field from a coordinate transform.


    Output information (spacing, size and direction) for the output image
    should be set. This information has the normal defaults of unit
    spacing, zero origin and identity direction. Optionally, the output
    information can be obtained from a reference image. If the reference
    image is provided and UseReferenceImage is On, then the spacing,
    origin and direction of the reference image will be used.

    Since this filter produces an image which is a different size than its
    input, it needs to override several of the methods defined in ProcessObject in order to properly manage the pipeline execution model. In
    particular, this filter overrides ProcessObject::GenerateOutputInformation() .

    This filter is implemented as a multithreaded filter. It provides a
    ThreadedGenerateData() method for its implementation.


    Marius Staring, Leiden University Medical Center, The Netherlands.
     This class was taken from the Insight Journal paper: https://doi.org/10.54294/4ids6q
    See:
     itk::simple::TransformToDisplacementFieldFilter for the procedural interface

     itk::TransformToDisplacementFieldFilter for the Doxygen on the original ITK class.


    C++ includes: sitkTransformToDisplacementFieldFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_TransformToDisplacementFieldFilter

    def __init__(self):
        r"""
        __init__(TransformToDisplacementFieldFilter self) -> TransformToDisplacementFieldFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.TransformToDisplacementFieldFilter_swiginit(
            self, _SimpleITK.new_TransformToDisplacementFieldFilter()
        )

    def SetOutputPixelType(self, OutputPixelType):
        r"""
        SetOutputPixelType(TransformToDisplacementFieldFilter self, itk::simple::PixelIDValueEnum OutputPixelType)


        Set the output pixel type, only sitkVectorFloat32 and
        sitkVectorFloat64 are supported.


        """
        return (
            _SimpleITK.TransformToDisplacementFieldFilter_SetOutputPixelType(
                self, OutputPixelType
            )
        )

    def GetOutputPixelType(self):
        r"""
        GetOutputPixelType(TransformToDisplacementFieldFilter self) -> itk::simple::PixelIDValueEnum


        Get the ouput pixel type.


        """
        return (
            _SimpleITK.TransformToDisplacementFieldFilter_GetOutputPixelType(
                self
            )
        )

    def SetSize(self, Size):
        r"""
        SetSize(TransformToDisplacementFieldFilter self, VectorUInt32 Size)


        Set/Get the size of the output image.


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_SetSize(
            self, Size
        )

    def GetSize(self):
        r"""
        GetSize(TransformToDisplacementFieldFilter self) -> VectorUInt32


        Set/Get the size of the output image.


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_GetSize(self)

    def SetOutputOrigin(self, OutputOrigin):
        r"""
        SetOutputOrigin(TransformToDisplacementFieldFilter self, VectorDouble OutputOrigin)


        Set the output image origin.


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_SetOutputOrigin(
            self, OutputOrigin
        )

    def GetOutputOrigin(self):
        r"""
        GetOutputOrigin(TransformToDisplacementFieldFilter self) -> VectorDouble


        Get the output image origin.


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_GetOutputOrigin(
            self
        )

    def SetOutputSpacing(self, OutputSpacing):
        r"""
        SetOutputSpacing(TransformToDisplacementFieldFilter self, VectorDouble OutputSpacing)


        Set the output image spacing.


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_SetOutputSpacing(
            self, OutputSpacing
        )

    def GetOutputSpacing(self):
        r"""
        GetOutputSpacing(TransformToDisplacementFieldFilter self) -> VectorDouble


        Get the output image spacing.


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_GetOutputSpacing(
            self
        )

    def SetOutputDirection(self, OutputDirection):
        r"""
        SetOutputDirection(TransformToDisplacementFieldFilter self, VectorDouble OutputDirection)


        Set the output direction cosine matrix.


        """
        return (
            _SimpleITK.TransformToDisplacementFieldFilter_SetOutputDirection(
                self, OutputDirection
            )
        )

    def GetOutputDirection(self):
        r"""
        GetOutputDirection(TransformToDisplacementFieldFilter self) -> VectorDouble


        Set the output direction cosine matrix.


        """
        return (
            _SimpleITK.TransformToDisplacementFieldFilter_GetOutputDirection(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(TransformToDisplacementFieldFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(TransformToDisplacementFieldFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.TransformToDisplacementFieldFilter___str__(self)

    def Execute(self, transform):
        r"""
        Execute(TransformToDisplacementFieldFilter self, Transform transform) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_Execute(
            self, transform
        )

    def SetReferenceImage(self, refImage):
        r"""
        SetReferenceImage(TransformToDisplacementFieldFilter self, Image refImage)


        This methods sets the size, origin, spacing and direction to that of
        the provided image


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_SetReferenceImage(
            self, refImage
        )


# Register TransformToDisplacementFieldFilter in _SimpleITK:
_SimpleITK.TransformToDisplacementFieldFilter_swigregister(
    TransformToDisplacementFieldFilter
)


def TransformToDisplacementField(*args, **kwargs):
    r"""
    TransformToDisplacementField(Transform transform, itk::simple::PixelIDValueEnum outputPixelType=sitkVectorFloat64, VectorUInt32 size=std::vector< unsigned int >(3, 64), VectorDouble outputOrigin=std::vector< double >(3, 0.0), VectorDouble outputSpacing=std::vector< double >(3, 1.0), VectorDouble outputDirection=std::vector< double >()) -> Image


    Generate a displacement field from a coordinate transform.


    This function directly calls the execute method of TransformToDisplacementFieldFilter in order to support a procedural API


    See:
     itk::simple::TransformToDisplacementFieldFilter for the object oriented interface



    """
    return _SimpleITK.TransformToDisplacementField(*args, **kwargs)


class TriangleThresholdImageFilter(ImageFilter):
    r"""


    Threshold an image using the Triangle Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the TriangleThresholdCalculator and applies that threshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/efycla


    See:
     HistogramThresholdImageFilter

     itk::simple::TriangleThreshold for the procedural interface

     itk::TriangleThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkTriangleThresholdImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_TriangleThresholdImageFilter

    def __init__(self):
        r"""
        __init__(TriangleThresholdImageFilter self) -> TriangleThresholdImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.TriangleThresholdImageFilter_swiginit(
            self, _SimpleITK.new_TriangleThresholdImageFilter()
        )

    def SetInsideValue(self, InsideValue):
        r"""
        SetInsideValue(TriangleThresholdImageFilter self, uint8_t InsideValue)


        Set the "inside" pixel value.


        """
        return _SimpleITK.TriangleThresholdImageFilter_SetInsideValue(
            self, InsideValue
        )

    def GetInsideValue(self):
        r"""
        GetInsideValue(TriangleThresholdImageFilter self) -> uint8_t


        Get the "inside" pixel value.


        """
        return _SimpleITK.TriangleThresholdImageFilter_GetInsideValue(self)

    def SetOutsideValue(self, OutsideValue):
        r"""
        SetOutsideValue(TriangleThresholdImageFilter self, uint8_t OutsideValue)


        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.TriangleThresholdImageFilter_SetOutsideValue(
            self, OutsideValue
        )

    def GetOutsideValue(self):
        r"""
        GetOutsideValue(TriangleThresholdImageFilter self) -> uint8_t


        Get the "outside" pixel value.


        """
        return _SimpleITK.TriangleThresholdImageFilter_GetOutsideValue(self)

    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        r"""
        SetNumberOfHistogramBins(TriangleThresholdImageFilter self, uint32_t NumberOfHistogramBins)


        Set/Get the number of histogram bins.


        """
        return (
            _SimpleITK.TriangleThresholdImageFilter_SetNumberOfHistogramBins(
                self, NumberOfHistogramBins
            )
        )

    def GetNumberOfHistogramBins(self):
        r"""
        GetNumberOfHistogramBins(TriangleThresholdImageFilter self) -> uint32_t


        """
        return (
            _SimpleITK.TriangleThresholdImageFilter_GetNumberOfHistogramBins(
                self
            )
        )

    def SetMaskOutput(self, MaskOutput):
        r"""
        SetMaskOutput(TriangleThresholdImageFilter self, bool MaskOutput)


        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.TriangleThresholdImageFilter_SetMaskOutput(
            self, MaskOutput
        )

    def MaskOutputOn(self):
        r"""
        MaskOutputOn(TriangleThresholdImageFilter self)


        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.TriangleThresholdImageFilter_MaskOutputOn(self)

    def MaskOutputOff(self):
        r"""
        MaskOutputOff(TriangleThresholdImageFilter self)


        """
        return _SimpleITK.TriangleThresholdImageFilter_MaskOutputOff(self)

    def GetMaskOutput(self):
        r"""
        GetMaskOutput(TriangleThresholdImageFilter self) -> bool


        """
        return _SimpleITK.TriangleThresholdImageFilter_GetMaskOutput(self)

    def SetMaskValue(self, MaskValue):
        r"""
        SetMaskValue(TriangleThresholdImageFilter self, uint8_t MaskValue)


        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.TriangleThresholdImageFilter_SetMaskValue(
            self, MaskValue
        )

    def GetMaskValue(self):
        r"""
        GetMaskValue(TriangleThresholdImageFilter self) -> uint8_t


        """
        return _SimpleITK.TriangleThresholdImageFilter_GetMaskValue(self)

    def GetThreshold(self):
        r"""
        GetThreshold(TriangleThresholdImageFilter self) -> double


        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.TriangleThresholdImageFilter_GetThreshold(self)

    def GetName(self):
        r"""
        GetName(TriangleThresholdImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.TriangleThresholdImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(TriangleThresholdImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.TriangleThresholdImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(TriangleThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(TriangleThresholdImageFilter self, Image image) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.TriangleThresholdImageFilter_Execute(self, *args)


# Register TriangleThresholdImageFilter in _SimpleITK:
_SimpleITK.TriangleThresholdImageFilter_swigregister(
    TriangleThresholdImageFilter
)


def TriangleThreshold(*args):
    r"""
    TriangleThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    TriangleThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    """
    return _SimpleITK.TriangleThreshold(*args)


class UnaryMinusImageFilter(ImageFilter):
    r"""


    Implements pixel-wise generic operation on one image.


    This class is parameterized over the type of the input image and the
    type of the output image. It is also parameterized by the operation to
    be applied, using a Functor style.

    UnaryFunctorImageFilter allows the output dimension of the filter to be larger than the input
    dimension. Thus subclasses of the UnaryFunctorImageFilter (like the CastImageFilter ) can be used to promote a 2D image to a 3D image, etc.


    See:
     UnaryGeneratorImageFilter

     BinaryFunctorImageFilter TernaryFunctorImageFilter

     itk::simple::UnaryMinus for the procedural interface

     itk::UnaryFunctorImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkUnaryMinusImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_UnaryMinusImageFilter

    def __init__(self):
        r"""
        __init__(UnaryMinusImageFilter self) -> UnaryMinusImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.UnaryMinusImageFilter_swiginit(
            self, _SimpleITK.new_UnaryMinusImageFilter()
        )

    def GetName(self):
        r"""
        GetName(UnaryMinusImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.UnaryMinusImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(UnaryMinusImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.UnaryMinusImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(UnaryMinusImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.UnaryMinusImageFilter_Execute(self, image1)


# Register UnaryMinusImageFilter in _SimpleITK:
_SimpleITK.UnaryMinusImageFilter_swigregister(UnaryMinusImageFilter)


def UnaryMinus(image1):
    r"""UnaryMinus(Image image1) -> Image"""
    return _SimpleITK.UnaryMinus(image1)


class UnsharpMaskImageFilter(ImageFilter):
    r"""


    Edge enhancement filter.


    This filter subtracts a smoothed version of the image from the image
    to achieve the edge enhancing effect. https://en.wikipedia.org/w/index.php?title=Unsharp_masking&oldid=75048
    6803#Photographic_unsharp_masking

    It has configurable amount, radius (sigma) and threshold, and whether
    to clamp the resulting values to the range of output type.

    Formula: sharpened=original+[ itk::Math::abs (original-blurred)-threshold]*amount

    If clamping is turned off (it is on by default), casting to output
    pixel format is done using C++ defaults, meaning that values are not
    clamped but rather wrap around e.g. 260 -> 4 (unsigned char).


    See:
     ImageToImageFilter

     SmoothingRecursiveGaussianImageFilter

     RescaleIntensityImageFilter

     itk::simple::UnsharpMask for the procedural interface

     itk::UnsharpMaskImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkUnsharpMaskImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_UnsharpMaskImageFilter

    def __init__(self):
        r"""
        __init__(UnsharpMaskImageFilter self) -> UnsharpMaskImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.UnsharpMaskImageFilter_swiginit(
            self, _SimpleITK.new_UnsharpMaskImageFilter()
        )

    def SetSigmas(self, *args):
        r"""
        SetSigmas(UnsharpMaskImageFilter self, double s)
        SetSigmas(UnsharpMaskImageFilter self, VectorDouble Sigmas)


        Set/Get Sigma values measured in the units of image spacing. Default:
        1.0.


        """
        return _SimpleITK.UnsharpMaskImageFilter_SetSigmas(self, *args)

    def GetSigmas(self):
        r"""
        GetSigmas(UnsharpMaskImageFilter self) -> VectorDouble


        Set/Get Sigma values measured in the units of image spacing. Default:
        1.0.


        """
        return _SimpleITK.UnsharpMaskImageFilter_GetSigmas(self)

    def SetAmount(self, Amount):
        r"""
        SetAmount(UnsharpMaskImageFilter self, double Amount)


        Set/Get amount of enhancement. Usual range: 0.1 to 2.0. Default: 0.5.


        """
        return _SimpleITK.UnsharpMaskImageFilter_SetAmount(self, Amount)

    def GetAmount(self):
        r"""
        GetAmount(UnsharpMaskImageFilter self) -> double


        Set/Get amount of enhancement. Usual range: 0.1 to 2.0. Default: 0.5.


        """
        return _SimpleITK.UnsharpMaskImageFilter_GetAmount(self)

    def SetThreshold(self, Threshold):
        r"""
        SetThreshold(UnsharpMaskImageFilter self, double Threshold)


        Set/Get threshold for enhancement. Default: 0.


        """
        return _SimpleITK.UnsharpMaskImageFilter_SetThreshold(self, Threshold)

    def GetThreshold(self):
        r"""
        GetThreshold(UnsharpMaskImageFilter self) -> double


        Set/Get threshold for enhancement. Default: 0.


        """
        return _SimpleITK.UnsharpMaskImageFilter_GetThreshold(self)

    def SetClamp(self, Clamp):
        r"""
        SetClamp(UnsharpMaskImageFilter self, bool Clamp)


        Set/Get whether to clamp values to supported range of output type.
        Default: On.


        """
        return _SimpleITK.UnsharpMaskImageFilter_SetClamp(self, Clamp)

    def ClampOn(self):
        r"""
        ClampOn(UnsharpMaskImageFilter self)


        Set the value of Clamp to true or false respectfully.


        """
        return _SimpleITK.UnsharpMaskImageFilter_ClampOn(self)

    def ClampOff(self):
        r"""
        ClampOff(UnsharpMaskImageFilter self)


        """
        return _SimpleITK.UnsharpMaskImageFilter_ClampOff(self)

    def GetClamp(self):
        r"""
        GetClamp(UnsharpMaskImageFilter self) -> bool


        Set/Get whether to clamp values to supported range of output type.
        Default: On.


        """
        return _SimpleITK.UnsharpMaskImageFilter_GetClamp(self)

    def GetName(self):
        r"""
        GetName(UnsharpMaskImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.UnsharpMaskImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(UnsharpMaskImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.UnsharpMaskImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(UnsharpMaskImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.UnsharpMaskImageFilter_Execute(self, image1)


# Register UnsharpMaskImageFilter in _SimpleITK:
_SimpleITK.UnsharpMaskImageFilter_swigregister(UnsharpMaskImageFilter)


def UnsharpMask(*args, **kwargs):
    r"""UnsharpMask(Image image1, VectorDouble sigmas=std::vector< double >(3, 1.0), double amount=0.5, double threshold=0.0, bool clamp=True) -> Image"""
    return _SimpleITK.UnsharpMask(*args, **kwargs)


class ValuedRegionalMaximaImageFilter(ImageFilter):
    r"""


    Transforms the image so that any pixel that is not a regional maxima
    is set to the minimum value for the pixel type. Pixels that are
    regional maxima retain their value.


    Regional maxima are flat zones surrounded by pixels of lower value. A
    completely flat image will be marked as a regional maxima by this
    filter.

    This code was contributed in the Insight Journal paper: "Finding
    regional extrema - methods and performance" by Beare R., Lehmann G. https://doi.org/10.54294/hva3gz


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    See:
     ValuedRegionalMinimaImageFilter

     ValuedRegionalExtremaImageFilter

     HMinimaImageFilter

     itk::simple::ValuedRegionalMaxima for the procedural interface

     itk::ValuedRegionalMaximaImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkValuedRegionalMaximaImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ValuedRegionalMaximaImageFilter

    def __init__(self):
        r"""
        __init__(ValuedRegionalMaximaImageFilter self) -> ValuedRegionalMaximaImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ValuedRegionalMaximaImageFilter_swiginit(
            self, _SimpleITK.new_ValuedRegionalMaximaImageFilter()
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(ValuedRegionalMaximaImageFilter self, bool FullyConnected)


        """
        return _SimpleITK.ValuedRegionalMaximaImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(ValuedRegionalMaximaImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.ValuedRegionalMaximaImageFilter_FullyConnectedOn(
            self
        )

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(ValuedRegionalMaximaImageFilter self)


        """
        return _SimpleITK.ValuedRegionalMaximaImageFilter_FullyConnectedOff(
            self
        )

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(ValuedRegionalMaximaImageFilter self) -> bool


        """
        return _SimpleITK.ValuedRegionalMaximaImageFilter_GetFullyConnected(
            self
        )

    def GetFlat(self):
        r"""
        GetFlat(ValuedRegionalMaximaImageFilter self) -> bool


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ValuedRegionalMaximaImageFilter_GetFlat(self)

    def GetName(self):
        r"""
        GetName(ValuedRegionalMaximaImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ValuedRegionalMaximaImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ValuedRegionalMaximaImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ValuedRegionalMaximaImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ValuedRegionalMaximaImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ValuedRegionalMaximaImageFilter_Execute(self, image1)


# Register ValuedRegionalMaximaImageFilter in _SimpleITK:
_SimpleITK.ValuedRegionalMaximaImageFilter_swigregister(
    ValuedRegionalMaximaImageFilter
)


def ValuedRegionalMaxima(image1, fullyConnected=False):
    r"""ValuedRegionalMaxima(Image image1, bool fullyConnected=False) -> Image"""
    return _SimpleITK.ValuedRegionalMaxima(image1, fullyConnected)


class ValuedRegionalMinimaImageFilter(ImageFilter):
    r"""


    Transforms the image so that any pixel that is not a regional minima
    is set to the maximum value for the pixel type. Pixels that are
    regional minima retain their value.


    Regional minima are flat zones surrounded by pixels of higher value. A
    completely flat image will be marked as a regional minima by this
    filter.

    This code was contributed in the Insight Journal paper: "Finding
    regional extrema - methods and performance" by Beare R., Lehmann G. https://doi.org/10.54294/hva3gz


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    See:
     ValuedRegionalMaximaImageFilter , ValuedRegionalExtremaImageFilter ,

     HMinimaImageFilter

     itk::simple::ValuedRegionalMinima for the procedural interface

     itk::ValuedRegionalMinimaImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkValuedRegionalMinimaImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ValuedRegionalMinimaImageFilter

    def __init__(self):
        r"""
        __init__(ValuedRegionalMinimaImageFilter self) -> ValuedRegionalMinimaImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ValuedRegionalMinimaImageFilter_swiginit(
            self, _SimpleITK.new_ValuedRegionalMinimaImageFilter()
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(ValuedRegionalMinimaImageFilter self, bool FullyConnected)


        """
        return _SimpleITK.ValuedRegionalMinimaImageFilter_SetFullyConnected(
            self, FullyConnected
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(ValuedRegionalMinimaImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.ValuedRegionalMinimaImageFilter_FullyConnectedOn(
            self
        )

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(ValuedRegionalMinimaImageFilter self)


        """
        return _SimpleITK.ValuedRegionalMinimaImageFilter_FullyConnectedOff(
            self
        )

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(ValuedRegionalMinimaImageFilter self) -> bool


        """
        return _SimpleITK.ValuedRegionalMinimaImageFilter_GetFullyConnected(
            self
        )

    def GetFlat(self):
        r"""
        GetFlat(ValuedRegionalMinimaImageFilter self) -> bool


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ValuedRegionalMinimaImageFilter_GetFlat(self)

    def GetName(self):
        r"""
        GetName(ValuedRegionalMinimaImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ValuedRegionalMinimaImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ValuedRegionalMinimaImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ValuedRegionalMinimaImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ValuedRegionalMinimaImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ValuedRegionalMinimaImageFilter_Execute(self, image1)


# Register ValuedRegionalMinimaImageFilter in _SimpleITK:
_SimpleITK.ValuedRegionalMinimaImageFilter_swigregister(
    ValuedRegionalMinimaImageFilter
)


def ValuedRegionalMinima(image1, fullyConnected=False):
    r"""ValuedRegionalMinima(Image image1, bool fullyConnected=False) -> Image"""
    return _SimpleITK.ValuedRegionalMinima(image1, fullyConnected)


class VectorConfidenceConnectedImageFilter(ImageFilter):
    r"""


    Segment pixels with similar statistics using connectivity.


    This filter extracts a connected set of pixels whose pixel intensities
    are consistent with the pixel statistics of a seed point. The mean and
    variance across a neighborhood (8-connected, 26-connected, etc.) are
    calculated for a seed point. Then pixels connected to this seed point
    whose values are within the confidence interval for the seed point are
    grouped. The width of the confidence interval is controlled by the
    "Multiplier" variable (the confidence interval is the mean plus or
    minus the "Multiplier" times the standard deviation). If the
    intensity variations across a segment were gaussian, a "Multiplier"
    setting of 2.5 would define a confidence interval wide enough to
    capture 99% of samples in the segment.

    After this initial segmentation is calculated, the mean and variance
    are re-calculated. All the pixels in the previous segmentation are
    used to calculate the mean the standard deviation (as opposed to using
    the pixels in the neighborhood of the seed point). The segmentation is
    then recalculated using these refined estimates for the mean and
    variance of the pixel values. This process is repeated for the
    specified number of iterations. Setting the "NumberOfIterations" to
    zero stops the algorithm after the initial segmentation from the seed
    point.

    NOTE: the lower and upper threshold are restricted to lie within the
    valid numeric limits of the input data pixel type. Also, the limits
    may be adjusted to contain the seed point's intensity.
    See:
     itk::simple::VectorConfidenceConnected for the procedural interface

     itk::VectorConfidenceConnectedImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkVectorConfidenceConnectedImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_VectorConfidenceConnectedImageFilter

    def __init__(self):
        r"""
        __init__(VectorConfidenceConnectedImageFilter self) -> VectorConfidenceConnectedImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.VectorConfidenceConnectedImageFilter_swiginit(
            self, _SimpleITK.new_VectorConfidenceConnectedImageFilter()
        )

    def SetSeedList(self, SeedList):
        r"""
        SetSeedList(VectorConfidenceConnectedImageFilter self, VectorUIntList SeedList)


        Set list of image indexes for seeds.


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_SetSeedList(
            self, SeedList
        )

    def GetSeedList(self):
        r"""
        GetSeedList(VectorConfidenceConnectedImageFilter self) -> VectorUIntList


        Get list of seeds.


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_GetSeedList(
            self
        )

    def AddSeed(self, point):
        r"""
        AddSeed(VectorConfidenceConnectedImageFilter self, VectorUInt32 point)


        Add SeedList point.


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_AddSeed(
            self, point
        )

    def ClearSeeds(self):
        r"""
        ClearSeeds(VectorConfidenceConnectedImageFilter self)


        Remove all SeedList points.


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_ClearSeeds(self)

    def SetNumberOfIterations(self, NumberOfIterations):
        r"""
        SetNumberOfIterations(VectorConfidenceConnectedImageFilter self, unsigned int NumberOfIterations)


        Set/Get the number of iterations


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_SetNumberOfIterations(
            self, NumberOfIterations
        )

    def GetNumberOfIterations(self):
        r"""
        GetNumberOfIterations(VectorConfidenceConnectedImageFilter self) -> unsigned int


        Set/Get the number of iterations


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_GetNumberOfIterations(
            self
        )

    def SetMultiplier(self, Multiplier):
        r"""
        SetMultiplier(VectorConfidenceConnectedImageFilter self, double Multiplier)


        Set/Get the multiplier to define the confidence interval. Multiplier
        can be anything greater than zero. A typical value is 2.5


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_SetMultiplier(
            self, Multiplier
        )

    def GetMultiplier(self):
        r"""
        GetMultiplier(VectorConfidenceConnectedImageFilter self) -> double


        Set/Get the multiplier to define the confidence interval. Multiplier
        can be anything greater than zero. A typical value is 2.5


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_GetMultiplier(
            self
        )

    def SetInitialNeighborhoodRadius(self, InitialNeighborhoodRadius):
        r"""
        SetInitialNeighborhoodRadius(VectorConfidenceConnectedImageFilter self, unsigned int InitialNeighborhoodRadius)


        Get/Set the radius of the neighborhood over which the statistics are
        evaluated


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_SetInitialNeighborhoodRadius(
            self, InitialNeighborhoodRadius
        )

    def GetInitialNeighborhoodRadius(self):
        r"""
        GetInitialNeighborhoodRadius(VectorConfidenceConnectedImageFilter self) -> unsigned int


        Get/Set the radius of the neighborhood over which the statistics are
        evaluated


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_GetInitialNeighborhoodRadius(
            self
        )

    def SetReplaceValue(self, ReplaceValue):
        r"""
        SetReplaceValue(VectorConfidenceConnectedImageFilter self, uint8_t ReplaceValue)


        Set/Get value to replace thresholded pixels


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_SetReplaceValue(
            self, ReplaceValue
        )

    def GetReplaceValue(self):
        r"""
        GetReplaceValue(VectorConfidenceConnectedImageFilter self) -> uint8_t


        Set/Get value to replace thresholded pixels


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_GetReplaceValue(
            self
        )

    def GetMean(self):
        r"""
        GetMean(VectorConfidenceConnectedImageFilter self) -> VectorDouble


        Get the Mean Vector computed during the segmentation

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_GetMean(self)

    def GetCovariance(self):
        r"""
        GetCovariance(VectorConfidenceConnectedImageFilter self) -> VectorDouble


        Get the Covariance matrix computed during the segmentation

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_GetCovariance(
            self
        )

    def GetName(self):
        r"""
        GetName(VectorConfidenceConnectedImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(VectorConfidenceConnectedImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(VectorConfidenceConnectedImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_Execute(
            self, image1
        )


# Register VectorConfidenceConnectedImageFilter in _SimpleITK:
_SimpleITK.VectorConfidenceConnectedImageFilter_swigregister(
    VectorConfidenceConnectedImageFilter
)


def VectorConfidenceConnected(*args, **kwargs):
    r"""VectorConfidenceConnected(Image image1, VectorUIntList seedList=std::vector< std::vector< unsigned int > >(), unsigned int numberOfIterations=4, double multiplier=4.5, unsigned int initialNeighborhoodRadius=1, uint8_t replaceValue=1) -> Image"""
    return _SimpleITK.VectorConfidenceConnected(*args, **kwargs)


class VectorConnectedComponentImageFilter(ImageFilter):
    r"""


    A connected components filter that labels the objects in a vector
    image. Two vectors are pointing similar directions if one minus their
    dot product is less than a threshold. Vectors that are 180 degrees out
    of phase are similar. Assumes that vectors are normalized.



    See:
     itk::simple::VectorConnectedComponent for the procedural interface

     itk::VectorConnectedComponentImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkVectorConnectedComponentImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_VectorConnectedComponentImageFilter

    def __init__(self):
        r"""
        __init__(VectorConnectedComponentImageFilter self) -> VectorConnectedComponentImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.VectorConnectedComponentImageFilter_swiginit(
            self, _SimpleITK.new_VectorConnectedComponentImageFilter()
        )

    def SetDistanceThreshold(self, DistanceThreshold):
        r"""
        SetDistanceThreshold(VectorConnectedComponentImageFilter self, double DistanceThreshold)


        """
        return _SimpleITK.VectorConnectedComponentImageFilter_SetDistanceThreshold(
            self, DistanceThreshold
        )

    def GetDistanceThreshold(self):
        r"""
        GetDistanceThreshold(VectorConnectedComponentImageFilter self) -> double


        """
        return _SimpleITK.VectorConnectedComponentImageFilter_GetDistanceThreshold(
            self
        )

    def SetFullyConnected(self, FullyConnected):
        r"""
        SetFullyConnected(VectorConnectedComponentImageFilter self, bool FullyConnected)


        """
        return (
            _SimpleITK.VectorConnectedComponentImageFilter_SetFullyConnected(
                self, FullyConnected
            )
        )

    def FullyConnectedOn(self):
        r"""
        FullyConnectedOn(VectorConnectedComponentImageFilter self)


        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.VectorConnectedComponentImageFilter_FullyConnectedOn(
            self
        )

    def FullyConnectedOff(self):
        r"""
        FullyConnectedOff(VectorConnectedComponentImageFilter self)


        """
        return (
            _SimpleITK.VectorConnectedComponentImageFilter_FullyConnectedOff(
                self
            )
        )

    def GetFullyConnected(self):
        r"""
        GetFullyConnected(VectorConnectedComponentImageFilter self) -> bool


        """
        return (
            _SimpleITK.VectorConnectedComponentImageFilter_GetFullyConnected(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(VectorConnectedComponentImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.VectorConnectedComponentImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(VectorConnectedComponentImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.VectorConnectedComponentImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(VectorConnectedComponentImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.VectorConnectedComponentImageFilter_Execute(
            self, image1
        )


# Register VectorConnectedComponentImageFilter in _SimpleITK:
_SimpleITK.VectorConnectedComponentImageFilter_swigregister(
    VectorConnectedComponentImageFilter
)


def VectorConnectedComponent(
    image1, distanceThreshold=1.0, fullyConnected=False
):
    r"""VectorConnectedComponent(Image image1, double distanceThreshold=1.0, bool fullyConnected=False) -> Image"""
    return _SimpleITK.VectorConnectedComponent(
        image1, distanceThreshold, fullyConnected
    )


class VectorIndexSelectionCastImageFilter(ImageFilter):
    r"""


    Extracts the selected index of the vector that is the input pixel
    type.


    This filter is templated over the input image type and output image
    type.

    The filter expect the input image pixel type to be a vector and the
    output image pixel type to be a scalar. The only requirement on the
    type used for representing the vector is that it must provide an
    operator[].


    See:
     ComposeImageFilter

     itk::simple::VectorIndexSelectionCast for the procedural interface

     itk::VectorIndexSelectionCastImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkVectorIndexSelectionCastImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_VectorIndexSelectionCastImageFilter

    def __init__(self):
        r"""
        __init__(VectorIndexSelectionCastImageFilter self) -> VectorIndexSelectionCastImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.VectorIndexSelectionCastImageFilter_swiginit(
            self, _SimpleITK.new_VectorIndexSelectionCastImageFilter()
        )

    def SetIndex(self, Index):
        r"""
        SetIndex(VectorIndexSelectionCastImageFilter self, unsigned int Index)


        Get/Set methods for the index


        """
        return _SimpleITK.VectorIndexSelectionCastImageFilter_SetIndex(
            self, Index
        )

    def GetIndex(self):
        r"""
        GetIndex(VectorIndexSelectionCastImageFilter self) -> unsigned int


        """
        return _SimpleITK.VectorIndexSelectionCastImageFilter_GetIndex(self)

    def SetOutputPixelType(self, OutputPixelType):
        r"""
        SetOutputPixelType(VectorIndexSelectionCastImageFilter self, itk::simple::PixelIDValueEnum OutputPixelType)


        Set the output pixel type of the scalar component to extract.


        """
        return (
            _SimpleITK.VectorIndexSelectionCastImageFilter_SetOutputPixelType(
                self, OutputPixelType
            )
        )

    def GetOutputPixelType(self):
        r"""
        GetOutputPixelType(VectorIndexSelectionCastImageFilter self) -> itk::simple::PixelIDValueEnum


        Get the ouput pixel type.


        """
        return (
            _SimpleITK.VectorIndexSelectionCastImageFilter_GetOutputPixelType(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(VectorIndexSelectionCastImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.VectorIndexSelectionCastImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(VectorIndexSelectionCastImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.VectorIndexSelectionCastImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(VectorIndexSelectionCastImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.VectorIndexSelectionCastImageFilter_Execute(
            self, image1
        )


# Register VectorIndexSelectionCastImageFilter in _SimpleITK:
_SimpleITK.VectorIndexSelectionCastImageFilter_swigregister(
    VectorIndexSelectionCastImageFilter
)


def VectorIndexSelectionCast(*args, **kwargs):
    r"""VectorIndexSelectionCast(Image image1, unsigned int index=0, itk::simple::PixelIDValueEnum outputPixelType=sitkUnknown) -> Image"""
    return _SimpleITK.VectorIndexSelectionCast(*args, **kwargs)


class VectorMagnitudeImageFilter(ImageFilter):
    r"""


    Take an image of vectors as input and produce an image with the
    magnitude of those vectors.


    The filter expects the input image pixel type to be a vector and the
    output image pixel type to be a scalar.

    This filter assumes that the PixelType of the input image is a
    VectorType that provides a GetNorm() method.
    See:
     itk::simple::VectorMagnitude for the procedural interface

     itk::VectorMagnitudeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkVectorMagnitudeImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_VectorMagnitudeImageFilter

    def __init__(self):
        r"""
        __init__(VectorMagnitudeImageFilter self) -> VectorMagnitudeImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.VectorMagnitudeImageFilter_swiginit(
            self, _SimpleITK.new_VectorMagnitudeImageFilter()
        )

    def GetName(self):
        r"""
        GetName(VectorMagnitudeImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.VectorMagnitudeImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(VectorMagnitudeImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.VectorMagnitudeImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(VectorMagnitudeImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.VectorMagnitudeImageFilter_Execute(self, image1)


# Register VectorMagnitudeImageFilter in _SimpleITK:
_SimpleITK.VectorMagnitudeImageFilter_swigregister(VectorMagnitudeImageFilter)


def VectorMagnitude(image1):
    r"""VectorMagnitude(Image image1) -> Image"""
    return _SimpleITK.VectorMagnitude(image1)


class VotingBinaryHoleFillingImageFilter(ImageFilter):
    r"""


    Fills in holes and cavities by applying a voting operation on each
    pixel.



    See:
     Image

     VotingBinaryImageFilter

     VotingBinaryIterativeHoleFillingImageFilter

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     itk::simple::VotingBinaryHoleFilling for the procedural interface

     itk::VotingBinaryHoleFillingImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkVotingBinaryHoleFillingImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_VotingBinaryHoleFillingImageFilter

    def __init__(self):
        r"""
        __init__(VotingBinaryHoleFillingImageFilter self) -> VotingBinaryHoleFillingImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.VotingBinaryHoleFillingImageFilter_swiginit(
            self, _SimpleITK.new_VotingBinaryHoleFillingImageFilter()
        )

    def SetRadius(self, *args):
        r"""
        SetRadius(VotingBinaryHoleFillingImageFilter self, VectorUInt32 Radius)
        SetRadius(VotingBinaryHoleFillingImageFilter self, unsigned int value)


        Set the values of the Radius vector all to value


        """
        return _SimpleITK.VotingBinaryHoleFillingImageFilter_SetRadius(
            self, *args
        )

    def GetRadius(self):
        r"""
        GetRadius(VotingBinaryHoleFillingImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.VotingBinaryHoleFillingImageFilter_GetRadius(self)

    def SetMajorityThreshold(self, MajorityThreshold):
        r"""
        SetMajorityThreshold(VotingBinaryHoleFillingImageFilter self, unsigned int MajorityThreshold)


        Majority threshold. It is the number of pixels over 50% that will
        decide whether an OFF pixel will become ON or not. For example, if the
        neighborhood of a pixel has 124 pixels (excluding itself), the 50%
        will be 62, and if you set up a Majority threshold of 5, that means
        that the filter will require 67 or more neighbor pixels to be ON in
        order to switch the current OFF pixel to ON. The default value is 1.


        """
        return (
            _SimpleITK.VotingBinaryHoleFillingImageFilter_SetMajorityThreshold(
                self, MajorityThreshold
            )
        )

    def GetMajorityThreshold(self):
        r"""
        GetMajorityThreshold(VotingBinaryHoleFillingImageFilter self) -> unsigned int


        Majority threshold. It is the number of pixels over 50% that will
        decide whether an OFF pixel will become ON or not. For example, if the
        neighborhood of a pixel has 124 pixels (excluding itself), the 50%
        will be 62, and if you set up a Majority threshold of 5, that means
        that the filter will require 67 or more neighbor pixels to be ON in
        order to switch the current OFF pixel to ON. The default value is 1.


        """
        return (
            _SimpleITK.VotingBinaryHoleFillingImageFilter_GetMajorityThreshold(
                self
            )
        )

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(VotingBinaryHoleFillingImageFilter self, double ForegroundValue)


        """
        return (
            _SimpleITK.VotingBinaryHoleFillingImageFilter_SetForegroundValue(
                self, ForegroundValue
            )
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(VotingBinaryHoleFillingImageFilter self) -> double


        """
        return (
            _SimpleITK.VotingBinaryHoleFillingImageFilter_GetForegroundValue(
                self
            )
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(VotingBinaryHoleFillingImageFilter self, double BackgroundValue)


        """
        return (
            _SimpleITK.VotingBinaryHoleFillingImageFilter_SetBackgroundValue(
                self, BackgroundValue
            )
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(VotingBinaryHoleFillingImageFilter self) -> double


        """
        return (
            _SimpleITK.VotingBinaryHoleFillingImageFilter_GetBackgroundValue(
                self
            )
        )

    def GetName(self):
        r"""
        GetName(VotingBinaryHoleFillingImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.VotingBinaryHoleFillingImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(VotingBinaryHoleFillingImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.VotingBinaryHoleFillingImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(VotingBinaryHoleFillingImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.VotingBinaryHoleFillingImageFilter_Execute(
            self, image1
        )


# Register VotingBinaryHoleFillingImageFilter in _SimpleITK:
_SimpleITK.VotingBinaryHoleFillingImageFilter_swigregister(
    VotingBinaryHoleFillingImageFilter
)


def VotingBinaryHoleFilling(*args, **kwargs):
    r"""VotingBinaryHoleFilling(Image image1, VectorUInt32 radius=std::vector< unsigned int >(3, 1), unsigned int majorityThreshold=1, double foregroundValue=1.0, double backgroundValue=0.0) -> Image"""
    return _SimpleITK.VotingBinaryHoleFilling(*args, **kwargs)


class VotingBinaryImageFilter(ImageFilter):
    r"""


    Applies a voting operation in a neighborhood of each pixel.



    Pixels which are not Foreground or Background will remain unchanged.

    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     itk::simple::VotingBinary for the procedural interface

     itk::VotingBinaryImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkVotingBinaryImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_VotingBinaryImageFilter

    def __init__(self):
        r"""
        __init__(VotingBinaryImageFilter self) -> VotingBinaryImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.VotingBinaryImageFilter_swiginit(
            self, _SimpleITK.new_VotingBinaryImageFilter()
        )

    def SetRadius(self, *args):
        r"""
        SetRadius(VotingBinaryImageFilter self, VectorUInt32 Radius)
        SetRadius(VotingBinaryImageFilter self, unsigned int value)


        Set the values of the Radius vector all to value


        """
        return _SimpleITK.VotingBinaryImageFilter_SetRadius(self, *args)

    def GetRadius(self):
        r"""
        GetRadius(VotingBinaryImageFilter self) -> VectorUInt32


        Get the radius of the neighborhood used to compute the median


        """
        return _SimpleITK.VotingBinaryImageFilter_GetRadius(self)

    def SetBirthThreshold(self, BirthThreshold):
        r"""
        SetBirthThreshold(VotingBinaryImageFilter self, unsigned int BirthThreshold)


        Birth threshold. Pixels that are OFF will turn ON when the number of
        neighbors ON is larger than the value defined in this threshold.


        """
        return _SimpleITK.VotingBinaryImageFilter_SetBirthThreshold(
            self, BirthThreshold
        )

    def GetBirthThreshold(self):
        r"""
        GetBirthThreshold(VotingBinaryImageFilter self) -> unsigned int


        Birth threshold. Pixels that are OFF will turn ON when the number of
        neighbors ON is larger than the value defined in this threshold.


        """
        return _SimpleITK.VotingBinaryImageFilter_GetBirthThreshold(self)

    def SetSurvivalThreshold(self, SurvivalThreshold):
        r"""
        SetSurvivalThreshold(VotingBinaryImageFilter self, unsigned int SurvivalThreshold)


        Survival threshold. Pixels that are ON will turn OFF when the number
        of neighbors ON is smaller than the value defined in this survival
        threshold.


        """
        return _SimpleITK.VotingBinaryImageFilter_SetSurvivalThreshold(
            self, SurvivalThreshold
        )

    def GetSurvivalThreshold(self):
        r"""
        GetSurvivalThreshold(VotingBinaryImageFilter self) -> unsigned int


        Survival threshold. Pixels that are ON will turn OFF when the number
        of neighbors ON is smaller than the value defined in this survival
        threshold.


        """
        return _SimpleITK.VotingBinaryImageFilter_GetSurvivalThreshold(self)

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(VotingBinaryImageFilter self, double ForegroundValue)


        Set the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.VotingBinaryImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(VotingBinaryImageFilter self) -> double


        Get the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.VotingBinaryImageFilter_GetForegroundValue(self)

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(VotingBinaryImageFilter self, double BackgroundValue)


        Set the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.VotingBinaryImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(VotingBinaryImageFilter self) -> double


        Get the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.VotingBinaryImageFilter_GetBackgroundValue(self)

    def GetName(self):
        r"""
        GetName(VotingBinaryImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.VotingBinaryImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(VotingBinaryImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.VotingBinaryImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(VotingBinaryImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.VotingBinaryImageFilter_Execute(self, image1)


# Register VotingBinaryImageFilter in _SimpleITK:
_SimpleITK.VotingBinaryImageFilter_swigregister(VotingBinaryImageFilter)


def VotingBinary(*args, **kwargs):
    r"""VotingBinary(Image image1, VectorUInt32 radius=std::vector< unsigned int >(3, 1), unsigned int birthThreshold=1, unsigned int survivalThreshold=1, double foregroundValue=1.0, double backgroundValue=0.0) -> Image"""
    return _SimpleITK.VotingBinary(*args, **kwargs)


class VotingBinaryIterativeHoleFillingImageFilter(ImageFilter):
    r"""


    Fills in holes and cavities by iteratively applying a voting
    operation.


    This filter uses internally the VotingBinaryHoleFillingImageFilter , and runs it iteratively until no pixels are being changed or until
    it reaches the maximum number of iterations. The purpose of the filter
    is to fill in holes of medium size (tens of pixels in radius). In
    principle the number of iterations is related to the size of the holes
    to be filled in. The larger the holes, the more iteration must be run
    with this filter in order to fill in the full hole. The size of the
    neighborhood is also related to the curvature of the hole borders and
    therefore the hole size. Note that as a collateral effect this filter
    may also fill in cavities in the external side of structures.

    This filter is templated over a single image type because the output
    image type must be the same as the input image type. This is required
    in order to make the iterations possible, since the output image of
    one iteration is taken as the input image for the next iteration.


    See:
     Image

     VotingBinaryImageFilter

     VotingBinaryHoleFillingImageFilter

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     itk::simple::VotingBinaryIterativeHoleFilling for the procedural interface

     itk::VotingBinaryIterativeHoleFillingImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkVotingBinaryIterativeHoleFillingImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_VotingBinaryIterativeHoleFillingImageFilter
    )

    def __init__(self):
        r"""
        __init__(VotingBinaryIterativeHoleFillingImageFilter self) -> VotingBinaryIterativeHoleFillingImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_swiginit(
            self, _SimpleITK.new_VotingBinaryIterativeHoleFillingImageFilter()
        )

    def SetRadius(self, *args):
        r"""
        SetRadius(VotingBinaryIterativeHoleFillingImageFilter self, VectorUInt32 Radius)
        SetRadius(VotingBinaryIterativeHoleFillingImageFilter self, unsigned int value)


        Set the values of the Radius vector all to value


        """
        return (
            _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_SetRadius(
                self, *args
            )
        )

    def GetRadius(self):
        r"""
        GetRadius(VotingBinaryIterativeHoleFillingImageFilter self) -> VectorUInt32


        Get the radius of the neighborhood used to compute the median


        """
        return (
            _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_GetRadius(
                self
            )
        )

    def SetMaximumNumberOfIterations(self, MaximumNumberOfIterations):
        r"""
        SetMaximumNumberOfIterations(VotingBinaryIterativeHoleFillingImageFilter self, unsigned int MaximumNumberOfIterations)


        Maximum number of iterations. This filter is executed iteratively as
        long as at least one pixel has changed in a previous iteration, or
        until the maximum number of iterations has been reached.


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_SetMaximumNumberOfIterations(
            self, MaximumNumberOfIterations
        )

    def GetMaximumNumberOfIterations(self):
        r"""
        GetMaximumNumberOfIterations(VotingBinaryIterativeHoleFillingImageFilter self) -> unsigned int


        Maximum number of iterations. This filter is executed iteratively as
        long as at least one pixel has changed in a previous iteration, or
        until the maximum number of iterations has been reached.


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_GetMaximumNumberOfIterations(
            self
        )

    def SetMajorityThreshold(self, MajorityThreshold):
        r"""
        SetMajorityThreshold(VotingBinaryIterativeHoleFillingImageFilter self, unsigned int MajorityThreshold)


        Majority threshold. It is the number of pixels over 50% that will
        decide whether an OFF pixel will become ON or not. For example, if the
        neighborhood of a pixel has 124 pixels (excluding itself), the 50%
        will be 62, and if you set up a Majority threshold of 5, that means
        that the filter will require 67 or more neighbor pixels to be ON in
        order to switch the current OFF pixel to ON. The default value is 1.


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_SetMajorityThreshold(
            self, MajorityThreshold
        )

    def GetMajorityThreshold(self):
        r"""
        GetMajorityThreshold(VotingBinaryIterativeHoleFillingImageFilter self) -> unsigned int


        Majority threshold. It is the number of pixels over 50% that will
        decide whether an OFF pixel will become ON or not. For example, if the
        neighborhood of a pixel has 124 pixels (excluding itself), the 50%
        will be 62, and if you set up a Majority threshold of 5, that means
        that the filter will require 67 or more neighbor pixels to be ON in
        order to switch the current OFF pixel to ON. The default value is 1.


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_GetMajorityThreshold(
            self
        )

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(VotingBinaryIterativeHoleFillingImageFilter self, double ForegroundValue)


        Set the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(VotingBinaryIterativeHoleFillingImageFilter self) -> double


        Get the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_GetForegroundValue(
            self
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(VotingBinaryIterativeHoleFillingImageFilter self, double BackgroundValue)


        Set the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(VotingBinaryIterativeHoleFillingImageFilter self) -> double


        Get the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_GetBackgroundValue(
            self
        )

    def GetName(self):
        r"""
        GetName(VotingBinaryIterativeHoleFillingImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(VotingBinaryIterativeHoleFillingImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter___str__(
            self
        )

    def Execute(self, image1):
        r"""
        Execute(VotingBinaryIterativeHoleFillingImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_Execute(
            self, image1
        )


# Register VotingBinaryIterativeHoleFillingImageFilter in _SimpleITK:
_SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_swigregister(
    VotingBinaryIterativeHoleFillingImageFilter
)


def VotingBinaryIterativeHoleFilling(*args, **kwargs):
    r"""VotingBinaryIterativeHoleFilling(Image image1, VectorUInt32 radius=std::vector< unsigned int >(3, 1), unsigned int maximumNumberOfIterations=10, unsigned int majorityThreshold=1, double foregroundValue=1.0, double backgroundValue=0.0) -> Image"""
    return _SimpleITK.VotingBinaryIterativeHoleFilling(*args, **kwargs)


class WarpImageFilter(ImageFilter):
    r"""


    Warps an image using an input displacement field.


    WarpImageFilter warps an existing image with respect to a given displacement field.

    A displacement field is represented as a image whose pixel type is
    some vector type with at least N elements, where N is the dimension of
    the input image. The vector type must support element access via
    operator [].

    The output image is produced by inverse mapping: the output pixels are
    mapped back onto the input image. This scheme avoids the creation of
    any holes and overlaps in the output image.

    Each vector in the displacement field represent the distance between a
    geometric point in the input space and a point in the output space
    such that:

    \\[ p_{in} = p_{out} + d \\]

    Typically the mapped position does not correspond to an integer pixel
    position in the input image. Interpolation via an image function is
    used to compute values at non-integer positions. The default
    interpolation typed used is the LinearInterpolateImageFunction . The user can specify a particular interpolation function via SetInterpolator() . Note that the input interpolator must derive from base class InterpolateImageFunction .

    Position mapped to outside of the input image buffer are assigned a
    edge padding value.

    The LargestPossibleRegion for the output is inherited from the input
    displacement field. The output image spacing, origin and orientation
    may be set via SetOutputSpacing, SetOutputOrigin and
    SetOutputDirection. The default are respectively a vector of 1's, a
    vector of 0's and an identity matrix.

    This class is templated over the type of the input image, the type of
    the output image and the type of the displacement field.

    The input image is set via SetInput. The input displacement field is
    set via SetDisplacementField.

    This filter is implemented as a multithreaded filter.


    WARNING:
    This filter assumes that the input type, output type and displacement
    field type all have the same number of dimensions.

    See:
     itk::simple::Warp for the procedural interface

     itk::WarpImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkWarpImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_WarpImageFilter

    def __init__(self):
        r"""
        __init__(WarpImageFilter self) -> WarpImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.WarpImageFilter_swiginit(
            self, _SimpleITK.new_WarpImageFilter()
        )

    def SetInterpolator(self, Interpolator):
        r"""
        SetInterpolator(WarpImageFilter self, itk::simple::InterpolatorEnum Interpolator)


        Get/Set the interpolator function.


        """
        return _SimpleITK.WarpImageFilter_SetInterpolator(self, Interpolator)

    def GetInterpolator(self):
        r"""
        GetInterpolator(WarpImageFilter self) -> itk::simple::InterpolatorEnum


        Get/Set the interpolator function.


        """
        return _SimpleITK.WarpImageFilter_GetInterpolator(self)

    def SetOutputSize(self, OutputSize):
        r"""
        SetOutputSize(WarpImageFilter self, VectorUInt32 OutputSize)


        Set the size of the output image.


        """
        return _SimpleITK.WarpImageFilter_SetOutputSize(self, OutputSize)

    def GetOutputSize(self):
        r"""
        GetOutputSize(WarpImageFilter self) -> VectorUInt32


        Get the size of the output image.


        """
        return _SimpleITK.WarpImageFilter_GetOutputSize(self)

    def SetOutputOrigin(self, OutputOrigin):
        r"""
        SetOutputOrigin(WarpImageFilter self, VectorDouble OutputOrigin)


        Set the output image origin.


        """
        return _SimpleITK.WarpImageFilter_SetOutputOrigin(self, OutputOrigin)

    def GetOutputOrigin(self):
        r"""
        GetOutputOrigin(WarpImageFilter self) -> VectorDouble


        Get the output image origin.


        """
        return _SimpleITK.WarpImageFilter_GetOutputOrigin(self)

    def SetOutputSpacing(self, OutputSpacing):
        r"""
        SetOutputSpacing(WarpImageFilter self, VectorDouble OutputSpacing)


        Set the output image spacing.


        """
        return _SimpleITK.WarpImageFilter_SetOutputSpacing(self, OutputSpacing)

    def GetOutputSpacing(self):
        r"""
        GetOutputSpacing(WarpImageFilter self) -> VectorDouble


        Get the output image spacing.


        """
        return _SimpleITK.WarpImageFilter_GetOutputSpacing(self)

    def SetOutputDirection(self, OutputDirection):
        r"""
        SetOutputDirection(WarpImageFilter self, VectorDouble OutputDirection)


        Set/Get the direction (orientation) of the output image


        """
        return _SimpleITK.WarpImageFilter_SetOutputDirection(
            self, OutputDirection
        )

    def GetOutputDirection(self):
        r"""
        GetOutputDirection(WarpImageFilter self) -> VectorDouble


        Set/Get the direction (orientation) of the output image


        """
        return _SimpleITK.WarpImageFilter_GetOutputDirection(self)

    def SetEdgePaddingValue(self, EdgePaddingValue):
        r"""
        SetEdgePaddingValue(WarpImageFilter self, double EdgePaddingValue)


        Set the edge padding value


        """
        return _SimpleITK.WarpImageFilter_SetEdgePaddingValue(
            self, EdgePaddingValue
        )

    def GetEdgePaddingValue(self):
        r"""
        GetEdgePaddingValue(WarpImageFilter self) -> double


        Get the edge padding value


        """
        return _SimpleITK.WarpImageFilter_GetEdgePaddingValue(self)

    def GetName(self):
        r"""
        GetName(WarpImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.WarpImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(WarpImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.WarpImageFilter___str__(self)

    def Execute(self, image, displacementField):
        r"""
        Execute(WarpImageFilter self, Image image, Image displacementField) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.WarpImageFilter_Execute(
            self, image, displacementField
        )

    def SetOutputParameteresFromImage(self, refImage):
        r"""
        SetOutputParameteresFromImage(WarpImageFilter self, Image refImage)


        This methods sets the output size, origin, spacing and direction to
        that of the provided image


        """
        return _SimpleITK.WarpImageFilter_SetOutputParameteresFromImage(
            self, refImage
        )


# Register WarpImageFilter in _SimpleITK:
_SimpleITK.WarpImageFilter_swigregister(WarpImageFilter)


def Warp(*args, **kwargs):
    r"""Warp(Image image, Image displacementField, itk::simple::InterpolatorEnum interpolator=sitkLinear, VectorUInt32 outputSize=std::vector< uint32_t >(3, 0), VectorDouble outputOrigin=std::vector< double >(3, 0.0), VectorDouble outputSpacing=std::vector< double >(3, 1.0), VectorDouble outputDirection=std::vector< double >(), double edgePaddingValue=0.0) -> Image"""
    return _SimpleITK.Warp(*args, **kwargs)


class WhiteTopHatImageFilter(ImageFilter):
    r"""


    White top hat extracts local maxima that are larger than the
    structuring element.


    Top-hats are described in Chapter 4.5 of Pierre Soille's book
    "Morphological Image Analysis: Principles and Applications", Second
    Edition, Springer, 2003.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     itk::simple::WhiteTopHat for the procedural interface

     itk::WhiteTopHatImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkWhiteTopHatImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_WhiteTopHatImageFilter

    def __init__(self):
        r"""
        __init__(WhiteTopHatImageFilter self) -> WhiteTopHatImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.WhiteTopHatImageFilter_swiginit(
            self, _SimpleITK.new_WhiteTopHatImageFilter()
        )

    def SetKernelRadius(self, *args):
        r"""
        SetKernelRadius(WhiteTopHatImageFilter self, VectorUInt32 KernelRadius)
        SetKernelRadius(WhiteTopHatImageFilter self, unsigned int value)


        Set the values of the KernelRadius vector all to value


        """
        return _SimpleITK.WhiteTopHatImageFilter_SetKernelRadius(self, *args)

    def GetKernelRadius(self):
        r"""
        GetKernelRadius(WhiteTopHatImageFilter self) -> VectorUInt32


        Get the radius of the kernel structuring element.


        """
        return _SimpleITK.WhiteTopHatImageFilter_GetKernelRadius(self)

    def SetKernelType(self, KernelType):
        r"""
        SetKernelType(WhiteTopHatImageFilter self, itk::simple::KernelEnum KernelType)


        Set the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.WhiteTopHatImageFilter_SetKernelType(
            self, KernelType
        )

    def GetKernelType(self):
        r"""
        GetKernelType(WhiteTopHatImageFilter self) -> itk::simple::KernelEnum


        Get the kernel or structuring element used for the morphology.


        """
        return _SimpleITK.WhiteTopHatImageFilter_GetKernelType(self)

    def SetSafeBorder(self, SafeBorder):
        r"""
        SetSafeBorder(WhiteTopHatImageFilter self, bool SafeBorder)


        A safe border is added to input image to avoid borders effects and
        remove it once the closing is done


        """
        return _SimpleITK.WhiteTopHatImageFilter_SetSafeBorder(
            self, SafeBorder
        )

    def SafeBorderOn(self):
        r"""
        SafeBorderOn(WhiteTopHatImageFilter self)


        Set the value of SafeBorder to true or false respectfully.


        """
        return _SimpleITK.WhiteTopHatImageFilter_SafeBorderOn(self)

    def SafeBorderOff(self):
        r"""
        SafeBorderOff(WhiteTopHatImageFilter self)


        """
        return _SimpleITK.WhiteTopHatImageFilter_SafeBorderOff(self)

    def GetSafeBorder(self):
        r"""
        GetSafeBorder(WhiteTopHatImageFilter self) -> bool


        A safe border is added to input image to avoid borders effects and
        remove it once the closing is done


        """
        return _SimpleITK.WhiteTopHatImageFilter_GetSafeBorder(self)

    def GetName(self):
        r"""
        GetName(WhiteTopHatImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.WhiteTopHatImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(WhiteTopHatImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.WhiteTopHatImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(WhiteTopHatImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.WhiteTopHatImageFilter_Execute(self, image1)


# Register WhiteTopHatImageFilter in _SimpleITK:
_SimpleITK.WhiteTopHatImageFilter_swigregister(WhiteTopHatImageFilter)


def WhiteTopHat(*args, **kwargs):
    r"""WhiteTopHat(Image image1, VectorUInt32 kernelRadius=std::vector< uint32_t >(3, 1), itk::simple::KernelEnum kernelType=sitkBall, bool safeBorder=True) -> Image"""
    return _SimpleITK.WhiteTopHat(*args, **kwargs)


class WienerDeconvolutionImageFilter(ImageFilter):
    r"""


    The Wiener deconvolution image filter is designed to restore an image
    convolved with a blurring kernel while keeping noise enhancement to a
    minimum.


    The Wiener filter aims to minimize noise enhancement induced by
    frequencies with low signal-to-noise ratio. The Wiener filter kernel
    is defined in the frequency domain as $W(\\omega) = H^*(\\omega) / (|H(\\omega)|^2 + (1 /
    SNR(\\omega)))$ where $H(\\omega)$ is the Fourier transform of the blurring kernel with which the
    original image was convolved and the signal-to-noise ratio $SNR(\\omega)$ . $SNR(\\omega)$ is defined by $P_f(\\omega) / P_n(\\omega)$ where $P_f(\\omega)$ is the power spectral density of the uncorrupted signal and $P_n(\\omega)$ is the power spectral density of the noise. When applied to the input
    blurred image, this filter produces an estimate $\\hat{f}(x)$ of the true underlying signal $f(x)$ that minimizes the expected error between $\\hat{f}(x)$ and $f(x)$ .

    This filter requires two inputs, the image to be deconvolved and the
    blurring kernel. These two inputs can be set using the methods
    SetInput() and SetKernelImage(), respectively.

    The power spectral densities of the signal and noise are typically
    unavailable for a given problem. In particular, $P_f(\\omega)$ cannot be computed from $f(x)$ because this unknown signal is precisely the signal that this filter
    aims to recover. Nevertheless, it is common for the noise to have a
    power spectral density that is flat or decreasing significantly more
    slowly than the power spectral density of a typical image as the
    frequency $\\omega$ increases. Hence, $P_n(\\omega)$ can typically be approximated with a constant, and this filter makes
    this assumption (see the NoiseVariance member variable). $P_f(\\omega)$ , on the other hand, will vary with input. This filter computes the
    power spectral density of the input blurred image, subtracts the power
    spectral density of the noise, and uses the result as the estimate of $P_f(\\omega)$ .

    For further information on the Wiener deconvolution filter, please see
    "Digital Signal Processing" by Kenneth R. Castleman, Prentice Hall,
    1995


    Gaetan Lehmann, Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France

    Chris Mullins, The University of North Carolina at Chapel Hill

    Cory Quammen, The University of North Carolina at Chapel Hill

    See:
     itk::simple::WienerDeconvolution for the procedural interface

     itk::WienerDeconvolutionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkWienerDeconvolutionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_WienerDeconvolutionImageFilter

    def __init__(self):
        r"""
        __init__(WienerDeconvolutionImageFilter self) -> WienerDeconvolutionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.WienerDeconvolutionImageFilter_swiginit(
            self, _SimpleITK.new_WienerDeconvolutionImageFilter()
        )

    def SetNoiseVariance(self, NoiseVariance):
        r"""
        SetNoiseVariance(WienerDeconvolutionImageFilter self, double NoiseVariance)


        Set/get the variance of the zero-mean Gaussian white noise assumed to
        be added to the input.


        """
        return _SimpleITK.WienerDeconvolutionImageFilter_SetNoiseVariance(
            self, NoiseVariance
        )

    def GetNoiseVariance(self):
        r"""
        GetNoiseVariance(WienerDeconvolutionImageFilter self) -> double


        Set/get the variance of the zero-mean Gaussian white noise assumed to
        be added to the input.


        """
        return _SimpleITK.WienerDeconvolutionImageFilter_GetNoiseVariance(self)

    def SetNormalize(self, Normalize):
        r"""
        SetNormalize(WienerDeconvolutionImageFilter self, bool Normalize)


        Normalize the output image by the sum of the kernel components


        """
        return _SimpleITK.WienerDeconvolutionImageFilter_SetNormalize(
            self, Normalize
        )

    def NormalizeOn(self):
        r"""
        NormalizeOn(WienerDeconvolutionImageFilter self)


        Set the value of Normalize to true or false respectfully.


        """
        return _SimpleITK.WienerDeconvolutionImageFilter_NormalizeOn(self)

    def NormalizeOff(self):
        r"""
        NormalizeOff(WienerDeconvolutionImageFilter self)


        """
        return _SimpleITK.WienerDeconvolutionImageFilter_NormalizeOff(self)

    def GetNormalize(self):
        r"""
        GetNormalize(WienerDeconvolutionImageFilter self) -> bool


        """
        return _SimpleITK.WienerDeconvolutionImageFilter_GetNormalize(self)

    ZERO_PAD = _SimpleITK.WienerDeconvolutionImageFilter_ZERO_PAD

    ZERO_FLUX_NEUMANN_PAD = (
        _SimpleITK.WienerDeconvolutionImageFilter_ZERO_FLUX_NEUMANN_PAD
    )

    PERIODIC_PAD = _SimpleITK.WienerDeconvolutionImageFilter_PERIODIC_PAD

    def SetBoundaryCondition(self, BoundaryCondition):
        r"""
        SetBoundaryCondition(WienerDeconvolutionImageFilter self, itk::simple::WienerDeconvolutionImageFilter::BoundaryConditionType BoundaryCondition)


        """
        return _SimpleITK.WienerDeconvolutionImageFilter_SetBoundaryCondition(
            self, BoundaryCondition
        )

    def GetBoundaryCondition(self):
        r"""
        GetBoundaryCondition(WienerDeconvolutionImageFilter self) -> itk::simple::WienerDeconvolutionImageFilter::BoundaryConditionType


        """
        return _SimpleITK.WienerDeconvolutionImageFilter_GetBoundaryCondition(
            self
        )

    SAME = _SimpleITK.WienerDeconvolutionImageFilter_SAME

    VALID = _SimpleITK.WienerDeconvolutionImageFilter_VALID

    def SetOutputRegionMode(self, OutputRegionMode):
        r"""
        SetOutputRegionMode(WienerDeconvolutionImageFilter self, itk::simple::WienerDeconvolutionImageFilter::OutputRegionModeType OutputRegionMode)


        """
        return _SimpleITK.WienerDeconvolutionImageFilter_SetOutputRegionMode(
            self, OutputRegionMode
        )

    def GetOutputRegionMode(self):
        r"""
        GetOutputRegionMode(WienerDeconvolutionImageFilter self) -> itk::simple::WienerDeconvolutionImageFilter::OutputRegionModeType


        """
        return _SimpleITK.WienerDeconvolutionImageFilter_GetOutputRegionMode(
            self
        )

    def GetName(self):
        r"""
        GetName(WienerDeconvolutionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.WienerDeconvolutionImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(WienerDeconvolutionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.WienerDeconvolutionImageFilter___str__(self)

    def Execute(self, image1, image2):
        r"""
        Execute(WienerDeconvolutionImageFilter self, Image image1, Image image2) -> Image


        Execute the filter on the input images


        """
        return _SimpleITK.WienerDeconvolutionImageFilter_Execute(
            self, image1, image2
        )


# Register WienerDeconvolutionImageFilter in _SimpleITK:
_SimpleITK.WienerDeconvolutionImageFilter_swigregister(
    WienerDeconvolutionImageFilter
)


def WienerDeconvolution(*args, **kwargs):
    r"""WienerDeconvolution(Image image1, Image image2, double noiseVariance=0.0, bool normalize=False, itk::simple::WienerDeconvolutionImageFilter::BoundaryConditionType boundaryCondition=ZERO_FLUX_NEUMANN_PAD, itk::simple::WienerDeconvolutionImageFilter::OutputRegionModeType outputRegionMode=SAME) -> Image"""
    return _SimpleITK.WienerDeconvolution(*args, **kwargs)


class WrapPadImageFilter(ImageFilter):
    r"""


    Increase the image size by padding with replicants of the input image
    value.


    WrapPadImageFilter changes the image bounds of an image. Added pixels are filled in with
    a wrapped replica of the input image. For instance, if the output
    image needs a pixel that is two pixels to the left of the
    LargestPossibleRegion of the input image, the value assigned will be
    from the pixel two pixels inside the right boundary of the
    LargestPossibleRegion. The image bounds of the output must be
    specified.

    Visual explanation of padding regions.

    This filter is implemented as a multithreaded filter. It provides a
    ThreadedGenerateData() method for its implementation.


    See:
     MirrorPadImageFilter , ConstantPadImageFilter

     itk::simple::WrapPad for the procedural interface

     itk::WrapPadImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkWrapPadImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_WrapPadImageFilter

    def __init__(self):
        r"""
        __init__(WrapPadImageFilter self) -> WrapPadImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.WrapPadImageFilter_swiginit(
            self, _SimpleITK.new_WrapPadImageFilter()
        )

    def SetPadLowerBound(self, PadLowerBound):
        r"""
        SetPadLowerBound(WrapPadImageFilter self, VectorUInt32 PadLowerBound)


        """
        return _SimpleITK.WrapPadImageFilter_SetPadLowerBound(
            self, PadLowerBound
        )

    def GetPadLowerBound(self):
        r"""
        GetPadLowerBound(WrapPadImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.WrapPadImageFilter_GetPadLowerBound(self)

    def SetPadUpperBound(self, PadUpperBound):
        r"""
        SetPadUpperBound(WrapPadImageFilter self, VectorUInt32 PadUpperBound)


        """
        return _SimpleITK.WrapPadImageFilter_SetPadUpperBound(
            self, PadUpperBound
        )

    def GetPadUpperBound(self):
        r"""
        GetPadUpperBound(WrapPadImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.WrapPadImageFilter_GetPadUpperBound(self)

    def GetName(self):
        r"""
        GetName(WrapPadImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.WrapPadImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(WrapPadImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.WrapPadImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(WrapPadImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.WrapPadImageFilter_Execute(self, image1)


# Register WrapPadImageFilter in _SimpleITK:
_SimpleITK.WrapPadImageFilter_swigregister(WrapPadImageFilter)


def WrapPad(*args, **kwargs):
    r"""WrapPad(Image image1, VectorUInt32 padLowerBound=std::vector< unsigned int >(3, 0), VectorUInt32 padUpperBound=std::vector< unsigned int >(3, 0)) -> Image"""
    return _SimpleITK.WrapPad(*args, **kwargs)


class XorImageFilter(ImageFilter):
    r"""


    Computes the XOR bitwise operator pixel-wise between two images.


    This class is templated over the types of the two input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    Since the bitwise XOR operation is only defined in C++ for integer
    types, the images passed to this filter must comply with the
    requirement of using integer pixel type.

    The total operation over one pixel will be


    Where "^" is the boolean XOR operator in C++.
    See:
     itk::simple::Xor for the procedural interface

     itk::XorImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkXorImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_XorImageFilter

    def __init__(self):
        r"""
        __init__(XorImageFilter self) -> XorImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.XorImageFilter_swiginit(
            self, _SimpleITK.new_XorImageFilter()
        )

    def GetName(self):
        r"""
        GetName(XorImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.XorImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(XorImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.XorImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(XorImageFilter self, Image image1, Image image2) -> Image
        Execute(XorImageFilter self, Image image1, int constant) -> Image
        Execute(XorImageFilter self, int constant, Image image2) -> Image


        """
        return _SimpleITK.XorImageFilter_Execute(self, *args)


# Register XorImageFilter in _SimpleITK:
_SimpleITK.XorImageFilter_swigregister(XorImageFilter)


def Xor(*args):
    r"""
    Xor(Image image1, Image image2) -> Image
    Xor(Image image1, int constant) -> Image
    Xor(int constant, Image image2) -> Image


    """
    return _SimpleITK.Xor(*args)


class YenThresholdImageFilter(ImageFilter):
    r"""


    Threshold an image using the Yen Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the YenThresholdCalculator and applies that threshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare

    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://doi.org/10.54294/efycla


    See:
     HistogramThresholdImageFilter

     itk::simple::YenThreshold for the procedural interface

     itk::YenThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkYenThresholdImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_YenThresholdImageFilter

    def __init__(self):
        r"""
        __init__(YenThresholdImageFilter self) -> YenThresholdImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.YenThresholdImageFilter_swiginit(
            self, _SimpleITK.new_YenThresholdImageFilter()
        )

    def SetInsideValue(self, InsideValue):
        r"""
        SetInsideValue(YenThresholdImageFilter self, uint8_t InsideValue)


        Set the "inside" pixel value.


        """
        return _SimpleITK.YenThresholdImageFilter_SetInsideValue(
            self, InsideValue
        )

    def GetInsideValue(self):
        r"""
        GetInsideValue(YenThresholdImageFilter self) -> uint8_t


        Get the "inside" pixel value.


        """
        return _SimpleITK.YenThresholdImageFilter_GetInsideValue(self)

    def SetOutsideValue(self, OutsideValue):
        r"""
        SetOutsideValue(YenThresholdImageFilter self, uint8_t OutsideValue)


        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.YenThresholdImageFilter_SetOutsideValue(
            self, OutsideValue
        )

    def GetOutsideValue(self):
        r"""
        GetOutsideValue(YenThresholdImageFilter self) -> uint8_t


        Get the "outside" pixel value.


        """
        return _SimpleITK.YenThresholdImageFilter_GetOutsideValue(self)

    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        r"""
        SetNumberOfHistogramBins(YenThresholdImageFilter self, uint32_t NumberOfHistogramBins)


        Set/Get the number of histogram bins.


        """
        return _SimpleITK.YenThresholdImageFilter_SetNumberOfHistogramBins(
            self, NumberOfHistogramBins
        )

    def GetNumberOfHistogramBins(self):
        r"""
        GetNumberOfHistogramBins(YenThresholdImageFilter self) -> uint32_t


        """
        return _SimpleITK.YenThresholdImageFilter_GetNumberOfHistogramBins(
            self
        )

    def SetMaskOutput(self, MaskOutput):
        r"""
        SetMaskOutput(YenThresholdImageFilter self, bool MaskOutput)


        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.YenThresholdImageFilter_SetMaskOutput(
            self, MaskOutput
        )

    def MaskOutputOn(self):
        r"""
        MaskOutputOn(YenThresholdImageFilter self)


        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.YenThresholdImageFilter_MaskOutputOn(self)

    def MaskOutputOff(self):
        r"""
        MaskOutputOff(YenThresholdImageFilter self)


        """
        return _SimpleITK.YenThresholdImageFilter_MaskOutputOff(self)

    def GetMaskOutput(self):
        r"""
        GetMaskOutput(YenThresholdImageFilter self) -> bool


        """
        return _SimpleITK.YenThresholdImageFilter_GetMaskOutput(self)

    def SetMaskValue(self, MaskValue):
        r"""
        SetMaskValue(YenThresholdImageFilter self, uint8_t MaskValue)


        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.YenThresholdImageFilter_SetMaskValue(self, MaskValue)

    def GetMaskValue(self):
        r"""
        GetMaskValue(YenThresholdImageFilter self) -> uint8_t


        """
        return _SimpleITK.YenThresholdImageFilter_GetMaskValue(self)

    def GetThreshold(self):
        r"""
        GetThreshold(YenThresholdImageFilter self) -> double


        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.YenThresholdImageFilter_GetThreshold(self)

    def GetName(self):
        r"""
        GetName(YenThresholdImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.YenThresholdImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(YenThresholdImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.YenThresholdImageFilter___str__(self)

    def Execute(self, *args):
        r"""
        Execute(YenThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(YenThresholdImageFilter self, Image image) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.YenThresholdImageFilter_Execute(self, *args)


# Register YenThresholdImageFilter in _SimpleITK:
_SimpleITK.YenThresholdImageFilter_swigregister(YenThresholdImageFilter)


def YenThreshold(*args):
    r"""
    YenThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    YenThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    """
    return _SimpleITK.YenThreshold(*args)


class ZeroCrossingBasedEdgeDetectionImageFilter(ImageFilter):
    r"""


    This filter implements a zero-crossing based edge detector.


    The zero-crossing based edge detector looks for pixels in the
    Laplacian of an image where the value of the Laplacian passes through
    zero points where the Laplacian changes sign. Such points often occur
    at "edges" in images i.e. points where the intensity of the image
    changes rapidly, but they also occur at places that are not as easy to
    associate with edges. It is best to think of the zero crossing
    detector as some sort of feature detector rather than as a specific
    edge detector.


    Zero crossings always lie on closed contours and so the output from
    the zero crossing detector is usually a binary image with single pixel
    thickness lines showing the positions of the zero crossing points.

    In this implementation, the input image is first smoothed with a
    Gaussian filter, then the LaplacianImageFilter is applied to smoothed image. Finally the zero-crossing of the
    Laplacian of the smoothed image is detected. The output is a binary
    image.
    Inputs and Outputs
    The input to the filter should be a scalar, itk::Image of arbitrary dimension. The output image is a binary, labeled image.
    See itkZeroCrossingImageFilter for more information on requirements of
    the data type of the output.

    To use this filter, first set the parameters (variance and maximum
    error) needed by the embedded DiscreteGaussianImageFilter , i.e. See DiscreteGaussianImageFilter for information about these parameters. Optionally, you may also set
    foreground and background values for the zero-crossing filter. The
    default label values are Zero for the background and One for the
    foreground, as defined in NumericTraits for the data type of the output image.

    See:
     DiscreteGaussianImageFilter

     LaplacianImageFilter

     ZeroCrossingImageFilter

     itk::simple::ZeroCrossingBasedEdgeDetection for the procedural interface

     itk::ZeroCrossingBasedEdgeDetectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkZeroCrossingBasedEdgeDetectionImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = (
        _SimpleITK.delete_ZeroCrossingBasedEdgeDetectionImageFilter
    )

    def __init__(self):
        r"""
        __init__(ZeroCrossingBasedEdgeDetectionImageFilter self) -> ZeroCrossingBasedEdgeDetectionImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_swiginit(
            self, _SimpleITK.new_ZeroCrossingBasedEdgeDetectionImageFilter()
        )

    def SetVariance(self, Variance):
        r"""
        SetVariance(ZeroCrossingBasedEdgeDetectionImageFilter self, double Variance)


        Set the variance parameter needed by the embedded gaussian filter


        """
        return (
            _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_SetVariance(
                self, Variance
            )
        )

    def GetVariance(self):
        r"""
        GetVariance(ZeroCrossingBasedEdgeDetectionImageFilter self) -> double


        Standard get/set macros for Gaussian filter parameters.


        """
        return (
            _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_GetVariance(
                self
            )
        )

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(ZeroCrossingBasedEdgeDetectionImageFilter self, uint8_t ForegroundValue)


        Get/Set the label values for the ZeroCrossingImageFilter


        """
        return _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(ZeroCrossingBasedEdgeDetectionImageFilter self) -> uint8_t


        Get/Set the label values for the ZeroCrossingImageFilter


        """
        return _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_GetForegroundValue(
            self
        )

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(ZeroCrossingBasedEdgeDetectionImageFilter self, uint8_t BackgroundValue)


        Get/Set the label values for the ZeroCrossingImageFilter


        """
        return _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(ZeroCrossingBasedEdgeDetectionImageFilter self) -> uint8_t


        Get/Set the label values for the ZeroCrossingImageFilter


        """
        return _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_GetBackgroundValue(
            self
        )

    def SetMaximumError(self, MaximumError):
        r"""
        SetMaximumError(ZeroCrossingBasedEdgeDetectionImageFilter self, double MaximumError)


        Set the MaximumError parameter needed by the embedded gaussian filter
        This value is used to set the desired maximum error of the gaussian
        approximation. Maximum error is the difference between the area under
        the discrete Gaussian curve and the area under the continuous
        Gaussian. Maximum error affects the Gaussian operator size. The value
        must be between 0.0 and 1.0.


        """
        return _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_SetMaximumError(
            self, MaximumError
        )

    def GetMaximumError(self):
        r"""
        GetMaximumError(ZeroCrossingBasedEdgeDetectionImageFilter self) -> double


        Standard get/set macros for Gaussian filter parameters.


        """
        return _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_GetMaximumError(
            self
        )

    def GetName(self):
        r"""
        GetName(ZeroCrossingBasedEdgeDetectionImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_GetName(
            self
        )

    def __str__(self):
        r"""
        __str__(ZeroCrossingBasedEdgeDetectionImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter___str__(
            self
        )

    def Execute(self, image1):
        r"""
        Execute(ZeroCrossingBasedEdgeDetectionImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_Execute(
            self, image1
        )


# Register ZeroCrossingBasedEdgeDetectionImageFilter in _SimpleITK:
_SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_swigregister(
    ZeroCrossingBasedEdgeDetectionImageFilter
)


def ZeroCrossingBasedEdgeDetection(
    image1,
    variance=1.0,
    foregroundValue=1,
    backgroundValue=0,
    maximumError=0.1,
):
    r"""ZeroCrossingBasedEdgeDetection(Image image1, double variance=1.0, uint8_t foregroundValue=1, uint8_t backgroundValue=0, double maximumError=0.1) -> Image"""
    return _SimpleITK.ZeroCrossingBasedEdgeDetection(
        image1, variance, foregroundValue, backgroundValue, maximumError
    )


class ZeroCrossingImageFilter(ImageFilter):
    r"""


    This filter finds the closest pixel to the zero-crossings (sign
    changes) in a signed itk::Image .


    Pixels closest to zero-crossings are labeled with a foreground value.
    All other pixels are marked with a background value. The algorithm
    works by detecting differences in sign among neighbors using city-
    block style connectivity (4-neighbors in 2d, 6-neighbors in 3d, etc.).

    Inputs and Outputs
    The input to this filter is an itk::Image of arbitrary dimension. The algorithm assumes a signed data type
    (zero-crossings are not defined for unsigned int data types), and
    requires that operator>, operator<, operator==, and operator!= are
    defined.

    The output of the filter is a binary, labeled image of user-specified
    type. By default, zero-crossing pixels are labeled with a default
    "foreground" value of itk::NumericTraits<OutputDataType>::OneValue() , where OutputDataType is the data type of the output image. All
    other pixels are labeled with a default "background" value of
    OutputDataType{}.
    Parameters
    There are two parameters for this filter. ForegroundValue is the value
    that marks zero-crossing pixels. The BackgroundValue is the value
    given to all other pixels.

    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     itk::simple::ZeroCrossing for the procedural interface

     itk::ZeroCrossingImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkZeroCrossingImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ZeroCrossingImageFilter

    def __init__(self):
        r"""
        __init__(ZeroCrossingImageFilter self) -> ZeroCrossingImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ZeroCrossingImageFilter_swiginit(
            self, _SimpleITK.new_ZeroCrossingImageFilter()
        )

    def SetForegroundValue(self, ForegroundValue):
        r"""
        SetForegroundValue(ZeroCrossingImageFilter self, uint8_t ForegroundValue)


        Set/Get the label value for zero-crossing pixels.


        """
        return _SimpleITK.ZeroCrossingImageFilter_SetForegroundValue(
            self, ForegroundValue
        )

    def GetForegroundValue(self):
        r"""
        GetForegroundValue(ZeroCrossingImageFilter self) -> uint8_t


        Set/Get the label value for zero-crossing pixels.


        """
        return _SimpleITK.ZeroCrossingImageFilter_GetForegroundValue(self)

    def SetBackgroundValue(self, BackgroundValue):
        r"""
        SetBackgroundValue(ZeroCrossingImageFilter self, uint8_t BackgroundValue)


        Set/Get the label value for non-zero-crossing pixels.


        """
        return _SimpleITK.ZeroCrossingImageFilter_SetBackgroundValue(
            self, BackgroundValue
        )

    def GetBackgroundValue(self):
        r"""
        GetBackgroundValue(ZeroCrossingImageFilter self) -> uint8_t


        Set/Get the label value for non-zero-crossing pixels.


        """
        return _SimpleITK.ZeroCrossingImageFilter_GetBackgroundValue(self)

    def GetName(self):
        r"""
        GetName(ZeroCrossingImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ZeroCrossingImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ZeroCrossingImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ZeroCrossingImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ZeroCrossingImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ZeroCrossingImageFilter_Execute(self, image1)


# Register ZeroCrossingImageFilter in _SimpleITK:
_SimpleITK.ZeroCrossingImageFilter_swigregister(ZeroCrossingImageFilter)


def ZeroCrossing(image1, foregroundValue=1, backgroundValue=0):
    r"""ZeroCrossing(Image image1, uint8_t foregroundValue=1, uint8_t backgroundValue=0) -> Image"""
    return _SimpleITK.ZeroCrossing(image1, foregroundValue, backgroundValue)


class ZeroFluxNeumannPadImageFilter(ImageFilter):
    r"""


    Increase the image size by padding according to the zero-flux Neumann
    boundary condition.


    A filter which extends the image size and fill the missing pixels
    according to a Neumann boundary condition where first, upwind
    derivatives on the boundary are zero. This is a useful condition in
    solving some classes of differential equations.

    For example, invoking this filter on an image with a corner like: returns the following padded image:


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     WrapPadImageFilter , MirrorPadImageFilter , ConstantPadImageFilter , ZeroFluxNeumannBoundaryCondition

     itk::simple::ZeroFluxNeumannPad for the procedural interface

     itk::ZeroFluxNeumannPadImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkZeroFluxNeumannPadImageFilter.h

    """

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ZeroFluxNeumannPadImageFilter

    def __init__(self):
        r"""
        __init__(ZeroFluxNeumannPadImageFilter self) -> ZeroFluxNeumannPadImageFilter


        Default Constructor that takes no arguments and initializes default
        parameters


        """
        _SimpleITK.ZeroFluxNeumannPadImageFilter_swiginit(
            self, _SimpleITK.new_ZeroFluxNeumannPadImageFilter()
        )

    def SetPadLowerBound(self, PadLowerBound):
        r"""
        SetPadLowerBound(ZeroFluxNeumannPadImageFilter self, VectorUInt32 PadLowerBound)


        """
        return _SimpleITK.ZeroFluxNeumannPadImageFilter_SetPadLowerBound(
            self, PadLowerBound
        )

    def GetPadLowerBound(self):
        r"""
        GetPadLowerBound(ZeroFluxNeumannPadImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.ZeroFluxNeumannPadImageFilter_GetPadLowerBound(self)

    def SetPadUpperBound(self, PadUpperBound):
        r"""
        SetPadUpperBound(ZeroFluxNeumannPadImageFilter self, VectorUInt32 PadUpperBound)


        """
        return _SimpleITK.ZeroFluxNeumannPadImageFilter_SetPadUpperBound(
            self, PadUpperBound
        )

    def GetPadUpperBound(self):
        r"""
        GetPadUpperBound(ZeroFluxNeumannPadImageFilter self) -> VectorUInt32


        """
        return _SimpleITK.ZeroFluxNeumannPadImageFilter_GetPadUpperBound(self)

    def GetName(self):
        r"""
        GetName(ZeroFluxNeumannPadImageFilter self) -> std::string


        Name of this class


        """
        return _SimpleITK.ZeroFluxNeumannPadImageFilter_GetName(self)

    def __str__(self):
        r"""
        __str__(ZeroFluxNeumannPadImageFilter self) -> std::string


        Print ourselves out


        """
        return _SimpleITK.ZeroFluxNeumannPadImageFilter___str__(self)

    def Execute(self, image1):
        r"""
        Execute(ZeroFluxNeumannPadImageFilter self, Image image1) -> Image


        Execute the filter on the input image


        """
        return _SimpleITK.ZeroFluxNeumannPadImageFilter_Execute(self, image1)


# Register ZeroFluxNeumannPadImageFilter in _SimpleITK:
_SimpleITK.ZeroFluxNeumannPadImageFilter_swigregister(
    ZeroFluxNeumannPadImageFilter
)


def ZeroFluxNeumannPad(*args, **kwargs):
    r"""ZeroFluxNeumannPad(Image image1, VectorUInt32 padLowerBound=std::vector< unsigned int >(3, 0), VectorUInt32 padUpperBound=std::vector< unsigned int >(3, 0)) -> Image"""
    return _SimpleITK.ZeroFluxNeumannPad(*args, **kwargs)


class PyCommand(Command):
    r"""Proxy of C++ itk::simple::PyCommand class."""

    thisown = property(
        lambda x: x.this.own(),
        lambda x, v: x.this.own(v),
        doc="The membership flag",
    )
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(PyCommand self) -> PyCommand"""
        _SimpleITK.PyCommand_swiginit(self, _SimpleITK.new_PyCommand())

    __swig_destroy__ = _SimpleITK.delete_PyCommand

    def SetCallbackPyCallable(self, obj):
        r"""SetCallbackPyCallable(PyCommand self, PyObject * obj)"""
        return _SimpleITK.PyCommand_SetCallbackPyCallable(self, obj)

    def GetCallbackPyCallable(self):
        r"""GetCallbackPyCallable(PyCommand self) -> PyObject *"""
        return _SimpleITK.PyCommand_GetCallbackPyCallable(self)

    def Execute(self):
        r"""
        Execute(PyCommand self)


        The method that defines action to be taken by the command


        """
        return _SimpleITK.PyCommand_Execute(self)


# Register PyCommand in _SimpleITK:
_SimpleITK.PyCommand_swigregister(PyCommand)
